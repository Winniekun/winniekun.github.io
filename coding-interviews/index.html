<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>剑指offer题解 | Wkkの笔记 | 好记性不如烂键盘</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="剑指offer">
    <meta name="description" content="数据结构类题目">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer题解">
<meta property="og:url" content="https://winniekun.github.io/coding-interviews/index.html">
<meta property="og:site_name" content="Wkkの笔记">
<meta property="og:description" content="数据结构类题目">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/12/rZjqTxz7GlPkyOE.png">
<meta property="og:image" content="https://i.loli.net/2020/05/12/IM5G4vFzfdieaCY.png">
<meta property="og:image" content="https://i.loli.net/2020/05/20/cRJmEYnhySDWBGF.png">
<meta property="og:image" content="https://i.loli.net/2020/05/25/gj6bfez2nES9RAk.png">
<meta property="og:image" content="https://i.loli.net/2020/05/25/ORwfn3l19JbGvij.png">
<meta property="og:image" content="https://i.loli.net/2020/05/25/P7ELQ91F2tjJ3YH.png">
<meta property="og:image" content="https://i.loli.net/2020/05/26/yobfmepW8j1BxEI.png">
<meta property="article:published_time" content="2020-05-28T02:37:49.000Z">
<meta property="article:modified_time" content="2021-07-05T05:19:16.366Z">
<meta property="article:author" content="weikunkun">
<meta property="article:tag" content="剑指offer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/12/rZjqTxz7GlPkyOE.png">
    
        <link rel="alternate" type="application/atom+xml" title="Wkkの笔记" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <link rel="stylesheet" href="/css/prism/prism-tomorrow-night.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-list-ul"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/people.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="https://avatars.githubusercontent.com/u/19886738?v=4">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">weikunkun</h5>
          <a href="mailto:kongwiki5@gmail.com" title="kongwiki5@gmail.com" class="mail">kongwiki5@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-user-md"></i>
                About
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://winniekun.github.io/acsaber/#/" target="_blank" >
                <i class="icon icon-lg icon-trello"></i>
                LeetCode
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Winniekun" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">剑指offer题解</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">剑指offer题解</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-05-28T02:37:49.000Z" itemprop="datePublished" class="page-time">
  2020-05-28
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#数据结构类题目"><span class="post-toc-number">1.</span> <span class="post-toc-text">数据结构类题目</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Array"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">Array</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#LinkedList"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">LinkedList</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Tree"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">Tree</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Stack-amp-Queue"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">Stack &amp; Queue</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Heap"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">Heap</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Hash-Table"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">Hash Table</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#图"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">图</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#具体算法类题目"><span class="post-toc-number">2.</span> <span class="post-toc-text">具体算法类题目</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#搜索算法"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">搜索算法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#动态规划"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">动态规划</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#回溯"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">回溯</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#排序"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">排序</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#位运算"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">位运算</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#刷题记录"><span class="post-toc-number">3.</span> <span class="post-toc-text">刷题记录</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题3-I：数组中重复的数字"><span class="post-toc-number">3.0.1.</span> <span class="post-toc-text">面试题3-I：数组中重复的数字</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#题目一：找出数组中的重复数字"><span class="post-toc-number">3.0.1.1.</span> <span class="post-toc-text">题目一：找出数组中的重复数字</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题3-II：不修改数组，找出重复的数字"><span class="post-toc-number">3.0.2.</span> <span class="post-toc-text">面试题3-II：不修改数组，找出重复的数字</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题4：二维数组查找"><span class="post-toc-number">3.0.3.</span> <span class="post-toc-text">面试题4：二维数组查找</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题5：替换空格"><span class="post-toc-number">3.0.4.</span> <span class="post-toc-text">面试题5：替换空格</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题6：从尾到头打印链表"><span class="post-toc-number">3.0.5.</span> <span class="post-toc-text">面试题6：从尾到头打印链表</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题7：-重建二叉树"><span class="post-toc-number">3.0.6.</span> <span class="post-toc-text">面试题7： 重建二叉树</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题8：-二叉树的下一个节点"><span class="post-toc-number">3.0.7.</span> <span class="post-toc-text">面试题8： 二叉树的下一个节点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题9：-两个栈实现队列"><span class="post-toc-number">3.0.8.</span> <span class="post-toc-text">面试题9： 两个栈实现队列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题10：-斐波那契数列"><span class="post-toc-number">3.0.9.</span> <span class="post-toc-text">面试题10： 斐波那契数列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#题目二：青蛙跳台阶"><span class="post-toc-number">3.0.9.1.</span> <span class="post-toc-text">题目二：青蛙跳台阶</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#题目三：-矩阵覆盖"><span class="post-toc-number">3.0.9.2.</span> <span class="post-toc-text">题目三： 矩阵覆盖</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题11：-旋转数组中的最小数字"><span class="post-toc-number">3.0.10.</span> <span class="post-toc-text">面试题11： 旋转数组中的最小数字</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题12：矩阵中的路径"><span class="post-toc-number">3.0.11.</span> <span class="post-toc-text">面试题12：矩阵中的路径</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题13：机器人的运动范围"><span class="post-toc-number">3.0.12.</span> <span class="post-toc-text">面试题13：机器人的运动范围</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题14：剪绳子"><span class="post-toc-number">3.0.13.</span> <span class="post-toc-text">面试题14：剪绳子</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题15：二进制中1个个数"><span class="post-toc-number">3.0.14.</span> <span class="post-toc-text">面试题15：二进制中1个个数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题16：数值的整数次方"><span class="post-toc-number">3.0.15.</span> <span class="post-toc-text">面试题16：数值的整数次方</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题17：打印从1到最大的n位整数"><span class="post-toc-number">3.0.16.</span> <span class="post-toc-text">面试题17：打印从1到最大的n位整数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题18：删除链表的节点"><span class="post-toc-number">3.0.17.</span> <span class="post-toc-text">面试题18：删除链表的节点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题19：正则表达式匹配"><span class="post-toc-number">3.0.18.</span> <span class="post-toc-text">面试题19：正则表达式匹配</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题20：表示数值的字符串"><span class="post-toc-number">3.0.19.</span> <span class="post-toc-text">面试题20：表示数值的字符串</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题21：调整数组顺序使奇数位于偶数前面"><span class="post-toc-number">3.0.20.</span> <span class="post-toc-text">面试题21：调整数组顺序使奇数位于偶数前面</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题22：链表中倒数第K个节点"><span class="post-toc-number">3.0.21.</span> <span class="post-toc-text">面试题22：链表中倒数第K个节点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题23：链表中环的入口节点"><span class="post-toc-number">3.0.22.</span> <span class="post-toc-text">面试题23：链表中环的入口节点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题24：反转链表"><span class="post-toc-number">3.0.23.</span> <span class="post-toc-text">面试题24：反转链表</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题25：-合并两个排序的链表"><span class="post-toc-number">3.0.24.</span> <span class="post-toc-text">面试题25： 合并两个排序的链表</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题26：树的子结构"><span class="post-toc-number">3.0.25.</span> <span class="post-toc-text">面试题26：树的子结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题27：二叉树的镜像"><span class="post-toc-number">3.0.26.</span> <span class="post-toc-text">面试题27：二叉树的镜像</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题28：对称二叉树"><span class="post-toc-number">3.0.27.</span> <span class="post-toc-text">面试题28：对称二叉树</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题29：-顺时针打印矩阵"><span class="post-toc-number">3.0.28.</span> <span class="post-toc-text">面试题29： 顺时针打印矩阵</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#流程"><span class="post-toc-number">3.0.28.1.</span> <span class="post-toc-text">流程</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题30：-包含min函数的栈"><span class="post-toc-number">3.0.29.</span> <span class="post-toc-text">面试题30： 包含min函数的栈</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#函数设计："><span class="post-toc-number">3.0.29.1.</span> <span class="post-toc-text">函数设计：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题31：栈的压入、弹出序列"><span class="post-toc-number">3.0.30.</span> <span class="post-toc-text">面试题31：栈的压入、弹出序列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题32：从上到下打印二叉树"><span class="post-toc-number">3.0.31.</span> <span class="post-toc-text">面试题32：从上到下打印二叉树</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题32-2：分行从上到下打印二叉树"><span class="post-toc-number">3.0.32.</span> <span class="post-toc-text">面试题32-2：分行从上到下打印二叉树</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题32-3：分行从上到下zigzag打印二叉树"><span class="post-toc-number">3.0.33.</span> <span class="post-toc-text">面试题32-3：分行从上到下zigzag打印二叉树</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题33：二叉搜索树的后序遍历序列"><span class="post-toc-number">3.0.34.</span> <span class="post-toc-text">面试题33：二叉搜索树的后序遍历序列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题34：二叉树中和为某一值的路径"><span class="post-toc-number">3.0.35.</span> <span class="post-toc-text">面试题34：二叉树中和为某一值的路径</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题35：复杂链表的复制"><span class="post-toc-number">3.0.36.</span> <span class="post-toc-text">面试题35：复杂链表的复制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题36：二叉搜索树与双向链表"><span class="post-toc-number">3.0.37.</span> <span class="post-toc-text">面试题36：二叉搜索树与双向链表</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题37：序列化二叉树"><span class="post-toc-number">3.0.38.</span> <span class="post-toc-text">面试题37：序列化二叉树</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题38：-字符串的排列"><span class="post-toc-number">3.0.39.</span> <span class="post-toc-text">面试题38： 字符串的排列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题39：数组中刚出现次数超过一半的数字"><span class="post-toc-number">3.0.40.</span> <span class="post-toc-text">面试题39：数组中刚出现次数超过一半的数字</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题40：最小的k个数"><span class="post-toc-number">3.0.41.</span> <span class="post-toc-text">面试题40：最小的k个数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题41：数据流中的中位数"><span class="post-toc-number">3.0.42.</span> <span class="post-toc-text">面试题41：数据流中的中位数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题42：连续数组的最大和"><span class="post-toc-number">3.0.43.</span> <span class="post-toc-text">面试题42：连续数组的最大和</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题43：1-N整数中1出现的次数"><span class="post-toc-number">3.0.44.</span> <span class="post-toc-text">面试题43：1~N整数中1出现的次数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题44：数字序列中某一位的数字"><span class="post-toc-number">3.0.45.</span> <span class="post-toc-text">面试题44：数字序列中某一位的数字</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题45：把数组排成最小数"><span class="post-toc-number">3.0.46.</span> <span class="post-toc-text">面试题45：把数组排成最小数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题46-把数字翻译成字符串"><span class="post-toc-number">3.0.47.</span> <span class="post-toc-text">面试题46: 把数字翻译成字符串</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题47-礼物的最大值"><span class="post-toc-number">3.0.48.</span> <span class="post-toc-text">面试题47: 礼物的最大值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题48-最长不含重复字符串的子字符串"><span class="post-toc-number">3.0.49.</span> <span class="post-toc-text">面试题48: 最长不含重复字符串的子字符串</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题49：丑数"><span class="post-toc-number">3.0.50.</span> <span class="post-toc-text">面试题49：丑数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题50：第一只出现一次的字符"><span class="post-toc-number">3.0.51.</span> <span class="post-toc-text">面试题50：第一只出现一次的字符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题51：数组中的逆序对"><span class="post-toc-number">3.0.52.</span> <span class="post-toc-text">面试题51：数组中的逆序对</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最基础的思路，暴力双for循环，不出意外，会超时"><span class="post-toc-number">3.0.52.1.</span> <span class="post-toc-text">最基础的思路，暴力双for循环，不出意外，会超时</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#第二种思路：回溯"><span class="post-toc-number">3.0.52.2.</span> <span class="post-toc-text">第二种思路：回溯</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#第三种思路：归并思想（炸裂，写不出来）"><span class="post-toc-number">3.0.52.3.</span> <span class="post-toc-text">第三种思路：归并思想（炸裂，写不出来）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题52：两个链表的第一个公共节点"><span class="post-toc-number">3.0.53.</span> <span class="post-toc-text">面试题52：两个链表的第一个公共节点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#第一种思路：暴力双循环"><span class="post-toc-number">3.0.53.1.</span> <span class="post-toc-text">第一种思路：暴力双循环</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#第二种思路：构造一个环"><span class="post-toc-number">3.0.53.2.</span> <span class="post-toc-text">第二种思路：构造一个环</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题53-在排序数组中查找数字"><span class="post-toc-number">3.0.54.</span> <span class="post-toc-text">面试题53: 在排序数组中查找数字</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题53-II-0～n-1中缺失的数字"><span class="post-toc-number">3.0.55.</span> <span class="post-toc-text">面试题53 - II. 0～n-1中缺失的数字</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题54-二叉搜索树的第K大节点"><span class="post-toc-number">3.0.56.</span> <span class="post-toc-text">面试题54: 二叉搜索树的第K大节点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题55-I-二叉树的深度"><span class="post-toc-number">3.0.57.</span> <span class="post-toc-text">面试题55-I: 二叉树的深度</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#递归"><span class="post-toc-number">3.0.57.1.</span> <span class="post-toc-text">递归</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#非递归"><span class="post-toc-number">3.0.57.2.</span> <span class="post-toc-text">非递归</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题55-II-平衡二叉树"><span class="post-toc-number">3.0.58.</span> <span class="post-toc-text">面试题55-II: 平衡二叉树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#解法一-自顶向下"><span class="post-toc-number">3.0.58.1.</span> <span class="post-toc-text">解法一(自顶向下):</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#解法二-自底向上"><span class="post-toc-number">3.0.58.2.</span> <span class="post-toc-text">解法二(自底向上):</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题56-I-数组中数字出现的次数"><span class="post-toc-number">3.0.59.</span> <span class="post-toc-text">面试题56-I: 数组中数字出现的次数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题56-II-数组中唯一出现一次的数字"><span class="post-toc-number">3.0.60.</span> <span class="post-toc-text">面试题56-II: 数组中唯一出现一次的数字</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题57-I-和为S的两个数字"><span class="post-toc-number">3.0.61.</span> <span class="post-toc-text">面试题57-I: 和为S的两个数字</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题57-II-和为S的连续整数序列"><span class="post-toc-number">3.0.62.</span> <span class="post-toc-text">面试题57-II: 和为S的连续整数序列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题58-I-翻转字符串"><span class="post-toc-number">3.0.63.</span> <span class="post-toc-text">面试题58-I: 翻转字符串</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题58-II-翻转字符串"><span class="post-toc-number">3.0.64.</span> <span class="post-toc-text">面试题58-II: 翻转字符串</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题59-I-滑动窗口的最大值"><span class="post-toc-number">3.0.65.</span> <span class="post-toc-text">面试题59-I: 滑动窗口的最大值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题59-II-队列的最大值"><span class="post-toc-number">3.0.66.</span> <span class="post-toc-text">面试题59-II: 队列的最大值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题60-n个骰子的点数"><span class="post-toc-number">3.0.67.</span> <span class="post-toc-text">面试题60: n个骰子的点数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题61-扑克牌中的顺子"><span class="post-toc-number">3.0.68.</span> <span class="post-toc-text">面试题61: 扑克牌中的顺子</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题62-圆圈中最后剩下的数字"><span class="post-toc-number">3.0.69.</span> <span class="post-toc-text">面试题62: 圆圈中最后剩下的数字</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#构造环-然后按照题意解决"><span class="post-toc-number">3.0.69.1.</span> <span class="post-toc-text">构造环,然后按照题意解决</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#约瑟夫环——公式法（递推公式）"><span class="post-toc-number">3.0.69.2.</span> <span class="post-toc-text">约瑟夫环——公式法（递推公式）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题63-股票的最大利润"><span class="post-toc-number">3.0.70.</span> <span class="post-toc-text">面试题63: 股票的最大利润</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题64-求1-2-…-n的结果"><span class="post-toc-number">3.0.71.</span> <span class="post-toc-text">面试题64: 求1+2+…+n的结果</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题65-不用加减乘除做加法"><span class="post-toc-number">3.0.72.</span> <span class="post-toc-text">面试题65: 不用加减乘除做加法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题66-构建乘积数组"><span class="post-toc-number">3.0.73.</span> <span class="post-toc-text">面试题66: 构建乘积数组</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题67-把字符串转换成整数"><span class="post-toc-number">3.0.74.</span> <span class="post-toc-text">面试题67: 把字符串转换成整数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题68-I-二叉搜索树的最近公共祖先"><span class="post-toc-number">3.0.75.</span> <span class="post-toc-text">面试题68-I: 二叉搜索树的最近公共祖先</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#面试题68-II-二叉树的最近公共祖先"><span class="post-toc-number">3.0.76.</span> <span class="post-toc-text">面试题68-II: 二叉树的最近公共祖先</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#References"><span class="post-toc-number">3.0.77.</span> <span class="post-toc-text">References</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-LeetCode/coding-interviews"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">剑指offer题解</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-05-28 10:37:49" datetime="2020-05-28T02:37:49.000Z"  itemprop="datePublished">2020-05-28</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="数据结构类题目"><a href="#数据结构类题目" class="headerlink" title="数据结构类题目"></a>数据结构类题目</h1><a id="more"></a>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><ol>
<li>面试题3: 数组中重复的数字</li>
<li>面试题4: 二维数组中的查找</li>
<li>面试题11: <strong>旋转数组中的最小数字</strong></li>
<li>面试题21: 调整数组顺序使奇数位于偶数前面</li>
<li>面试题29: 顺时针打印矩阵</li>
<li>面试题39: 数组中出现次数操作一半的数字</li>
<li>面试题42: 连续子数组的最大和</li>
<li>面试题45: 把数组排成最小的数</li>
<li>面试题47: 礼物的最大值</li>
<li>面试题51: <strong>数组中的逆序对</strong></li>
<li>面试题53: 在排序数组中查找数字</li>
<li>面试题53-I: 在排序数组中查找数字I</li>
<li>面试题53-II: 0 ~ n-1 中缺失的数字</li>
<li>面试题56: 数组中数字出现的次数</li>
<li>面试题66: 构建乘积数组</li>
</ol>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ol>
<li>面试题6：从尾到头打印链表</li>
<li>面试题18：删除链表的节点</li>
<li>面试题22：链表中倒数第k个结点</li>
<li>面试题23：链表中环的入口节点</li>
<li>面试题24：反转链表</li>
<li>面试题25：合并两个或k个有序链表</li>
<li>面试题35：复杂链表的复制</li>
<li><strong>面试题36</strong>：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof" target="_blank" rel="noopener"> 二叉搜索树与双向链表</a> </li>
<li>面试题52：两个链表的第一个公共结点</li>
<li>面试题56：删除链表中重复的结点</li>
</ol>
<h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><ol>
<li>面试题7：<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof" target="_blank" rel="noopener">重建二叉树</a> </li>
<li>面试题26：<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof" target="_blank" rel="noopener">树的子结构</a> </li>
<li>面试题27：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof" target="_blank" rel="noopener">二叉树的镜像</a></li>
<li>面试题28：<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof" target="_blank" rel="noopener">对称的二叉树</a> </li>
<li>面试题32-I：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof" target="_blank" rel="noopener">从上到下打印二叉树</a> </li>
<li>面试题32-II：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof" target="_blank" rel="noopener">从上到下打印二叉树 II</a> </li>
<li>面试题32-III：<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof" target="_blank" rel="noopener">从上到下打印二叉树 III</a> </li>
<li>面试题33：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof" target="_blank" rel="noopener">二叉搜索树的后序遍历序列</a> </li>
<li>面试题34：<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof" target="_blank" rel="noopener"> 二叉树中和为某一值的路径</a> </li>
<li><strong>面试题36</strong>：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof" target="_blank" rel="noopener">二叉搜索树与双向链表</a> </li>
<li>面试题37：<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof" target="_blank" rel="noopener">序列化二叉树</a> </li>
<li>面试题54：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof" target="_blank" rel="noopener">二叉搜索树的第k大节点</a> </li>
<li>面试题55-I：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof" target="_blank" rel="noopener"> 二叉树的深度</a> </li>
<li>面试题55-II：<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof" target="_blank" rel="noopener">平衡二叉树</a> </li>
<li>面试题68-I：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a> </li>
<li>面试题68-II：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof" target="_blank" rel="noopener">二叉树的最近公共祖先</a> </li>
</ol>
<h2 id="Stack-amp-Queue"><a href="#Stack-amp-Queue" class="headerlink" title="Stack &amp; Queue"></a>Stack &amp; Queue</h2><ol>
<li>面试题9：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof" target="_blank" rel="noopener">用两个栈实现队列</a></li>
<li>面试题9-I:  两个队列实现栈</li>
<li>面试题30：<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof" target="_blank" rel="noopener">包含min函数的栈</a> </li>
<li>面试题31：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof" target="_blank" rel="noopener">栈的压入、弹出序列</a> </li>
<li>面试题58-I：<a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof" target="_blank" rel="noopener">翻转单词顺序</a> </li>
<li>面试题59-I：<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof" target="_blank" rel="noopener">滑动窗口的最大值</a> </li>
</ol>
<h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><ol>
<li>面试题29: <a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof" target="_blank" rel="noopener">最小的k个数</a> </li>
<li>面试题41: <a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof" target="_blank" rel="noopener">数据流中的中位数</a> </li>
</ol>
<h2 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h2><ol>
<li>面试题3: <a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof" target="_blank" rel="noopener">数组中重复的数字</a> </li>
</ol>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ol>
<li>面试题12: <a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof" target="_blank" rel="noopener">矩阵中的路径</a> </li>
<li>面试题13: <a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof" target="_blank" rel="noopener">机器人的运动范围</a> </li>
</ol>
<h1 id="具体算法类题目"><a href="#具体算法类题目" class="headerlink" title="具体算法类题目"></a>具体算法类题目</h1><h2 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h2><ol>
<li>面试题4: <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof" target="_blank" rel="noopener"> 二维数组中的查找</a> </li>
<li>面试题11: <a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof" target="_blank" rel="noopener"> 旋转数组的最小数字</a> </li>
<li>面试题39: <a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof" target="_blank" rel="noopener"> 数组中出现次数超过一半的数字</a></li>
</ol>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ol>
<li><p>面试题10-I: <a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">10- I. 斐波那契数列</a></p>
</li>
<li><p>面试题10-II: <a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">10- II. 青蛙跳台阶问题</a></p>
</li>
<li><p>面试题19: <a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank" rel="noopener">19. 正则表达式匹配</a></p>
</li>
<li><p>面试题42: <a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">42. 连续子数组的最大和</a></p>
</li>
<li><p>面试题46: <a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">46. 把数字翻译成字符串</a></p>
</li>
<li><p>面试题47: <a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">47. 礼物的最大价值</a></p>
</li>
<li><p>面试题48: <a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">48. 最长不含重复字符的子字符串</a></p>
</li>
<li><p>面试题49: <a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">49. 丑数</a></p>
</li>
<li><p>面试题60: <a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">60. n 个骰子的点数</a></p>
</li>
<li><p>面试题63: <a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">63. 股票的最大利润</a></p>
</li>
</ol>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><ol>
<li>面试题12: 矩阵中的路径</li>
<li>面试题13: 机器人的运动范围</li>
</ol>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ol>
<li>面试题29: <a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof" target="_blank" rel="noopener">最小的k个数</a>  (堆排序)</li>
<li>面试题39: <a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof" target="_blank" rel="noopener"> 数组中出现次数超过一半的数字</a> (快排序)</li>
<li>面试题51: <a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof" target="_blank" rel="noopener"> 数组中的逆序对</a>(归并排序)</li>
</ol>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ol>
<li>面试题15: <a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof" target="_blank" rel="noopener"> 二进制中1的个数</a> </li>
<li>面试题56-I: <a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof" target="_blank" rel="noopener">数组中数字出现的次数</a> </li>
<li>面试题56-II: <a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof" target="_blank" rel="noopener">数组中数字出现的次数 II</a> </li>
</ol>
<h1 id="刷题记录"><a href="#刷题记录" class="headerlink" title="刷题记录"></a>刷题记录</h1><h3 id="面试题3-I：数组中重复的数字"><a href="#面试题3-I：数组中重复的数字" class="headerlink" title="面试题3-I：数组中重复的数字"></a>面试题3-I：数组中重复的数字</h3><h4 id="题目一：找出数组中的重复数字"><a href="#题目一：找出数组中的重复数字" class="headerlink" title="题目一：找出数组中的重复数字"></a>题目一：找出数组中的重复数字</h4><p><strong>方法一: 排序之后 查找</strong><br>排序，之后遇到有重复的返回该数字即可</p>
<p>时间复杂度： O(nlogn)</p>
<p>空间复杂度：O(1)</p>
<pre><code class="lang-java">// 内置排序算法
public int findRepeatNumber(int[] arrays) {
    Arrays.sort(arrays);
    int t = 0;
    for (int i = 0; i &lt; arrays.length-1; i++) {
        if (arrays[i] == arrays[i + 1]) {
            t = arrays[i];
        }
    }
    return t;
}

// 使用快排
public int findRepeatNumber(int[] nums) {
        quickSort(nums);
        for(int i = 1; i&lt;nums.length; i++){
            if(nums[i] == nums[i-1]){
                return nums[i];
            }
        }
        return -1;
    }
    private void quickSort(int[] nums){
        quickSort(nums, 0, nums.length-1);
    }
    private void quickSort(int[] nums, int low, int high){
        if(low &gt; high){
            return;
        }
        else{
            int position = patition(nums, low, high);
            quickSort(nums, low, position-1);
            quickSort(nums, position+1, high);
        }
    }
    private int patition(int[] nums, int low, int high){
        int position = nums[low];
        while(low &lt; high){
            while(low &lt; high &amp;&amp; nums[high] &gt;= position){
                high--;
            }
            nums[low] = nums[high];
            while(low &lt; high &amp;&amp; nums[low] &lt;= position){
                low++;
            }
            nums[high] = nums[low];
        }
        nums[low] = position;
        return low;
    }
</code></pre>
<p><strong>方法二: 散列表</strong></p>
<p>将所有的元素当做key存如散列表，value表示key出现的个数</p>
<pre><code class="lang-java">public int findRepeatNumber(int[] nums) {
        int a = 0;
        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();
        for (int i : nums) {
            if (map.containsKey(i)) {
                Integer integer = map.get(i);
                integer += 1;
                a = i;
            } else {
                map.put(i, 0);
            }
        }
        return a;
    }
</code></pre>
<p><strong>方法三: 位图</strong></p>
<p>具体可参见编程珠玑或算法新解</p>
<h3 id="面试题3-II：不修改数组，找出重复的数字"><a href="#面试题3-II：不修改数组，找出重复的数字" class="headerlink" title="面试题3-II：不修改数组，找出重复的数字"></a>面试题3-II：不修改数组，找出重复的数字</h3><p>二分查找<a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></p>
<pre><code class="lang-java">public int findDuplicate(int[] nums) {
        int i = 0; 
        int j = nums.length - 1;
        while( i &lt; j ){
            // j = mid 
            // 所以 mid = (i+j)/2
            // 若果i = mid
            // 则 mid = (i + j + 1)/2
            int mid = (i + j) /2;
            int count = 0;
            // 统计小于中值的数量
            for(int num : nums){
                if(num &lt;= mid){
                    count++;
                }
            }
            // 如果统计出的数量&gt;中值
            // 重复的元素可定出现在i~mid区间, 所以mid+1~j区间就可以不用考虑了
            if(count &gt; mid){
                j = mid;
            }else {
                i = mid + 1;
            }
        }
        return i;
}
</code></pre>
<h3 id="面试题4：二维数组查找"><a href="#面试题4：二维数组查找" class="headerlink" title="面试题4：二维数组查找"></a>面试题4：二维数组查找</h3><p>从左下角开始</p>
<pre><code class="lang-java">public boolean findNumberIn2DArray(int[][] matrix, int target) {
        int m = matrix.length -1;
        int n = 0;
        while(m &gt;= 0 &amp;&amp; n&lt;=matrix[0].length-1){
            if(matrix[m][n] &lt; target){
                n++;
            }else if(matrix[m][n] &gt; target){
                m--;
            }
            else {
                return true;
            }
        }
        return false;
    }
</code></pre>
<h3 id="面试题5：替换空格"><a href="#面试题5：替换空格" class="headerlink" title="面试题5：替换空格"></a>面试题5：替换空格</h3><pre><code class="lang-java">public String replaceSpace(String s) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i &lt; s.length(); i++) {
        if(s.charAt(i) == ' '){
            sb.append("%20");
        }
        else{
            sb.append(s.charAt(i));
        }
    }
    return sb.toString();
}
</code></pre>
<h3 id="面试题6：从尾到头打印链表"><a href="#面试题6：从尾到头打印链表" class="headerlink" title="面试题6：从尾到头打印链表"></a>面试题6：从尾到头打印链表</h3><pre><code class="lang-java">public int[] reversePrint(ListNode head) {
    // 使用栈
    ListNode p = head;
    Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();
    while (p != null){
        stack.push(p);
        p = p.next;
    }
    int[] res = new int[stack.size()];
    int i = 0;
    while (!stack.isEmpty()){
        res[i++] = stack.pop().val;
    }
    return res;
}
// 头插法重新构造链表 然后依次放入
public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {
        ListNode dummy = new ListNode(-1);
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        while(listNode != null){
            ListNode temp = listNode.next;
            listNode.next = dummy.next;
            dummy.next = listNode;

            listNode = temp;
        }

        listNode = dummy.next;
        while(listNode != null){
            list.add(listNode.val);
            listNode = listNode.next;
        }
        return list;
    }
</code></pre>
<h3 id="面试题7：-重建二叉树"><a href="#面试题7：-重建二叉树" class="headerlink" title="面试题7： 重建二叉树"></a>面试题7： 重建二叉树</h3><pre><code class="lang-java">public static TreeNode buildTree(int[] preorder, int[] inorder) {
        Map&lt;Integer, Integer&gt; inMap = new HashMap&lt;Integer, Integer&gt;();

        for (int i = 0; i &lt; inorder.length; i++) {
            inMap.put(inorder[i], i);
        }

        TreeNode root = buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, inMap);
        return root;
    }

    public static TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd, Map&lt;Integer, Integer&gt; inMap) {
        if (preStart &gt; preEnd) {
            return null;
        }

        TreeNode root = new TreeNode(preorder[preStart]);
        // 当前根节点所在中序遍历位置
        int inRoot = inMap.get(root.val);
        // 该根节点左边子节点的个数
        int numsLeft = inRoot - inStart;

        root.left = buildTree(preorder, preStart + 1, preStart + numsLeft, inorder, inStart, inRoot - 1, inMap);
        root.right = buildTree(preorder, preStart + numsLeft + 1 , preEnd, inorder, inRoot + 1, inEnd, inMap);

        return root;
    }
</code></pre>
<h3 id="面试题8：-二叉树的下一个节点"><a href="#面试题8：-二叉树的下一个节点" class="headerlink" title="面试题8： 二叉树的下一个节点"></a>面试题8： 二叉树的下一个节点</h3><h3 id="面试题9：-两个栈实现队列"><a href="#面试题9：-两个栈实现队列" class="headerlink" title="面试题9： 两个栈实现队列"></a>面试题9： 两个栈实现队列</h3><pre><code class="lang-java">// 使用两个栈实现队列
Deque&lt;Integer&gt; A, B;
public interview9() {
    A = new ArrayDeque&lt;&gt;();
    B = new ArrayDeque&lt;&gt;();
}
public void appendTail(int value) {
    A.push(value);
}
public int deleteHead() {
    if (!B.isEmpty()) {
        return B.removeLast();
    }
    // 表明两个栈都为空了, 所以没有能返回的值了
    if (A.isEmpty()) {
        return -1;
    }
    while (!A.isEmpty()) {
        B.addLast(A.removeLast());
    }
    return B.removeLast();
}
</code></pre>
<h3 id="面试题10：-斐波那契数列"><a href="#面试题10：-斐波那契数列" class="headerlink" title="面试题10： 斐波那契数列"></a>面试题10： 斐波那契数列</h3><p><strong>方法一：递归</strong></p>
<p><strong>方法二：DP</strong> </p>
<h4 id="题目二：青蛙跳台阶"><a href="#题目二：青蛙跳台阶" class="headerlink" title="题目二：青蛙跳台阶"></a>题目二：青蛙跳台阶</h4><h4 id="题目三：-矩阵覆盖"><a href="#题目三：-矩阵覆盖" class="headerlink" title="题目三： 矩阵覆盖"></a>题目三： 矩阵覆盖</h4><h3 id="面试题11：-旋转数组中的最小数字"><a href="#面试题11：-旋转数组中的最小数字" class="headerlink" title="面试题11： 旋转数组中的最小数字"></a>面试题11： 旋转数组中的最小数字</h3><p><strong>二分查找, 注意元素会重复</strong></p>
<pre><code class="lang-java">public int minArray(int[] numbers) {
    int i = 0;
    int j = numbers.length -1;
    while(i &lt; j){
        int mid = (i + j )/2;
        if(numbers[mid] &gt; numbers[j]){
            i = mid + 1;
        }else if(numbers[mid] &lt; numbers[j]){
            j = mid;
        }else {
            j -= 1;
        }
    }
    return numbers[i];
}
</code></pre>
<h3 id="面试题12：矩阵中的路径"><a href="#面试题12：矩阵中的路径" class="headerlink" title="面试题12：矩阵中的路径"></a>面试题12：矩阵中的路径</h3><pre><code class="lang-java">public boolean exist(char[][] matrix, String str) {
    int n = matrix.length;
    int m = matrix[0].length;
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            if (hasPathCore(matrix, str, 0, i, j)) {
                return true;
            }
        }
    }
    return false;
}
public boolean hasPathCore(char[][] matrix, String str, int start, int row, int col) {
    int n = matrix.length;
    int m = matrix[0].length;
    if (start == str.length()) {
        return true;
    }
    if (row &lt; 0 || row &gt;= n || col &lt; 0 || col &gt;= m || matrix[row][col] != str.charAt(start)) {
        return false;
    }
    char c = matrix[row][col];
    matrix[row][col] = ' ';
    boolean result = hasPathCore(matrix, str, start + 1, row + 1, col)
            || hasPathCore(matrix, str, start + 1, row - 1, col)
            || hasPathCore(matrix, str, start + 1, row, col + 1)
            || hasPathCore(matrix, str, start + 1, row, col - 1);
    matrix[row][col] = c;
    return result;
}
</code></pre>
<h3 id="面试题13：机器人的运动范围"><a href="#面试题13：机器人的运动范围" class="headerlink" title="面试题13：机器人的运动范围"></a>面试题13：机器人的运动范围</h3><pre><code class="lang-java">private int count = 0;
public int movingCount(int m, int n, int k) {
    boolean[][] vistied = new boolean[m][n];
    visit(vistied, k,  m, n, 0, 0);
    return count;
}
public void visit(boolean visited[][], int k , int m, int n, int i, int j){
    if(i &lt;0 || i&gt;=m || j &lt; 0 || j&gt;= n || visited[i][j] || cal(i, j) &gt; k){
        return;
    }
    visited[i][j] = true;
    count++;
    visit(visited, k, m, n, i+1, j);
    visit(visited, k, m, n, i-1, j);
    visit(visited, k, m, n, i, j+1);
    visit(visited, k, m, n, i, j                                -1);
}
private int cal(int i, int j) {
    int calI = calculate(i);
    int calJ = calculate(j);                                                                                                                            
    return calI + calJ;
}
private int calculate(int num){
    int sum = 0;
    while (num != 0){
        sum += (num%10);
        num /= 10;
    }
    return sum;
}
</code></pre>
<h3 id="面试题14：剪绳子"><a href="#面试题14：剪绳子" class="headerlink" title="面试题14：剪绳子"></a>面试题14：剪绳子</h3><p><strong>动态规划</strong></p>
<pre><code class="lang-java">//理解不好
public int cuttingRope(int n) {
    if (n &lt;= 3) {
        return n - 1;
    }
    int a = n / 3;
    int b = n % 3;
    if (b == 0) {
        return (int) Math.pow(3, a);
    } else if (b == 1) {
        return (int) (Math.pow(3, a - 1) * 4);
    }
    return (int) Math.pow(3, a) * 2;
}
public int cuttingRopeII(int n) {
    int[] dp = new int[n+1];
    if(n&lt;=1){
        return 0;
    }
    if(n==2){
        return 1;
    }
    if(n==3){
        return 2;
    }
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 3;
    int max = 0;
    int temp = 0;
    for(int i = 4; i&lt;=n; i++){
        for(int k=1; k&lt;=i/2; k++){
            temp = dp[k] * dp[i-k];
            if(max &lt; temp){
                max = temp;
            }
        }
        dp[i] = max;
    }
    return dp[n];
}
</code></pre>
<h3 id="面试题15：二进制中1个个数"><a href="#面试题15：二进制中1个个数" class="headerlink" title="面试题15：二进制中1个个数"></a>面试题15：二进制中1个个数</h3><pre><code class="lang-java">public static int numberOf2(int n){
    // n &amp; (n - 1) 会消除 n 中最后一位中的 1。
    int res = 0;
    while (n != 0){
        n &amp;= (n-1);
        res++;
    }
    return res;
}
</code></pre>
<h3 id="面试题16：数值的整数次方"><a href="#面试题16：数值的整数次方" class="headerlink" title="面试题16：数值的整数次方"></a>面试题16：数值的整数次方</h3><h3 id="面试题17：打印从1到最大的n位整数"><a href="#面试题17：打印从1到最大的n位整数" class="headerlink" title="面试题17：打印从1到最大的n位整数"></a>面试题17：打印从1到最大的n位整数</h3><pre><code class="lang-java">public int[] printNumbers(int n ){
    int nums = (int) Math.pow(10, n);
    int[] res = new int[nums-1];
    for (int i = 0; i &lt; nums-1; i++) {
        res[i] = i+1;
    }
    return res;
}
</code></pre>
<h3 id="面试题18：删除链表的节点"><a href="#面试题18：删除链表的节点" class="headerlink" title="面试题18：删除链表的节点"></a>面试题18：删除链表的节点</h3><pre><code class="lang-java">public static ListNode deleteNode(ListNode head, ListNode q) {
    ListNode dummy = new ListNode(-1);
    if (head == null) {
        return null;
    }
    dummy.next = head;
    ListNode pre = dummy;
    ListNode p = head;
    while (p != null) {
        if (p == q) {
            pre.next = p.next;
            p = pre.next;
        }
        else {
            pre = p;
            p = p.next;
        }
    }
    return dummy.next;
}
</code></pre>
<h3 id="面试题19：正则表达式匹配"><a href="#面试题19：正则表达式匹配" class="headerlink" title="面试题19：正则表达式匹配"></a>面试题19：正则表达式匹配</h3><p>还没理好</p>
<h3 id="面试题20：表示数值的字符串"><a href="#面试题20：表示数值的字符串" class="headerlink" title="面试题20：表示数值的字符串"></a>面试题20：表示数值的字符串</h3><p>按照题目提示写就是了</p>
<ul>
<li><code>.</code>: <code>.</code>之前不能出现<code>.</code>和<code>e</code></li>
<li><code>e</code>: <code>e</code>之前不能出现<code>e</code>, 且前一位必须是数字,且后面必须还要有数字</li>
<li><code>+/-</code>: <code>+/-</code>只能出现在0位置或者<code>e</code>后面</li>
</ul>
<pre><code class="lang-java">public static boolean isNumber(String s) {
    if(s == null || s.length() == 0){
        return false;
    }
    boolean res = true;
    boolean isNums = false;
    boolean isDot = false;
    boolean isE = false;
    String trim = s.trim();
    for (int i = 0; i &lt; trim.length(); i++) {
        if (trim.charAt(i) &lt;= '9' &amp;&amp; trim.charAt(i) &gt;= '0') {
            isNums = true;
        } else if (trim.charAt(i) == 'e' || trim.charAt(i) == 'E') {
            if (!isNums || isE) {
                return false;
            }
            isE = true;
            // 防止出现12e的情况(不能表示数字)
            isNums = false;
        } else if (trim.charAt(i) == '.') {
            if (isE || isDot) {
                return false;
            }
            isDot = true;
        } else if (trim.charAt(i) == '+' || trim.charAt(i) == '-') {
            if (i != 0 &amp;&amp; trim.charAt(i - 1) != 'E' &amp;&amp; trim.charAt(i - 1) != 'e') {
                return false;
            }
        } else {
            return false;
        }
    }
    return isNums;
}
</code></pre>
<h3 id="面试题21：调整数组顺序使奇数位于偶数前面"><a href="#面试题21：调整数组顺序使奇数位于偶数前面" class="headerlink" title="面试题21：调整数组顺序使奇数位于偶数前面"></a>面试题21：调整数组顺序使奇数位于偶数前面</h3><pre><code class="lang-java">// 最直白的做法，依次遍历，然后遇到偶数的时候
// 后面的元素调前面，该元素放置末尾
public int[] exchange(int[] nums) {
    if (nums == null || nums.length &lt; 2) {
        return nums;
    }
    int left = 0;
    int right = nums.length - 1;
    int temp[] = new int[nums.length];
    for (int i = 0; i &lt; nums.length; i++) {
        if ((nums[i] &amp; 1) == 0) {//偶数
            temp[right--] = nums[i];
        } else {//奇数
            temp[left++] = nums[i];
        }
    }
    return temp;
}
// 双指针方法
public static int[] exchangeII(int[] nums) {
    int p = 0;
    int q = nums.length - 1;
    while (p &lt; q) {
        while (p &lt; q &amp;&amp; nums[p] % 2 == 0) {
            if(nums[q] %2 == 1){
                int temp = nums[p];
                nums[p] = nums[q];
                nums[q] = temp;
                p++;
                q--;
            }else if(nums[q] %2 == 0){
                q--;
            }
        }
        while (p &lt; q &amp;&amp; nums[p]%2 == 1){
            p++;
        }
    }
    return nums;
}
// 上面的逻辑 是基于正常交换逻辑
// 但是是依次处理， 可以先假设符合条件， 之后将不符合条件的一一处理
// 类似快排的枢轴处理
// 代码的可读性更高
public static int[] exchangeIII(int[] nums){
    int pBegin = 0;
    int pRear = nums.length-1;
    while (pBegin &lt; pRear){
        while (pBegin &lt; pRear &amp;&amp; nums[pBegin]%2 == 1){
            pBegin ++;
        }
        while (pBegin &lt; pRear &amp;&amp; nums[pRear] %2 == 0){
            pRear--;
        }
        if(pBegin &lt; pRear){
            int temp = nums[pBegin];
            nums[pBegin] = nums[pRear];
            nums[pRear] = temp;
        }
    }
    return  nums;
}
</code></pre>
<h3 id="面试题22：链表中倒数第K个节点"><a href="#面试题22：链表中倒数第K个节点" class="headerlink" title="面试题22：链表中倒数第K个节点"></a>面试题22：链表中倒数第K个节点</h3><pre><code class="lang-java">// 遍历两次链表
public static ListNode getKthFromEnd(ListNode head, int k){
    if(head==null){
        return null;
    }
    int length = getLength(head);
    if(k&gt;length){
        return null;
    }
    if(k==length){
        return head;
    }
    ListNode preNode = getPreNode(head, length - k);
    return preNode.next;
}
private static ListNode getPreNode(ListNode head, int preK){
    while (preK &gt; 1){
        head = head.next;
        preK--;
    }
    return head;
}
private static int getLength(ListNode head){
    int length = 0;
    while (head != null){
        head = head.next;
        length ++;
    }
    return length;
}
// 双指针解决
public static ListNode getKthFromEndII(ListNode head, int k){
    if(head == null || k==0){
        return null;
    }
    ListNode fast = head;
    ListNode slow = head;
    while (k-1 &gt; 0){
        fast = fast.next;
        k--;
    }
    while (fast.next != null){
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
}
</code></pre>
<h3 id="面试题23：链表中环的入口节点"><a href="#面试题23：链表中环的入口节点" class="headerlink" title="面试题23：链表中环的入口节点"></a>面试题23：链表中环的入口节点</h3><p>双指针之快慢指针</p>
<pre><code class="lang-java">public ListNode meetingNode(ListNode head) {
    ListNode entry = null;
    if (head == null) {
        return entry;
    }
    ListNode fast = head;
    ListNode slow = head;
    while (fast != null &amp;&amp; fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) {
            ListNode slowII = head;
            while (slow != slowII) {
                slowII = slowII.next;
                slow = slowII.next;
            }
            return slow;
        }
    }
    return null;
}
</code></pre>
<h3 id="面试题24：反转链表"><a href="#面试题24：反转链表" class="headerlink" title="面试题24：反转链表"></a>面试题24：反转链表</h3><p><strong>头插法</strong></p>
<pre><code class="lang-java">public static ListNode reverseList(ListNode head){
    ListNode dummmy = new ListNode(-1);
    ListNode p = head;
    while (p != null){
        ListNode temp = p.next;
        p.next = dummmy.next;
        dummmy.next = p;
        p = temp;
    }
    return dummmy.next;
}
</code></pre>
<h3 id="面试题25：-合并两个排序的链表"><a href="#面试题25：-合并两个排序的链表" class="headerlink" title="面试题25： 合并两个排序的链表"></a>面试题25： 合并两个排序的链表</h3><pre><code class="lang-java">// 尾插法
public ListNode mergeTwoLists(ListNode l1, ListNode l2){
    ListNode dummy = new ListNode(-1);
    ListNode rear = dummy;
    while (l1!= null &amp;&amp; l2!= null){
        if(l1.value &lt;= l2.value){
            rear.next = l1;
            l1 = l1.next;
        }else {
            rear.next = l2;
            l2 = l2.next;
        }
        rear = rear.next;
    }
    if (l1 != null){
        rear.next = l1;
    }
    if (l2!= null) {
        rear.next = l2;
    }
    return dummy.next;
}
</code></pre>
<h3 id="面试题26：树的子结构"><a href="#面试题26：树的子结构" class="headerlink" title="面试题26：树的子结构"></a>面试题26：树的子结构</h3><pre><code class="lang-java">public boolean isSubStructure(TreeNode A, TreeNode B){
    boolean res = false;
    if(A!=null &amp;&amp; B!=null){
        if(A.val == B.val){
            res = doesHaveTree2(A, B);
        }if(!res){
            res = isSubStructure(A.left, B);
        }if(!res){
            res = isSubStructure(A.right, B);
        }
    }
    return res;
}
private boolean doesHaveTree2(TreeNode A, TreeNode B){
    if(B == null) {
        return true;
    }
    if(A == null){
        return false;
    }
    if(A.val != B.val){
        return false;
    }
    return doesHaveTree2(A.left, B.left) &amp;&amp; doesHaveTree2(A.right, B.right);
}
</code></pre>
<h3 id="面试题27：二叉树的镜像"><a href="#面试题27：二叉树的镜像" class="headerlink" title="面试题27：二叉树的镜像"></a>面试题27：二叉树的镜像</h3><pre><code class="lang-java">public TreeNode mirrorTree(TreeNode root) {
    if (root != null) {
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        mirrorTree(root.left);
        mirrorTree(root.right);
    }
    return root;
}
</code></pre>
<h3 id="面试题28：对称二叉树"><a href="#面试题28：对称二叉树" class="headerlink" title="面试题28：对称二叉树"></a>面试题28：对称二叉树</h3><pre><code class="lang-java">// 递归
public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    return isSymmetric(root.left, root.right);
}
private boolean isSymmetric(TreeNode left, TreeNode right) {
    if (left == null &amp;&amp; right == null) {
        return true;
    }
    if ((left != null &amp;&amp; right == null) || (left == null &amp;&amp; right != null)
            || (left.value != right.value)){
        return false;
    }
    return isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left);
}
</code></pre>
<h3 id="面试题29：-顺时针打印矩阵"><a href="#面试题29：-顺时针打印矩阵" class="headerlink" title="面试题29： 顺时针打印矩阵"></a>面试题29： 顺时针打印矩阵</h3><p>打印矩阵的顺序是 <strong>“从左向右、从上向下、从右向左、从下向上”</strong> 循环。基础点为（0,0）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/05/12/rZjqTxz7GlPkyOE.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol>
<li><p>空值处理</p>
</li>
<li><p>初始化， 初始化 上下左右的四个边界<code>t</code>、 <code>b</code>、 <code>l</code>、<code>r</code></p>
</li>
<li><p>循环打印</p>
<ol>
<li><p>根据边界依次添加到<code>res</code>尾部</p>
</li>
<li><p>边界修改（内缩1）</p>
</li>
<li><p>边界是否相遇，若相遇则打印完毕</p>
<p>| 打印方向 |     根据边界打印     | 边界内缩 | 是否打印完毕 |<br>| :———: | :—————————: | :———: | :—————: |<br>| 从左到右 | 左边界：l，右边界: r |   t+1    |  是否t+1&gt;b   |<br>| 从上到下 | 上边界: t，下边界: b |   r-1    |  是否r-1<l |="" 从右到左="" 右边界:="" r，左边界:="" l="" b-1="" 是否b-1<t="" 从下到上="" 下边界:="" b，上边界:="" t="" l+1="" 是否l+1="">r   |</l></p>
</li>
</ol>
</li>
</ol>
<pre><code class="lang-java">public int[] spiralOrderII(int[][] martix){
    if(martix.length == 0){
        return new int[0];
    }
    int l, r, t, b, x=0;
    l = 0;
    r = martix[0].length-1;
    t = 0;
    b = martix.length-1;
    int[] res = new int[(r + 1) * (b + 1)];
    while (true){
        // 从左到右
        for (int i = l; i &lt;= r; i++) {
            res[x++] = martix[t][i];
        }
        if(++t &gt; b){
            break;
        }
        // 从上到下
        for (int i = t; i &lt;= b; i++) {
            res[x++] = martix[i][r];
        }
        if(--r &lt; l){
            break;
        }
        // 从右到左
        for (int i = r; i &gt;= l; i--) {
            res[x++] = martix[b][i];
        }
        if(--b &lt; t){
            break;
        }
        // 从下到上
        for (int i = b; i &gt;= t; i--) {
            res[x++] = martix[i][l];
        }
        if(++l &gt; r){
            break;
        }
    }
    return res;
}
</code></pre>
<h3 id="面试题30：-包含min函数的栈"><a href="#面试题30：-包含min函数的栈" class="headerlink" title="面试题30： 包含min函数的栈"></a>面试题30： 包含min函数的栈</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/05/12/IM5G4vFzfdieaCY.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="函数设计："><a href="#函数设计：" class="headerlink" title="函数设计："></a>函数设计：</h4><ul>
<li>push(x) 函数： 重点为保持栈 B 的元素是 非严格降序 的。<ol>
<li>将 x 压入栈 A （即 A.add(x) ）</li>
<li>若栈 B 为空 或  x 小于等于 栈 B 的栈顶元素，则将 x 压入栈 B（即 B.add(x) ）。</li>
</ol>
</li>
</ul>
<ul>
<li>pop() 函数： 重点为保持栈 A, B 的 元素<strong>一致性</strong> 。<ol>
<li>执行栈 AA 出栈（即 A.pop() ），将出栈元素记为 yy ；</li>
<li>若 y 等于栈 B 的栈顶元素，则执行栈 B 出栈（即 B.pop() ）。</li>
</ol>
</li>
<li>top() 函数： 直接返回栈 A 的栈顶元素即可，即返回 A.peek() 。</li>
<li>min() 函数： 直接返回栈 BB 的栈顶元素即可，即返回 B.peek() 。</li>
</ul>
<pre><code class="lang-java">private Stack&lt;Integer&gt; stackA, stackB;
public Interview30() {
    stackA = new Stack&lt;&gt;();
    stackB = new Stack&lt;&gt;();
}
public void push(int x) {
    stackA.push(x);
    if(stackB.isEmpty() || x &lt;= stackB.peek()){
        stackB.push(x);
    }
}
public void pop() {
    if(stackA.pop().equals(stackB.peek())){
        stackB.pop();
    }
}
public int top() {
    return stackA.peek();
}
public int min() {
    return stackB.peek();
}
</code></pre>
<h3 id="面试题31：栈的压入、弹出序列"><a href="#面试题31：栈的压入、弹出序列" class="headerlink" title="面试题31：栈的压入、弹出序列"></a>面试题31：栈的压入、弹出序列</h3><p><strong>建立一个辅助栈</strong>，只有给定了一个<code>压入</code>和<code>弹出</code>序列，才能确定栈的<code>压入</code>和<code>弹出</code>的顺序。按照题目给的<code>入栈</code>序列<code>[1,2,3,4,5]</code> 和<code>出栈</code>序列<code>[4,5,3,2,1]</code>为例</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>步骤</th>
<th>压入操作</th>
<th>辅助栈</th>
<th>弹出数字</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>压入1</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>压入2</td>
<td>1、2</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>压入3</td>
<td>1、 2、 3</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>压入4</td>
<td>1、 2、 3、4</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>弹出</td>
<td>1、 2、 3</td>
<td>4</td>
</tr>
<tr>
<td>6</td>
<td>压入5</td>
<td>1、2、 3、 5</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>弹出</td>
<td>1、 2、 3</td>
<td>5</td>
</tr>
<tr>
<td>8</td>
<td>弹出</td>
<td>1、 2</td>
<td>3</td>
</tr>
<tr>
<td>9</td>
<td>弹出</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>10</td>
<td>弹出</td>
<td></td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>依次思路，实现如下：</p>
<pre><code class="lang-java">public boolean validateStackSequences(int[] pushed, int[] popped) {
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    int i = 0;
    for (int num : pushed) {
        stack.push(num);
        while (!stack.isEmpty() &amp;&amp; stack.peek() == popped[i]){
            stack.pop();
            i++;
        }
    }
    return stack.isEmpty();
}
</code></pre>
<h3 id="面试题32：从上到下打印二叉树"><a href="#面试题32：从上到下打印二叉树" class="headerlink" title="面试题32：从上到下打印二叉树"></a>面试题32：从上到下打印二叉树</h3><p><strong>层次遍历</strong></p>
<pre><code class="lang-java">public int[] levelOrder(TreeNode root) {
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    if(root == null){
        return new int[0];
    }
    Queue&lt;TreeNode&gt; queue = new LinkedList(){{add(root);}};
    TreeNode q;
    while (!queue.isEmpty()){
        for (int i = 0; i &lt; queue.size(); i++) {
            q = queue.poll();
            list.add(q.val);
            if(q.left != null){
                queue.add(q.left);
            }
            if(q.right!=null){
                queue.add(q.right);
            }
        }
    }
    int[] res = new int[list.size()];
    int i = 0;
    for (Integer integer : list) {
        res[i++] = integer;
    }
    return res;
}
</code></pre>
<h3 id="面试题32-2：分行从上到下打印二叉树"><a href="#面试题32-2：分行从上到下打印二叉树" class="headerlink" title="面试题32-2：分行从上到下打印二叉树"></a>面试题32-2：分行从上到下打印二叉树</h3><p><strong>每一层打印一行</strong></p>
<pre><code class="lang-java">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; out = new ArrayList&lt;&gt;();
    if(root == null){
        return lists;
    }
    Queue&lt;TreeNode&gt; queue = new LinkedList() {{
        add(root);
    }};
    int preCount = 1;
    int count = 0;
    while (!queue.isEmpty()){
        TreeNode p = queue.poll();
        out.add(p.val);
        preCount--;
        if(p.left != null){
            queue.add(p.left);
            count++;
        }
        if (p.right != null) {
            queue.add(p.right);
            count++;
        }
        if(preCount == 0){
            preCount = count;
            count=0;
            lists.add(out);
            out = new ArrayList&lt;&gt;();
        }
    }
    return lists;
}
</code></pre>
<h3 id="面试题32-3：分行从上到下zigzag打印二叉树"><a href="#面试题32-3：分行从上到下zigzag打印二叉树" class="headerlink" title="面试题32-3：分行从上到下zigzag打印二叉树"></a>面试题32-3：分行从上到下zigzag打印二叉树</h3><p><strong>判断当前行数为奇偶即可</strong>说白了就是通过层次遍历获取二叉树的高度。</p>
<pre><code class="lang-java">public static List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; out = new ArrayList&lt;&gt;();
    if(root == null){
        return res;
    }
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    int level = 0;
    queue.add(root);
    while (!queue.isEmpty()){
        level ++;
        int size = queue.size();
        for (int i = 0; i &lt; size; i++) {
            TreeNode p = queue.poll();
            if(level % 2 == 1){
                out.add(p.val);
            }else if(level % 2 == 0){
                out.add(0, p.val);
            }
            if(p.left !=null){
                queue.add(p.left);
            }
            if(p.right != null){
                queue.add(p.right);
            }
        }
        res.add(out);
        out = new ArrayList&lt;&gt;();
    }
    return res;
}
</code></pre>
<h3 id="面试题33：二叉搜索树的后序遍历序列"><a href="#面试题33：二叉搜索树的后序遍历序列" class="headerlink" title="面试题33：二叉搜索树的后序遍历序列"></a>面试题33：二叉搜索树的后序遍历序列</h3><p>递归，还有一个辅助栈的解法，暂时还没看懂，就不贴了</p>
<p>递归的思想和书上一模一样，确定好递归的返回值、终止条件、当前层处理逻辑即可</p>
<pre><code class="lang-java">public boolean verifyPostorder(int[] postorder) {
    if(postorder == null || postorder.length == 0){
        return true;
    }
    return verifyPostorder(postorder, 0, postorder.length-1);
}
private boolean verifyPostorder(int[] postorder, int start, int end){
    // 终止条件
    if(start&gt;=end){
        return true;
    }
    // 当前层处理逻辑
    int p = start;
    while (postorder[p] &lt; postorder[end]) {
        p++;
    }
    int m = p;
    while (postorder[p] &gt; postorder[end]){
        p++;
    }
    // 返回值
    return p == end &amp;&amp; verifyPostorder(postorder, start, m-1) &amp;&amp; verifyPostorder(postorder, m, end-1);
}
</code></pre>
<h3 id="面试题34：二叉树中和为某一值的路径"><a href="#面试题34：二叉树中和为某一值的路径" class="headerlink" title="面试题34：二叉树中和为某一值的路径"></a>面试题34：二叉树中和为某一值的路径</h3><p>这个，直接<code>dfs</code>吧</p>
<pre><code class="lang-java">public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {
    List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;();
    if(root == null){
        return results;
    }
    List&lt;Integer&gt; out = new ArrayList&lt;&gt;();
    backTrack(root , results, out, sum);
    return results;
}
private void backTrack(TreeNode root, List&lt;List&lt;Integer&gt;&gt; lists, List&lt;Integer&gt; out, int ta
    if(root == null){
        return;
    }
    out.add(root.val);
    if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == target){
        lists.add(new ArrayList&lt;&gt;(out));
    }
    backTrack(root.left, lists, out, target-root.val);
    backTrack(root.right, lists, out, target-root.val);
    out.remove(out.size()-1);
}
</code></pre>
<h3 id="面试题35：复杂链表的复制"><a href="#面试题35：复杂链表的复制" class="headerlink" title="面试题35：复杂链表的复制"></a>面试题35：复杂链表的复制</h3><blockquote>
<p>在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p>
</blockquote>
<p><strong>方法1</strong>：</p>
<ol>
<li>先复制链表上的每个节点，将创建的节点使用<code>next</code>指针链接</li>
<li>在原链表上寻找<code>random</code>指针指向的位置，然后新链表上找对应的位置即可</li>
</ol>
<p><strong>方法2：</strong></p>
<ol>
<li>先复制链表上的每个节点，将创建的节点使用<code>next</code>指针链接，同时创建map，存储每个节点的<code>random</code> 指向</li>
<li>新链表确定<code>random</code>时，通过map查找</li>
</ol>
<pre><code class="lang-java">public Node copyRandomList(Node head) {
    Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;();
    Node nodeNew = new Node(head.val);
    map.put(head, nodeNew);
    Node oldP = head;
    Node newP = nodeNew;
    // 第一步 复制节点&amp;next指针
    while (oldP.next != null){
        newP.next = new Node(oldP.next.val);
        newP = newP.next;
        oldP = oldP.next;
        map.put(oldP, newP);
    }
    // 第二步 复制random指针
    oldP = head;
    newP = nodeNew;
    while (oldP != null){
        if(oldP.random!=null){
            newP.random = map.get(oldP.random);
        }
        newP = newP.next;
        oldP = oldP.next;
    }
    return nodeNew;
}
</code></pre>
<p><strong>方法3</strong>：</p>
<ol>
<li>将复制的每个新节点插入原链表的原节点的后面(原节点奇数位置、复制节点偶数位置)</li>
<li>原链表的节点的<code>random</code>指向<code>S</code>，对应的新节点指向<code>S</code>的复制节点<code>S'</code></li>
<li>按照奇偶位置拆分链表即可</li>
</ol>
<h3 id="面试题36：二叉搜索树与双向链表"><a href="#面试题36：二叉搜索树与双向链表" class="headerlink" title="面试题36：二叉搜索树与双向链表"></a>面试题36：二叉搜索树与双向链表</h3><p><strong>不同思路:</strong></p>
<p>和书上的思路略有不同，这道题的核心是中序遍历，书中是遍历到根节点的时候进行处理。我们可以直接进行构造双向链表，不用考虑是否为根节点。</p>
<p>构造双向链表的基础(当前遍历到的节点<code>cur</code>, 其前驱节点<code>pre</code>):</p>
<ol>
<li>不仅要<code>cur.left = pre</code> 还要 <code>pre.right = cur</code></li>
<li>最后，构造的双向链表的头结点<code>head</code>和尾节点<code>tail</code> 需要 <code>head.left = tail</code> , <code>tail.right = head</code></li>
</ol>
<p><strong>二叉树的中序遍历</strong></p>
<pre><code class="lang-java">void inOrder(TreeNode root){
    if(root == null){
        return;
    }
    inOrder(root.left);
    // 操作节点
    dosomething();
    inOrder(root.right);
}
</code></pre>
<p><strong>实现</strong></p>
<pre><code class="lang-java">Node pre, head;
public Node treeToDoublyList(Node root) {
    if(root == null){
        return null;
    }
    recur(root);
    head.left = pre;
    pre.right = head;
    return head;
}
private void recur(Node cur) {
    if(cur == null){
        return;
    }
    recur(cur.left);
    if(pre != null){
        pre.right = cur;
    }else {
        // 确定头节点
        head = cur;
    }
    cur.left = pre;
    pre = cur;
    recur(cur.right);
}
</code></pre>
<h3 id="面试题37：序列化二叉树"><a href="#面试题37：序列化二叉树" class="headerlink" title="面试题37：序列化二叉树"></a>面试题37：序列化二叉树</h3><pre><code class="lang-java">private final String delimiter = ",";
private final String emptyNode = "#";
// Encodes a tree to a single string.
public String serialize(TreeNode root) {
    StringBuilder sb = new StringBuilder();
    if (root == null) {
        return emptyNode;
    }
    serialize(root, sb);
    return sb.toString();
}
private void serialize(TreeNode cur, StringBuilder sb) {
    if (cur == null) {
        sb.append(emptyNode).append(delimiter);
        return;
    }
    sb.append(cur.val).append(delimiter);
    serialize(cur.left, sb);
    serialize(cur.right, sb);
}
// Decodes your encoded data to tree.
public TreeNode deserialize(String data) {
    Deque&lt;String&gt; nodes = new LinkedList&lt;&gt;();
    nodes.addAll(Arrays.asList(data.split(delimiter)));
    return deserialize(nodes);
}
private TreeNode deserialize(Deque&lt;String&gt; nodes) {
    String s = nodes.pollFirst();
    if(s.equalsIgnoreCase(emptyNode)){
        return null;
    }
    TreeNode root = new TreeNode(Integer.parseInt(s));
    root.left = deserialize(nodes);
    root.right = deserialize(nodes);
    return root;
}
</code></pre>
<h3 id="面试题38：-字符串的排列"><a href="#面试题38：-字符串的排列" class="headerlink" title="面试题38： 字符串的排列"></a>面试题38： 字符串的排列</h3><p>排列问题，使用回溯</p>
<h3 id="面试题39：数组中刚出现次数超过一半的数字"><a href="#面试题39：数组中刚出现次数超过一半的数字" class="headerlink" title="面试题39：数组中刚出现次数超过一半的数字"></a>面试题39：数组中刚出现次数超过一半的数字</h3><p><strong>方法一: 使用map</strong></p>
<pre><code class="lang-java">public static int majorityElement(int[] nums) {
    int ret = 0;
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    for (int num : nums) {
        map.compute(num, (k, v) -&gt; {
            if (null == v) {
                v = 0;
            }
            v = v + 1;
            return v;
        });
        if (map.get(num) &gt; nums.length / 2) {
            ret = num;
            break;
        }
    }
    return ret;
}
</code></pre>
<p><strong>方法二：快排枢轴思想</strong></p>
<pre><code class="lang-java">// 快排思想
// 枢轴的选择，若是选择start, 则从high开始while循环。若是选择high,则从low开始while循环
public static int majorityElementII(int[] nums) {
    int middle = nums.length &gt;&gt; 1;
    int len = nums.length;
    int start = 0;
    int end = nums.length - 1;
    int partition = partition(nums, start, end, len);
    while (partition != middle) {
        if (partition &lt; middle) {
            start = partition + 1;
            partition = partition(nums, start, end, len);
        } else {
            end = partition - 1;
            partition = partition(nums, start, end, len);
        }
    }
    if (isMoreThanHalf(nums, len, nums[middle])) {
        return nums[middle];
    }
    return 0;
}
private static int partition(int[] nums, int i, int j, int length) {
    if (nums == null || length == 0 || i &lt; 0 || j &gt;= length) {
        throw new IllegalArgumentException("输入错误");
    }
    int partition = nums[j];
    while (i &lt; j) {
        while (i &lt; j &amp;&amp; nums[i] &lt;= partition) {
            i++;
        }
        nums[j] = nums[i];
        while (i &lt; j &amp;&amp; nums[j] &gt;= partition) {
            j--;
        }
        nums[i] = nums[j];
    }
    nums[j] = partition;
    return i;
}
private static boolean isMoreThanHalf(int[] nums, int length, int num) {
    int times = 0;
    for (int i = 0; i &lt; length; i++) {
        if (nums[i] == num) {
            times++;
        }
    }
    boolean flag = true;
    if (times * 2 &lt;= length) {
        flag = false;
    }
    return flag;
}
</code></pre>
<p><strong>方法三：摩尔投票法</strong></p>
<pre><code class="lang-java">// 摩尔投票
public int majorityElementIII(int[] nums) {
    int votes = 0;
    int mark = 0;
    for (int num : nums) {
        if (votes == 0) {
            mark = num;
        }
        votes += num == mark ? 1 : -1;
    }
    return mark;
}
</code></pre>
<h3 id="面试题40：最小的k个数"><a href="#面试题40：最小的k个数" class="headerlink" title="面试题40：最小的k个数"></a>面试题40：最小的k个数</h3><pre><code class="lang-java">public int[] getLeastNumbers(int[] arr, int k) {
    if(k == arr.length){
        return arr;
    }
    int start = 0;
    int end = arr.length - 1;
    int length = arr.length;
    int partition = partition(arr, start, end, length);
    while (partition != k) {
        if (partition &lt; k) {
            start = partition + 1;
            partition = partition(arr, start, end, length);
        } else {
            end = partition - 1;
            partition = partition(arr, start, end, length);
        }
    }
    int[] res = new int[k];
    for (int i = 0; i &lt; k; i++) {
        res[i] = arr[i];
    }
    return res;
}
private int partition(int[] nums, int start, int end, int length) {
    if (nums == null || nums.length == 0) {
        throw new IllegalArgumentException("参数错误");
    }
    int partition = nums[start];
    while (start &lt; end) {
        while (start &lt; end &amp;&amp; nums[end] &gt;= partition) {
            end--;
        }
        nums[start] = nums[end];
        while (start &lt; end &amp;&amp; nums[start] &lt;= partition) {
            start++;
        }
        nums[end] = nums[start];
    }
    nums[start] = partition;
    return start;
}
</code></pre>
<h3 id="面试题41：数据流中的中位数"><a href="#面试题41：数据流中的中位数" class="headerlink" title="面试题41：数据流中的中位数"></a>面试题41：数据流中的中位数</h3><pre><code class="lang-java">class MedianFinder {
    Queue&lt;Integer&gt; A, B;

    /** initialize your data structure here. */
    public MedianFinder() {
        A = new PriorityQueue&lt;&gt;();
        B = new PriorityQueue&lt;&gt;((x, y) -&gt; (y - x));
    }

    public void addNum(int num) {
        if(A.size() != B.size()) {
            A.add(num);
            B.add(A.poll());
        } else {
            B.add(num);
            A.add(B.poll());
        }
    }
    public double findMedian() {
        return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;
    }
}
</code></pre>
<h3 id="面试题42：连续数组的最大和"><a href="#面试题42：连续数组的最大和" class="headerlink" title="面试题42：连续数组的最大和"></a>面试题42：连续数组的最大和</h3><pre><code class="lang-java">public static int maxSubArray(int[] nums) {
    int sum = 0;
    int maxSum = nums[0];
    for (int num : nums) {
        sum += num;
        if (sum &lt; 0) {
            sum = 0;
        }
        if (maxSum &lt; sum) {
            maxSum = sum;
        }
    }
    return maxSum;
}
</code></pre>
<h3 id="面试题43：1-N整数中1出现的次数"><a href="#面试题43：1-N整数中1出现的次数" class="headerlink" title="面试题43：1~N整数中1出现的次数"></a>面试题43：1~N整数中1出现的次数</h3><p>首先想到的是最基础的算法，暴力枚举(当N非常大的时候，计算就会特别特别慢，时间复杂度 $O(NlogN)$)</p>
<pre><code class="lang-java">public int countDigitOne(int n) {
    int sum = 0;
    for (int i = 1; i &lt;=n; i++) {
        int count = countNumberOf1(i);
        sum += count;
    }
    return sum;
}
private int countNumberOf1(int n){
    int count = 0;
    while (n != 0){
        if(n %10 == 1){
            count++;
        }
        n /= 10;
    }
    return count;
}
</code></pre>
<p><strong>第二种解法：</strong></p>
<p>这个和剑指offer中的思想不太一样，但是也都是递归的思想，<a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/" target="_blank" rel="noopener">思路</a></p>
<p><strong>简单总结：将 1 ~ n 的个位、十位、百位、…1 出现次数相加，即为 1 出现的总次数。</strong></p>
<p>刚开始是分类讨论，当前位的出现1的次数：</p>
<ol>
<li>当前位为1</li>
<li>当前位为0</li>
<li>当前位为2~9</li>
</ol>
<pre><code class="lang-java">public int countDigitOneII(int n){
    int digits=1, res = 0;
    int high = n / 10, cur = n%10, low = 0;
    while (high != 0 || cur != 0){
        if(cur == 1){
            res += high*digits + low +1;
        }else if(cur == 0){
            res += high * digits;
        }else {
            res += (high+1) * digits;
        }
        low += cur * digits;
        cur = high %10;
        high = high/10;
        digits *= 10;
    }
    return res;
}
</code></pre>
<h3 id="面试题44：数字序列中某一位的数字"><a href="#面试题44：数字序列中某一位的数字" class="headerlink" title="面试题44：数字序列中某一位的数字"></a>面试题44：数字序列中某一位的数字</h3><h3 id="面试题45：把数组排成最小数"><a href="#面试题45：把数组排成最小数" class="headerlink" title="面试题45：把数组排成最小数"></a>面试题45：把数组排成最小数</h3><p>排序问题, 自定义比大小规则</p>
<pre><code class="lang-java">public String minNumber(int[] nums) {
    String[] strs = new String[nums.length];
    int i = 0;
    for (int num : nums) {
        strs[i++] = String.valueOf(num);
    }
    Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x));
    StringBuilder sb = new StringBuilder();
    for (String str : strs) {
        sb.append(str);
    }
    return sb.toString();
}
public String minNumberII(int[] nums) {
    String[] strs = new String[nums.length];
    int i = 0;
    for (int num : nums) {
        strs[i++] = String.valueOf(num);
    }
    StringBuilder stringBuilder = new StringBuilder();
    // 快排
    quickSort(strs, 0, strs.length-1);
    for (String str : strs) {
        stringBuilder.append(str);
    }
    return stringBuilder.toString();
}
private void quickSort(String[] strings, int low, int high){
    if(low == high){
        return;
    }
    if(low &lt; high){
        int pri = pri(strings, low, high);
        quickSort(strings, low, pri-1);
        quickSort(strings, pri+1, high);
    }
}
private int position(String[] strs, int left, int right) {
        String temp = strs[left];
        while (left &lt; right) {
            while(left &lt; right &amp;&amp; (strs[right] + temp).compareTo((temp + strs[right])) &gt;= 0) {
                right--;
            }
            strs[left] = strs[right];
            while(left &lt; right &amp;&amp; (strs[left] + temp).compareTo((temp + strs[left])) &lt;= 0) {
                left++;
            }
            strs[right] = strs[left];
        }
        strs[left] = temp;
        return left;
}
</code></pre>
<h3 id="面试题46-把数字翻译成字符串"><a href="#面试题46-把数字翻译成字符串" class="headerlink" title="面试题46: 把数字翻译成字符串"></a>面试题46: 把数字翻译成字符串</h3><pre><code class="lang-java">public int translateNum(int num) {
        String s = String.valueOf(num);
        int[] dp = new int[s.length()+1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i &lt;= s.length(); i ++){
            String temp = s.substring(i-2, i);
            if(temp.compareTo("10") &gt;= 0 &amp;&amp; temp.compareTo("25") &lt;= 0)
                dp[i] = dp[i-1] + dp[i-2];
            else
                dp[i] = dp[i-1];
        }
        return dp[s.length()];
}
</code></pre>
<h3 id="面试题47-礼物的最大值"><a href="#面试题47-礼物的最大值" class="headerlink" title="面试题47: 礼物的最大值"></a>面试题47: 礼物的最大值</h3><p>动态规划</p>
<pre><code class="lang-java">public int maxValue(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (i == 0 &amp;&amp; j == 0) {
                continue;
            }
            if (i == 0) {
                grid[i][j] += grid[i][j - 1];
            } else if (j == 0) {
                grid[i][j] += grid[i - 1][j];
            } else {
                grid[i][j] += Math.max(grid[i - 1][j], grid[i][j - 1]);
            }
        }
    }
    return grid[m - 1][n - 1];
}
</code></pre>
<h3 id="面试题48-最长不含重复字符串的子字符串"><a href="#面试题48-最长不含重复字符串的子字符串" class="headerlink" title="面试题48: 最长不含重复字符串的子字符串"></a>面试题48: 最长不含重复字符串的子字符串</h3><p>滑动窗口</p>
<pre><code class="lang-java">// 滑动窗口
public static int lengthOfLongestSubstring(String s) {
    if(s==null || s.length()==0){
        return 0;
    }
    int low = 0;
    int height = 0;
    int maxSize = 0;
    List&lt;Character&gt; list = new ArrayList&lt;&gt;();
    while (height &lt; s.length()){
        while (height &lt; s.length() &amp;&amp; !list.contains(s.charAt(height))){
            list.add(s.charAt(height));
            height++;
            maxSize = Math.max(maxSize, list.size());
        }
        while (height &lt; s.length() &amp;&amp; list.contains(s.charAt(height))){
            list.remove(0);
        }
    }
    return maxSize;
}
</code></pre>
<h3 id="面试题49：丑数"><a href="#面试题49：丑数" class="headerlink" title="面试题49：丑数"></a>面试题49：丑数</h3><p>最直白的方式超出了时间限制，所以使用动态规划</p>
<pre><code class="lang-java">public static int nthUglyNumber(int n){
        int a = 0, b = 0, c = 0;
        int[] dp = new int[n];
        dp[0] = 1;
        for (int i = 1; i &lt; n; i++) {
            dp[i] = Math.min(Math.min(dp[a] * 2, dp[b] * 3), dp[c] * 5);
            if(dp[i] == dp[a] *2){
                a++;
            }
            if(dp[i] == dp[b] * 3){
                b++;
            }
            if(dp[i] == dp[c] * 5){
                c++;
            }
        }
        return dp[n-1];
}
</code></pre>
<h3 id="面试题50：第一只出现一次的字符"><a href="#面试题50：第一只出现一次的字符" class="headerlink" title="面试题50：第一只出现一次的字符"></a>面试题50：第一只出现一次的字符</h3><p>使用一个Map，利用空间换时间即可</p>
<pre><code class="lang-java">public char firstUniqChar(String s) {
    Map&lt;Character, Boolean&gt; map = new HashMap&lt;&gt;();
    char[] sc  = s.toCharArray();
    for (char c : sc) {
        map.put(c, !map.containsValue(c));
        if(map.get(c)){
            return c;
        }
    }
    return ' ';
}
</code></pre>
<h3 id="面试题51：数组中的逆序对"><a href="#面试题51：数组中的逆序对" class="headerlink" title="面试题51：数组中的逆序对"></a>面试题51：数组中的逆序对</h3><h4 id="最基础的思路，暴力双for循环，不出意外，会超时"><a href="#最基础的思路，暴力双for循环，不出意外，会超时" class="headerlink" title="最基础的思路，暴力双for循环，不出意外，会超时"></a>最基础的思路，暴力双for循环，不出意外，会超时</h4><pre><code class="lang-java">public int reversePairs(int[] nums) {
    int count = 0;
    for (int i = 0; i &lt; nums.length-1; i++) {
        for (int j = i+1; j &lt; nums.length; j++) {
            if(nums[i] &gt; nums[j]){
                count++;
            }
        }
    }
    return count;
}
</code></pre>
<h4 id="第二种思路：回溯"><a href="#第二种思路：回溯" class="headerlink" title="第二种思路：回溯"></a>第二种思路：<strong>回溯</strong></h4><p>好吧，也超时了</p>
<pre><code class="lang-java">public static int reversePairsII(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; out = new ArrayList&lt;&gt;();
    backtrack(nums, res, out, 0);
    return res.size();
}
private static void backtrack(int[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; out, int start) {
    if (out.size() == 2) {
        res.add(new ArrayList&lt;&gt;(out));
    }
    for (int i = start; i &lt; nums.length; i++) {
        if(!out.isEmpty() &amp;&amp; out.get(0) &lt; nums[i]){
            continue;
        }
        out.add(nums[i]);
        backtrack(nums, res, out, i + 1);
        out.remove(out.size() - 1);
    }
}
</code></pre>
<h4 id="第三种思路：归并思想（炸裂，写不出来）"><a href="#第三种思路：归并思想（炸裂，写不出来）" class="headerlink" title="第三种思路：归并思想（炸裂，写不出来）"></a>第三种思路：归并思想（炸裂，写不出来）</h4><pre><code class="lang-java">public int reversePairsIII(int[] nums){
    int length = nums.length;
    if(length &lt; 2){
        return 0;
    }
    // copy数组，用于数组操作
    int[] copy = new int[length];
    int i = 0;
    for (int num : nums) {
        copy[i++] = num;
    }
    // 用于存储操作后的数据
    int[] temp = new int[length];
    return reversePairsIII(copy, 0, length-1, temp);
}
/**
 * nums[left..right] 计算逆序对个数并且排序
 * @param nums
 * @param left
 * @param right
 * @param temp
 * @return
 */
private int reversePairsIII(int[] nums, int left, int right, int[] temp) {
    int mid = left + (right - left) / 2;
    int leftPairs = reversePairsIII(nums, left, mid, temp);
    int rightPairs = reversePairsIII(nums, mid + 1, right, temp);
    if (nums[mid] &lt;= nums[mid + 1]) {
        return leftPairs + rightPairs;
    }
    int crossPairs = mergeAndCount(nums, left, mid, right, temp);
    return leftPairs + rightPairs + crossPairs;
}
private int mergeAndCount(int[] nums, int left, int mid, int right, int[] temp) {
    for (int i = 0; i &lt; nums.length; i++) {
        temp[i] = nums[i];
    }
    int i = left;
    int j = mid + 1;
    int count = 0;
    for (int k = left; k &lt;= right; k++) {
        if (i == mid + 1) {
            nums[k] = temp[j];
            j++;
        } else if (j == right + 1) {
            nums[k] = temp[i];
            i++;
        } else if (temp[i] &lt;= temp[j]) {
            nums[k] = temp[i];
            i++;
        } else {
            nums[k] = temp[j];
            j++;
            count += (mid - i + 1);
        }
    }
    return count;
}
</code></pre>
<h3 id="面试题52：两个链表的第一个公共节点"><a href="#面试题52：两个链表的第一个公共节点" class="headerlink" title="面试题52：两个链表的第一个公共节点"></a>面试题52：两个链表的第一个公共节点</h3><h4 id="第一种思路：暴力双循环"><a href="#第一种思路：暴力双循环" class="headerlink" title="第一种思路：暴力双循环"></a>第一种思路：暴力双循环</h4><h4 id="第二种思路：构造一个环"><a href="#第二种思路：构造一个环" class="headerlink" title="第二种思路：构造一个环"></a>第二种思路：构造一个环</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/05/20/cRJmEYnhySDWBGF.png" alt="环" title="">
                </div>
                <div class="image-caption">环</div>
            </figure>
<p><strong>一图胜万言</strong>，直接上代码</p>
<p>注意, 因为是自己构造的环, 所以需要在返回之前要将构造环的地方断开, 所以不能直接在循环中找到节点就断开</p>
<pre><code class="lang-java">public static ListNode getIntersectionNode(ListNode headA, ListNode headB){
    if (headA == null || headB == null) {
        return null;
    }
    ListNode endA = headA;
    while (endA.next != null) {
        endA = endA.next;
    }
    endA.next = headA;
    ListNode slowII = null;
    // 快慢指针法
    ListNode fast = headB;
    ListNode slow = headB;
    while (fast != null &amp;&amp; fast.next != null){
        fast = fast.next.next;
        slow = slow.next;
        if (slow == fast){
            slowII = headB;
            while (slowII != slow){
                slowII = slowII.next;
                slow = slow.next;
            }
            break;
        }
    }
    endA.next = null;
    return slowII;
}
</code></pre>
<h3 id="面试题53-在排序数组中查找数字"><a href="#面试题53-在排序数组中查找数字" class="headerlink" title="面试题53: 在排序数组中查找数字"></a>面试题53: 在排序数组中查找数字</h3><p><strong>解题思路</strong></p>
<blockquote>
<p>排序数组中的搜索问题，首先想到 <strong>二分法</strong> 解决。</p>
</blockquote>
<p>使用二分法分别找到 左边界 $left$ 和 右边界$right$ ，易得数字$target$的数量为 $right -left -1$</p>
<p><strong>实现步骤</strong></p>
<ol>
<li>初始化左边界 left = 0, 右边界right = length-1;</li>
<li>循环$[left, right]$内无元素的时候退出<ol>
<li>计算中点 $mid = \lfloor left+right \rfloor/2$</li>
<li>nums[mid] &lt; target, 则target在区间$[mid+1, right]$中</li>
<li>nums[mid] &gt; target, 则target在区间$[left, mid-1]$中</li>
<li>nums[mid] = target, 则左边界在$[left, mid-1]$ 中, 右边界在$[mid+1, right]$<ol>
<li>若查找 右边界 right ，则执行 left = mid + 1 ；（跳出时left指向右边界）</li>
<li>若查找 左边界 left，则执行 right = m id - 1 ；（跳出时right指向左边界)</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>代码</strong></p>
<pre><code class="lang-java">public static int search(int[] nums, int target) {
    int i = 0;
    int j = nums.length -1;
    return helper(nums, target) - helper(nums, target-1);
}
private static int helper(int[] nums, int target) {
    int i = 0;
    int j = nums.length - 1;
    while (i &lt;= j) {
        int mid = (i + j) / 2;
        if (nums[mid] &lt;= target) {
            i = mid + 1;
        } else {
            j = mid - 1;
        }
    }
    return i;
}
</code></pre>
<h3 id="面试题53-II-0～n-1中缺失的数字"><a href="#面试题53-II-0～n-1中缺失的数字" class="headerlink" title="面试题53 - II. 0～n-1中缺失的数字"></a>面试题53 - II. 0～n-1中缺失的数字</h3><pre><code class="lang-java">public int missingNumber(int[] nums) {
        int i = 0;
        int j = nums.length - 1;
        while(i &lt; j){
            int mid = (i + j)/ 2;
            if(mid == nums[mid]){
                i = mid + 1;
            }else {
                j = mid;
            }
        }
        if(nums[i] == i){
            return i+1;
        }
        return i;
}
</code></pre>
<h3 id="面试题54-二叉搜索树的第K大节点"><a href="#面试题54-二叉搜索树的第K大节点" class="headerlink" title="面试题54: 二叉搜索树的第K大节点"></a>面试题54: 二叉搜索树的第K大节点</h3><pre><code class="lang-java">int res, k;
public int kthLargest(TreeNode root, int k) {
    this.k = k;
    inOrder(root);
    return res;
}
private void inOrder(TreeNode root){
    if(root == null){
        return;
    }
    inOrder(root.right);
    if(k == 0){
        return;
    }
    if(--k == 0){
        res = root.val;
    }
    inOrder(root.left);
}
</code></pre>
<p><strong>非递归实现</strong></p>
<p>第K小的节点, 寻找第K大的节点, 可以按照右根左遍历</p>
<pre><code class="lang-java">public TreeNode kthNode(TreeNode pRoot, int k){
    Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;();
    TreeNode p = pRoot;
    TreeNode res = null;
    while(p != null || !stack.isEmpty()){
        if(p != null){
            stack.push(p);
            p = p.left;
        }
        else {
            p = stack.pop();
            if(--k == 0){
                res = p;
            }
            p = p.right;
        }
    }
    return res;
}
</code></pre>
<h3 id="面试题55-I-二叉树的深度"><a href="#面试题55-I-二叉树的深度" class="headerlink" title="面试题55-I: 二叉树的深度"></a>面试题55-I: 二叉树的深度</h3><blockquote>
<p>树的遍历方式总体分为两类：深度优先搜索（DFS）、广度优先搜索（BFS）；</p>
<p>常见的 DFS ： 先序遍历、中序遍历、后序遍历；<br>常见的 BFS ： 层序遍历（即按层遍历）。<br>求树的深度需要遍历树的所有节点</p>
</blockquote>
<p>奉上三种解法:一种递归写法(DFS), 两种种借助队列的非递归写法(层次遍历)</p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><pre><code class="lang-java">public int maxDepth(TreeNode root){
    if(root == null){
        return 0;
    }
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
</code></pre>
<h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><pre><code class="lang-java">public int maxDepth(TreeNode root) {
    int level = 0;
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.offer(root);
    TreeNode p = null;
    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i &lt; size; i++) {
            p = queue.poll();
            if (p.left != null) {
                queue.offer(p.left);
            }
            if (p.right != null) {
                queue.offer(p.right);
            }
        }
        level++;
    }
    return level;
}

public int maxDepthII(TreeNode root) {
    int level = 0;
    int preCount = 1;
    int count = 0;
    if (root == null){
        return level;
    }
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    TreeNode p = null;
    queue.offer(root);
    while (!queue.isEmpty()){
        preCount--;
        p = queue.poll();
        if(p.left != null){
            queue.offer(p.left);
            count++;
        }
        if(p.right != null){
            queue.offer(p.right);
            count++;
        }
        if(preCount == 0){
            level++;
            preCount = count;
            count = 0;
        }
    }
    return level;
}
</code></pre>
<h3 id="面试题55-II-平衡二叉树"><a href="#面试题55-II-平衡二叉树" class="headerlink" title="面试题55-II: 平衡二叉树"></a>面试题55-II: 平衡二叉树</h3><h4 id="解法一-自顶向下"><a href="#解法一-自顶向下" class="headerlink" title="解法一(自顶向下):"></a>解法一(自顶向下):</h4><p>借助上一题, 判断当前节点左子树高度和右子树高度,若是绝对值差≤1则当前节点的子树平衡,然后递归的检测每一个子树即可</p>
<pre><code class="lang-java">public boolean isBalanced(TreeNode root) {
    if(root == null){
        return true;
    }
    int left = helper(root.left);
    int right = helper(root.right);
    return Math.abs(left-right) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);
}
private int helper(TreeNode root){
    if(root == null){
        return 0;
    }
    return Math.max(helper(root.left), helper(root.right)) + 1;
}
</code></pre>
<h4 id="解法二-自底向上"><a href="#解法二-自底向上" class="headerlink" title="解法二(自底向上):"></a>解法二(自底向上):</h4><p>但是,上述的解法,重复遍历了很多的节点, 导致性能降低.</p>
<pre><code class="lang-java">public boolean isBalanced(TreeNode root) {
   if(root == null){
       return true;
   }
   return postOrder(root) != -1;
}

private int postOrder(TreeNode root){
    if(root == null){
        return 0;
    }
    int left = postOrder(root.left);
    if(left == -1){
        return -1;
    }
    int right = postOrder(root.right);
    if(right == -1){
        return -1;
    }
    return Math.abs(left-right) &lt; 2? Math.max(left, right) + 1 : -1;
}
</code></pre>
<h3 id="面试题56-I-数组中数字出现的次数"><a href="#面试题56-I-数组中数字出现的次数" class="headerlink" title="面试题56-I: 数组中数字出现的次数"></a>面试题56-I: 数组中数字出现的次数</h3><p>和数组中数字出现一次的思路一样,使用异或操作,但是需要将现有数组分为两组</p>
<p>使得：</p>
<ol>
<li>两个只出现一次的数字在不同的组中；</li>
<li>相同的数字会被分到相同的组中。</li>
</ol>
<pre><code class="lang-java">public static int[] singleNumbers(int[] nums) {
    int[] resNum = new int[2];
    int res = 0;
    for (int num : nums) {
        res ^= num;
    }
    int div = 1;
    while ((div &amp; res) == 0) {
        div &lt;&lt;= 1;
    }
    int a = 0, b = 0;
    for (int num : nums) {
        if ((div &amp; num) == 0) {
            a ^= num;
        }else {
            b ^= num;
        }
    }
    resNum[0] = a;
    resNum[1] = b;
    return resNum;
}
</code></pre>
<h3 id="面试题56-II-数组中唯一出现一次的数字"><a href="#面试题56-II-数组中唯一出现一次的数字" class="headerlink" title="面试题56-II: 数组中唯一出现一次的数字"></a>面试题56-II: 数组中唯一出现一次的数字</h3><pre><code class="lang-java">public int singleNumber(int[] nums) {
    int[] counts = new int[32];
    for(int num : nums) {
        for(int j = 0; j &lt; 32; j++) {
            counts[j] += num &amp; 1;
            num &gt;&gt;&gt;= 1;
        }
    }
    int res = 0, m = 3;
    for(int i = 0; i &lt; 32; i++) {
        res &lt;&lt;= 1;
        res |= counts[31 - i] % m;
    }
    return res;
}
</code></pre>
<h3 id="面试题57-I-和为S的两个数字"><a href="#面试题57-I-和为S的两个数字" class="headerlink" title="面试题57-I: 和为S的两个数字"></a>面试题57-I: 和为S的两个数字</h3><p>双指针问题 while执行要比if效率高一些</p>
<pre><code class="lang-java">public int[] twoSum(int[] nums, int target) {
    int[] res = new int[]{-1, -1};
    int i = 0;
    int j = nums.length - 1;
    while (i &lt; j) {
        int temp = nums[i] + nums[j];
        if(temp == target){
            res[0] = nums[i];
            res[1] = nums[j];
            break;
        }
        while (nums[i] + nums[j] &gt; target){
            j--;
        }
        while (nums[i] + nums[j] &lt;target){
            i++;
        }
    }
    return res;
}
</code></pre>
<h3 id="面试题57-II-和为S的连续整数序列"><a href="#面试题57-II-和为S的连续整数序列" class="headerlink" title="面试题57-II: 和为S的连续整数序列"></a>面试题57-II: 和为S的连续整数序列</h3><p>滑动窗口问题</p>
<pre><code class="lang-java">// 双指针 滑动窗口
public int[][] findContinuousSequenceII(int target) {
    int small = 1;
    int big = 1;
    int curSum = 0;
    List&lt;int[]&gt; res = new ArrayList&lt;&gt;();
    while (small &lt;= target/2){
        while(curSum &lt; target){
            curSum += big;
            big++;
        }
        while(curSum &gt; target){
            curSum -= small;
            small++;
        }
        if(curSum == target){
            int[] arr = new int[big - small];
            for (int i = small; i &lt; big; i++) {
                arr[i-small] = i;
            }
            res.add(arr);
            curSum -= small;
            small++;
        }
    }
    return res.toArray(new int[res.size()][]);
}
</code></pre>
<h3 id="面试题58-I-翻转字符串"><a href="#面试题58-I-翻转字符串" class="headerlink" title="面试题58-I: 翻转字符串"></a>面试题58-I: 翻转字符串</h3><p><strong>循环执行部分</strong></p>
<ol>
<li>索引i从右向左移动 直到搜索到搜个空格</li>
<li>添加单词s[i+1, j+1]到sb中</li>
<li>索引跳过空格</li>
<li>执行j=i, 此时j指向下一个单词的尾字符</li>
</ol>
<pre><code class="lang-java">public String reverseWords(String s) {
    int i = s.length()-1;
    int j = i;
    StringBuilder sb = new StringBuilder();
    while (i &gt;= 0){
        while (i&gt;=0 &amp;&amp; s.charAt(i) != ' '){
            i--;
        }
        sb.append(s.substring(i+1, j+1) + " ");
        while (i&gt;=0 &amp;&amp; s.charAt(i) == ' '){
            i--;
        }
        j = i;
    }
    return sb.toString().trim();
}
</code></pre>
<h3 id="面试题58-II-翻转字符串"><a href="#面试题58-II-翻转字符串" class="headerlink" title="面试题58-II: 翻转字符串"></a>面试题58-II: 翻转字符串</h3><p> <strong>“字符串切片”</strong> ， <strong>“列表遍历拼接”</strong> ， <strong>“字符串遍历拼接”</strong> 三种方法</p>
<p><strong>字符串切片</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/05/25/gj6bfez2nES9RAk.png" alt="字符串切片" title="">
                </div>
                <div class="image-caption">字符串切片</div>
            </figure>
<pre><code class="lang-java">class Solution {
    public String reverseLeftWords(String s, int n) {
        return s.substring(n, s.length()) + s.substring(0, n);
    }
}
</code></pre>
<p><strong>列表遍历拼接</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/05/25/ORwfn3l19JbGvij.png" alt="列表遍历拼接" title="">
                </div>
                <div class="image-caption">列表遍历拼接</div>
            </figure>
<pre><code class="lang-java">public String reverseLeftWords(String s, int n) {
    StringBuilder sb = new StringBuilder();
    for (int i = n; i &lt; s.length(); i++) {
        sb.append(s.charAt(i));
    }
    for (int i = 0; i &lt; n; i++) {
        sb.append(s.charAt(i));
    }
    return sb.toString();
}
</code></pre>
<p><strong>字符串遍历拼接</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/05/25/P7ELQ91F2tjJ3YH.png" alt="字符串遍历拼接" title="">
                </div>
                <div class="image-caption">字符串遍历拼接</div>
            </figure>
<pre><code class="lang-java">public String reverseLeftWords(String s, int n){
    String res = "";
    for (int i = n; i &lt; s.length(); i++) {
        res += s.charAt(i);
    }
    for (int i = 0; i &lt; n; i++) {
        res += s.charAt(i);
    }
    return res;
}
</code></pre>
<p>方法一不消耗额外的空间, 方法二需要创建一个<strong>StringBuilder</strong>对象, 方法三会创建n个<strong>String</strong>对象.</p>
<p>所以效率上:</p>
<p>方法一&gt;方法二&gt;方法三</p>
<h3 id="面试题59-I-滑动窗口的最大值"><a href="#面试题59-I-滑动窗口的最大值" class="headerlink" title="面试题59-I: 滑动窗口的最大值"></a>面试题59-I: 滑动窗口的最大值</h3><p>暴力法: 时间复杂度 $O(nk)$</p>
<pre><code class="lang-java">public static int[] maxSlidingWindow(int[] nums, int k) {
    if(nums.length == 0 || nums == null){
        return new int[]{};
    }
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    int slow = 0;
    int hight = k - 1;
    while (slow &lt; nums.length - k + 1) {
        int max = Integer.MIN_VALUE;
        for (int i = slow; i &lt;= hight; i++) {
            if (nums[i] &gt; max) {
                max = nums[i];
            }
        }
        list.add(max);
        hight++;
        slow++;
    }
    int[] res = new int[list.size()];
    int j = 0;
    for (Integer integer : list) {
        res[j++] = integer;
    }
    return res;
}
</code></pre>
<h3 id="面试题59-II-队列的最大值"><a href="#面试题59-II-队列的最大值" class="headerlink" title="面试题59-II: 队列的最大值"></a>面试题59-II: 队列的最大值</h3><p>和30题的思路一样, 不过这里是维持一个非严格递增的最大双端队列</p>
<p><strong>举例说明:</strong></p>
<p>{2,3,4,2,6,2,5,1}</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>步骤</th>
<th>插入数字</th>
<th>正常队列值</th>
<th>双端队列值</th>
<th>最大值</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>2,3</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>2,3,4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>2,3,4,2</td>
<td>4,2</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>6</td>
<td>2,3,4,2,6</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
<td>2,3,4,2,6,2</td>
<td>6,2</td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td>5</td>
<td>2,3,4,2,6,2,5</td>
<td>6,5</td>
<td>6</td>
</tr>
<tr>
<td>8</td>
<td>1</td>
<td>2,3,4,2,6,2,5,1</td>
<td>6,5,1</td>
<td>6</td>
</tr>
</tbody>
</table>
</div>
<p>在第四步的时候, 接下来如果4弹出之后, 2可能会是最大值, 所以需要入队</p>
<pre><code class="lang-java">private Queue&lt;Integer&gt; queue1;
private Deque&lt;Integer&gt; queue2;
public MaxQueue() { {
    this.queue1 = new LinkedList&lt;&gt;();
    this.queue2 = new LinkedList&lt;&gt;();
}
public int max_value() {
    return queue2.size()&gt;0?queue2.peek():-1;
}
public void push_back(int value) {
    queue1.offer(value);
    while (!queue2.isEmpty() &amp;&amp; queue2.peekLast() &lt; value){
        queue2.pollLast();
    }
    queue2.offer(value);
}
public int pop_front() {
    int ans = queue1.isEmpty()?-1:queue1.poll();
    if(!queue2.isEmpty() &amp;&amp; queue2.peek().equals(ans)){
        queue2.poll();
    }
    return ans;
}
</code></pre>
<h3 id="面试题60-n个骰子的点数"><a href="#面试题60-n个骰子的点数" class="headerlink" title="面试题60: n个骰子的点数"></a>面试题60: n个骰子的点数</h3><h3 id="面试题61-扑克牌中的顺子"><a href="#面试题61-扑克牌中的顺子" class="headerlink" title="面试题61: 扑克牌中的顺子"></a>面试题61: 扑克牌中的顺子</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/05/26/yobfmepW8j1BxEI.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<pre><code class="lang-java">public boolean isStraight(int[] nums) {
    Set&lt;Integer&gt; repeat = new HashSet&lt;&gt;();
    int max = 0;
    int min = 14;
    for (int num : nums) {
        if(num==0){
            continue; // 跳过大小王
        }
        if(repeat.contains(num)){
            return false;
        }
        max = Math.max(max, num);
        min = Math.min(min, num);
        repeat.add(num);
    }
    return max-min &lt; 5;
}
</code></pre>
<h3 id="面试题62-圆圈中最后剩下的数字"><a href="#面试题62-圆圈中最后剩下的数字" class="headerlink" title="面试题62: 圆圈中最后剩下的数字"></a>面试题62: 圆圈中最后剩下的数字</h3><h4 id="构造环-然后按照题意解决"><a href="#构造环-然后按照题意解决" class="headerlink" title="构造环,然后按照题意解决"></a>构造环,然后按照题意解决</h4><p>实践证明, 太繁琐了.复杂度为$O(nm) ≈ O(n^2)$ 会超时</p>
<pre><code class="lang-java">public int lastRemainingII(int n, int m){
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            list.add(i);
        }
        int index = 0;
        while (n &gt; 1){
            index = (index + m - 1) % n;
            list.remove(index);
            n--;
        }
        return list.get(0);

}
</code></pre>
<h4 id="约瑟夫环——公式法（递推公式）"><a href="#约瑟夫环——公式法（递推公式）" class="headerlink" title="约瑟夫环——公式法（递推公式）"></a>约瑟夫环——公式法（递推公式）</h4><pre><code class="lang-java">public int lastRemaining(int n, int m) {
    if(n&lt;1 || m &lt; 1){
        return -1;
    }
    int last = 0;
     // 最后一轮剩下2个人，所以从2开始反推
    for(int i =2; i&lt;=n; i++){
        last = (last+m)%i;
    }
    return last;
}
</code></pre>
<h3 id="面试题63-股票的最大利润"><a href="#面试题63-股票的最大利润" class="headerlink" title="面试题63: 股票的最大利润"></a>面试题63: 股票的最大利润</h3><p>在卖出价格固定的时候, 买入价越低, 利润也就越高, 换成程序理解就是: 在扫描当前元素i的时候, 记住前面i-1个元素中最小的元素.就能在当前卖出的价格中最高</p>
<pre><code class="lang-java">public int maxProfit(int[] prices) {
    if (prices == null || prices.length &lt; 2) {
        return 0;
    }
    int len = prices.length - 1;
    int min = prices[0];
    int diff = prices[1] - prices[0];
    for (int k = 2; k &lt;= len; k++) {
        if (min &gt; prices[k - 1]) {
            min = prices[k - 1];
        }
        diff = Math.max(diff, (prices[k] - min));
    }
    return diff &lt; 0 ? 0 : diff;
}
</code></pre>
<p>其实这道题也可以理解为动态规划问题</p>
<ul>
<li><p>状态定义: 设置动态规划列表$dp$ , $dp[i]$表示以$prces[i]$为结尾的子数组的最大利润</p>
</li>
<li><p>转移方程: 由于题目限定 “买卖该 股票一次” ，因此前$i$日最大利润 $dp[i]$ 等于前$ i - 1$ 日最大利润 $dp[i-1]$ 和第 $i$ 日卖出的最大利润中的最大值。</p>
<p>$dp[i] = max(dp[i-1], (prices[i]- min(prices[0:i])))$</p>
</li>
<li><p>初始状态: $dp[0] = 0$</p>
</li>
<li><p>返回值: $dp[n-1]$</p>
</li>
</ul>
<pre><code class="lang-java">public int maxProfit(int[] prices) {
   int cost = Integer.MAX_VALUE, profit = 0;
   for(int price : prices) {
        cost = Math.min(cost, price);
        profit = Math.max(profit, price - cost);
   }
   return profit;
}
</code></pre>
<h3 id="面试题64-求1-2-…-n的结果"><a href="#面试题64-求1-2-…-n的结果" class="headerlink" title="面试题64: 求1+2+…+n的结果"></a>面试题64: 求1+2+…+n的结果</h3><pre><code class="lang-java">public int sumNums(int n) {
    return (1+n)*n/2;
}
</code></pre>
<h3 id="面试题65-不用加减乘除做加法"><a href="#面试题65-不用加减乘除做加法" class="headerlink" title="面试题65: 不用加减乘除做加法"></a>面试题65: 不用加减乘除做加法</h3><pre><code class="lang-java">public int add(int a, int b) {
    // 当进位为 0 时跳出
    while(b != 0) {
        // c = 进位
        int c = (a &amp; b) &lt;&lt; 1;
        // a = 非进位和
        a ^= b;
        // b = 进位
        b = c;
    }
    return a;
}
</code></pre>
<h3 id="面试题66-构建乘积数组"><a href="#面试题66-构建乘积数组" class="headerlink" title="面试题66: 构建乘积数组"></a>面试题66: 构建乘积数组</h3><pre><code class="lang-java">public int[] constructArr(int[] a) {
    if (a.length == 0) {
        return new int[0];
    }
    int[] b = new int[a.length];
    b[0] = 1;
    for (int i = 1; i &lt; a.length; i++) {
        b[i] = a[i-1] * b[i-1];
    }
    int temp = 1;
    for (int i = a.length-2; i&gt;=0; i--){
        temp *= a[i+1];
        b[i] = b[i] * temp;
    }
    return b;
}
// 使用前缀数组和后缀数组
public int[] constructArrII(int[] nums){
    int[] pre = new int[nums.length];
    int[] post = new int[nums.length];
    pre[0] = 1;
    for(int i = 1; i &lt; nums.length; i++){
        pre[i] = nums[i-1] * pre[i-1];
    }
    post[nums.length-1] = 1;
    for(int i = nums.length-2; i&gt;=0; i--){
        post[i] = post[i+1] * nums[i+1];
    }
    for(int i = 0; i&lt; nums.length; i++){
        pre[i] = pre[i] * post[i];
    }
    return pre;
}
</code></pre>
<h3 id="面试题67-把字符串转换成整数"><a href="#面试题67-把字符串转换成整数" class="headerlink" title="面试题67: 把字符串转换成整数"></a>面试题67: 把字符串转换成整数</h3><pre><code class="lang-java">public int strToInt(String str) {
        char[] c = str.trim().toCharArray();
        if(c.length == 0) return 0;
        int res = 0, bndry = Integer.MAX_VALUE / 10;
        int i = 1, sign = 1;
        if(c[0] == '-') sign = -1;
        else if(c[0] != '+') i = 0;
        for(int j = i; j &lt; c.length; j++) {
            if(c[j] &lt; '0' || c[j] &gt; '9') break;
            if(res &gt; bndry || res == bndry &amp;&amp; c[j] &gt; '7') return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            res = res * 10 + (c[j] - '0');
        }
        return sign * res;
    }
</code></pre>
<h3 id="面试题68-I-二叉搜索树的最近公共祖先"><a href="#面试题68-I-二叉搜索树的最近公共祖先" class="headerlink" title="面试题68-I: 二叉搜索树的最近公共祖先"></a>面试题68-I: 二叉搜索树的最近公共祖先</h3><pre><code class="lang-java">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) {
        return root;
    }
    if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) {
        return lowestCommonAncestor(root.right, p, q);
    }
    if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) {
        return lowestCommonAncestor(root.left, p, q);
    }
    return root;
}
</code></pre>
<h3 id="面试题68-II-二叉树的最近公共祖先"><a href="#面试题68-II-二叉树的最近公共祖先" class="headerlink" title="面试题68-II: 二叉树的最近公共祖先"></a>面试题68-II: 二叉树的最近公共祖先</h3><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/" target="_blank" rel="noopener">无敌讲解</a></p>
<pre><code class="lang-java">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if(root == null || root==p || root ==q){
        return root;
    }
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if(left == null &amp;&amp; right==null){
        return null;
    }
    if(left == null){
        return right;
    }
    if(right == null){
        return left;
    }
    return root;
}
</code></pre>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><p>剑指offer原解</p>
</li>
<li><p><a href="https://leetcode-cn.com/u/jyd/" target="_blank" rel="noopener">Krahets系列题解</a></p>
</li>
<li>LeetCode官方题解</li>
</ul>
<p>5</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2021-07-05T05:19:16.366Z" itemprop="dateUpdated">2021-07-05 13:19:16</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://winniekun.github.io">
            <img src="https://avatars.githubusercontent.com/u/19886738?v=4" alt="weikunkun">
            weikunkun
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%91%E6%8C%87offer/" rel="tag">剑指offer</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://winniekun.github.io/coding-interviews/&title=《剑指offer题解》 — Wkkの笔记&pic=https://avatars.githubusercontent.com/u/19886738?v=4" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://winniekun.github.io/coding-interviews/&title=《剑指offer题解》 — Wkkの笔记&source=数据结构类题目" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://winniekun.github.io/coding-interviews/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《剑指offer题解》 — Wkkの笔记&url=https://winniekun.github.io/coding-interviews/&via=https://winniekun.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://winniekun.github.io/coding-interviews/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/cas/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">cas</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/vector&stack-analysis/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Vector&amp;Stack源码解读</h4>
      </a>
    </div>
  
</nav>



    





















</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


            <p>
                
                    <span>
                        <a href="/atom.xml" target="_blank" class="rss" title="rss">
                            <i class="icon icon-lg icon-rss"></i>
                        </a>
                    </span>
                    
                        <span>
                            博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
                        </span>
            </p>
    </div>
    <div class="bottom">
        <p>
            <span>
                weikunkun &copy;
                    
                        2015 -
                            
                                2021
            </span>
            <span>
                
                        Power by
                        <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
                        <a href="https://github.com/abelsu7/hexo-theme-indigo-plus" target="_blank">indigo plus</a>
                        <p>Hosted by <a href="https://pages.github.com" target="_blank" style="font-weight: bold">Github Pages</a></p>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>
<a href="javascript:;" id="gobottom" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-comments"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://winniekun.github.io/coding-interviews/&title=《剑指offer题解》 — Wkkの笔记&pic=https://avatars.githubusercontent.com/u/19886738?v=4" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://winniekun.github.io/coding-interviews/&title=《剑指offer题解》 — Wkkの笔记&source=数据结构类题目" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://winniekun.github.io/coding-interviews/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《剑指offer题解》 — Wkkの笔记&url=https://winniekun.github.io/coding-interviews/&via=https://winniekun.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://winniekun.github.io/coding-interviews/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACKklEQVR42u3aOXLDMBAEQP3/03biwIElzSwgVxFsRiyKB1rBFvZ4POLj69fx+0pyZ/Lm2bP1gYGBcVnG18vj2T17v5J/9+kaMDAwbsBIQmHy6+uPtd9K7sfAwMDISclm8fVGsN2AYmBgYMxS1haMgYGBkTOSZHKW0LZ/x8dzcQwMjAsyZuX7/zn/SH8DAwPjUoxZsT5vPSZp6sp6ft6DgYFxNCMPcHnJLKeuBFwMDIy7MZLSWLvQveE4b4ViYGCcytg1EpFvItdbCH9cwcDAuAGjDbjttm8lfNctTAwMjOMY64tu240rqeybFBcDA+M4xspYQ95ozJPbZIP4yOM0BgbGcYyVYn3bblz5y/44x8DAOJrRht12iXnQbBPpN51YDAyM4xhtKjvb0s02hW1LFQMD41TGrOjfht0299w8bIGBgXFxxqxmlQ9b5CH448NhGBgYl2UkoXNvqF1JdzEwMO7GyB/I2wMJvm18vrmOgYFxNCMvb8147YBFXrbDwMC4G6MtciXNg13geoeLgYFxA8YsQZ0V5mbRMqoXYmBgHM1YKXttnvuIv4KBgXE2Yzaimj+bbxaT8tzTd2JgYBzN2BWz81HUdnS1HXLFwMA4ldEGzby5uN68zMtzGBgYd2C0wxN5qa4NwXkzAAMDA2M2BtEmq+vJLQYGBkYSWNtFt0tcmsbFwMA4iDEbs5iVyZKU9YO5OAYGxgUZbeo4ayTsCq9LjUwMDIzrMb4BEbMD8UE9+LwAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.jsdelivr.net/npm/node-waves@0.7.6/src/js/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>


<script src="/js/prism.min.js?v=1.7.2"></script>
<script src="/js/prism-vim.min.js?v=1.7.2"></script>
</body>
</html>
