---
title: aqs系列-初识
date: 2020-05-28 11:45:25
tags: 
	- 并发
	- 锁
categories: java
thumbnail:
---

## 前言

<!--more-->

Java的内置锁, 在JDK1.6之前等价于重量级锁, 1.6之后, 做了大量的锁优化策略, 衍生除了偏向锁, 轻量级锁,重量级锁. 使得`synchronized`不再是如此的笨重,  但是和`Lock`相比, 还是缺少了一些灵活性: 虽然`synchronized`提供了便捷的隐式的获取和释放锁(JVM机制), 但是缺少了锁的获取和释放的可操作性,可中断、超时获取锁. 这样就引导我们去了解`Lock`的实现机制, 在了解`Lock`之前, 我们需要先了解一个非常重要的组件`AQS`

它是构建锁或者其他同步组件的基础框架（如ReentrantLock、ReentrantReadWriteLock、Semaphore等），JUC并发包的作者（**Doug Lea**）期望它能够成为实现大部分同步需求的基础。它是JUC并发包中的核心基础组件。

## 核心思想

如果被请求的共享资源空闲, 则将当前请求资源的线程设置为有效的工作线程, 并且将共享资源设置为锁定状态. 如果被请求的共享资源被占用, 那么就需要一套**线程阻塞等待以及被唤醒是锁分配的机制** , 这个机制AQS是用同步队列锁是实现的, 将获不到锁的线程加入到队列中.

![AQS内部数据结构](https://i.loli.net/2020/05/29/INbc5ihoatWKFD4.png)

## 优点

AQS 解决了在实现同步器时涉及到的大量细节问题，例如获取同步状态、FIFO 同步队列。基于 AQS 来构建同步器可以带来**很多好处**。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。在基于 AQS 构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。同时在设计 AQS 时充分考虑了可伸缩性，因此 J.U.C 中，所有基于 AQS 构建的同步器均可以获得这个优势

## 同步状态

`AQS`的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态,  `AQS`使用一个 `int` 类型的成员变量 `state` 来**表示同步状态**：

- 当 `state > 0` 时，表示已经获取了锁。
- 当 `state = 0` 时，表示释放了锁。

在抽象方法实现的过程中, 避免不了要对同步状态的改变, AQS提供了三个方法，来对同步状态 `state` 进行操作，并且 AQS 可以确保对 `state` 的操作是**安全**的：

- `getState()`
- `setState(int newState)`
- `compareAndSetState(int expect, int update)`

> 同时子类被推荐定义为自定义同步组件的静态内部类, AQS自身没有实现任何同步接口,  只是定义了若干的同步状态获取和释放的方法来供自定义同步组件使用, AQS既支持独占的获取同步状态,也支持共享的获取同步状态.这样就可以方便实现不同类型的同步组件(ReentrantLock、ReentrantReadWriteLock和CountDownLatch等)

AQS是实现锁(同步组件)的关键, 锁和AQS的关系: 

1. 锁是面向使用者的, 其定义了使用者和锁交互的接口, 隐藏了实现的细节(ReentrantLock)
2. AQS是面向锁的实现者, 其简化了锁的实现方式, 屏蔽了同步状态的管理, 线程的排队, 等待和唤醒等操作

这样就很好的隔离了使用者和实现着的关注领域

## 同步队列

AQS 通过内置的 FIFO 同步队列来完成资源获取线程的**排队工作**：

- 如果当前线程获取同步状态失败（锁）时，AQS 则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程
- 当同步状态**释放**时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。

## References

* [【死磕Java并发】—–J.U.C之AQS：AQS简介](http://cmsblogs.com/?p=2174)
* Java并发编程的艺术

