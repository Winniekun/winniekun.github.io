---
title: JVM中的垃圾回收器---G1&CMS
mathjax: false
tags: jvm
categories: java
---

## 序

在了解了JVM中的垃圾回收算法之后，接下来就需要理解JVM中具体的收集器，以及其是如何实现对应的回收算法的，有哪些优点，还有哪些不足。



## CMS





## G1

G1 的全称是 Garbage-First。鉴于 CMS 的一些不足之外，比如: 老年代内存碎片化，STW 时间虽然已经改善了很多，但是仍然有提升空间。G1 就横空出世了，它对于 heap 区的内存划思路很新颖，有点算法中分治法`分而治之`的味道。

G1属于全年代的垃圾回收器，不需要去和其他的垃圾回收器进行配合。其他的收集器是基于分代收集算法的理论，所以会直接将整个堆空间划分为`新生代`、`老年代`两个连续的物理空间。但是G1不一样， G1 将整个堆划分为一个个大小相等的小块（每一块称为一个 region），每一块的`内存是连续的`。和分代算法一样，G1 中每个块也会充当 `Eden`、`Survivor`、`Old` 三种角色，但是它们`不是固定的`，这使得内存使用更加地灵活，（多个Region代表新生代，而多个Region并不是强制性的物理连续的，老年代同理）。

**特点：**

1. G1取消了对新生代、老年代的物理划分，而是通过组合Region的形式构成新生代和老年代

2. G1可以通过设置一个垃圾回收动作的预期时间

   如何实现的呢？

   - Region是用于存储实例对象的内存空间，其就有可能产生垃圾，都可以作为回收目标，同时每个region都有一个隐藏属性---回收价值，G1通过跟踪每个Region的回收价值，做到在有限的时间内回收更多的垃圾。  同时相比于CMS每次回收都要扫描整个老年代的内存空间，G1通过跟踪Region的回收价值，然后组合一些最优价值的Region（这些Region属于同一代），而不是直接暴力扫码整个新生代或者老年代。

==Region是动态变化的，其既可以是新生代也可能是老年代。==

### 新生代回收（Young GC 会触发STW）

1. 问题1：每个Region有多大？Region有多少个？

   > -XX:UserG1GC  表示使用G1作为收集器
   >
   > 使用G1收集器之后，JVM会将堆内存划分为2048个Region， Region nums = heap size / 2048

2. 问题2：新生代需要分配多少个Region呢

   > 总Region的5%

3. 问题3：新生代中的Eden、S0、S1空间还适用吗

   > 仍然适用，比例仍然为8:1:1
   >
   > 注意：Eden、S0、S1空间的构成仍然是由多个Region构成，并不是分代收集中的物理上连续的内存空间。

4. 问题4：新生代的垃圾什么时候进行回收

   > 达到60%，然后触发垃圾回收，采用标记复制算法

5. 问题5：新生代经过多久进入老年代

   > 1. 经过多次复制之后，达到阈值 -XX:MaxTenuringThreshold 
   >
   >    也就是经过了多少次Minor GC 对象仍然存活，则进入老年代
   >
   > 2. 动态年龄判断
   >
   >    1. 当前存放对象的survivor区，其对象的存活率已经达到了50%，则直接进入老年代
   >
   > 3. ==大对象不是直接进入老年代的，而是进入Humongous的Region区域==
   >
   >    1. 新生代、老年代垃圾回收会顺带回收Humongous的Region区域

### 老年代回收

对象肯定不会一直处于新生代。

1. 什么时候触发老年代的Region进行垃圾回收

   > 老年代的占比达到45%时，触发垃圾回收

2. 回收范围：

   > 不仅回收老年代的Region，还会回收新生代的Region、大对象的Region
   >
   > 采用的复制算法
   >
   > 整体的回收过程：
   >
   > 1. 初始标记
   >
   > 2. 并发标记
   >
   > 3. 最终标记
   >
   > 4. 筛选清除
   >
   >    老年代中各个region的回收价值，然后开始选中部分新生代、老年代、大对象的Region区域进行回收，触发STW
   >
   >    混合回收阶段分为多次进行（避免一次的回收时间过长）

   









![G1收集器](https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210524195416568.png)

执行垃圾收集时，和 CMS 一样，G1 收集线程在标记阶段和应用程序线程**并发**执行，标记结束后，G1 也就知道哪些区块基本上是垃圾，存活对象极少，G1 会先从这些区块下手，因为从这些区块能很快释放得到很大的可用空间，**这也是为什么 G1 被取名为 Garbage-First 的原因**。

### 执行流程

#### 初始标记

#### 并发标记

#### 最终标记

#### 筛选回收

## references

* 深入理解Java虚拟机
* [G1 垃圾收集器介绍](https://javadoop.com/post/g1)