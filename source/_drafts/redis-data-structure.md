---
title: Redis中使用的数据结构理解与分析
mathjax: false
tags: 数据结构
categories: Redis
---

## 序

一面被面试官问到了如果让自己设计Redis中String，如何设计。

因为太久没使用过C了，勉强记得一个结构体，然后忘了C不像Java那样自动回收内存，同时对于正常的字符的长度获取的时间复杂度是O(1)。所以有些点答的不是很好

![全局hash表](https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210716011241601.png)

## SDS

![SDS](https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210715220709898.png)

![结构体的设计](https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210716002001143.png)

如上，可以看到Redis中的源码，结构体的设计核心为三块儿内容：

1. len：用于标记已经使用的字节数量
2. free：表示当前还可以使用的字节数量
3. 数据类型为char的buf数组： 整个字节数组

### 获取字符串长度的时间复杂度为O(1)

因为C语言中的字符串并不记录自身的长度信息，所以为了获取一个C语言的字符串长度，遍历整个字符串，知道遇到字符串结束的标志位`\0`。时间复杂度为$O(n)$。SDS中有一专门用来统计当前已经使用的字节数量，内部自动维护（涉及到影响字节长度变动的API），所以SDS中获取字符串的长度为$O(1)$

### 支持动态扩容，避免缓冲区溢出

因为底层是数组的形式，运行过程中，数组的长度我们是无法确定，所以为了避免开辟的数组长度不过使用，出新缓冲区溢出的问题，SDS内部有自动扩容的机制。也就是在每次执行字符串增长操作的API时，都会先判断当前的空间大小是否能够容纳增长之后的字符串，然后将SDS的数组空间大小扩容到能够容纳增长后的字符串。

### 尽可能的避免内存重新分配的次数

为了避免每次涉及到字符串增长、缩减时的导致的频繁重新分配数组的大小（内存重新分配）。做了如下优化

1. 预先分配空间：

   除了分配字符串自身的所需的空间大小，还会根据公式多分配一些空间，避免因为字符串增长操作，导致增加内存重新分配次数

2. 懒惰空间释放

   对于字符串的缩短操作，对于空余的空间不会立即回收，主要是应对后序可能继续执行增长操作。同时也有具体的API提供真正释放未使用的空间。

### 总结 

对于SDS的设计，思想整体和JDK中的以Object[]数组作为底层实现的一些集合差不多，如ArrayList、ArrayDeque这种。都需要考虑到自动扩容，正确获取元素数量等问题。唯一的区别就是内存的回收吧，Java是自动挡，C是手动挡。

## 压缩列表

### 结构

作为hash、列表、有序集合键值的底层实现结构。

![压缩列表的数据结构](https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210716185047729.png)

| 属性    | 类型     | 长度  | 用途                                                         |
| ------- | -------- | ----- | ------------------------------------------------------------ |
| zlbytes | Uint32_t | 4字节 | 用于记录压缩列表整体占用内存大小                             |
| zltail  | Uint32_t | 4字节 | 用于记录压缩列表尾节点距离起始位置有多少字节。O(1)时间复杂度获取尾节点的位置 |
| zllen   | Uint32_t | 2字节 | 记录了压缩列表的节点数量                                     |
| entry   | 列表节点 | 不定  | 压缩列表内部各个节点的数据结构                               |
| zlend   | Uint8_t  | 1字节 | 标记压缩列表的末端                                           |





![ziplist](https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210716185630082.png)

![Entry节点内部结构](https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210716190721726.png)

* prevrawlen
  * 用于记录当前节点的前驱节点的大小
* encoding（因为列表内部的数据类型不能确定，所以需要有个标志位标识对应的数据类型）
  * 用于记录当前节点的content属性所保存数据的类型以及长度
    * 用一维地址表示类型和长度
    * 高几位用于表示数据的类型
    * 低位表示数据的实际长度
* content
  * 用于保存实际存储的数据

#### 连锁更新问题：

连锁更新在最坏的情况下，需要对压缩列表需要$O(N)$的时间复杂度进行空间重新分配，同时空间重新分配又需要$O(N)$。所以整体更新的时间复杂度会达到$O(N^2)$

**举例说明：**

首先明确一点。prevrawlen属性记录了前一个节点的长度

1. 如果前一个节点的长度 < 254字节，使用1个字节长度空间
2. 如果前一个节点的长度 > 254字节，使用5个字节长度空间

假设有一个压缩列表，有多个连续的、长度介于250 - 253字节之间的节点。用于记录的前一个节点的长度的prevrawlen的长度为1个字节。如果我们在此基础上，在连续的节点起始位置插入一个长度 > 254字节的节点。就会导致一个连锁效应：

1. 后序第一个节点需要修改用于表示第一个节点长度的prevrawlen属性，改为5字节。同时自身字节长度超过了254了
2. 连锁效应，导致后序的所有的节点都需要重新调整空间长度

**注意：**

虽然有上述的现象，但是条件也比较特殊：

1. 压缩列表需要多个连续的、长度介于250-253字节之间的节点
2. 即使出现了连锁更新，也要整个连续的节点数量很多

所以出现连锁现象很正常，但是出现发生很糟糕的连锁更新现象很小。

## 双向链表

### 结构

类似LinkedList

**整体：**

<img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210716223319991.png" alt="ListNode结构" style="zoom:50%;" />



<img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210716223426796.png" alt="单个Node构造" style="zoom:50%;" />

**应用范围：**

1. 列表键的底层实现
2. 发布订阅
3. 监控



## 有序数组



## Hash表



## 跳表

