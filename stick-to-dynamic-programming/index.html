<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>死磕动态规划 | Wkkの笔记 | 好记性不如烂键盘</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="动态规划,死磕系列">
    <meta name="description" content="前言LeetCode死磕系列七： DP 终于轮到了DP, 怎么说类, 感觉自己写DP的题挺玄幻的, 状态好了, 能找出转移方程, 就能瞬间解决, 搞不好还能优化, 状态不好了, 只知道可以用DP, 也只是知道….">
<meta property="og:type" content="article">
<meta property="og:title" content="死磕动态规划">
<meta property="og:url" content="https://winniekun.github.io/stick-to-dynamic-programming/index.html">
<meta property="og:site_name" content="Wkkの笔记">
<meta property="og:description" content="前言LeetCode死磕系列七： DP 终于轮到了DP, 怎么说类, 感觉自己写DP的题挺玄幻的, 状态好了, 能找出转移方程, 就能瞬间解决, 搞不好还能优化, 状态不好了, 只知道可以用DP, 也只是知道….">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/05/03/pH6t78sQ1OcbyxC.png">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">
<meta property="og:image" content="https://i.loli.net/2021/05/03/VeSxlBqgs3hAuWf.png">
<meta property="og:image" content="https://i.loli.net/2021/05/03/BaXHZ6tGKTwPkpF.png">
<meta property="og:image" content="https://i.loli.net/2021/05/03/uphPcL5YEI81MTg.png">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://i.loli.net/2021/05/03/mJ1etinXxgrUDVh.png">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://i.loli.net/2021/04/12/lFQkd97gexEPaSt.png">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://winniekun.github.io/Users/weikunkun/Library/Application%20Support/typora-user-images/image-20210503172329150.png">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://winniekun.github.io/Users/weikunkun/Library/Application%20Support/typora-user-images/image-20210503182851023.png">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://winniekun.github.io/Users/weikunkun/Library/Application%20Support/typora-user-images/image-20210503192846897.png">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://i.loli.net/2021/05/03/DC472lOaLZEeAx6.png">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://i.loli.net/2021/05/03/bS3WCZPmtzVjnTQ.png">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210625160741945.png">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://i.loli.net/2021/05/03/8RkwpuvamjqLlX6.png">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://i.loli.net/2021/05/03/8bOeEmRhqSCyfrG.png">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">
<meta property="og:image" content="https://i.loli.net/2020/07/16/zEyUVD7BHSgZfmM.png">
<meta property="og:image" content="https://i.loli.net/2020/07/16/zXl6dEmFGOoWZLr.png">
<meta property="og:image" content="https://i.loli.net/2020/07/16/DaAS8LupU6gZxXk.png">
<meta property="og:image" content="https://winniekun.github.io/Users/weikunkun/Library/Application">
<meta property="og:image" content="https://i.loli.net/2021/04/13/BCcVPSgpHxvTdt3.png">
<meta property="article:published_time" content="2020-06-16T02:54:10.000Z">
<meta property="article:modified_time" content="2021-06-28T04:46:20.223Z">
<meta property="article:author" content="weikunkun">
<meta property="article:tag" content="动态规划">
<meta property="article:tag" content="死磕系列">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/05/03/pH6t78sQ1OcbyxC.png">
    
        <link rel="alternate" type="application/atom+xml" title="Wkkの笔记" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <link rel="stylesheet" href="/css/prism/prism-tomorrow-night.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-list-ul"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/people.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="https://avatars.githubusercontent.com/u/19886738?v=4">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">weikunkun</h5>
          <a href="mailto:kongwiki5@gmail.com" title="kongwiki5@gmail.com" class="mail">kongwiki5@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-user-md"></i>
                About
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://winniekun.github.io/acsaber/#/" target="_blank" >
                <i class="icon icon-lg icon-trello"></i>
                LeetCode
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Winniekun" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">死磕动态规划</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">死磕动态规划</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-06-16T02:54:10.000Z" itemprop="datePublished" class="page-time">
  2020-06-16
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/LeetCode/">LeetCode</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前言"><span class="post-toc-number">1.</span> <span class="post-toc-text">前言</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#两大特性"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">两大特性</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目特点"><span class="post-toc-number">2.</span> <span class="post-toc-text">题目特点</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#主要类型"><span class="post-toc-number">3.</span> <span class="post-toc-text">主要类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#I-时间序列模型"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">I:时间序列模型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#II-时间序列加强版-子序列模型"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">II:时间序列加强版(子序列模型)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#III-双序列模型"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">III:双序列模型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#IV-第I类区间型DP"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">IV:第I类区间型DP</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#V-第II类区间型DP"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">V:第II类区间型DP</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#VI-背包入门"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">VI:背包入门</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#LeetCode-amp-Offer-DP题目整理-按照上述的分类整理"><span class="post-toc-number">4.</span> <span class="post-toc-text">LeetCode&amp;Offer DP题目整理(按照上述的分类整理)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#时间序列模型-x"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">时间序列模型❌</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#时间序列模型加强版-子序列问题-white-check-mark"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">时间序列模型加强版(子序列问题)✅</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#双序列模型-white-check-mark"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">双序列模型✅</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#区间序列模型"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">区间序列模型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#区间序列模型加强版"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">区间序列模型加强版</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#背包模型"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">背包模型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组系列"><span class="post-toc-number">4.7.</span> <span class="post-toc-text">数组系列</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解"><span class="post-toc-number">5.</span> <span class="post-toc-text">题解</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#时间序列模型-x-1"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">时间序列模型❌</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#198-打家劫舍-white-check-mark"><span class="post-toc-number">5.1.1.</span> <span class="post-toc-text">198. 打家劫舍 ✅</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#213-打家劫舍-II-white-check-mark"><span class="post-toc-number">5.1.2.</span> <span class="post-toc-text">213.  打家劫舍 II ✅</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#337-打家劫舍-III-white-check-mark"><span class="post-toc-number">5.1.3.</span> <span class="post-toc-text">337. 打家劫舍 III ✅</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#121-买卖股票的最佳时机-white-check-mark"><span class="post-toc-number">5.1.4.</span> <span class="post-toc-text">121. 买卖股票的最佳时机✅</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#122-买卖股票的最佳时机-II-white-check-mark"><span class="post-toc-number">5.1.5.</span> <span class="post-toc-text">122. 买卖股票的最佳时机 II ✅</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#714-买卖股票的最佳时机含手续费-white-check-mark"><span class="post-toc-number">5.1.6.</span> <span class="post-toc-text">714. 买卖股票的最佳时机含手续费✅</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#123-买卖股票的最佳时机-III-white-check-mark"><span class="post-toc-number">5.1.7.</span> <span class="post-toc-text">123. 买卖股票的最佳时机 III✅</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#188-买卖股票的最佳时机-IV-white-check-mark"><span class="post-toc-number">5.1.8.</span> <span class="post-toc-text">188. 买卖股票的最佳时机 IV✅</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#309-最佳买卖股票时机含冷冻期-white-check-mark"><span class="post-toc-number">5.1.9.</span> <span class="post-toc-text">309. 最佳买卖股票时机含冷冻期✅</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#276-栅栏涂色"><span class="post-toc-number">5.1.10.</span> <span class="post-toc-text">276. 栅栏涂色</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#256-粉刷房子"><span class="post-toc-number">5.1.11.</span> <span class="post-toc-text">256. 粉刷房子</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#265-粉刷房子-II"><span class="post-toc-number">5.1.12.</span> <span class="post-toc-text">265. 粉刷房子 II</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#487-最大连续1的个数-II-white-check-mark"><span class="post-toc-number">5.1.13.</span> <span class="post-toc-text">487. 最大连续1的个数 II✅</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1186-删除一次得到子数组最大和-white-check-mark"><span class="post-toc-number">5.1.14.</span> <span class="post-toc-text">1186. 删除一次得到子数组最大和✅</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#时间序列模型加强版（子序列模型）-white-check-mark"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">时间序列模型加强版（子序列模型）✅</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#300-最长递增子序列-white-check-mark"><span class="post-toc-number">5.2.1.</span> <span class="post-toc-text">300. 最长递增子序列✅</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#368-最大整除子集-white-check-mark"><span class="post-toc-number">5.2.2.</span> <span class="post-toc-text">368. 最大整除子集✅</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1105-填充书架"><span class="post-toc-number">5.2.3.</span> <span class="post-toc-text">1105. 填充书架</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#双序列模型-white-check-mark-1"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">双序列模型✅</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#区间序列模型-1"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">区间序列模型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1278-分割回文串-III"><span class="post-toc-number">5.4.1.</span> <span class="post-toc-text">1278. 分割回文串 III</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#813-最大平均值和的分组"><span class="post-toc-number">5.4.2.</span> <span class="post-toc-text">813. 最大平均值和的分组</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#区间序列模型加强版-1"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">区间序列模型加强版</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#背包模型-1"><span class="post-toc-number">5.6.</span> <span class="post-toc-text">背包模型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组系列-1"><span class="post-toc-number">5.7.</span> <span class="post-toc-text">数组系列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#70-爬楼梯"><span class="post-toc-number">5.7.1.</span> <span class="post-toc-text"> 70. 爬楼梯</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#746-使用最小花费爬楼梯"><span class="post-toc-number">5.7.2.</span> <span class="post-toc-text">746. 使用最小花费爬楼梯</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#73-编辑距离"><span class="post-toc-number">5.7.3.</span> <span class="post-toc-text">73. 编辑距离</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#337-打家劫舍-III"><span class="post-toc-number">5.7.4.</span> <span class="post-toc-text">337. 打家劫舍 III</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#53-最大子序和"><span class="post-toc-number">5.7.5.</span> <span class="post-toc-text">53. 最大子序和</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#322-零钱兑换"><span class="post-toc-number">5.7.6.</span> <span class="post-toc-text">322. 零钱兑换</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#518-零钱兑换-II"><span class="post-toc-number">5.7.7.</span> <span class="post-toc-text">518. 零钱兑换 II</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#120-三角形最小路径和"><span class="post-toc-number">5.7.8.</span> <span class="post-toc-text">120 三角形最小路径和</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#300-最长上升子序列"><span class="post-toc-number">5.7.9.</span> <span class="post-toc-text">300  最长上升子序列</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#354-俄罗斯套娃信封"><span class="post-toc-number">5.7.10.</span> <span class="post-toc-text">354. 俄罗斯套娃信封</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#64-最小路径和"><span class="post-toc-number">5.7.11.</span> <span class="post-toc-text"> 64 最小路径和</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#174-地下城游戏"><span class="post-toc-number">5.7.12.</span> <span class="post-toc-text">174 地下城游戏</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#62-不同路径"><span class="post-toc-number">5.7.13.</span> <span class="post-toc-text">62. 不同路径</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#63-不同路径II"><span class="post-toc-number">5.7.14.</span> <span class="post-toc-text">63. 不同路径II</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字符串系列"><span class="post-toc-number">5.8.</span> <span class="post-toc-text">字符串系列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#72-编辑距离"><span class="post-toc-number">5.8.1.</span> <span class="post-toc-text">72. 编辑距离</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#32-最长有效括号"><span class="post-toc-number">5.8.2.</span> <span class="post-toc-text">32. 最长有效括号</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#115-不同的子序列"><span class="post-toc-number">5.8.3.</span> <span class="post-toc-text">115. 不同的子序列</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1143-最长公共子序列"><span class="post-toc-number">5.8.4.</span> <span class="post-toc-text">1143. 最长公共子序列</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最长公共子串"><span class="post-toc-number">5.8.5.</span> <span class="post-toc-text">最长公共子串</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#字符串交错组成"><span class="post-toc-number">5.8.6.</span> <span class="post-toc-text">字符串交错组成</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-LeetCode/stick-to-dynamic-programming"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">死磕动态规划</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-06-16 10:54:10" datetime="2020-06-16T02:54:10.000Z"  itemprop="datePublished">2020-06-16</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/LeetCode/">LeetCode</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LeetCode死磕系列七： DP</p>
<p>终于轮到了DP, 怎么说类, 感觉自己写DP的题挺玄幻的, 状态好了, 能找出转移方程, 就能瞬间解决, 搞不好还能优化, 状态不好了, 只知道可以用DP, 也只是知道…. </p>
<a id="more"></a>
<p>的确, 和网上的很多总结类似, 做到后面也感觉DP使用的数学知识就是数学归纳法, 然后还有自身的优化, 譬如大多数情况自底向上的DP往往要比自顶向下的DP实现起来简约且效率高, 也可使用滚动数组将高纬的dp数组降维.</p>
<h3 id="两大特性"><a href="#两大特性" class="headerlink" title="两大特性"></a>两大特性</h3><ol>
<li><p>无后效行</p>
<ul>
<li>一旦f(i,j)确定，就不用关心 “我们如何计算出f(i,j)”。</li>
<li>想要确定f(i,j)，只需要知道f(i-1,j)和f(i,j-1)的值，而至于它们 是如何算出来的，对当前或之后的任何子问题都没有影响。</li>
<li>过去不依赖将来，将来不影响过去 —- 智巅语录</li>
</ul>
</li>
<li><p>最优子结构</p>
<ol>
<li><p>f(i,j)的定义就已经蕴含了“最优”。</p>
</li>
<li><p>大问题的最优解可以由若干个小 问题的最优解推出。(max,</p>
<p>min, sum…)</p>
</li>
</ol>
</li>
</ol>
<p><strong>DP能适用的问题:能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。</strong></p>
<h2 id="题目特点"><a href="#题目特点" class="headerlink" title="题目特点"></a>题目特点</h2><ol>
<li>计数<ol>
<li>有多少种方式走到右下角</li>
<li>有多少种方法选出k个数使得和是sum</li>
</ol>
</li>
<li>求最大值最小值<ol>
<li>从左上角走到右下角路径的最大数字和</li>
<li>最长上升子序列长度</li>
</ol>
</li>
<li>求存在性<ol>
<li>取石子游戏，先手是否必胜</li>
<li>能不能选出k个数使得和是sum</li>
</ol>
</li>
</ol>
<h2 id="主要类型"><a href="#主要类型" class="headerlink" title="主要类型"></a>主要类型</h2><h3 id="I-时间序列模型"><a href="#I-时间序列模型" class="headerlink" title="I:时间序列模型"></a>I:时间序列模型</h3><p>给出一个序列（字符串、数组），其中每一个元素可以认为一天，并且<strong>今天</strong>的状态只取决于<strong>昨天</strong>的状态</p>
<p><strong>套路</strong></p>
<ul>
<li>定义$dp[i][j]$： 表示第i-th轮的第j种状态（j=1,2,3,..k）</li>
<li>千方百计将$dp[i][j]$和前一轮的状态$dp[i-1][j]$产生关系（j=1,2,3,..k）</li>
<li>最后的结果就是$dp[last][j]$的某种操作（sum、max、min…）</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2021/05/03/pH6t78sQ1OcbyxC.png" alt="image-20210503140232767" title="">
                </div>
                <div class="image-caption">image-20210503140232767</div>
            </figure>
<h3 id="II-时间序列加强版-子序列模型"><a href="#II-时间序列加强版-子序列模型" class="headerlink" title="II:时间序列加强版(子序列模型)"></a>II:时间序列加强版(子序列模型)</h3><p>给出一个序列（数组、字符串），其中每一个元素可以认为<strong>一天</strong>，但是<strong>今天</strong>的状态和之前的<strong>某一天</strong>相关，需要进行挑选</p>
<p><strong>套路</strong></p>
<ul>
<li>定义$dp[i]$: 表示第i-th轮的状态，一般这个状体要求和<u>元素i直接相关</u><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
<li>千方百计的将$dp[i]$与之前的状态$dp[i’]$产生关系（i=1,2,3..i-1）操作如（sum、max、min）<ul>
<li>$dp[i]$肯定不能与大于 i的轮次有任何关系，否 则违反了DP 的无后效性。</li>
</ul>
</li>
<li>最终的结果为$dp[i]$中的某一个</li>
</ul>
<p><img src="https://i.loli.net/2021/05/03/VeSxlBqgs3hAuWf.png" alt="image-20210503141804480" style="zoom:50%;"></p>
<h3 id="III-双序列模型"><a href="#III-双序列模型" class="headerlink" title="III:双序列模型"></a>III:双序列模型</h3><p>给出两个序列$S$和$T$ (数组、字符串)，对它们两个搞事情</p>
<ul>
<li>编辑距离公式</li>
</ul>
<p><strong>套路：</strong></p>
<ul>
<li>定于$dp[i][j]$: 表示针对$S[1:i]$和$T[1:j]$的子问题的求解</li>
<li>千方百计将$dp[i][j]$往之前的状态去转移：$dp[i-1][j], dp[i][j-1], dp[i-1][j-1]$</li>
<li>最终的结果为$dp[m][n]$</li>
</ul>
<h3 id="IV-第I类区间型DP"><a href="#IV-第I类区间型DP" class="headerlink" title="IV:第I类区间型DP"></a>IV:第I类区间型DP</h3><p>给出一个序列（数组、字符串），明确要求分割成<strong>k个连续空间</strong>，要你计算这些区间的某个最优性质。</p>
<p><strong>套路</strong></p>
<ul>
<li>状态定义：$dp[i][k]$表示针对$S[1:i]$分成<strong>k个区间</strong>，此时能够得到的最优解</li>
<li>搜寻最后一个区间的起始位置$j$，将$dp[i][k]$分割成$dp[j-1][k-1]$和$两个部分</li>
<li>最终的结果是$dp[N][K]$</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2021/05/03/BaXHZ6tGKTwPkpF.png" alt="image-20210503143245100" title="">
                </div>
                <div class="image-caption">image-20210503143245100</div>
            </figure>
<h3 id="V-第II类区间型DP"><a href="#V-第II类区间型DP" class="headerlink" title="V:第II类区间型DP"></a>V:第II类区间型DP</h3><p>只给出一个序列S（数组、字符串），求一个针对这个序列的最优解</p>
<p><strong>适合条件：</strong> 这个最优解对于序列的index而言，没有<strong>“无后效性”</strong>。即无法设计$dp[i]$使得 $dp[i]$仅依赖于$dp[j] (j&lt;i)$. 但是大区间的最优解，可以依赖小区间的最优解。</p>
<p><strong>套路：</strong></p>
<ul>
<li>定义$dp[i][j]$:表示针对$s[i:j]$的子问题的求解。</li>
<li>千方百计将最大区间的$dp[i][j]$往小区间的$dp[i’][j’]$转移<ul>
<li>第一层循环是区间大小；第二层循环是起始点</li>
</ul>
</li>
<li>最终的结果是$dp[1][N]$</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2021/05/03/uphPcL5YEI81MTg.png" alt="image-20210503144732050" title="">
                </div>
                <div class="image-caption">image-20210503144732050</div>
            </figure>
<h3 id="VI-背包入门"><a href="#VI-背包入门" class="headerlink" title="VI:背包入门"></a>VI:背包入门</h3><p>题目抽象：给出N件物品，每个物品可用不可用（若干种不同的用法）需要消耗一定的代价。要求以某个有上限C的代价来实现最大收益。（有时候反过来，要求以某个有下限的收益来实现 最小代价。）</p>
<p><strong>套路：</strong></p>
<ul>
<li>定义$dp[i][j]$表示只从前i件物品的子集里面选择、代价为$j$的最大收益<ul>
<li>j = 1、2、3、4…C</li>
</ul>
</li>
<li>千方百计的将$dp[i][j]$往$dp[i-1][j’]$转移：考虑如何使用物品i，对代价/收益的影响<ul>
<li>第一层建议循环物品</li>
<li>第二层建议循环容量/代价</li>
</ul>
</li>
<li>最后的结果$max{dp[N][c]} | c \in {1,2,..c}$</li>
</ul>
<h2 id="LeetCode-amp-Offer-DP题目整理-按照上述的分类整理"><a href="#LeetCode-amp-Offer-DP题目整理-按照上述的分类整理" class="headerlink" title="LeetCode&amp;Offer DP题目整理(按照上述的分类整理)"></a>LeetCode&amp;Offer DP题目整理(按照上述的分类整理)</h2><p><strong>牢记动归的步骤：</strong></p>
<ol>
<li>确定dp的数组和下标的含义</li>
<li>确定递归公式</li>
<li>dp数组的初始化</li>
<li>确定遍历顺序</li>
<li>列举dp数组</li>
</ol>
<h3 id="时间序列模型-x"><a href="#时间序列模型-x" class="headerlink" title="时间序列模型:x:"></a>时间序列模型<span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h3><ol>
<li><a href="https://leetcode-cn.com/problems/house-robber" target="_blank" rel="noopener">198. 打家劫舍</a> <span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
<li><a href="https://leetcode-cn.com/problems/house-robber-ii" target="_blank" rel="noopener">213.  打家劫舍 II</a> <span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
<li><a href="https://leetcode-cn.com/problems/house-robber-iii" target="_blank" rel="noopener">337. 打家劫舍 III</a> <span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a> <span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></li>
<li><a href="https://leetcode-cn.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">376. 摆动序列</a></li>
<li><a href="https://leetcode-cn.com/problems/max-consecutive-ones-ii/" target="_blank" rel="noopener">487. 最大连续1的个数 II</a><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
<li><a href="https://leetcode-cn.com/problems/maximum-subarray-sum-with-one-deletion/" target="_blank" rel="noopener">1186. 删除一次得到子数组最大和</a><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a></li>
<li><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">剑指 Offer 63. 股票的最大利润</a></li>
</ol>
<h3 id="时间序列模型加强版-子序列问题-white-check-mark"><a href="#时间序列模型加强版-子序列问题-white-check-mark" class="headerlink" title="时间序列模型加强版(子序列问题):white_check_mark:"></a>时间序列模型加强版(子序列问题)<span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h3><ol>
<li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长递增子序列</a><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
<li><a href="https://leetcode-cn.com/problems/largest-divisible-subset/" target="_blank" rel="noopener">368. 最大整除子集</a><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li>
</ol>
<h3 id="双序列模型-white-check-mark"><a href="#双序列模型-white-check-mark" class="headerlink" title="双序列模型:white_check_mark:"></a>双序列模型<span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h3><p><strong>备注：</strong>设置dp空间是，看有效位从0还是1开始。</p>
<ul>
<li>从1开始，是为了让dp转移方程更加具有适用性，能从最开始的字符串就能计算</li>
<li>从0开始，需要额外考虑初始化过程。行、列</li>
</ul>
<p><strong>题目：</strong></p>
<ol>
<li><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a> </li>
<li><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号</a></li>
<li><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">115. 不同的子序列</a></li>
<li><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">最长公共子串</a></li>
<li><a href="https://leetcode-cn.com/problems/interleaving-string/" target="_blank" rel="noopener">字符串交错组成</a></li>
</ol>
<h3 id="区间序列模型"><a href="#区间序列模型" class="headerlink" title="区间序列模型"></a>区间序列模型</h3><ol>
<li><a href="https://leetcode-cn.com/problems/palindrome-partitioning-iii/" target="_blank" rel="noopener">1278. 分割回文串 III</a></li>
<li><a href="https://leetcode-cn.com/problems/largest-sum-of-averages/" target="_blank" rel="noopener">813. 最大平均值和的分组</a></li>
</ol>
<h3 id="区间序列模型加强版"><a href="#区间序列模型加强版" class="headerlink" title="区间序列模型加强版"></a>区间序列模型加强版</h3><h3 id="背包模型"><a href="#背包模型" class="headerlink" title="背包模型"></a>背包模型</h3><h3 id="数组系列"><a href="#数组系列" class="headerlink" title="数组系列"></a>数组系列</h3><ol>
<li><a href="https://leetcode-cn.com/problems/climbing-stairs" target="_blank" rel="noopener"> 70. 爬楼梯</a> </li>
<li><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a> </li>
<li><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></li>
<li><a href="https://leetcode-cn.com/problems/house-robber" target="_blank" rel="noopener">198. 打家劫舍</a> </li>
<li><a href="https://leetcode-cn.com/problems/house-robber-ii" target="_blank" rel="noopener">213.  打家劫舍 II</a> </li>
<li><a href="https://leetcode-cn.com/problems/house-robber-iii" target="_blank" rel="noopener">337. 打家劫舍 III</a> </li>
<li><a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener">53. 最大子序和</a> </li>
<li><a href="https://leetcode-cn.com/problems/coin-change" target="_blank" rel="noopener">322. 零钱兑换</a> </li>
<li><a href="https://leetcode-cn.com/problems/coin-change-2" target="_blank" rel="noopener">518. 零钱兑换 II</a> </li>
<li><a href="https://leetcode-cn.com/problems/triangle" target="_blank" rel="noopener">120 三角形最小路径和</a> </li>
<li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence" target="_blank" rel="noopener">300  最长上升子序列</a> </li>
<li><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">354. 俄罗斯套娃信封</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-path-sum" target="_blank" rel="noopener"> 64 最小路径和</a> </li>
<li><a href="https://leetcode-cn.com/problems/dungeon-game" target="_blank" rel="noopener">174 地下城游戏</a> </li>
<li><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">不同路径</a></li>
<li><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">不同路径II</a></li>
</ol>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="时间序列模型-x-1"><a href="#时间序列模型-x-1" class="headerlink" title="时间序列模型:x:"></a>时间序列模型<span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h3><h4 id="198-打家劫舍-white-check-mark"><a href="#198-打家劫舍-white-check-mark" class="headerlink" title="198. 打家劫舍 :white_check_mark:"></a><a href="https://leetcode-cn.com/problems/house-robber" target="_blank" rel="noopener">198. 打家劫舍</a> <span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>时间序列模型：其中每一个元素可以认为一天，并且<strong>今天</strong>的状态只取决于<strong>昨天</strong>的状态</p>
<ol>
<li><p>定于状态$dp[i][j]$ 表示第i家，偷或不偷 $j\in {0,1}, i \in {N_i}$</p>
</li>
<li><p>转移方程</p>
<p><img src="https://i.loli.net/2021/05/03/mJ1etinXxgrUDVh.png" alt="image-20210503151927577" style="zoom:50%;"></p>
<ul>
<li>$ dp[i][j]=\left{ \begin{array}{rcl} dp[i][0]= dp[i-1][1] + val[i] &amp;&amp; {偷}\ dp[i][1]=Math.max(dp[i-1][0], dp[i-1][1]) &amp;&amp;{不偷}\end{array} \right. $</li>
</ul>
</li>
</ol>
<pre><code class="lang-java">class Solution {
    public int rob(int[] nums) {
        // 0表示偷
        // 1表示不偷
        int[][] dp = new int[nums.length][2];
        dp[0][0] = nums[0];
        for (int i = 1; i &lt; nums.length; i++) {
            dp[i][0] = dp[i-1][1] + nums[i];
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]);
            int temp = Math.max(dp[i][0], dp[i][1]);
        }
        int len = nums.length;
        return Math.max(dp[len-1][0], dp[len-1][1]);
    }
}
</code></pre>
<p><strong>一维解法</strong></p>
<ol>
<li><p>定义状态</p>
<p>$dp[i]$表到第i家能偷到的最高金额 </p>
</li>
<li><p>寻找状态转移方程</p>
<ol>
<li>$dp[0]=nums[0]$ : 目前只有一家, 所以对于小偷来说, 就偷这一家就是最高金额</li>
<li>$dp[1] = Math.max(nums[0], nums[1])$: 目前有两家, 对于小偷来说因为条件限制, 所以只能偷两家中金额最大的那家</li>
<li>$dp[2] = Math.max(dp[0]+nums[2], dp[1])$: 目前有三家, 对于小偷来说因为条件限制, 有两种可能  </li>
<li>$dp[3] = Math.max(dp[2], dp[1]+nums[3])$</li>
<li>$dp[i] = Math.max(dp[i-1], dp[i-2]+nums[i])$</li>
</ol>
</li>
<li><p>确定边界值</p>
<ol>
<li>$dp[0] = nums[0]$</li>
<li>$dp[1] = Math.max(nums[0], nums[1])$</li>
</ol>
</li>
</ol>
<pre><code class="lang-java">public int rob(int[] nums) {
    // TODO 校验
    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[1], nums[0]);
    for (int i = 2; i &lt; nums.length; i++) {
        dp[i] = Math.max(dp[i-1], nums[i] + dp[i-2]);
    }
    return dp[nums.length-1];
}
</code></pre>
<h4 id="213-打家劫舍-II-white-check-mark"><a href="#213-打家劫舍-II-white-check-mark" class="headerlink" title="213.  打家劫舍 II :white_check_mark:"></a><a href="https://leetcode-cn.com/problems/house-robber-ii" target="_blank" rel="noopener">213.  打家劫舍 II</a> <span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>绕圈圈的打家劫舍，在循环数组中打家劫舍，思路是一样的，不过需要分类讨论了（注意数组的边界，可能会出现越界问题）</p>
<p>Trick:首位和末位不能同时抢，这说明至少有一个不能抢。</p>
<ol>
<li><p>考虑首位的房子我不抢，那么对于house[1]~house[last]就是一个基本的 House Robber问题。</p>
</li>
<li><p>考虑末位的房子我不抢，那么对于house[0]~house[last-1]就是一个基本的 House Robber问题。</p>
</li>
</ol>
<pre><code class="lang-java">class Solution {
    public int rob(int[] nums) {
        // 环形
        // 1. 首位和末位不能同时抢
        // 1.1 首位抢 array[1:N-1];
        // 1.2 末位抢 array[2:N];
        if (nums.length == 1) {
            return nums[0];
        }
        int len = nums.length;
        int first = rob(nums, 0, len - 2);
        int last = rob(nums, 1, len - 1);
        return Math.max(first, last);
    }

    private int rob(int[] nums, int first, int last) {
        int len = last - first + 1;
        if (last == first) {
            return nums[first];
        }
        int[][] dp = new int[len][2];
        // 0 表示偷. dp[i][0] = dp[i-1][0] + val[i];
        // 1 表示不偷 dp[i][1] = max(dp[i-1][0], dp[i-1][1]);
        dp[0][0] = nums[first];
        for (int i = 1; i &lt; len; i++) {
            dp[i][0] = dp[i-1][1] + nums[first + i];
            dp[i][1] = Math.max(dp[i-1][0], dp[i-1][1]);
        }    
        return Math.max(dp[len - 1][0], dp[len - 1][1]);
    }
}
</code></pre>
<p><strong>一维解法</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2021/04/12/lFQkd97gexEPaSt.png" alt="image-20210412181723948" title="">
                </div>
                <div class="image-caption">image-20210412181723948</div>
            </figure>
<blockquote>
<p>不管是环形的还是正常的数组，数组的位置是不会改变的，所以不会因为偷了i家之后，i-1和i+1就成为邻居了，下次可以考虑在i-1和i+1偷了</p>
</blockquote>
<pre><code class="lang-java">public int rob(int[] nums) {
        // dp
        // 定义dp数组和下标含义
        // dp[i] 到第i间房子后，能获取的最大金额
        // dp[i] = Max(dp[i-1],dp[i-2] + nums[i]);
        // 按照分类
        // 1. 小偷偷的房间不包含头尾
        // 2. 小偷偷的房间包含头部
        // 3. 小偷偷的房间包含尾部
        // 1 包含在了2、3两种情况中了
        if (nums == null || nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return nums[0];
        }
        int left = 0;
        int right = nums.length - 1;
        int first = rob(nums, 0, right - 1);
        int second = rob(nums, 1, right);
        return Math.max(first, second);
    }

    private int rob(int[] nums, int left, int right) {
        if (left == right) {
            return nums[left];
        }
        int len = right - left + 1;
        int[] dp = new int[len];
        dp[0] = nums[left];
        dp[1] = Math.max(nums[left], nums[left + 1]);
        for (int i = 2; i &lt; len; i++) {
            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i+left]);
        }
        return dp[len-1];
    }
</code></pre>
<h4 id="337-打家劫舍-III-white-check-mark"><a href="#337-打家劫舍-III-white-check-mark" class="headerlink" title="337. 打家劫舍 III :white_check_mark:"></a><a href="https://leetcode-cn.com/problems/house-robber-iii" target="_blank" rel="noopener">337. 打家劫舍 III</a> <span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>在树上偷。。。</p>
<p>使用后序遍历，已经包含了遍历，所以只需要确定后序面遍历，遍历过程中向上传递什么内容，按照时间序列模型定义，可以直接返回一个二维数组</p>
<p><img src="/Users/weikunkun/Library/Application Support/typora-user-images/image-20210503172329150.png" alt="image-20210503172329150" style="zoom:50%;"></p>
<p>$ array<em>i[2]=\left{ \begin{array}{rcl}array_i[0]=array</em>{left}[1] + array<em>{right}[1] + root.val  &amp;&amp; {偷}\ array[1]=Max(array</em>{left}[0], array<em>{right}[1]) + Max(arry</em>{right}[0], aray_{right}[1]) &amp;&amp;{不偷}\end{array} \right. $</p>
<pre><code class="lang-java">class Solution {
    public int rob(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int[] array = postOrer(root);
        return Math.max(array[0], array[1]);
    }

    private int[] postOrer(TreeNode root) {
        int[] array = new int[2];
        if (root == null) {
            return array;
        }
        int[] left = postOrer(root.left);
        int[] right = postOrer(root.right);
        // int[] array = new int[2];
        // 0 表示偷 max(left[1], right[1]) + root.val;
        // 1 表示不偷 
        // 向上传递整个array数组
        // 偷当前节点
        int first = root.val+left[1]+right[1];
        // 不偷当前节点
        int second = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        // ans = Math.max()
        array[0] = first;
        array[1] = second;
        return array;
    }
}
</code></pre>
<h4 id="121-买卖股票的最佳时机-white-check-mark"><a href="#121-买卖股票的最佳时机-white-check-mark" class="headerlink" title="121. 买卖股票的最佳时机:white_check_mark:"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>买卖股票有约束，根据题目意思，有以下两个约束条件：</p>
<ul>
<li>条件 1：你不能在买入股票前卖出股票；</li>
<li>条件 2：最多只允许完成一笔交易。</li>
</ul>
<p>因此 <strong>当天是否持股</strong> 是一个很重要的因素，而当前是否持股和<strong>昨天是否持股有关系</strong>，所以也为时间序列模型</p>
<p>若是昨天不持股，今天持股，则和第一天持股一个道理，则当前的金额数量为$-V[i]$，最后我们只需要返回最后一天不持股的最大金额数量即可。</p>
<p><img src="/Users/weikunkun/Library/Application Support/typora-user-images/image-20210503182851023.png" alt="image-20210503182851023" style="zoom: 50%;"></p>
<p>$ dp[i][2]=\left{ \begin{array}{rcl}dp[i][0]= Max(dp[i-1][0], -v[i]])  &amp;&amp; {持股}\ dp[i][1]=Max(dp[i-1][0] + v[i], dp[i-1][1]) &amp;&amp;{不持股}\end{array} \right. $</p>
<pre><code class="lang-java">class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len &lt; 2) {
            return 0;
        }
        // 可以理解为折线统计图，然后求上升最高的线段
        // 不过这次使用动规
        // 0 持股  -prices[i]
        // 1 不持股 +prices[i]
        int[][] dp = new int[len][2];
        dp[0][0] = -prices[0]; // 第0天持股手上的现金
        dp[0][1] = 0; //第0天不持股，手上的现金
        for (int i = 1; i &lt; len; i++) {
            dp[i][0] = Math.max(dp[i-1][0], -prices[i]);
            dp[i][1] = Math.max(dp[i-1][0] + prices[i], dp[i-1][1]);
        }
        return dp[len - 1][1];
    }
}
</code></pre>
<p>附加一题<a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">剑指 Offer 63. 股票的最大利润</a>，一摸一样。</p>
<h4 id="122-买卖股票的最佳时机-II-white-check-mark"><a href="#122-买卖股票的最佳时机-II-white-check-mark" class="headerlink" title="122. 买卖股票的最佳时机 II :white_check_mark:"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a> <span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p><img src="/Users/weikunkun/Library/Application Support/typora-user-images/image-20210503192846897.png" alt="image-20210503192846897" style="zoom: 50%;"></p>
<p>根据上述的转移方式，可以得到如下状态转换</p>
<p>$ dp[i][2]=\left{ \begin{array}{rcl}dp[i][0]= Max(dp[i-1][0], dp[i-1][1]-v[i]])  &amp;&amp; {持股}\ dp[i][1]=Max(dp[i-1][0] + v[i], dp[i-1][1]) &amp;&amp;{不持股}\end{array} \right. $</p>
<pre><code class="lang-java">class Solution {
    public int maxProfit(int[] prices) {
        // 动归
        int len = prices.length;
        int[][] dp = new int[len][2];
        // 初始化
        // 0 表示 第i天持有股票
        // 1 表示 第i不持有股票
        dp[0][1] = 0;
        dp[0][0] = -prices[0];
        for (int i = 1; i &lt; len; i++) {
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] - prices[i]);
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]);

        } 
        return dp[len-1][1];
    }
}
</code></pre>
<h4 id="714-买卖股票的最佳时机含手续费-white-check-mark"><a href="#714-买卖股票的最佳时机含手续费-white-check-mark" class="headerlink" title="714. 买卖股票的最佳时机含手续费:white_check_mark:"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>和上述同理，需要添加手续费</p>
<pre><code class="lang-java">class Solution {
    public int maxProfit(int[] prices, int fee) {
        int len = prices.length;
        // 0 : 持股（买入）
        // 1 : 不持股（售出）
        // dp 定义第i天持股/不持股 所得最多现金
        int[][] dp = new int[len][2];
        dp[0][0] = -prices[0];
        for (int i = 1; i &lt; len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][0] + prices[i] - fee, dp[i - 1][1]);
        }
        return Math.max(dp[len - 1][0], dp[len - 1][1]);
    }
}
</code></pre>
<h4 id="123-买卖股票的最佳时机-III-white-check-mark"><a href="#123-买卖股票的最佳时机-III-white-check-mark" class="headerlink" title="123. 买卖股票的最佳时机 III:white_check_mark:"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2021/05/03/DC472lOaLZEeAx6.png" alt="image-20210503100324818" title="">
                </div>
                <div class="image-caption">image-20210503100324818</div>
            </figure>
<p><strong>思路</strong></p>
<p>最高持有两股，分为四种状态</p>
<ol>
<li>$ dp[i][j]=\left{ \begin{array}{rcl} dp[i][0] = Max(dp[i-1][0], -val[i]) &amp;&amp; {第i天，持第有1股的最大利润}\ dp[i][1]=Max(dp[i-1][1], dp[i-1][0] + val[i]) &amp;&amp; {第i天，售出第1股的最大收益} \dp[i][2] = Max(dp[i-1][2], dp[i-1][1] - val[i] &amp;&amp; {第i天，持有第2股的最大收益} \dp[i][3] = Max(dp[i-1][3], dp[i-1][2] + val[i]) &amp;&amp; {第i天，售出第2股的最大收益} \end{array} \right. $ </li>
</ol>
<p>最后的结果为$Max{dp[N][i]} (i = 0, 1, 2, 3)$</p>
<pre><code class="lang-java">class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        long[][] dp = new long[n][4];
        // 0 持有1股
        // 1 售出1股
        // 2 持有2股
        // 3 售出2股
        // 第0天 持有一股， 第0天不可能出现售出的现象，只有持有第一股的可能
        dp[0][0] = -prices[0];
        dp[0][2] = -prices[0];
        for (int i = 1; i &lt; n; i++) {
            dp[i][0] = Math.max(dp[i-1][0], -prices[i]);
            dp[i][1] = Math.max(dp[i-1][0] + prices[i], dp[i-1][1]);
            dp[i][2] = Math.max(dp[i-1][1] - prices[i], dp[i-1][2]);
            dp[i][3] = Math.max(dp[i-1][2] + prices[i], dp[i-1][3]);
        }
        long res = 0;
        for(int i = 0; i &lt; 4; i++) {
            res = Math.max(res, dp[n-1][i]);
        }
        return (int)res;
    }
}
</code></pre>
<h4 id="188-买卖股票的最佳时机-IV-white-check-mark"><a href="#188-买卖股票的最佳时机-IV-white-check-mark" class="headerlink" title="188. 买卖股票的最佳时机 IV:white_check_mark:"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>属于123题的抽象类型，k次买卖，则我们会出现2*k次的持有、售卖状态，然后我们假设偶数为持有股票，奇数为售卖股票</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2021/05/03/bS3WCZPmtzVjnTQ.png" alt="image-20210503202846471" title="">
                </div>
                <div class="image-caption">image-20210503202846471</div>
            </figure>
<pre><code class="lang-java">class Solution {
    public int maxProfit(int k, int[] prices) {
        // 类比买卖股票III
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int len = prices.length;
        int[][] dp = new int[len][2*k];
        for (int i = 0; i &lt; 2 * k; i++) {
            if (i % 2 == 0) {
                dp[0][i] = -prices[0];
            }
        }
        for (int i = 1; i &lt; len; i++) {
            for (int j = 0; j &lt; 2 * k ; j++) {
                if (j == 0) {
                    dp[i][j] = Math.max(dp[i-1][0], -prices[i]);
                } else if (j % 2 == 0) {
                    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-1] - prices[i]);
                } else {
                    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-1] + prices[i]);        
                }
            }
        }
        // return Arrays.stream(dp[n -1]).max().getAsInt();
        int res = 0;
        for (int i = 0; i &lt; 2 * k; i++) {
            res = Math.max(dp[len-1][i], res);
        }
        return res;
    }
}
</code></pre>
<h4 id="309-最佳买卖股票时机含冷冻期-white-check-mark"><a href="#309-最佳买卖股票时机含冷冻期-white-check-mark" class="headerlink" title="309. 最佳买卖股票时机含冷冻期:white_check_mark:"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210625160741945.png" alt="image-20210625160741945" title="">
                </div>
                <div class="image-caption">image-20210625160741945</div>
            </figure>
<p>$ dp[i][j]=\left{ \begin{array}{rcl} dp[i][0] = Max(dp[i-1][0], dp[i - 1][1] - priece[i]]) &amp;&amp; {第i天，刚持有股票的最大利益}\ dp[i][1]=Max(dp[i-1][1], dp[i-1][2]) &amp;&amp; {冷冻的最大收益} \dp[i][2] = Max(dp[i-1][2], dp[i-1][0] + val[i] &amp;&amp; {这一轮已经清空股票的最大收益} \end{array} \right. $</p>
<pre><code class="lang-java">class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n &lt; 2) {
            return 0;
        }
        //定义 前i天 不同状态的最大利润
        int[][] dp = new int[n][3];
        // 初始化   
        // 0 : 买入
        // 1 : 冷冻
        // 2 : 清空
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        dp[0][2] = 0;
        for (int i = 1; i &lt; n; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][2]);
            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][0] + prices[i]);
        }
        return Arrays.stream(dp[n - 1]).max().getAsInt();
    }
}
</code></pre>
<h4 id="276-栅栏涂色"><a href="#276-栅栏涂色" class="headerlink" title="276. 栅栏涂色"></a><a href="https://leetcode-cn.com/problems/paint-fence/" target="_blank" rel="noopener">276. 栅栏涂色</a></h4><h4 id="256-粉刷房子"><a href="#256-粉刷房子" class="headerlink" title="256. 粉刷房子"></a><a href="https://leetcode-cn.com/problems/paint-house/" target="_blank" rel="noopener">256. 粉刷房子</a></h4><h4 id="265-粉刷房子-II"><a href="#265-粉刷房子-II" class="headerlink" title="265. 粉刷房子 II"></a><a href="https://leetcode-cn.com/problems/paint-house-ii/" target="_blank" rel="noopener">265. 粉刷房子 II</a></h4><h4 id="487-最大连续1的个数-II-white-check-mark"><a href="#487-最大连续1的个数-II-white-check-mark" class="headerlink" title="487. 最大连续1的个数 II:white_check_mark:"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones-ii/" target="_blank" rel="noopener">487. 最大连续1的个数 II</a><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2021/05/03/8RkwpuvamjqLlX6.png" alt="image-20210503235309983" title="">
                </div>
                <div class="image-caption">image-20210503235309983</div>
            </figure>
<pre><code class="lang-java">class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int len = nums.length;
        // 以 当前元素为结尾，是否形式翻转权利的最长连续的1
        int[][] dp = new int[len][2];
        // 0 未翻转1
        // 1 翻转1
        dp[0][1] = 1;
        dp[0][0] = nums[0] == 1 ? 1 : 0;
        int ans = Math.max(dp[0][1], dp[0][0]);
        for (int i = 1; i &lt; len; i++) {
            if (nums[i] == 1) {
                dp[i][0] = dp[i-1][0] + 1;
                dp[i][1] = dp[i-1][1] + 1;
            } else {
                dp[i][1] = dp[i-1][0] + 1;
                dp[i][0] = 0; 
            } 
            ans = Math.max(ans, Math.max(dp[i][0], dp[i][1]));
        }
        return ans;
    }
}
</code></pre>
<h4 id="1186-删除一次得到子数组最大和-white-check-mark"><a href="#1186-删除一次得到子数组最大和-white-check-mark" class="headerlink" title="1186. 删除一次得到子数组最大和:white_check_mark:"></a><a href="https://leetcode-cn.com/problems/maximum-subarray-sum-with-one-deletion/" target="_blank" rel="noopener">1186. 删除一次得到子数组最大和</a><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2021/05/03/8bOeEmRhqSCyfrG.png" alt="image-20210503235251921" title="">
                </div>
                <div class="image-caption">image-20210503235251921</div>
            </figure>
<pre><code class="lang-java">class Solution {
    public int maximumSum(int[] nums) {
        int len = nums.length;
        // 0 不删除
        // 1 删除
        int ans = nums[0];
        int[][] dp = new int[len][2];
        dp[0][0] = nums[0];
        dp[0][1] = 0;
        for (int i = 1; i &lt; len; i++) {
            dp[i][0] = Math.max(dp[i-1][0]+nums[i], nums[i]);
            dp[i][1] = Math.max(dp[i-1][0], dp[i-1][1] + nums[i]);
            int temp = Math.max(dp[i][0], dp[i][1]);
            ans = Math.max(ans, temp);
        }
        return ans;

    }
}
</code></pre>
<h3 id="时间序列模型加强版（子序列模型）-white-check-mark"><a href="#时间序列模型加强版（子序列模型）-white-check-mark" class="headerlink" title="时间序列模型加强版（子序列模型）:white_check_mark:"></a>时间序列模型加强版（子序列模型）<span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h3><h4 id="300-最长递增子序列-white-check-mark"><a href="#300-最长递增子序列-white-check-mark" class="headerlink" title="300. 最长递增子序列:white_check_mark:"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长递增子序列</a><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><pre><code class="lang-java">class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if (len &lt; 2) {
            return len;
        }   
        int[] dp = new int[len];
        Arrays.fill(dp, 1);
        dp[0] = 1;
        int ans = 1;
        for (int i = 1; i &lt; len; i++) {
            for (int j = 0; j &lt; i; j++) {
                if (nums[i] &gt; nums[j]) {
                    dp[i] = Math.max(dp[j] + 1, dp[i]);
                }
            }
            ans = Math.max(dp[i], ans);
        }
        return ans;
    }
}
</code></pre>
<h4 id="368-最大整除子集-white-check-mark"><a href="#368-最大整除子集-white-check-mark" class="headerlink" title="368. 最大整除子集:white_check_mark:"></a><a href="https://leetcode-cn.com/problems/largest-divisible-subset/" target="_blank" rel="noopener">368. 最大整除子集</a><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><pre><code class="lang-java">class Solution {
    public List&lt;Integer&gt; largestDivisibleSubset(int[] nums) {
        int len = nums.length;
        // 第 1 步：动态规划找出最大子集的个数、最大子集中的最大整数
        int[] dp = new int[len];
        Arrays.sort(nums);
        Arrays.fill(dp, 1);
        int maxSize = 1;
        int maxVal = dp[0];
        for (int i = 1; i &lt; len; i++) {
            for (int j = 0; j &lt; i; j++) {
                if (nums[i] % nums[j] == 0) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);           
                }
            }
            if (dp[i] &gt; maxSize) {
                maxSize = dp[i];
                maxVal = nums[i];
            }
        }

         // 第 2 步：倒推获得最大子集
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        if (maxSize == 1) {
            res.add(nums[0]);
            return res;
        }

        for (int i = len - 1; i &gt;= 0 &amp;&amp; maxSize &gt; 0; i--) {
            if (dp[i] == maxSize &amp;&amp; maxVal % nums[i] == 0) {
                res.add(nums[i]);
                maxVal = nums[i];
                maxSize--;
            }
        }
        return res;
    }
}
</code></pre>
<h4 id="1105-填充书架"><a href="#1105-填充书架" class="headerlink" title="1105. 填充书架"></a><a href="https://leetcode-cn.com/problems/filling-bookcase-shelves/" target="_blank" rel="noopener">1105. 填充书架</a></h4><h3 id="双序列模型-white-check-mark-1"><a href="#双序列模型-white-check-mark-1" class="headerlink" title="双序列模型:white_check_mark:"></a>双序列模型<span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h3><h3 id="区间序列模型-1"><a href="#区间序列模型-1" class="headerlink" title="区间序列模型"></a>区间序列模型</h3><p>做到现在，其实可以感觉到，对于区间序列模型，其实基本思想是和子序列模型是类似的，不过子序列模型是从前面的多种状态里面获取最优结果，而区间序列是依据前面多种状态+剩余的元素构成的结果 共同决定的最优结果。</p>
<h4 id="1278-分割回文串-III"><a href="#1278-分割回文串-III" class="headerlink" title="1278. 分割回文串 III"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning-iii/" target="_blank" rel="noopener">1278. 分割回文串 III</a></h4><p>明确要求分割成<strong>K</strong>个连续区间</p>
<p><strong>思路：（经典的区间序列DP）</strong></p>
<ol>
<li>首先需要预处理每个区间$[i, j]$变成回文所需修改的字符数量(直接暴力就能获得)， 计为$cost[i,j]$</li>
<li>设$dp[i][j]$表示前$i$个字符，分为$j$段，最少所需要修改的字符数量，有效字符的下标从$1$开始</li>
<li>初始时$dp[i,j]$为$+\infty$, $dp[0,0] = 0$</li>
<li>转移时，枚举前一次的分割点$l \in {0, i-1}$ 这次转移所产生的新的区间为$[l+1, i]$，$dp[i][j] = min(dp[l][j-1] + g(l+1, j))$。</li>
<li>最终的答案$dp[N][K]$</li>
</ol>
<p><strong>复杂度分析</strong></p>
<ul>
<li>预处理需要$O(n^3)$</li>
<li>动态规划需要$O(nk)$空间</li>
<li>总时间复杂度$O(n^3)$</li>
</ul>
<pre><code class="lang-java">public static int palindromePartition(String s, int _k) {
    int n = s.length();
    s = "#" + s;
    int K = _k;
    int[][] dp = new int[n+1][K+1];
    int[][] cost = new int[n+1][n+1];
    // fill
    for (int[] temp : dp) {
        Arrays.fill(temp, 1000);
    }
    for (int i = 1; i &lt;= n; i++){
        dp[i][1]=calc(s.substring(1, i+1));
    }
    for (int i = 1; i &lt;= n; i++) {
        for (int j = i; j &lt;= n; j++) {
            cost[i][j] = cost[i][j] = calc(s.substring(i, j + 1));
        }
    }
    dp[1][1] = 0;
    for (int i = 1; i &lt;= n; i++) {
        for (int k = 1; k &lt;= Math.min(i, K); k++) {
            for (int l = 0; l &lt;= i - 1; l++) {
                dp[i][k] = Math.min(dp[i][k], dp[l][k-1] + cost[l + 1][i]);
            }
        }
    }
    return dp[n][K];
}
private static int calc(String t) {
    int a = 0;
    int left = 0;
    int right = t.length() - 1;
    while (left &lt; right) {
        if (t.charAt(left) != t.charAt(right)) {
            a++;
        }
        left++;
        right--;
    }
    return a;
}
</code></pre>
<h4 id="813-最大平均值和的分组"><a href="#813-最大平均值和的分组" class="headerlink" title="813. 最大平均值和的分组"></a><a href="https://leetcode-cn.com/problems/largest-sum-of-averages/" target="_blank" rel="noopener">813. 最大平均值和的分组</a></h4><p>本题求“最大值”，一般可以朝DP的方向考虑。另外，<strong>题意里有明确的分成k个subarray的要求</strong>，大概率就是区间型DP。</p>
<p><strong>套路:</strong></p>
<ol>
<li>定义$dp[i][k]$，表示将前$i$个元素分成$k$个subarray的最优解，这里表示前$i$个元素，构成$k$个组，得到的最大平均数的值。突破口就是针对最后一个元素$A[i]$，它必定是在当前的最后一个subarray。</li>
<li>考虑最后的区间的首元素$j$会在哪里？如果选定了这个位置$j$，那么$dp[i][k]$就分解为了两个子问题，一个是$dp[j-1][k-1]$，是以前已经解决的状态，另一个就是$s[j:i]$这段区间的平均值。两者相加就是$dp[i][k]$.我们搜索所有的$j$的位置，选择使$dp[i][k]$最大化的结果。</li>
</ol>
<pre><code class="lang-java">public static double largestSumOfAverages(int[] nums, int k) {
    if (nums == null || nums.length == 0) {
        return 0D;
    }
    int len = nums.length;
    // dp[i][j]: 前i个元素，划分为j组，获得的最大平均总值
    double[][] dp = new double[len+1][k+1];
    // 优化 获取前缀和
    //存储前缀和
    double[] prefixSum = getPrefixSum(nums);
    // int[] prefixSum = new int[len + 1];
    // for(int i = 1; i &lt;= len; i++){
    //     prefixSum[i] = prefixSum[i - 1] + nums[i - 1];
    // }
    for (int i = 1; i &lt;= len; i++) { // 元素
        for (int j = 1; j &lt;= Math.min(i, k); j++) { // 组
            if(j == 1){ //针对只有1个分组的情况
                dp[i][j] = (double)prefixSum[i] / i;
                continue;
            }
            for (int l = 0; l &lt;= i - 1; l++) {
                dp[i][j] = Math.max(dp[i][j], dp[l][j-1] + (double)(prefixSum[i] - prefixSum[l]) / (i - l));
            }
        }
    }
    return dp[len][k];
}
private static double[] getPrefixSum(int[] nums) {
    int len = nums.length;
    double[] prefixSum = new double[len + 1];
    for (int i = 1; i &lt;= len; i++) {
        prefixSum[i] = prefixSum[i-1] + nums[i-1];
    }
    return prefixSum;
}
</code></pre>
<h3 id="区间序列模型加强版-1"><a href="#区间序列模型加强版-1" class="headerlink" title="区间序列模型加强版"></a>区间序列模型加强版</h3><h3 id="背包模型-1"><a href="#背包模型-1" class="headerlink" title="背包模型"></a>背包模型</h3><h3 id="数组系列-1"><a href="#数组系列-1" class="headerlink" title="数组系列"></a>数组系列</h3><h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title=" 70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs" target="_blank" rel="noopener"> 70. 爬楼梯</a></h4><ol>
<li><p>定义状态:</p>
<p>$dp[i]$ 代表到达第$i$阶台阶, 有多少种走法</p>
</li>
<li><p>寻找状态转移方程</p>
<ol>
<li>$dp[1] = 1$: 到达第1阶台阶只有一种走法$[1]$</li>
<li>$dp[2] = 2$: 到达第2阶台阶有两种走法$[1,1], [2]$</li>
<li>$dp[3] = 3$: 到达第3阶台阶有三种走法$[1,1,1], [1,2], [2, 1]$</li>
<li>$dp[4]  = 5$: 到达第4阶台阶有五种走法$[1,1,1,1], [1,1,2],[1,2,1],[2,2][2,1,1]$</li>
<li>通过上述的推演, 可以归纳, $dp[i]=dp[i-1] + dp[i-2]$, 也就是到达第$i$阶的台阶共有<strong>两种可能方式</strong>, 第一种是通过第$i-1$阶再走1步, 第二种是通过第$i-2$阶再走2步, 同时到达第$i-1$阶的走法有$dp[i-1]$种, 到达第$i-2$阶的走法有$dp[i-2]$种, 则$dp[i] = dp[i-1] + dp[i-2]$</li>
</ol>
</li>
<li><p>确定边界值</p>
<p>刚才找状态转移方程的时候已经确定好了</p>
<ol>
<li>$dp[1] = 1$</li>
<li>$dp[2] = 2$</li>
</ol>
</li>
</ol>
<p>因为计算机中, 索引是从0开始的, 如果我们定义长度为n的数组, 则最后一个数组的索引为n-1(<strong>我们理解上的dp[n]也就是数组中的dp[n-1]</strong>), 则我们定义的边界值$dp[0] = 1$, $dp[1] = 2$, 同理, 若是想直接返回dp[n], 则我们就需要将索引为0的数组元素空出来, 也就是dp[0] = 0, dp[1] = 1, dp[2] = 2</p>
<pre><code class="lang-java">public int climbStairsI(int n) {
    if(n &lt;= 2){
        return n;
    }
    int[] dp = new int[n];
    dp[0] = 1;
    dp[1] = 2;
    for(int i = 2; i&lt;n; i++){
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n-1];
}

public int climbStairsII(int n) {
    if(n &lt;= 2){
        return n;
    }
    int[] dp = new int[n+1];
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 2;
    for(int i = 3; i&lt;=n; i++){
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
</code></pre>
<p><strong>最后优化</strong></p>
<p>因为我们上述的算法, 消耗了$O(n)$的空间, 同时我们能感觉到可以使用累加的方式进行计算, 而且也只需要返回最终结果, 中间结果我们没必要存储起来, 所以可以做加法运算</p>
<pre><code class="lang-java">public int climbStairs(int n) {
    if(n &lt;= 2){
        return n;
    }
    int a = 1;
    int b = 2;
    int temp;
    for(int i = 3; i&lt;=n; i++){
        temp = a + b;
        a = b;
        b = temp;
    }
    return b;
}
</code></pre>
<h4 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a></h4><p>$ f[i] = cost[i] + min(f[i+1], f[i+2])$</p>
<pre><code class="lang-java">public int minCostClimbingStairs(int[] cost) {
    int f1 = 0, f2 = 0;
    for (int i = cost.length - 1; i &gt;= 0; --i) {
        int f0 = cost[i] + Math.min(f1, f2);
        f2 = f1;
        f1 = f0;
    }
    return Math.min(f1, f2);
}
</code></pre>
<h4 id="73-编辑距离"><a href="#73-编辑距离" class="headerlink" title="73. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">73. 编辑距离</a></h4><ol>
<li><p>定义状态:</p>
<p>$dp[i][j]$ 表示A的前i个字符到B的前j个字符之间的编辑距离</p>
</li>
<li><p>寻找状态转移方程</p>
<p>我觉得二维的状态, 画在纸上更加的简单明了</p>
<p><img src="https://i.loli.net/2020/07/16/zEyUVD7BHSgZfmM.png" alt="初始化"></p>
<p><img src="https://i.loli.net/2020/07/16/zXl6dEmFGOoWZLr.png" alt="过程说明"></p>
<p><img src="https://i.loli.net/2020/07/16/DaAS8LupU6gZxXk.png" alt="运行部分结果"></p>
<ol>
<li>$dp[0][j]$表示一个空字符串A到B的前j个字符之间的距离</li>
<li>$dp[i][0]$表示一个空字符串B到字符串A的前i个字符之间的距离</li>
<li>$d[i,j]=min(d[i-1,j]+1 、d[i,j-1]+1、d[i-1,j-1]+temp)$ 这三个当中的最小值<ol>
<li>$str1[i] == str2[j]$，表示相同, 用temp记录它，为0。否则temp记为1</li>
<li>$dp[i-1][j]$ 表示增加操作</li>
<li>$dp[i][j-1]$表示删除操作</li>
<li>$dp[i-1][j-1] + temp$表示替换操作</li>
</ol>
</li>
</ol>
</li>
<li><p>边界值</p>
<ol>
<li>$dp[i][0]$</li>
<li>$dp[0][j]$</li>
</ol>
</li>
</ol>
<pre><code class="lang-java">public static int minDistance(String word1, String word2) {
    int m = word1.length();
    int n = word2.length();
    int[][] dp = new int[m+1][n+1];
    dp[0][0] = 0;
    // 初始化dp
    for(int i = 1; i&lt;=m; i++){
        dp[i][0] = dp[i-1][0] + 1;
    }
    for(int j = 1; j&lt;=n; j++){
        dp[0][j] = dp[0][j-1] + 1;
    }
    int temp = 0;
    // 转移方程: dp[i][j] = Math.min(dp[i-1][j-1]+temp,
    //                       dp[i][j-1]+1, dp[i-1][j]+1);
    for(int i = 1; i&lt;=m; i++){
        for(int j = 1; j&lt;=n; j++){
            // 因为我们的数组这只有效位从1开始
            // 所以标记当前遍历到的字符串的位置为i-1|j-1
            if(word1.charAt(i-1) == word2.charAt(j-1)){
                temp = 0;
            }else {
                temp = 1;
            }
            dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]) + 1, dp[i-1][j-1] + temp);
        }
    }
    return dp[m][n];
}
</code></pre>
<h4 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a href="https://leetcode-cn.com/problems/house-robber-iii" target="_blank" rel="noopener">337. 打家劫舍 III</a></h4><p>在树上偷。。。</p>
<p>使用后序遍历，定义一个二维数组</p>
<ol>
<li><p>dp[0] : 不偷当前节点的结果</p>
<p>$dp[0] = Math.max(left[0], left[1]) + Math.max(rigth[0] + right[1])$</p>
</li>
<li><p>dp[1]：偷当前节点的结果</p>
<p>$dp[1] = root.val + left[0] + right[0]$</p>
</li>
</ol>
<pre><code class="lang-java">public int rob(TreeNode root) {
    int[] res = postOrder(root);
    return Math.max(res[0], res[1]);
}
private int[] postOrder(TreeNode root) {
    if (root == null) {
        return new int[2];
    }
    int[] left = postOrder(root.left);
    int[] right = postOrder(root.right);
    int[] res = new int[2];
    // 不偷当前节点
    int first = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
    // 偷当前节点
    int second = root.val+left[0]+right[0];
    res[0] = first;
    res[1] = second;
    return res;
}
</code></pre>
<h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener">53. 最大子序和</a></h4><h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change" target="_blank" rel="noopener">322. 零钱兑换</a></h4><h4 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode-cn.com/problems/coin-change-2" target="_blank" rel="noopener">518. 零钱兑换 II</a></h4><h4 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120 三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle" target="_blank" rel="noopener">120 三角形最小路径和</a></h4><h4 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300  最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence" target="_blank" rel="noopener">300  最长上升子序列</a></h4><h4 id="354-俄罗斯套娃信封"><a href="#354-俄罗斯套娃信封" class="headerlink" title="354. 俄罗斯套娃信封"></a><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">354. 俄罗斯套娃信封</a></h4><p>最后的思路和最长上升子序列一样，不过在此之之前需要整理好数据</p>
<pre><code class="lang-java">/**
 * 354 俄罗斯套娃信封
 * 思路： 详见程序员代码面试指南216页
 * @author weikunkun
 * @since 2021/4/2
 */
public class LC_354 {
    public int maxEnvelopes(int[][] envelopes) {
        // 思路
        // 封装一个信封对象，然后按照信封的宽度进行排序 小-大
        // 如果宽度相同，按照高度排序 大到小
        // 之后 对 高度序列 求最长递增子序列即可
        Envelope[] array = genEnvelope(envelopes);
        int[] heights = genHeightArray(array);
        int[] dp = new int[heights.length];
        Arrays.fill(dp, 1);
        int maxNumber = 0;
        for (int i = 0; i &lt; heights.length; i++) {
            int cur = heights[i];
            int j = 0;
            int max = 0;
            while (j &lt; i) {
                if (heights[j] &lt; cur) {
                    max = Math.max(max, dp[j]);
                }
                j++;
            }
            dp[i] = max + 1;
            maxNumber = Math.max(dp[i], maxNumber);
        }
        return maxNumber;
    }
    private Envelope[] genEnvelope(int[][] envelopes) {
        Envelope[] array = new Envelope[envelopes.length];
        int i = 0;
        for (int[] envelope : envelopes) {
            Envelope env = new Envelope(envelope[0], envelope[1]);
            array[i++] = env;
        }
        Arrays.sort(array, new EnvelopComparetor());
        return array;
    }
    private int[] genHeightArray(Envelope[] array) {
        int[] heights = new int[array.length];
        int i = 0;
        for (Envelope envelope : array) {
            heights[i++] = envelope.height;
        }
        return heights;
    }
}
// 构建一个信封对象
class Envelope {
    public int wight;
    public int height;
    public Envelope(int wight, int height) {
        this.wight = wight;
        this.height = height;
    }
}
class EnvelopComparetor implements Comparator&lt;Envelope&gt; {
    @Override
    public int compare(Envelope o1, Envelope o2) {
        return o1.wight != o2.wight ? o1.wight - o2.wight : o2.height - o1.height;
    }
}
</code></pre>
<h4 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title=" 64 最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum" target="_blank" rel="noopener"> 64 最小路径和</a></h4><h4 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174 地下城游戏"></a><a href="https://leetcode-cn.com/problems/dungeon-game" target="_blank" rel="noopener">174 地下城游戏</a></h4><p>从下至上，然后每次当前位置的血量，为 dp[i+1][j+1] - dungeon[i][j]</p>
<pre><code class="lang-java">public int calculateMinimumHP(int[][] dungeon) {
        int[][] dp = new int[dungeon.length][dungeon[0].length];
        int rows = dungeon.length;
        int cols = dungeon[0].length;
        dp[rows-1][cols-1] = Math.max(1-dungeon[rows-1][cols-1], 1);
        for (int i = rows-2; i &gt;= 0; i--) {
            dp[i][cols-1] = Math.max(1, dp[i+1][cols-1] - dungeon[i][cols-1]);
        }
        for (int i = cols-2; i &gt;= 0; i--) {
            dp[rows-1][i] = Math.max(1, dp[rows - 1][i + 1] - dungeon[rows-1][i]);
        }

        for (int i = rows - 2; i &gt;= 0; i--) {
            for (int j = cols - 2; j &gt;= 0; j--) {
                int min = Math.min(dp[i+1][j], dp[i][j+1]);
                dp[i][j] = Math.max(1, min - dungeon[i][j]);
            }
        }
        return dp[0][0];
    }
</code></pre>
<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></h4><pre><code class="lang-java">public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        dp[0][0] = 1;
        for(int i = 1; i &lt; m; i++) {
            dp[i][0] = 1;
        }
        for (int i = 1; i &lt; n; i++) {
            dp[0][i] = 1;

        }

        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
</code></pre>
<h4 id="63-不同路径II"><a href="#63-不同路径II" class="headerlink" title="63. 不同路径II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径II</a></h4><pre><code class="lang-java">public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (null == obstacleGrid || obstacleGrid.length == 0 || null == obstacleGrid[0] || obstacleGrid[0].length == 0) {
            return 0;
        }
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        if (obstacleGrid[0][0] == 1) {
            return 0;
        }
        int[][] dp = new int[m][n];
        dp[0][0] = 1;
        for(int i = 1; i &lt; m; i++) {
            if (obstacleGrid[i][0] == 1) {
                dp[i][0] = 0;
                break;
            } else {
                dp[i][0] = 1;
            }
        }
        for (int i = 1; i &lt; n; i++) {
            if (obstacleGrid[0][i] == 1) {
                dp[0][i] = 0;
                break;
            } else {
                dp[0][i] = 1;
            }
        }

        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                if (obstacleGrid[i][j] == 0) {
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                } else {
                    dp[i][j] = 0;
                }
            }
        }
        return dp[m-1][n-1];
    }
</code></pre>
<h3 id="字符串系列"><a href="#字符串系列" class="headerlink" title="字符串系列"></a>字符串系列</h3><h4 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></h4><p>这个在数组部分已经讲解过了。</p>
<h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号</a></h4><ol>
<li><p>确定dp数组，和索引下标意义</p>
<p>$dp[i]$ 表示 以s[i]结尾的最长有效括号</p>
</li>
<li><p>确定递归公式</p>
<ol>
<li><p><code>s[i]</code>是<code>'('</code>，以它为结尾的子串，肯定不是有效括号子串——<code>dp[i] = 0</code></p>
</li>
<li><p><code>s[i]是')'</code>，  以它为结尾的子串，分类讨论</p>
<ol>
<li><p><code>s[i-1] == '('</code></p>
<p>dp[i] = dp[i-2] + 1;</p>
</li>
<li><p><code>s[i-1] == ')'</code></p>
<p><code>s[i-1]</code>的最长子串为dp[i-1], 所以减去得<code>s[i-dp[i-1]-1]</code> </p>
<ol>
<li><p><code>s[i-dp[i-1]-1]</code>不存在或为<code>')'</code>，则<code>s[i]</code>找不到匹配，直接gg——<code>dp[i]=0</code></p>
</li>
<li><p><code>s[i-dp[i-1]-1]是'('</code>，与<code>s[i]</code>匹配，有效长度 = 2 + 跨过的dp[i-1]+ 前方的dp[i-dp[i-1]-2]。等一下，s[i-dp[i-1]-2]要存在才行！</p>
<p>s[i-dp[i-1]-2]存在，dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2<br>s[i-dp[i-1]-2]不存在，dp[i] = dp[i-1] + 2</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code class="lang-java">public int longestValidParentheses(String s) {
        int maxans = 0;
        int[] dp = new int[s.length()];
        for (int i = 1; i &lt; s.length(); i++) {
            if (s.charAt(i) == ')') {
                if (s.charAt(i - 1) == '(') {
                    dp[i] = (i &gt;= 2 ? dp[i - 2] : 0) + 2;
                } else if (i - dp[i - 1] &gt; 0 &amp;&amp; s.charAt(i - dp[i - 1] - 1) == '(') {
                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) &gt;= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
                maxans = Math.max(maxans, dp[i]);
            }
        }
        return maxans;
    }
</code></pre>
<h4 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115. 不同的子序列"></a><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">115. 不同的子序列</a></h4><p>这道题感觉和编辑距离公式的思路差不多，不过，没有那么复杂，只需要考虑减这一个步骤即可。</p>
<p>还是那一个例子来说吧：</p>
<pre><code class="lang-tex">输入：S="bagbagbag", T="bag"
输出：5
</code></pre>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/Users/weikunkun/Library/Application" alt="image-20200907231246178" title="Support/typora-user-images/image-20200907231246178.png">
                </div>
                <div class="image-caption">Support/typora-user-images/image-20200907231246178.png</div>
            </figure>
<ol>
<li><p>定义状态</p>
<p>$dp[i][j]$ 表示为$T$的前$i$个字符可以由$S$的前$j$个字符组成最多的个数</p>
</li>
<li><p>寻找状态转移方程</p>
<ol>
<li><p>$S[i] == T[j]$</p>
<ol>
<li>取$S[i]$，那么当前情况总数，应该和字符串$S$的前$i-1$个字符所构成的子序列中出现字符串$T$的前$j-1$个字符的情况总数相等。$dp[i][j] = dp[i-1][j-1]$</li>
<li>不取$S[i]$,那么当前情况总数，应该和字符串$S$的前$i$个字符所构成的子序列中出现字符串$T$的前$j-1$个字符的情况总数相等。$dp[i][j] = dp[i][j-1]$<br>那么$dp[i][j]$应等于这两种情况的和。$dp[i][j] = dp[i-1][j-1] + dp[i][j-1]$</li>
</ol>
</li>
<li><p>$S[i] != T[j]$</p>
<p>只有一种情况，和$S[i] == T[j]$的第二种情况是一样的，因为当前不相等，也就不能取（图中蓝色框）。</p>
<p>$dp[i][j] = dp[i][j-1]$</p>
</li>
<li><p>状态转移方程</p>
<p>$ dp[i][j]=\left{ \begin{array}{rcl} dp[i][j] = dp[i-1][j-1] + dp[i][j-1]       &amp;      &amp; {S[i]      ==      T[j]}\ dp[i][j]=dp[i][j-1]     &amp;      &amp; {S[i] != T[j]} \end{array} \right. $</p>
</li>
</ol>
</li>
</ol>
<ol>
<li><p>确定边界值</p>
<ol>
<li>$dp[0][j]=1$，此时表示为<code>T==NULL</code>，也就是空字符串T可以由非空的S组成的最多的个数，很明显为1。</li>
<li>$dp[i][0] = 0$，此时表示为<code>S==NULL</code>，也就是非空字符串T可以由空的字符串S组成的最多的个数，很明显为0。</li>
</ol>
</li>
</ol>
<pre><code class="lang-java">public int numDistinct(String s, String t) {
    int m = s.length();
    int n = t.length();
    int[][] dp = new int[n + 1][m + 1];
    dp[0][0] = 1;
    for (int i = 1; i &lt;= n; i++) {
        dp[i][0] = 0;
    }
    for (int i = 1; i &lt;= m; i++) {
        dp[0][i] = 1;
    }
    // 注意i和j和题解上的是相反的
    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= m; j++) {
            if (t.charAt(i - 1) == s.charAt(j - 1)) {
                dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1];
            } else {
                dp[i][j] = dp[i][j - 1];
            }
        }
    }
    return dp[n][m];
}
</code></pre>
<h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></h4><p>思路和编辑距离差不多，编辑距离返回最后的结果，这里需要遍历整个dp矩阵，返回最大。</p>
<pre><code class="lang-java">/**
 * 首先定义好第一行和第一列
 * 假设 行 text2
 * 假设 列 text1
 * 对于行： text1[0] 和text2[i]中任意一位置字符相同，则i-len位置为1
 * 对于列： 同理
 * 非首行和首列： 1. dp[i-1][j]  dp[i][j-1] dp[i-1][j-1]+1 最大
 * @param text1
 * @param text2
 * @return
 */
public int longestCommonSubsequence(String text1, String text2) {
    int[][] dp = new int[text1.length()][text2.length()];
    int max = 0;
    // 初始化行
    // 初始化列
    // 遍历整个
    int rows = dp.length;
    int cols = dp[0].length;
    dp[0][0] = text1.charAt(0) == text2.charAt(0) ? 1 : 0;
    for (int i = 1; i &lt; rows; i++) {
        dp[i][0] = Math.max(dp[i-1][0], text1.charAt(i) == text2.charAt(0) ? 1 : 0);
        max = Math.max(dp[i][0], max);
    }
    for (int i = 1; i &lt; cols; i++) {
        dp[0][i] = Math.max(dp[0][i-1], text1.charAt(0) == text2.charAt(i) ? 1 : 0);
        max = Math.max(dp[0][i], max);
    }
    for (int i = 1; i &lt; rows; i++) {
        for (int j = 1; j &lt; cols; j++) {
            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            if (text2.charAt(j) == text1.charAt(i)) {
                dp[i][j] = Math.max(dp[i][j], dp[i-1][j-1] + 1);
            }
            max = Math.max(dp[i][j], max);
        }
    }
    return max;
}
</code></pre>
<h4 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">最长公共子串</a></h4><p>找到了和公共子串类似的数组，就拿着替代一下</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2021/04/13/BCcVPSgpHxvTdt3.png" alt="image-20210413155100877" title="">
                </div>
                <div class="image-caption">image-20210413155100877</div>
            </figure>
<pre><code class="lang-java">public int findLengthII(int[] nums1, int[] nums2) {
    int len1 = nums1.length;
    int len2 = nums2.length;
    int[][] dp = new int[len1][len2];
    //
    // if nums1[i] == nums2[j]  dp[i][j] = dp[i-1][j-1] + 1;
    // else dp[i][j] = 0;
    int max = 0;
    for (int i = 0; i &lt; len1; i++) {
        if (nums1[i] == nums2[0]) {
            dp[i][0] = 1;
            max = Math.max(max, dp[i][0]);
        }
    }
    for (int i = 0; i &lt; len2; i++) {
        if (nums2[i] == nums1[0]) {
            dp[0][i] = 1;
            max = Math.max(max, dp[0][i]);
        }
    }
    for (int i = 1; i &lt; len1; i++) {
        for (int j = 1; j &lt; len2; j++) {
            if (nums1[i] == nums2[j]) {
                dp[i][j] = dp[i-1][j-1] + 1;
                max = Math.max(dp[i][j], max);
            }
        }
    }
    return max;
}
</code></pre>
<h4 id="字符串交错组成"><a href="#字符串交错组成" class="headerlink" title="字符串交错组成"></a><a href="https://leetcode-cn.com/problems/interleaving-string/" target="_blank" rel="noopener">字符串交错组成</a></h4><pre><code class="lang-java">class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int n = s1.length(), m = s2.length(), t = s3.length();

        if (n + m != t) {
            return false;
        }

        boolean[][] f = new boolean[n + 1][m + 1];

        f[0][0] = true;
        for (int i = 0; i &lt;= n; ++i) {
            for (int j = 0; j &lt;= m; ++j) {
                int p = i + j - 1;
                if (i &gt; 0) {
                    f[i][j] = f[i][j] || (f[i - 1][j] &amp;&amp; s1.charAt(i - 1) == s3.charAt(p));
                }
                if (j &gt; 0) {
                    f[i][j] = f[i][j] || (f[i][j - 1] &amp;&amp; s2.charAt(j - 1) == s3.charAt(p));
                }
            }
        }

        return f[n][m];
    }
}
</code></pre>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2021-06-28T04:46:20.223Z" itemprop="dateUpdated">2021-06-28 12:46:20</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://winniekun.github.io">
            <img src="https://avatars.githubusercontent.com/u/19886738?v=4" alt="weikunkun">
            weikunkun
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/" rel="tag">死磕系列</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://winniekun.github.io/stick-to-dynamic-programming/&title=《死磕动态规划》 — Wkkの笔记&pic=https://avatars.githubusercontent.com/u/19886738?v=4" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://winniekun.github.io/stick-to-dynamic-programming/&title=《死磕动态规划》 — Wkkの笔记&source=前言LeetCode死磕系列七： DP
终于轮到了DP, 怎么说类, 感觉自己写DP的题挺玄幻的, 状态好了, 能找出转移方程, 就能瞬间解决, 搞不好还..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://winniekun.github.io/stick-to-dynamic-programming/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《死磕动态规划》 — Wkkの笔记&url=https://winniekun.github.io/stick-to-dynamic-programming/&via=https://winniekun.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://winniekun.github.io/stick-to-dynamic-programming/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/copy-on-write-arraylist/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">CopyOnWriteArrayList源码解读</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/stick-to-monotonicity-stack/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">死磕单调栈</h4>
      </a>
    </div>
  
</nav>



    





















</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


            <p>
                
                    <span>
                        <a href="/atom.xml" target="_blank" class="rss" title="rss">
                            <i class="icon icon-lg icon-rss"></i>
                        </a>
                    </span>
                    
                        <span>
                            博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
                        </span>
            </p>
    </div>
    <div class="bottom">
        <p>
            <span>
                weikunkun &copy;
                    
                        2015 -
                            
                                2021
            </span>
            <span>
                
                        Power by
                        <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
                        <a href="https://github.com/abelsu7/hexo-theme-indigo-plus" target="_blank">indigo plus</a>
                        <p>Hosted by <a href="https://pages.github.com" target="_blank" style="font-weight: bold">Github Pages</a></p>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>
<a href="javascript:;" id="gobottom" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-comments"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://winniekun.github.io/stick-to-dynamic-programming/&title=《死磕动态规划》 — Wkkの笔记&pic=https://avatars.githubusercontent.com/u/19886738?v=4" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://winniekun.github.io/stick-to-dynamic-programming/&title=《死磕动态规划》 — Wkkの笔记&source=前言LeetCode死磕系列七： DP
终于轮到了DP, 怎么说类, 感觉自己写DP的题挺玄幻的, 状态好了, 能找出转移方程, 就能瞬间解决, 搞不好还..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://winniekun.github.io/stick-to-dynamic-programming/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《死磕动态规划》 — Wkkの笔记&url=https://winniekun.github.io/stick-to-dynamic-programming/&via=https://winniekun.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://winniekun.github.io/stick-to-dynamic-programming/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACI0lEQVR42u3aQXKDMAwF0Nz/0nTbLqBfElkgHqtMY4wfnVEky59PfB2/ruTbs5HJXcm9zQsDA+OxjOPyyh9wNuZ65rMx+dowMDDewzhbVjJm9PjLZyXjMTAwMKqM6wVNSBgYGBj3Btx5wYyBgYHRK2LPpkhSw6+nmBgYGKsZkyD47c9f6W9gYGA8inEUrzy8TpZYXhUGBsZqxl1TJ0Xm9V/mBzUwMDC2MvKyMxmZHLlIks7qK8DAwNjNmD8gCZG9rbrkc/S7gYGB8XBGHl6rLYR5iVtoAGBgYKxm5M2A3uvohe8kTSzwMDAwVjDyGyahNt+Sy38AMDAw3sbIE7XJBlw+Z3UnDQMDYzfjrm36fKHVtkE5z8XAwFjEyI84TJqd1fBahmFgYLyAUQ2USdDsbes3D5lhYGCsZkxu7i0xL32b/xMMDIyljHsPVdyVdN5wtAIDA2MFo7qhlge+SRsgL2L/bLdhYGAsZcxL1smmfxJwC3NiYGC8gDFJJecd1F6AjmpxDAyMRYy8ZVgN0L1UshqsMTAw3sDo7W7NE8rJc0epIQYGxkMYvQXlR8R6G2flOTEwMFYz7gqyvQ395JBHNcXEwMDYypgUovmmW/7mmm1ODAyMFzDywFdN7/LmZRVZOJ2BgYHxMkav7CwsqNcqwMDAwCg2OKsj88L4n/YABgbGakZSxE6aB5OGaBL0MTAwdjPy0jGfrvoikidWU08MDIwVjB875iLgOc9PzQAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.jsdelivr.net/npm/node-waves@0.7.6/src/js/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>


<script src="/js/prism.min.js?v=1.7.2"></script>
<script src="/js/prism-vim.min.js?v=1.7.2"></script>
</body>
</html>
