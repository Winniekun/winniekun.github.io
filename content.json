{"meta":{"title":"Wkkの笔记","subtitle":"好记性不如烂键盘","description":"Anything in life worth doing is worth overdoing. Moderation is for cowards. ","author":"weikunkun","url":"https://winniekun.github.io","root":"/"},"pages":[{"title":"About Me","date":"2021-05-19T09:47:58.000Z","updated":"2021-10-03T14:03:18.251Z","comments":true,"path":"about/index.html","permalink":"https://winniekun.github.io/about/index.html","excerpt":"","text":"NPE 😈"},{"title":"Tags","date":"2021-05-19T09:47:52.000Z","updated":"2021-05-19T10:27:30.150Z","comments":true,"path":"tags/index.html","permalink":"https://winniekun.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2021-05-19T09:47:47.000Z","updated":"2021-05-19T10:27:14.252Z","comments":true,"path":"categories/index.html","permalink":"https://winniekun.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux常见命令汇总","slug":"Linux-command","date":"2022-10-07T13:24:10.000Z","updated":"2022-10-07T13:35:30.360Z","comments":true,"path":"Linux-command/","link":"","permalink":"https://winniekun.github.io/Linux-command/","excerpt":"","text":"前言 最近在折腾自己的服务器，干些有趣的事情，记录下，一些重复性高，但是又记不住的内容 Root免密登陆 腾讯云默认给的是 ubuntu 账号，无法直接登陆 root 账号，导致没办法统一管理几个服务器，所以需要重新配置下 步骤 首先用 ubuntu 或者其他的账号登录主机。 然后按照提示输入即可 sudo passwd root 其次修改 /etc/ssh/sshd_config，wq 保存 接下来你就可以使用 root 登录。 sudo vim /etc/ssh/sshd_config image-20221007213028636 免密登陆步骤 配置文件 创建文件 ~/.ssh/config，然后在文件中输入如下内容，之后再使用服务器时，可以直接使用别名myserver1、myserver2。 Host myserver1 HostName IP地址或域名 User 用户名 Host myserver2 HostName IP地址或域名 User 用户名 密钥登录 创建密钥： ssh-keygen 执行结束后，~/.ssh/目录下会多两个文件： id_rsa：私钥 id_rsa.pub：公钥 ​ 之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。例如，想免密登录myserver服务器。则将公钥中的内容，复制到myserver中的~/.ssh/authorized_keys文件里即可。 也可以使用如下命令一键添加公钥： ssh-copy-id myserver 使用 ssh myserver","categories":[{"name":"Linux","slug":"Linux","permalink":"https://winniekun.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://winniekun.github.io/tags/Linux/"}]},{"title":"Spring Security 学习系列I","slug":"spring/springsecurity/spring-security-01","date":"2022-05-23T07:13:07.000Z","updated":"2022-05-23T07:14:23.430Z","comments":true,"path":"spring-security-01/","link":"","permalink":"https://winniekun.github.io/spring-security-01/","excerpt":"","text":"","categories":[{"name":"spring","slug":"spring","permalink":"https://winniekun.github.io/categories/spring/"}],"tags":[{"name":"security","slug":"security","permalink":"https://winniekun.github.io/tags/security/"}]},{"title":"2021年总结","slug":"碎碎念/2021-conclusion","date":"2022-01-22T04:31:24.000Z","updated":"2022-01-22T04:32:04.132Z","comments":true,"path":"2021-conclusion/","link":"","permalink":"https://winniekun.github.io/2021-conclusion/","excerpt":"","text":"","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"2022年书单【年汇总】","slug":"碎碎念/2022-book-list","date":"2022-01-01T02:01:26.000Z","updated":"2022-07-16T02:38:38.775Z","comments":true,"path":"2022-book-list/","link":"","permalink":"https://winniekun.github.io/2022-book-list/","excerpt":"我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 摘自鶸道场 趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。","text":"我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 摘自鶸道场 趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。 书籍相关 Java8实战 设计模式之美 电影、电视剧、综艺、纪录片 这个杀手不太冷静 人生大事 百妖谱 来说出你的故事，看我能不能救 警察荣耀 特战荣耀 梦华录","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"书单","slug":"书单","permalink":"https://winniekun.github.io/tags/%E4%B9%A6%E5%8D%95/"}]},{"title":"vim使用","slug":"效率工具/vim-programming","date":"2021-11-06T07:28:57.000Z","updated":"2021-11-06T07:34:31.747Z","comments":true,"path":"vim-programming/","link":"","permalink":"https://winniekun.github.io/vim-programming/","excerpt":"","text":"Vim常用命令功能： (1) 命令行模式下的文本编辑器。 (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。 (3) 使用方式：vim filename 如果已有该文件，则打开它。 如果没有该文件，则打开个一个新的文件，并命名为filename 模式： (1) 一般命令模式 默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。 (2) 编辑模式 在一般命令模式里按下i，会进入编辑模式。 按下ESC会退出编辑模式，返回到一般命令模式。 (3) 命令行模式 在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。 可以查找、替换、保存、退出、配置编辑器等。 操作： (1) i：进入编辑模式 (2) ESC：进入一般命令模式 (3) h 或 左箭头键：光标向左移动一个字符 (4) j 或 向下箭头：光标向下移动一个字符 (5) k 或 向上箭头：光标向上移动一个字符 (6) l 或 向右箭头：光标向右移动一个字符 (7) n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符 (8) 0 或 功能键[Home]：光标移动到本行开头 (9) $ 或 功能键[End]：光标移动到本行末尾 (10) G：光标移动到最后一行 (11) :n 或 nG：n为数字，光标移动到第n行 (12) gg：光标移动到第一行，相当于1G (13) n&lt;Enter&gt;：n为数字，光标向下移动n行 (14) /word：向光标之下寻找第一个值为word的字符串。 (15) ?word：向光标之上寻找第一个值为word的字符串。 (16) n：重复前一个查找操作 (17) N：反向重复前一个查找操作 (18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2 (19) :1,$s/word1/word2/g：将全文的word1替换为word2 (20) :1,$s/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。 (21) v：选中文本 (22) d：删除选中的文本 (23) dd: 删除当前行 (24) y：复制选中的文本 (25) yy: 复制当前行 (26) p: 将复制的数据在光标的下一行/下一个位置粘贴 (27) u：撤销 (28) Ctrl + r：取消撤销 (29) 大于号 &gt;：将选中的文本整体向右缩进一次 (30) 小于号 &lt;：将选中的文本整体向左缩进一次 (31) :w 保存 (32) :w! 强制保存 (33) :q 退出 (34) :q! 强制退出 (35) :wq 保存并退出 (36) :set paste 设置成粘贴模式，取消代码自动缩进 (37) :set nopaste 取消粘贴模式，开启代码自动缩进 (38) :set nu 显示行号 (39) :set nonu 隐藏行号 (40) gg=G：将全文代码格式化 (41) :noh 关闭查找关键词高亮 (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令 异常处理： 每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。 如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种： (1) 找到正在打开该文件的程序，并退出 (2) 直接删掉该swp文件即可","categories":[{"name":"vim","slug":"vim","permalink":"https://winniekun.github.io/categories/vim/"}],"tags":[{"name":"效率工具","slug":"效率工具","permalink":"https://winniekun.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"}]},{"title":"效率工具/shell-programming","slug":"效率工具/shell-programming","date":"2021-11-06T07:18:42.000Z","updated":"2021-11-27T09:00:20.839Z","comments":true,"path":"shell-programming/","link":"","permalink":"https://winniekun.github.io/shell-programming/","excerpt":"","text":"Shell学习记录Shell 这个单词的原意是外壳，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。 ch02学习记录ln 用于链接文件，相比于cp避免了创建副本，相当于引用，多个文件使用同一个文件 一些通配符通配符的含义和正则类似，正则表达式30分钟入门教程 * 符号 和正则里的*一样， 用于匹配0个或以上的字符 ？符号 和正则里的?类似， 不过在shell中用于匹配1个字符。正则中?用于匹配0个或一个字符 [] 符号 任选括号中元素中的一个，相比于?范围更明确 STDIN/STDOUT image-20211108161710871 以who为例，who的输出用于表示所有当前登录进系统的用户 who示例 输出重定向 命令的输出通常是提交到标准输出设备，同时我们也可以进行重定向，将输出重定向到文件中。可类比为Go的管道操作 输入重定向 既然有输出重定向，必然有输入重定向，也可类比为Go的管道操作 ch02练习题第一题 指定目录文件有以下内容 ➜ ch02 ./print.sh feb96 jan12.02 jan19.02 jan26.02 jan5.02 jan95 jan96 jan97 jan98 mar98 memo1 memo10 memo2 memo2.sv echo * 输出所有结果 echo *[!0-9] 输出所有不已数字结尾的文件 ➜ ch02 echo *[\\!0-9] memo2.sv echo m[a-df-z]* 输出所有 m开头，后跟除e以外的所有字符 ➜ ch02 echo m[a-df-z]* mar98 echo [A-Z]* 输出文件名仅包含大些字符的元素 ➜ ch02 echo [A-Z]* zsh: no matches found: [A-Z]* echo jan* 输出jan开头的所有文件名 ➜ ch02 echo jan* jan12.02 jan19.02 jan26.02 jan5.02 jan95 jan96 jan97 jan98 echo *.* 输出中间以.的文件 ➜ ch02 echo *.* jan12.02 jan19.02 jan26.02 jan5.02 memo2.sv echo ????? 输出文件名长度为5的文件 ➜ ch02 echo ????? feb96 jan95 jan96 jan97 jan98 mar98 memo1 memo2 echo *02 输出以02结尾的文件 ➜ ch02 echo *02 jan12.02 jan19.02 jan26.02 jan5.02 echo jan?? feb?? mar?? 输出以jan开头长度5、feb开头长度为5，mar开头长度为5的文件 ➜ ch02 echo jan?? feb?? mar?? jan95 jan96 jan97 jan98 feb96 mar98 echo [fjm][ae][bnr]* 输出第一个字符[fjm]，第二个字符[ae]、第三个字符[bnr]的所有文件 ➜ ch02 echo \\[fjm]\\[ae][bnr]* zsh: no matches found: [fjm][ae][bnr]* 第二题 下列命名序列的结果是什么 ls | wc -l 统计当前文件夹内文件的数量 rm ??? 删除文件名长度为3的文件 who | wc -l 统计登录用户 mv progs/* /users/Steve/backup 移动文件 ls *.c | wc -l 统计所有C文件数量 rm *.o 删除所有.o后缀的文件 who | sort 排序之后 输出登录用户 cp memo1 .. 复制 memo1 到上一级目录 plotdata 2 &gt; errors &amp; 后台运行 ch03学习记录 cut、paste、sed、tr、grep、sort、uniq的操作 正则再补充在开始学习上述命令时，首先需要再梳理下正则。因为很多命令都可以通过正则进行高效的匹配我们需要的内容 在第2章中，通过shell了解到了几个常用的通配符：*、[]、?。不过上述的命令能够识别出的正则表达式要比shell所能够识别的要复杂的多。并且这些操作中有些符号的还以和shell的有一些区别 代码 说明 例子 匹配结果 . 匹配除换行符以外的任意字符（1个） ^ 匹配行首 ^word 仅出现在行首的word $ 匹配行尾 x$ 仅出现在行尾的x ^INSERT$ 仅包含INSERT的行 ^$ 空行 * 匹配除了换行符以外的任意字符（0 —- ∞个） x* 零个或多个连续的x xx* 一个或多个连续的x .* 零个或多个字符 w.*s w及紧随其后的零个或多个字符，再加上s + 匹配除了换行符以外的任意字符（1—- ∞个） x+ 一个或多个连续的x xx+ 两个或多个连续的x .+ 一个或多个字符 w.+s w及紧随其后的一个或多个字符，再加上s ？ 匹配除了换行符以外的任意字符（0、1个） x? 1个或者2个x [chars] 匹配chars中的任意字符 [tT] 小写或大些T [a-z] 小写字母 [a-zA-Z] 小写或大写字母 chars 匹配不包含chars中的字符 0-9 非数字字符 a-zA-Z 非字母字符 \\{…\\} 匹配字符串精确的数目 x\\{1,5\\} 至少1个最多5个x [0-9]\\{3,9\\} 连续的3~9个数字 [0-9]\\{3\\} 3位数字 [0-9]\\{3,\\} 至少3位数字 \\(…\\) 保存匹配的字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 cut命令 cut命令在从数据文件或命令输出中提取各种字段，格式如下： cut OPTION... [FILE]... 常用选项如下： -f : 提取指定的字段，cut 命令使用 Tab 作为默认的分隔符。 -d : Tab 是默认的分隔符，使用这一选项可以指定自己的分隔符。 -b : 提取指定的字节，也可以指定一个范围。 -c : 提取指定的字符，可以是以逗号分隔的数字的列表，也可以是以连字符分隔的数字的范围。 –complement : 补充选中的部分，即反选。 –output-delimiter : 修改输出时使用的分隔符。 --only-delimited : 不输出不包含分隔符的列。 上述的命令中-c指定了我们想从file中的每行内提取哪些字符（根据位置）。 单个数字，譬如-c5就指名在每行提取第5个字符， 数字列表，使用,分割数字列表，这样我们匹配多个字符，-c1,5,6,25表示每行提取第1、5、6、25个字符。 数字范围，使用-作为数字的范围，这样我们可以匹配一段的字符，-c20-50表示提取第20~50的字符，若是匹配到结尾，则使用-c20- 以当前登录的用户记录为例子 ➜ ~ who root pts/0 2021-11-12 13:43 (113.200.78.120) root pts/1 2021-11-04 13:36 (tmux(17718).%0) root pts/2 2021-11-04 13:37 (tmux(17718).%1) kwk pts/3 2021-11-12 13:44 (113.200.78.120) wkk pts/4 2021-11-12 13:44 (113.200.78.120) 匹配出哪些用户已经登录了系统，同时并不关心其所在的终端以及登录时间 ➜ ~ who | cut -c 1-8 root root root kwk wkk 匹配出哪些用户已经登录了系统，并排序，同时并不关心其所在的终端以及登录时间 ➜ ~ who | cut -c 1-8 | sort kwk root root root wkk cut命令的-c选项适合从拥有固定格式的文件或命令中获取我们需要的字符，正如上述操作，因为我们知道前8个字符就是表示用户名，第10~16个字符表示终端类型，第18~29个字符表示登录时间，但是并不是所有的文件都是很好的格式的，譬如/etc/passwd，其包含了用户ID、主目录、以及特定用户登录后自动运行的程序等 ➜ ~ cat /etc/passwd root:x:0:0:root:/root:/usr/bin/zsh daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin systemd-network:x:100:102:systemd Network Management,,,:/run/systemd/netif:/usr/sbin/nologin systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd/resolve:/usr/sbin/nologin syslog:x:102:106::/home/syslog:/usr/sbin/nologin messagebus:x:103:107::/nonexistent:/usr/sbin/nologin _apt:x:104:65534::/nonexistent:/usr/sbin/nologin uuidd:x:105:109::/run/uuidd:/usr/sbin/nologin sshd:x:107:65534::/run/sshd:/usr/sbin/nologin _chrony:x:108:117:Chrony daemon,,,:/var/lib/chrony:/usr/sbin/nologin admin:x:1000:1000::/home/admin:/bin/bash www:x:1001:1001::/home/www:/sbin/nologin mysql:x:1002:1002::/home/mysql:/sbin/nologin redis:x:1003:1003::/home/redis:/sbin/nologin mongo:x:1004:1004::/home/mongo:/sbin/nologin wkk:x:1005:1005::/home/wkk:/bin/sh hhh:x:1006:1009::/home/hhh:/bin/sh kwk:x:1007:1010::/home/kwk/:/bin/sh 经过观察，发现内部是通过:进行分割，所以我们可以通过:对每行的内容进行分割，然后再截取我们需要的内容 从/etc/passwd中提取所有的用户名 ➜ ~ cut -d: -f1 /etc/passwd root daemon ... www mysql redis mongo wkk hhh kwk 从/etc/passwd中提取所有的用户名以及对应的主目录 ➜ ~ cut -d: /etc/passwd -f1,6 root:/root daemon:/usr/sbin ... www:/home/www mysql:/home/mysql redis:/home/redis mongo:/home/mongo wkk:/home/wkk hhh:/home/hhh kwk:/home/kwk/ 一些实用的例子 提取 ps 命令中的 USER，PID和COMMAND： ➜ shell ps -L u n | tr -s \" \" | cut -d \" \" -f 2,3,14- USER PID COMMAND 0 760 /sbin/agetty -o -p -- \\u --noclear tty1 linux 0 1022 /sbin/agetty -o -p -- \\u --keep-baud 115200,38400,9600 ttyS0 vt220 0 4518 -zsh 0 12155 ps -L u n 0 12156 tr -s 0 12157 cut -d -f 2,3,14- 0 17719 -zsh 0 20660 -zsh 提取内存的 total，used和free值，并保存到一个文件中 $ free -m | tr -s ' ' | sed '/^Mem/!d' | cut -d\" \" -f2-4 &gt;&gt; memory.txt $ cat memory.txt 985 86 234 总结 cut 命令可以和很多其他Linux或Unix命令通过管道连接。可以通过管道传递一个或多个过滤器进行额外的文本处理。 cut 命令的局限性之一是它不支持指定多个字符作为分隔符。多个空格会被计算为多个字段分隔符，因此必须在 cut 命令前使用 tr 命令才能获得需要的输出。 paste命令 和cut想法，cut用于拆分，paste用于合并，格式如下： paste [-s][-d ][--help][--version][文件...] 常用参数如下： -d或–delimiters= 用指定的间隔字符取代跳格字符。 -s或–serial 串列进行而非平行处理。 假设有一个名为names的文件，内容为一系列姓名： ➜ ch03 cat names Tony Emanuel Lucy Ralph Fred 另一个名为numbers的文件，其中包含了names文件中姓名所对应的电话 ➜ ch03 cat numbers (307) 555-5456 (212) 555-3456 (212) 555-9959 (212) 555-7741 (212) 555-0040 另一个名为addresses的文件，其中包含names文件中姓名所对应好的地址 ➜ ch03 cat addresses 55-23 Vine Street, Miami 39 University Place, New York 17 E. 25th Street, New York 38 Chauncey St., Bensonhurst 17 E. 25th Street, New York 将上述三者进行合并： ➜ ch03 paste names numbers addresses Tony (307) 555-5456 55-23 Vine Street, Miami Emanuel (212) 555-3456 39 University Place, New York Lucy (212) 555-9959 17 E. 25th Street, New York Ralph (212) 555-7741 38 Chauncey St., Bensonhurst Fred (212) 555-0040 17 E. 25th Street, New York 使用-d自定义分隔符 ➜ ch03 paste -d '+' names numbers addresses Tony+(307) 555-5456+55-23 Vine Street, Miami Emanuel+(212) 555-3456+39 University Place, New York Lucy+(212) 555-9959+17 E. 25th Street, New York Ralph+(212) 555-7741+38 Chauncey St., Bensonhurst Fred+(212) 555-0040+17 E. 25th Street, New York 使用-s将文件串列处理 ➜ ch03 paste -s names Tony Emanuel Lucy Ralph Fred sed命令 sed 是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等，用法如下： sed [options] 'command' file(s) sed [options] -f scriptfile file(s) command中的选项如下： a\\ # 在当前行下面插入文本。 i\\ # 在当前行上面插入文本。 c\\ # 把选定的行改为新的文本。 d # 删除，删除选择的行。 D # 删除模板块的第一行。 s # 替换指定字符 h # 拷贝模板块的内容到内存中的缓冲区。 H # 追加模板块的内容到内存中的缓冲区。 g # 获得内存缓冲区的内容，并替代当前模板块中的文本。 G # 获得内存缓冲区的内容，并追加到当前模板块文本的后面。 l # 列表不能打印字符的清单。 n # 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。 N # 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。 p # 打印模板块的行。 P # (大写) 打印模板块的第一行。 q # 退出Sed。 b lable # 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。 r file # 从file中读行。 t label # if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。 T label # 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。 w file # 写并追加模板块到file末尾。 W file # 写并追加模板块的第一行到file末尾。 ! # 表示后面的命令对所有没有被选定的行发生作用。 = # 打印当前行号码。 # # 把注释扩展到下一个换行符以前。 选项如下： -n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。 -e ：直接在命令列模式上进行 sed 的动作编辑； -f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作； -r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法) -i ：直接修改读取的文件内容，而不是输出到终端。 有一个intro文件，具体内容如下： ➜ ch03 cat intro The Unix operating system was pioneered by Ken Theopson and Dennis Ritchie at Bell Laboratories in the late 1960s. One of the primary goals in the esign of the Unix system was to crate an environment that promoted efficient program development. 替换操作：s命令 将所有的Unix替换为UNIX ➜ ch03 sed 's/Unix/UNIX/' intro The UNIX operating system was pioneered by Ken Theopson and Dennis Ritchie at Bell Laboratories in the late 1960s. One of the primary goals in the esign of the UNIX system was to crate an environment that promoted efficient program development. 只输出那些发生替换的行 ➜ ch03 sed -n 's/Unix/UNIX/p' intro The UNIX operating system was pioneered by Ken the esign of the UNIX system was to crate an 切换oh-my-zsh中的主题，从默认主题切换为awesomepanda sed -i 's/ZSH_THEME=\"robbyrussell\"/ZSH_THEME=\"awesomepanda\"/g' ~/.zshrc 删除操作：d命令 使用sed删除文件的前两行 ➜ ch03 sed '1,2d' intro in the late 1960s. One of the primary goals in the esign of the Unix system was to crate an environment that promoted efficient program development. tr命令 tr命令 可以对来自标准输入的字符进行替换、压缩和删除。它可以将一组字符变成另一组字符，经常用来编写优美的单行命令，作用很强大。用法如下： tr(选项)(from to) 选项： -c或——complerment：取代所有不属于第一字符集的字符； -d或——delete：删除所有属于第一字符集的字符； -s或--squeeze-repeats：把连续重复的字符以单独一个字符表示； -t或--truncate-set1：先删除第一字符集较第二字符集多出的字符。 参数 ： from：指定要转换或删除的原字符集。当执行转换操作时，必须使用参数“字符集2”指定转换的目标字符集。但执行删除操作时，不需要参数“字符集2”； to：指定要转换成的目标字符集。 简单使用 将输入字符进行大小写转换： ➜ ch03 echo \"HELLO world\" | tr '[a-zA-Z]' '[A-Za-z]' hello WORLD 将intro中的所有的字符e替换为x ➜ ch03 tr e x &lt; intro Thx Unix opxrating systxm was pionxxrxd by Kxn Thxopson and Dxnnis Ritchix at Bxll Laboratorixs in thx latx 1960s. Onx of thx primary goals in thx xsign of thx Unix systxm was to cratx an xnvironmxnt that promotxd xfficixnt program dxvxlopmxnt. 提取/etc/passwd中的用户和主目录，同时将分隔符:替换为' ' ➜ ch03 cut -d : -f 1,6 /etc/passwd | tr : ' ' root /root daemon /usr/sbin bin /bin sys /dev sync /bin 使用 -s进行压缩譬如我们想将下述文件中连续的a替换一个b，如果按照上述的直白命令会导致如下问题： ➜ ch03 cat test | tr a b this is bbbbbbbbbbbbbbbb file 所以我们可以使用-s将多个重复的元素使用一个单独的字符进行替换 ➜ ch03 cat test | tr -s a b this is b file 使用-d进行删除可以使用-d操作删除输入流中的一些字符 ➜ ch03 cat intro | tr -d ' ' TheUnixoperatingsystemwaspioneeredbyKen TheopsonandDennisRitchieatBellLaboratories inthelate1960s.Oneoftheprimarygoalsin theesignoftheUnixsystemwastocratean environmentthatpromotedefficientprogram development. grep （global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤/搜索的特定字符。可使用正则表达式能配合多种命令使用，使用上十分灵活。常见用法如下： grep match_pattern file_name grep \"match_pattern\" file_name 选项： -a --text # 不要忽略二进制数据。 -A &lt;显示行数&gt; --after-context=&lt;显示行数&gt; # 除了显示符合范本样式的那一行之外，并显示该行之后的内容。 -b --byte-offset # 在显示符合范本样式的那一行之外，并显示该行之前的内容。 -B&lt;显示行数&gt; --before-context=&lt;显示行数&gt; # 除了显示符合样式的那一行之外，并显示该行之前的内容。 -c --count # 计算符合范本样式的列数。 -C&lt;显示行数&gt; --context=&lt;显示行数&gt;或-&lt;显示行数&gt; # 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。 -d&lt;进行动作&gt; --directories=&lt;动作&gt; # 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。 -e&lt;范本样式&gt; --regexp=&lt;范本样式&gt; # 指定字符串作为查找文件内容的范本样式。 -E --extended-regexp # 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。 -f&lt;范本文件&gt; --file=&lt;规则文件&gt; # 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。 -F --fixed-regexp # 将范本样式视为固定字符串的列表。 -G --basic-regexp # 将范本样式视为普通的表示法来使用。 -h --no-filename # 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。 -H --with-filename # 在显示符合范本样式的那一列之前，标示该列的文件名称。 -i --ignore-case # 忽略字符大小写的差别。 -l --file-with-matches # 列出文件内容符合指定的范本样式的文件名称。 -L --files-without-match # 列出文件内容不符合指定的范本样式的文件名称。 -n --line-number # 在显示符合范本样式的那一列之前，标示出该列的编号。 -P --perl-regexp # PATTERN 是一个 Perl 正则表达式 -q --quiet或--silent # 不显示任何信息。 -R/-r --recursive # 此参数的效果和指定“-d recurse”参数相同。 -s --no-messages # 不显示错误信息。 -v --revert-match # 反转查找。 -V --version # 显示版本信息。 -w --word-regexp # 只显示全字符合的列。 -x --line-regexp # 只显示全列符合的列。 -y # 此参数效果跟“-i”相同。 -o # 只输出文件中匹配到的部分。 -m &lt;num&gt; --max-count=&lt;num&gt; # 找到num行结果后停止查找，用来限制匹配行数 正则使用详见上述正则再补充内容 常见用法 在文件中搜索某个字符，返回对应字符所在行 ➜ ch03 cat intro | grep 'Unix' The Unix operating system was pioneered by Ken the esign of the Unix system was to crate an 多个文件中查找（注意一些shell中具有特殊含义的字符，建议将需要匹配的内容放入''之中） ➜ ch03 grep 'The' * ed.cmd:There were a sensitivity and a beauty to her that have nothing to do with looks. She was one to be listened to, whose words were so easy to take to heart. ed.cmd:It is said that the true nature of being is veiled. The labor of words, the expression of art, the seemingly ceaseless buzz that is human thought all have in common the need to get at what really is so. The hope to draw close to and possess the truth of being can be a feverish one. In some cases it can even be fatal, if pleasure is one's truth and its attainment more important than life itself. In other lives, though, the search for what is truthful gives life. ed.cmd:I used to find notes left in the collection basket, beautiful notes about my homilies and about the writer's thoughts on the daily scriptural readings. The person who penned the notes would add reflections to my thoughts and would always include some quotes from poets and mystics he or she had read and remembered and loved. The notes fascinated me. Here was someone immersed in a search for truth and beauty. Words had been treasured, words that were beautiful. And I felt as if the words somehow delighted in being discovered, for they were obviously very generous to the as yet anonymous writer of the notes. And now this person was in turn learning the secret of sharing them. Beauty so shines when given away. The only truth that exists is, in that sense, free. ed.cmd:One Sunday morning, I was told that someone was waiting for me in the office. The young person who answered the rectory door said that it was \"the woman who said she left all the notes.\" When I saw her I was shocked, since I immediately recognized her from church but had no idea that it was she who wrote the notes. She was sitting in a chair in the office with her hands folded in her lap. Her head was bowed and when she raised it to look at me, she could barely smile without pain. Her face was disfigured, and the skin so tight from surgical procedures that smiling or laughing was very difficult for her. She had suffered terribly from treatment to remove the growths that had so marred her face. intro:The Unix operating system was pioneered by Ken intro:Theopson and Dennis Ritchie at Bell Laboratories 搜索多个文件并查找匹配文本在哪些文件中 ➜ ch03 grep -l 'The' * ed.cmd intro 输出除之外的所有行 -v 选项 ➜ ch03 grep -v 'Unix' intro Theopson and Dennis Ritchie at Bell Laboratories in the late 1960s. One of the primary goals in environment that promoted efficient program development. 只输出文件中匹配到的部分 -o 选项 ➜ ch03 grep -o 'Unix' intro Unix Unix 标记匹配颜色 —color=auto 选项 统计文件或者文本中包含匹配字符串的行数 -c 选项 ➜ ch03 grep -c 'Unix' intro 2 sort 按照字典序排序，用法如下： sort [OPTION]... [FILE]... sort [OPTION]... --files0-from=F 选项： -b, --ignore-leading-blanks 忽略开头的空白。 -d, --dictionary-order 仅考虑空白、字母、数字。 -f, --ignore-case 将小写字母作为大写字母考虑。 -g, --general-numeric-sort 根据数字排序。 -i, --ignore-nonprinting 排除不可打印字符。 -M, --month-sort 按照非月份、一月、十二月的顺序排序。 -h, --human-numeric-sort 根据存储容量排序(注意使用大写字母，例如：2K 1G)。 -n, --numeric-sort 根据数字排序。 -R, --random-sort 随机排序，但分组相同的行。 --random-source=FILE 从FILE中获取随机长度的字节。 -r, --reverse 将结果倒序排列。 --sort=WORD 根据WORD排序，其中: general-numeric 等价于 -g，human-numeric 等价于 -h，month 等价于 -M，numeric 等价于 -n，random 等价于 -R，version 等价于 -V。 -V, --version-sort 文本中(版本)数字的自然排序。 现有names文件，具体内容如下： Charlie Emanuel Fred Lucy Ralph Tony Tony 按照字典序排序 ➜ ch03 sort names a:01:1.0 aaa:10:1.1 b:02:2.0 bbb:20:2.2 c:03:3.0 ccc:30:3.3 ddd:40:4.4 eee:50:5.5 eee:50:5.5 忽略相同行使用-u选项或者uniq： ➜ ch03 sort names Charlie Emanuel Fred Lucy Ralph Tony Tony 按照字典序的逆序输出 ➜ ch03 sort -r names Tony Tony Ralph Lucy Fred Emanuel Charlie 使用-n按照数字大小进行排序（按照第一个字段进行排序） 可以使用-k number 跳过number-1个字段，从第number个字段开始排序 可以使用-t指定分隔符 ➜ ch03 sort -n data -5 11 2 12 3 33 5 27 14 -9 15 6 ➜ ch03 sort -k2n data ## 以第二个字段开始排序 14 -9 23 2 15 6 -5 11 2 12 5 27 3 33 ➜ ch03 sort -k3 -n -t : /etc/passwd | cut -d : -f1,3 # 按照 : 进行分割，并且以第三个字段进行排序，截取第一个字段第三个字段进行输出 root:0 daemon:1 bin:2 sys:3 sync:4 games:5 uniq 主要用途 将输入文件（或标准输入）中邻近的重复行写入到输出文件（或标准输出）中。 当没有选项时，邻近的重复行将合并为一个。 用法如下： uniq [OPTION]... [INPUT [OUTPUT]] 选项： -c, --count 在每行开头增加重复次数。 -d, --repeated 所有邻近的重复行只被打印一次。 -D 所有邻近的重复行将全部打印。 --all-repeated[=METHOD] 类似于 -D，但允许每组之间以空行分割。METHOD取值范围{none(默认)，prepend，separate}。 -f, --skip-fields=N 跳过对前N个列的比较。 --group[=METHOD] 显示所有行，允许每组之间以空行分割。METHOD取值范围：{separate(默认)，prepend，append，both}。 -i, --ignore-case 忽略大小写的差异。 -s, --skip-chars=N 跳过对前N个字符的比较。 -u, --unique 只打印非邻近的重复行。 -z, --zero-terminated 设置行终止符为NUL（空），而不是换行符。 -w, --check-chars=N 只对每行前N个字符进行比较。 --help 显示帮助信息并退出。 --version 显示版本信息并退出。 参数： INPUT（可选）：输入文件，不提供时为标准输入。 OUTPUT（可选）：输出文件，不提供时为标准输出。 还是按照sort中引用的names为例。以下是其内容： Charlie Emanuel Tony Fred Lucy Ralph Tony 输出names中的姓名，重复元素只输出一次即可 ➜ ch03 uniq names ## 因为两个Tony不是连续的，所以直接使用uniq无法去除重复元素 Charlie Emanuel Tony Fred Lucy Ralph Tony ➜ ch03 sort names | uniq # 先通过sort排序，之后再使用uniq，将重复的元素放在一起 Charlie Emanuel Fred Lucy Ralph Tony 输出出现重复的内容 ➜ ch03 sort names | uniq -d Tony 词频统计 ➜ ch03 sort names | uniq -c 1 Charlie 1 Emanuel 1 Fred 1 Lucy 1 Ralph 2 Tony 找出文件中频率最高的元素 tr '[A-Z]' '[a-z]' file | sort | uniq -c | head ch04学习记录为了简化一些操作，我们可以将一些命令统一放置在一个文件中，然后将该文件赋予可执行权限，这样，就避免了大量的重复操作，譬如当前有一个stats文件内容如下： ➜ ch04 cat stats echo '现在的日期是: ' `date` echo '现在共有: ' `who | wc -l` '个用户登录' echo '当前的位置为: ' `pwd` ➜ ch04 chmod u+x stats ➜ ch04 ./stats 现在的日期是: Sun Nov 14 20:08:38 CST 2021 现在共有: 14 个用户登录 当前的位置为: /root/exper/shell/ch04 变量 和正常的编程语言一样，Shell中也可以使用变量，命名要求为以字母或_开头，后面跟上零个或多个字母及数字或下划线，赋值格式如下： variable=value 一些注意事项： =号两边不需要和类似Java的编码规范一样， 使用空格隔开，Shell中不能有空格 Shell中并无各种明确的数据类型，无论分配什么样的值，在Shell中都将其视为字符串 变量的显示 echo $variable # 显示 系统环境变量 ➜ ch04 echo $PATH /root/.oh-my-zsh/custom/plugins/git-open:/opt/jdk-11.0.13/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin # 显示多个变量 ➜ ch04 echo $count $name 1 孔维坤 # 变量出现在任何其他命令中 ➜ ch04 $my_pos=/root/expr/shell/ch04 zsh: /root/expr/shell/ch04 not found ➜ ch04 ls $my_pos nu stats 变量的默认值 ➜ ch04 echo :$null: :: # 未赋值的变量为空， 并且不会影响其他的命令 ➜ ch04 who $null | wc $null -l 2 # 更好的声明空值变量， 关于\"\"和''的区别，后续会阐述 ➜ ch04 $null=\"\" ➜ ch04 $null='' ${variable}结构 假设将$name 重命名为$nameX ➜ ch04 name=/Users/weikunkun/ShellProjects/ch04/aaa ➜ ch04 $name ➜ ch04 mv $name ${name}X 内建的整数算术操作 算术扩展的格式为：$((expression)) 运算符号包括：+、-、、/、%和* 复合操作：+=、-=、*、=、/= 自增自减：variable++、variable— ➜ ch04 echo $a ➜ ch04 echo $((a = a + 1)) 1 ch05学习记录本章节主要用于阐述字符引用，Shell中能够识别4种不同的引用字符 单引号和双引号 双引号和单引号的区别： 两者的功能类似，但是对于内容的保护，双引号要弱于单引号：单引号告诉Shell忽略引用的所有特殊字符，而双引号则忽略引用的大部分字符，但是如下的字符不能忽略 $ ` \\ ➜ ch04 echo one two three one two three ➜ ch04 echo 'one two three' one two three ➜ ch04 cur_path=$(pwd) ➜ ch04 echo $cur_path /Users/weikunkun/ShellProjects/ch04 ➜ ch04 echo '$cur_path' $cur_path ➜ ch04 echo \"$cur_path\" /Users/weikunkun/ShellProjects/ch04 ➜ ch05 address=\"成都市 锦江区\" ➜ ch05 echo $address 成都市 锦江区 ➜ ch05 echo '$adress' $adress ➜ ch05 echo \"$address\" 成都市 锦江区 图示 反斜线 用于转义 ➜ ch05 echo $x * ➜ ch05 echo \\$x $x ➜ ch05 line=one' quote&gt; 'two ➜ ch05 echo $line one two ➜ ch05 line=one\\ &gt; two ➜ ch05 echo $line onetwo 命令替换和Java中的printf类似，可以输出命令或者变量中的结果替换命令内部其他命令。 命令替换有两种形式 ➜ ch05 `command` ➜ ch05 $(...) # demo ➜ ch05 echo The date and time is: `date` The date and time is: 2021年11月19日 星期五 15时17分39秒 CST ➜ ch05 echo The date and time is: $(date) The date and time is: 2021年11月19日 星期五 15时17分43秒 CST 虽然两种写法都可以进行命令的替换，但是$()的写法要比第一种好 方便阅读 $()易于嵌套，能够在命令中在进行命令的嵌套，同时括号内部可以支持多个命令，多命令之间使用;隔开，同时还可以使用|进行传递 譬如： ➜ ch05 vim nu echo '################`command`################' echo 现在有 `who | wc -l `用户登录 echo '现在有 `who | wc -l`用户登录' echo \"现在有 `who | wc -l`用户登录\" echo '################$(...)################' echo 现在有 $(who | wc -l) 用户登录 echo '现在有 $(who | wc -l) 用户登录' echo \"现在有 $(who | wc -l) 用户登录\" ➜ ch05 ./nu ################`command`################ 现在有 2用户登录 现在有 `who | wc -l`用户登录 现在有 2用户登录 ################$(...)################ 现在有 2 用户登录 现在有 $(who | wc -l) 用户登录 现在有 2 用户登录 expr命令 用于数学计算，优先级和正常算术运算同步 ➜ ch05 expr 1 + 1 2 ➜ ch05 expr 10 + 10 / 2 15 ➜ ch05 expr 10 / 3 3 ➜ ch05 expr 10 / 3.0 expr: not a decimal number: '3.0' ➜ ch05 expr 10 * 3 expr: syntax error ➜ ch05 expr 10 \\* 3 30 ➜ ch05 expr '10 * 3' 10 * 3 ➜ ch05 expr \"10 * 3\" 10 * 3 ➜ ch05 i=1 ➜ ch05 i=$(expr $i + 1) ➜ ch05 echo $i 2 ➜ ch05 i=`expr $i + 100` ➜ ch05 echo $i 102 书本练习text=\" 123 456 \" name= Tony Ralph Tony Lucy Fred Emanuel Charlie 写出一个命令，用来去掉shell变量text值中所有的空格字符。要保证把结果重新赋值给text。（分别使用tr和sed实现） ➜ ch05 text=\" 123 456 \" ➜ ch05 text=$(echo $text | sed -e 's/[ ]*//g') ➜ ch05 echo $text 123456 ➜ ch05 text=\" 123 456 \" ➜ ch05 text=$(echo $text | tr -d ' ') ➜ ch05 echo $text 123456 写出一个命令，用来计数shell变量text值中包含字符的个数。然后再写一个命令，统计其中字母的个数（使用sed、wc） ➜ ch05 cat names | wc -cw 7 42 写出一个命令，吧文件names中各不相同的行存到变量namelist中 ➜ ch05 sort names | uniq &gt; namelist ➜ ch05 cat namelist ───────┬──────────────────────────────────────────────────────────────────────── │ File: namelist ───────┼──────────────────────────────────────────────────────────────────────── 1 │ Charlie 2 │ Emanuel 3 │ Fred 4 │ Lucy 5 │ Ralph 6 │ Tony ───────┴──────────────────────────────────────────────────────────────────────── ch06 传递参数 本章用于学习参数的处理 特殊的参数表示 $# 表示命令行中输入的参数个数 $* 表示所有的参数 $0 表示文件名 $? 表示运行结束后的状态码 # exampole for some specific args echo \"文件名： $0\" echo \"所有参数：$*\" echo \"输出的参数： $#\" for i in $(seq 1 5) do echo \"第i个参数：$i\" done ➜ ch06 ./args 1 2 3 4 5 文件名： ./args 所有参数：1 2 3 4 5 输出的参数： 5 第i个参数：1 第i个参数：2 第i个参数：3 第i个参数：4 第i个参数：5 ➜ ch06 echo $? 0 传递参数电话簿中查找联系人如果我们在phonebook中寻找用户的话，通过grep name phonebook即可，但是为了使得该功能更加灵活，可以将name抽出来作为参数，然后编写一个专门用于在phonebook中查找人名的脚本。 ➜ ch06 vim lu # Look someone up in the phone book grep $1 phonebook ➜ ch06 ./lu Alice Alice Chebba 973-555-2015 但是有一个小问题，具体如下： ➜ ch06 ./lu \"Susan T\" grep: T: No such file or directory phonebook:Susan Goldberg 201-555-7776 phonebook:Susan Topple 212-555-4932 虽然我们只传递了一个参数，但实际执行时变成了两个参数。 # 代入到我们编写的脚本 # Look someone up in the phone book grep Susan T phonebook # 通过脚本就能明显的看到，我们是在T、phonebook两个文件中，匹配Susan这个名字，所以会爆 no such file问题 所以我们可以将脚本优化为： ➜ ch06 vim lu # Look someone up in the phone book grep \"$1\" phonebook ➜ ch06 ./lu \"Susan T\" Susan Topple 212-555-4932 电话簿中添加联系人➜ ch06 vim add # Add someone to the phone book echo \"$1 $2\" &gt;&gt; phonebook sort -o phonebook phonebook ➜ ch06 ./add 'Stromboli Pizza' 973-555-9478 ➜ ch06 cat phonebook ───────┬──────────────────────────────────────────────────────────────────────── │ File: phonebook ───────┼──────────────────────────────────────────────────────────────────────── 1 │ Alice Chebba 973-555-2015 2 │ Barbara Swingle 201-555-9257 3 │ Liz Stachiw 212-555-2298 4 │ Stromboli Pizza 973-555-9478 5 │ Susan Goldberg 201-555-7776 6 │ Susan Topple 212-555-4932 7 │ Tony Iannino 973-555-1295 ───────┴──────────────────────────────────────────── 电话簿中删除联系人➜ ch06 vim rem # remove someone fromm the phone book grep -v \"$1\" phonebook &gt; /tmp/phonebook mv /tmp/phonebook phonebook ➜ ch06 cat phonebook ───────┬──────────────────────────────────────────────────────────────────────── │ File: phonebook ───────┼──────────────────────────────────────────────────────────────────────── 1 │ Alice Chebba 973-555-2015 2 │ Barbara Swingle 201-555-9257 3 │ Liz Stachiw 212-555-2298 4 │ Susan Goldberg 201-555-7776 5 │ Susan Topple 212-555-4932 6 │ Tony Iannino 973-555-1295 ───────┴──────────────────────────────────────────────────────────────────────── 更多参数如果参数的数量超过9个，那么我们无法使用$10进行表示第10个参数，其会覆盖第一个参数（$1）的值，所以要想正确接受到10个以上的参数，从第10个开始，我们需要使用\\${n}的形式 ch07条件语句退出状态在条件测试中，退出状态很重要。只要程序执行完成，都会向Shell返回一个退出状态码，这个状态码类似HTTP的响应码，是一个数字，表示程序是否运行成功。0表示运行成功，非0状态表示运行失败，状态码对应于不同的失败原因。其中$?可以作为程序运行结束后的返回结果。 test和[]命令test的一般格式为 test expression 在命令行中输入man test，可以查看test命令的用法。 test命令用于判断文件类型，以及对变量做比较。 test命令用exit code返回结果，而不是使用stdout。0表示真，非0表示假。 test 2 -lt 3 # 为真，返回值为0 echo $? # 输出上个命令的返回值，输出0 同时我们也可以使用另一种形式来表示： [ expression ] # 在 ] 之前和 [ 之后要保证有空格 if [ \"$name\" = kwk ] then // do something done 文件类型判断格式： test -e filename # 判断文件是否存在 测试参数 代表意义 -e 文件是否存在 -f 是否为文件 -d 是否为目录 文件权限判断格式： test -r filename # 判断文件是否可读 测试参数 代表意义 -r 文件是否可读 -w 文件是否可写 -x 文件是否可执行 -s 是否为非空文件 整数间的比较格式： test $a -eq $b # a是否等于b 测试参数 代表意义 -eq a是否等于b -ne a是否不等于b -gt a是否大于b -lt a是否小于b -ge a是否大于等于b -le a是否小于等于b 字符串比较 测试参数 代表意义 test -z STRING 判断STRING是否为空，如果为空，则返回true test -n STRING 判断STRING是否非空，如果非空，则返回true（-n可以省略） test str1 == str2 判断str1是否等于str2 test str1 != str2 判断str1是否不等于str2 多重条件判定格式： test -r filename -a -x filename 测试参数 代表意义 -a 两条件是否同时成立（与） -o 两条件是否至少一个成立（或） -r 取反。如 test ! -x file，当file不可执行时，返回true（非） 根据以上的各种类型判断，可以编写一个更为完整的用户登录脚本 #! /bin/bash user=\"$1\" if who | grep \"^$user\" &gt; /dev/null # 避免 grep的输出结果 then echo \"$user is logged on\" else echo \"$user is not logged on\" fi 同时，为了成为一个长期可用的程序，我们应该添加对该程序的阐述，并且校验参数数量上的正确性。如果哪个参数不对，还需要进行指出 #! /bin/bash # determine if someone is logged on V1 # judge correct number of arguments were supplied if [ \"$#\" -ne 1 ] then echo \"Incorrect number of arguments\" echo \"Usage: ./on user\" else user=\"$1\" if who | grep \"^$user\" &gt; /dev/null then echo \"$user is logged on\" else echo \"$user is not logged on\" fi fi 输出： ➜ ch07 ./on hanhuanhuan hanhuanhuan is not logged on ➜ ch07 ./on Incorrect number of arguments Usage: ./on user ➜ ch07 ./on weikunkun weikunkun is logged on ➜ ch07 ./on aa bb cc Incorrect number of arguments Usage: ./on user exit命令 exit命令用来退出当前shell进程，并返回一个退出状态；使用$?可以接收这个退出状态。 exit命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是 0。 exit退出状态只能是一个介于 0~255 之间的整数，其中只有 0 表示成功，其它值都表示失败。 8 编写删除phone book中的任意一个用户的脚本，同时为了保证系统安全，使用对参数进行校验，仅支持传入一个参数 # rem v2.0 # remove someone from phone book # if [ \"$#\" -ne 1 ] then echo \"Incorrect number of arguments.\" echo \"Usage: ./rem name\" exit 1 # 指定错误码 fi grep -v \"$1\" phonebook &gt; /tmp/phonebook mv /tmp/phonebook phonebook if…then形式格式： if condition then 语句1 语句2 ... else 语句1 语句2 ... fi 示例： a=3 b=4 if ! [ \"$a\" -lt \"$b\" ] then echo ${a}不小于${b} else echo ${a}小于${b} fi 输出结果： 3小于4 多层if-elif-elif-else格式： if condition then 语句1 语句2 ... elif condition then 语句1 语句2 ... elif condition then 语句1 语句2 else 语句1 语句2 ... fi 示例： 还是以删除phone book为例，之前的写法，虽然检验了参数的合法性，但还不能很好明白用户的意图，对于其他的行为并没有做过多的检测。有时候会误删非用户目标的内容。所以仍需要优化 ➜ ch07 vim rem #! /bin/bash # rem v3.0 # remove someone from phone book # if [ \"$#\" -ne 1 ] then echo \"Incorrect number of arguments.\" echo \"Usage: ./rem name\" exit 1 # 指定错误码 fi # 获取入参 name=$1 # 先匹配出根据参数 删除的条目数量 matches=$(grep $name phonebook | wc -l) if [ \"$matches\" -gt 1 ] then echo \"More than one match; please qualify further\" elif [ \"$matches\" -eq 1 ] then grep -v \"$name\" phonebook &gt; /tmp/phonebook mv /tmp/phonebook phonebook else echo \"I could not find $name in the phone book\" fi ➜ ch07 ./rem aaaa I could not find aaaa in the phone book ➜ ch07 cat phonebook ───────┬──────────────────────────────────────────────────────────────────────── │ File: phonebook ───────┼──────────────────────────────────────────────────────────────────────── 1 │ Alice Chebba 973-555-2015 2 │ Barbara Swingle 201-555-9257 3 │ Liz Stachiw 212-555-2298 4 │ Susan Goldberg 201-555-7776 5 │ Susan Topple 212-555-4932 6 │ Tony Iannino 973-555-1295 ───────┴──────────────────────────────────────────────────────────────────────── ➜ ch07 ./rem Susan More than one match; please qualify further ➜ ch07 ./rem Tony ➜ ch07 cat phonebook ───────┬──────────────────────────────────────────────────────────────────────── │ File: phonebook ───────┼──────────────────────────────────────────────────────────────────────── 1 │ Alice Chebba 973-555-2015 2 │ Barbara Swingle 201-555-9257 3 │ Liz Stachiw 212-555-2298 4 │ Susan Goldberg 201-555-7776 5 │ Susan Topple 212-555-4932 ───────┴──────────────────────────────────────────────────────────────────────── case…esac形式格式： case $变量名称 in 值1) 语句1 语句2 ... ;; # 类似于C/C++中的break 值2) 语句1 语句2 ... ;; *) # 类似于C/C++中的default 语句1 语句2 ... ;; esac 示例： 输入一个数字，然后转化为对应的英语单词 ➜ ch07 vim number #! /bin/bash # # Translate a didgit to English # if [ \"$#\" -ne 1 ] then echo \"Usage: number digit\" exit 1 fi number=$1 case $number in 0) echo zero ;; 1) echo one ;; 2) echo two ;; 3) echo three ;; 4) echo four ;; 5) echo five ;; 6) echo six ;; 7) echo seven ;; 8) echo eight ;; 9) echo nine ;; *) echo \"Bad argumnet; please specify a single digit\" ;; esac 输出结果： ➜ ch07 ./number 1 one ➜ ch07 ./number 100 Bad argumnet; please specify a single digit ➜ ch07 ./number Usage: number digit 调试一个用于识别数字、大小写字符、特殊字符的程序 # !/bin/bash # # Ensure that only one character was types # verify arguments if [ \"$#\" -ne 1 ] then echo \"Please type a single character\" exit 1 fi char=\"$1\" numberchar=$(echo \"$char\" | wc -c) if [ \"$numberchar\" -ne 1 ] then echo \"Please type a single character\" exit 1 fi # classify it case \"$char\" in [0-9]) echo \"digit\" ;; [a-z]) echo \"lowercase letter\" ;; [A-Z]) echo \"uppercase letter\" ;; *) echo \"special character\" ;; esac 但是，当我们执行之后，却发现不符合我们的预期 ➜ ch07 ./ctype a Please type a single character ➜ ch07 ./ctype 1 Please type a single character ➜ ch07 ./ctype '*' Please type a single character 我们可以通过-x进行调试 ➜ ch07 sh -x ./ctype a + '[' 1 -ne 1 ']' + char=a ++ echo a ++ wc -c + numberchar=' 2' # echo \"$name\" | wc -c 输出为2？？？ + '[' ' 2' -ne 1 ']' + echo 'Please type a single character' Please type a single character + exit 1 通过输出调试，我们发现一个特性： echo \"$name\" | wc -c 统计的结果出了我们需要的统计字符外，还有一个是echo在行尾自带的不可见字符换行符,所以需要重新修改判断逻辑，最后执行结果符合预期： ➜ ch07 ./ctype '*' special character ➜ ch07 ./ctype a lowercase letter ➜ ch07 ./ctype 1 digit ch08循环for…in…do…done格式： for var in val1 val2 val3 do 语句1 语句2 ... done for ((…;…;…)) do…done格式： for ((expression; condition; expression)) do 语句1 语句2 done while…do…done循环格式： while condition do 语句1 语句2 ... done until…do…done循环格式： until condition do 语句1 语句2 ... done ch09 数据的读取和打印 主要介绍如何使用read命令从终端或文件中读取数据，以及如何使用printf将数据格式化并输出 read 命令格式： read variables 例子： 编写一个具有复制功能的脚本，同时要求根据用户的自己的意愿判断是否需要覆盖文件 # Copy a file if [ \"$#\" -ne 2 ] then echo \"Usage: mycp from to\" exit 1 fi from=\"$1\" to=\"$2\" # see if the destination file already exits if [ -e \"$to\" ] then echo \"$to already exit; overwrite（yes/no）?\" read anwser if [ \"$anwser\" != yes ] then echo \"Copy not performed\" exit 0 fi fi # either desitination doesn't exist or \"yes\" was typed cp $from $to ==小技巧== # 我们可以使用 \\c 将echo中最后自带的换行符替换 echo \"$to already exit; overwrite (yes/no)? \\c\" 字符 输出 \\b Backspace \\c 忽略输出最后的换行符 \\f 换页 \\n 回车换行 \\r 回车 \\t Tab \\\\ 反斜线 \\0nnn ASCII值为nnn的字符，其中nnn是1~3份的八进制数 输出结果： ➜ ch09 git:(master) ✗ mycp.sh names numbers numbers already exit; overwrite（yes/no）? no Copy not performed mycp的系列优化 当前的复制，没有检测to是否为一个目录，可能会导致我们的目标文件被移动到to目录中，所以需要有效的通知用户，同时将移动的文件名保持为愿文件名 ```shell Copy a fileif [ “$#” -ne 2 ]then echo \"Usage: mycp from to\" exit 1 fi from=”$1”to=”$2” check to is a directoryif [ -d “$to” ]; then # if better expression to=\"$to/$(basename $from)\" fi see if the destination file already exits if [ -e “$to” ] then echo “$to already exit; overwrite（yes/no）?\\c “ read anwser if [ \"$anwser\" != yes ] then echo \"Copy not performed\" exit 0 fi fi either desitination doesn’t exist or “yes” was typed cp $from $to 2. mycp支持可变参数。使其和`cp`更加接近 ```shell # Copy a file # mycp final version 5 numargs=$# filelist= copylist= while [ \"$#\" -gt 1 ]; do filelist=\"$filelist $1\" shift done to=\"$1\" # if less than two args, or if more than two ags and last args # is not a directory then issue an error message if [ \"$numargs\" -lt 2 -o \"$numargs\" -gt 2 -a ! -d \"$to\" ]; then echo \"Usage: mycp file1 file2\" echo \" mycp file(s) dir\" exit 1 fi for form in $filelist; do # judege $to is a directory if [ -d \"$to\" ]; then toFile=\"$to/$(basename $from)\" else toFile=\"$to\" fi # add file if [ -e \"$toFile\" ]; then echo \"$toFile already exits; overwrite (yes/no)? \\c\" read anwser if [ \"$anwser\" = yes ]; then copylist=\"$copylist $from\" fi else copylist=\"$copylist $from\" fi done if [ -n \"$copylist\" ]; then cp $copylist $to fi 一个具有交互功能的电话簿脚本 ######################################################################### # File Name: rolo.sh # Author: weikunkun # mail: kongwiki@163.com # Created Time: 日 11/21 21:21:35 2021 ######################################################################### #!/bin/bash # role - rolodex program to look up, add, and remove people form the phone book # display menu echo \" Would you like to: 1. Look someone up 2. Add someone to the phone book 3. Remove someone from the phone book Please select one of the above (1 - 3): \\c \" # read input and process selection read choice echo \"\" case \"$choice\" in 1) echo \"Enter name to look up: \\c\" read name lu \"$name\" ;; 2) echo \"Enter name to added: \\c\" read name add \"$name\" ;; 3) echo \"Enter name to be removed: \\c\" read name rem \"$name\" ;; *) echo \"Bad choice\" ;; esac 输出： ➜ ch09 git:(master) ✗ rolo.sh Would you like to: 1. Look someone up 2. Add someone to the phone book 3. Remove someone from the phone book Please select one of the above (1 - 3): 1 Enter name to look up: wkk ➜ ch09 git:(master) ✗ cat lu ───────┬──────────────────────────────────────────────────────────────────────── │ File: lu ───────┼──────────────────────────────────────────────────────────────────────── 1 │ # Look someone up in the phone book 2 │ grep \"$1\" phonebook ───────┴──────────────────────────────────────────────────────────────────────── ➜ ch09 git:(master) ✗ lu Alice ➜ ch09 git:(master) ✗ rolo.sh Would you like to: 1. Look someone up 2. Add someone to the phone book 3. Remove someone from the phone book Please select one of the above (1 - 3): 2 Enter name to added: kwk ➜ ch09 git:(master) ✗ rolo.sh Would you like to: 1. Look someone up 2. Add someone to the phone book 3. Remove someone from the phone book Please select one of the above (1 - 3): 1 Enter name to look up: kwk kwk 优化： rolo大多数功能还是查找，当误参数的时候，默认使用lu进行查找，然后退出。同时使用util命令，进行优化，保证用户肯定有操作，避免选错其他字符导致程序结束 ######################################################################### # File Name: rolo2.sh # Author: weikunkun # mail: kongwiki@163.com # Created Time: 日 11/21 21:38:40 2021 ######################################################################### #!/bin/bash # role - rolodex program to look up, add, and remove people form the phone book if [ \"$#\" -ne 0 ]; then lu \"$@\" exit fi validchoice=\"\" until [ -n \"$validchoice\" ]; do # display menu echo \" Would you like to: 1. Look someone up 2. Add someone to the phone book 3. Remove someone from the phone book Please select one of the above (1 - 3): \\c \" # read input and process selection read choice echo \"\" case \"$choice\" in 1) echo \"Enter name to look up: \\c\" read name lu \"$name\" validchoice=TRUE ;; 2) echo \"Enter name to added: \\c\" read name echo \"Enter number: \\c\" read number add \"$name\" \"$number\" validchoice=TRUE ;; 3) echo \"Enter name to be removed: \\c\" read name rem \"$name\" validchoice=TRUE ;; *) echo \"Bad choice\" ;; esac done 输出： ➜ ch09 git:(master) ✗ cat phonebook ───────┬───────────────────────────────────────────────────────────────────────────────── │ File: phonebook ───────┼───────────────────────────────────────────────────────────────────────────────── 1 │ Alice Chebba 973-555-2015 2 │ Barbara Swingle 201-555-9257 3 │ Liz Stachiw 212-555-2298 4 │ Susan Goldberg 201-555-7776 5 │ Susan Topple 212-555-4932 6 │ Tony Iannino 973-555-1295 ───────┴───────────────────────────────────────────────────────────────────────────────── ➜ ch09 git:(master) ✗ rolo2.sh Tony Tony Iannino 973-555-1295 ➜ ch09 git:(master) ✗ rolo2.sh Would you like to: 1. Look someone up 2. Add someone to the phone book 3. Remove someone from the phone book Please select one of the above (1 - 3): 2 Enter name to added: Tong Du Enter number: 999=-^H^H2332-332 ➜ ch09 git:(master) ✗ rolo2.sh Tony Tony Iannino 973-555-1295 ➜ ch09 git:(master) ✗ cat phonebook ───────┬───────────────────────────────────────────────────────────────────────────────── │ File: phonebook ───────┼───────────────────────────────────────────────────────────────────────────────── 1 │ Alice Chebba 973-555-2015 2 │ Barbara Swingle 201-555-9257 3 │ Liz Stachiw 212-555-2298 4 │ Susan Goldberg 201-555-7776 5 │ Susan Topple 212-555-4932 6 │ Tong Du 9992332-332 7 │ Tony Iannino 973-555-1295 ───────┴───────────────────────────────────────────────────────────────────────────────── printf命令 格式化输出 格式规范 功能 %d 整数 %u 无符号整数 %o 八进制数字 %x 十六进制数字，使用a~f %X 十六进制数字，使用A~F %c 单个字符 %s 字符串字面量 %b 包含转义字符的字符串 %% 百分号 编写一个格式化数组的程序： ######################################################################### # File Name: align.sh # Author: weikunkun # mail: kongwiki@163.com # Created Time: 日 11/21 22:00:55 2021 ######################################################################### #!/bin/bash cat $* | while read number1 number2 do printf \"%20d %20d \\n\" $number1 $number2 done 输出： ➜ ch09 git:(master) ✗ cat data ───────┬──────────────────────────────────────────────────────────────────────── │ File: data ───────┼──────────────────────────────────────────────────────────────────────── 1 │ 95436928923 54398857123 2 │ 96327974 978968345823 3 │ 96324623375324 9745738523 4 │ 962372735 96243642523 5 │ 9764236246452352 952352234 6 │ 91414124 545235 7 │ 79861236 9461246213 8 │ 9412376413264 23461275 9 │ 52161273521 94612746123 10 │ 9412341234674 941267451254162 ───────┴──────────────────────────────────────────────────────────────────────── ➜ ch09 git:(master) ✗ align.sh data 95436928923 54398857123 96327974 978968345823 96324623375324 9745738523 962372735 96243642523 9764236246452352 952352234 91414124 545235 79861236 9461246213 9412376413264 23461275 52161273521 94612746123 9412341234674 941267451254162 通过printf命令，其实我们可以优化下add程序，因为我们之前在phonebook中新增联系人，都要按照格式输入，这样才能保持格式的一致，现在可通过printf进行优化。 # Add someone to the phone book # echo \"$1 $2\" &gt;&gt; phonebook printf \"%10s %20s\" $1 $2 &gt;&gt; phonebook sort -o phonebook phonebook 输出： ➜ ch09 git:(master) ✗ cat phonebook ➜ ch09 git:(master) ✗ add 孔维坤 999-999-9999 ➜ ch09 git:(master) ✗ add 维坤坤 888-888-8888 ➜ ch09 git:(master) ✗ cat phonebook ───────┬──────────────────────────────────────────────────────────────────────── │ File: phonebook ───────┼──────────────────────────────────────────────────────────────────────── 1 │ 维坤坤 888-888-8888 2 │ 孔维坤 999-999-9999 3 │ Alice Chebba 973-555-2015 4 │ Barbara Swingle 201-555-9257 5 │ Liz Stachiw 212-555-2298 6 │ Susan Goldberg 201-555-7776 7 │ Susan Topple 212-555-4932 8 │ Tony Iannino 973-555-1295 ───────┴──────────────────────────────────────────────────────────────────────── ch10环境 当我们登录到系统中，我们其实使用的都是一个全新的shell副本。登录之后，shell提供的就是属于我们自己的环境，该环境从登录一直持续到退出系统。 Shell中变量的作用域变量的作用域顾名思义就是说变量的有效范围。在不同的范围中，同名的变量不会互相干涉，但是在相同的作用域中，同名的变量就会互相干扰，这也就是我们需要了解作用域的原因，避免变量之间的互相干扰。 shell中作用域共分为三种： 变量仅在函数内部可以使用，称为局部变量 变量可以在当前的Shell中使用， 称为全局变量 变量除了在当前Shell进程中使用，还可以在其子进程中使用，称为环境变量 局部变量正常编程中，函数内部的变量称之为局部变量。在Shell中略微不同的是，我们通过local声明的变量才能称之为局部变量。 例子： ➜ ch10 git:(master) ✗ cat func.sh ───────┬───────────────────────────────────────────────────────────────────────────────── │ File: func.sh ───────┼───────────────────────────────────────────────────────────────────────────────── 1 │ ######################################################################### 2 │ # File Name: func.sh 3 │ # Author: weikunkun 4 │ # mail: kongwiki@163.com 5 │ # Created Time: 一 11/22 19:15:39 2021 6 │ ######################################################################### 7 │ #!/bin/bash 8 │ 9 │ function func() { 10 │ a=99 11 │ } 12 │ ───────┴───────────────────────────────────────────────────────────────────────────────── ➜ ch10 git:(master) ✗ func.sh ➜ ch10 git:(master) ✗ echo $x 100 ➜ ch10 git:(master) ✗ cat func.sh ───────┬───────────────────────────────────────────────────────────────────────────────── │ File: func.sh ───────┼───────────────────────────────────────────────────────────────────────────────── 1 │ ######################################################################### 2 │ # File Name: func.sh 3 │ # Author: weikunkun 4 │ # mail: kongwiki@163.com 5 │ # Created Time: 一 11/22 19:15:39 2021 6 │ ######################################################################### 7 │ #!/bin/bash 8 │ 9 │ function func() { 10 │ local a=99 11 │ } 12 │ ───────┴───────────────────────────────────────────────────────────────────────────────── ➜ ch10 git:(master) ✗ func.sh ➜ ch10 git:(master) ✗ echo $x 全局变量所谓的全局变量，就是在当前的Shell进程中都有效，每个进程都有自己的作用域，彼此之间互不影响。在当前Shell中定义的变量，默认为全局变量。 需要注意的是，全局变量的作用域当前的Shell进程，不是当前的Shell脚本文件，这也就解释了，上述的例子中，最开始未加local关键字的示例中，func.sh中定义的变量x，在该Shell脚本外，仍能被正确调用，因为变量x是一个全局变量 当我们打开多个Shell窗口时，就创建了多个Shell进程。每个Shell进程都是独立的。同时我们通过source命令可以引入多个脚本，然后全局变量对这些脚本都有效。 b = 200 ➜ ch10 git:(master) ✗ cat a.sh ───────┬───────────────────────────────────────────────────────────────────────────────── │ File: a.sh ───────┼───────────────────────────────────────────────────────────────────────────────── 1 │ ######################################################################### 2 │ # File Name: a.sh 3 │ # Author: weikunkun 4 │ # mail: kongwiki@163.com 5 │ # Created Time: 一 11/22 19:54:12 2021 6 │ ######################################################################### 7 │ #!/bin/bash 8 │ echo \"a = $a\" 9 │ b=200 ───────┴───────────────────────────────────────────────────────────────────────────────── ➜ ch10 git:(master) ✗ cat b.sh ───────┬───────────────────────────────────────────────────────────────────────────────── │ File: b.sh ───────┼───────────────────────────────────────────────────────────────────────────────── 1 │ ######################################################################### 2 │ # File Name: b.sh 3 │ # Author: weikunkun 4 │ # mail: kongwiki@163.com 5 │ # Created Time: 一 11/22 19:54:25 2021 6 │ ######################################################################### 7 │ #!/bin/bash 8 │ echo \"b = $b\" ───────┴─────────────────────────────────────────────────────────────────────────────── ➜ ch10 git:(master) ✗ a=99 ➜ ch10 git:(master) ✗ source a.sh a = 99 ➜ ch10 git:(master) ✗ source b.sh b = 200 这三条命令都是在一个进程中执行的，从输出结果可以发现，在 Shell 窗口中以命令行的形式定义的变量 a，在 a.sh 中有效；在 a.sh中定义的变量 b，在 b.sh 中也有效，变量 b 的作用范围已经超越了 a.sh。 注意：这里是使用source的方式执行的脚本，效果是在当前进程下执行，而如果使用bash a.sh这种方式执行脚本就不会有上述结果，因为这种方式执行脚本是在子进程下执行的，具体执行方式的区别参考这篇文章。 全局变量冲突： 虽然通过source可以打通所有脚本，共用多个全局变量，但是有些问题需要我们注意： 写了一个函数脚本，名为qc.sh 在另一个脚本run.sh中对qc.sh进行了source执行 qc.sh截取： 复制# func one func_1(){ for i in $(ls ${local_variable}/*_test.zip) do mv ${i} something done } # func two func_2(){ for i in $(ls ${local_variable_2}/*_test.zip) do mv ${i} something_2 done } run.sh截取： 复制for i in \"190915_data\" do func_1 ${results_folder}/${i}/${j}/qc func_2 ${results_folder}/${i}/${j}/trim ${results_folder}/${i}/${j}/trim done 最后程序在执行func_2时报错，而func_1正常执行，检查日志发现func_2传递的参数有误，其中的${i}部分变成了func_1中for循环最终停止的i，已经不是目标的190915_data，source方式执行脚本会打通全局变量，所以func_1执行之后由于其中的i变量不是局部变量，所以其作用域是整个脚本，并且会对之前的变量i的值进行覆盖，从而导致其值变为了func_1中for循环最终停止的i，并将其传递给了第二个函数func_2，最终导致出错。 环境变量全局变量只能在当前的Shell进程中有效，若是还想在子进程中仍然有效，就需要使用到环境变量，其中环境变量又称为临时环境变量和永久环境变量 如果是使用export修饰的变量，则改变量在所有的子进程也都有效了，称为临时环境变量 如果是将变量写在配置文件中，譬如/etc/profile、~/.profile、/etc/zsh/zprofile中，在所有的Shell进程中都有效了，称为永久环境变量 临时环境变量： 创建Shell子进程最简单的方法就是zsh命令，退出Shell子进程的方法是exit命令(采用的是zsh)： ➜ ch10 git:(master) ✗ echo $$ 29625 ➜ ch10 git:(master) ✗ echo $$ 36389 ➜ ch10 git:(master) ✗ exit ➜ ch10 git:(master) ✗ echo $$ 29625 ➜ ch10 git:(master) ✗ a=22 ➜ ch10 git:(master) ✗ echo $a 22 ➜ ch10 git:(master) ✗ zsh ➜ ch10 git:(master) ✗ echo $a ➜ ch10 git:(master) ✗ exit ➜ ch10 git:(master) ✗ export a ➜ ch10 git:(master) ✗ zsh ➜ ch10 git:(master) ✗ echo $a 22 永久环境变量： export TERM=xterm-256color ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=208' clear export PATH=\"/usr/local/opt/redis@3.2/bin:$PATH\" export PATH=\"/usr/local/opt/tcl-tk/bin:$PATH\" export JAVA_HOME=\"/Library/Java/JavaVirtualMachines/jdk-11.0.12.jdk/Contents/Home\" export PATH=$JAVA_HOME/bin:$PATH # Go PATH export GOROOT=/usr/local/go export PATH=$GOROOT/bin:$PATH # 添加当前位置到环境变量 export PATH=.:$PATH # Aliases alias cat=\"/usr/local/bin/bat\" alias grep=\"grep --color\" 对于永久环境变量， 其加载顺序如下（以bash为例）： PS1、PS2PS1用于终端的提示符，PS2用于命令中输入的长度多于一行后的辅助提示符。 HOME、PATHHOME用于表示当前用户登录所处的位置。 ➜ ch10 git:(master) ✗ echo $HOME /Users/weikunkun PATH用于记录当前系统的环境变量。 ➜ ch10 git:(master) ✗ echo $PATH .:/usr/local/go/bin:/Library/Java/JavaVirtualMachines/jdk-11.0.12.jdk/Contents/Home/bin:/usr/local/opt/tcl-tk/bin:/usr/local/opt/redis@3.2/bin:/Users/weikunkun/bin:/usr/local/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/go/bin:/opt/apache-maven-3.6.3/bin:/usr/local/mysql/bin 在命令中，输入的命令，Shell会搜索PATH列出的目录，知道找到可以匹配的可执行文件。所以想要最先搜索当前目录，可以将.放到当前$PATH的最开始（注意取舍安全性） rolo再优化通过上述的学习，我们会发现rolo还能继续优化 无法在任意位置执行rolo 所有用户都可以执行rolo之后，可能当前用户想操作的是自己的phonebook而不是其他人的，所以我们需要创建一个能够面向多用户的phonebook ######################################################################### # File Name: rolo.sh # Author: weikunkun # mail: kongwiki@163.com # Created Time: 一 11/22 21:09:23 2021 ######################################################################### #!/bin/bash PHONEBOOK=$HOME/phonebook export PHONEBOOK if [ ! -f \"$PHONEBOOK\" ]; then echo \"No phone book file in $HOME\" exit 1 fi # 如果提供了参数，则执行查询操作 if [ \"$#\" -ne 0 ]; then lu \"$@\" exit fi validchoice=\"\" # 循环 直到用户已经做出有效选择 until [ -n \"$validchoice\" ]; do # 显示菜单 echo \" Would you like to: 1. Look someone up 2. Add someone to the phone book 3. Remove someone fomr the phone book Please select one of the above (1-3): \\c \" # 查找 read choice echo case \"$choice\" in 1) echo \"Enter name to look up: \\c\" read name lu \"$name\" validchoice=TRUE ;; 2) echo \"Enter name to be added: \\c\" read name echo \"Enter number: \\c\" read number add $name $number validchoice=TRUE ;; 3) echo \"Enter name to be removed: \\c\" read name read number rem \"$name\" validchoice=TRUE ;; *) echo \"Bad choic\" ;; esac done 执行结果： ➜ ch10 git:(master) ✗ rolo 孔维坤 孔维坤 111-111-1111 ➜ ch10 git:(master) ✗ rolo Would you like to: 1. Look someone up 2. Add someone to the phone book 3. Remove someone fomr the phone book Please select one of the above (1-3): 1 Enter name to look up: 孔维坤 孔维坤 111-111-1111 ➜ ch10 git:(master) ✗ rolo Would you like to: 1. Look someone up 2. Add someone to the phone book 3. Remove someone fomr the phone book Please select one of the above (1-3): 2 Enter name to be added: 小坤坤 Enter number: 999-999-9999 ➜ ch10 git:(master) ✗ cat $HOME/phonebook ───────┬──────────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: /Users/weikunkun/phonebook ───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 孔维坤 111-111-1111 2 │ 维坤坤 222-222-2222 3 │ 韩欢欢 333-333-3333 4 │ 小坤坤 999-999-9999 ───────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────────── ch11参数 该章节主要详细阐述了各种参数的操作 位置参数（行参） 特殊参数（$#、$?） 关键字参数（普通变量） ${paramter}这种形式的内容主要用于当前应用包含过多的参数（10个及以上） ${10} ${11} 进行替换： mv ${file} ${file}x ${paramter:-value}类似于getOrdeDefault的功能，如果当前paramter不为空，则使用它的值，否则就是用value。 示例： ➜ book git:(master) echo Using editor ${EDITOR:-$(which vim)} Using editor /usr/local/bin/vim 其并不会对当前的paramter进行覆盖操作，如果不存在则会赋值我们指定的默认值，否则不进行任何操作，类似如下的if-else判断 ######################################################################### # File Name: usevim.sh # Author: weikunkun # mail: kongwiki@163.com # Created Time: 二 11/23 16:21:22 2021 ######################################################################### #!/bin/bash if [ -n \"$EDITOR\" ]; then echo \"Using editor $EDITOR\" else echo \"Using editor $(which vim)\" fi 示例： ➜ book git:(master) ✗ EDITOR=$(which ed) ➜ book git:(master) ✗ echo ${EDITOR:-$(which vim)} /bin/ed ➜ book git:(master) ✗ EDITOR= ➜ book git:(master) ✗ echo ${EDITOR:-$(which vim)} /usr/local/bin/vim ➜ book git:(master) ✗ ${paramter:=value}该操作类似直接对变量进行赋值。当然我们无法使用这种形式，对位置参数进行赋值（paramter不能是数字）。如果想要将其作为一个命令，需要做如下操作 : ${paramter:=value} ➜ ch10 : ${PHONEBOOK:=$HOME/phonebook} ➜ ch10 echo $PHONEBOOK /root/phonebook ➜ ch10 : ${PHONEBOOK:=aaa} ➜ ch10 echo $PHONEBOOK /root/phonebook 这种形式的用法一般在条件语句或者echo语句中第一次使用变量的时候会使用 ${paramter:?value}如果paramter不为空，Shell会进行替换，否则写入到标准错误中。和三目运算类似 ${paramter:+value}和-value相反，如果paramter不为空，则替换成value，否则不进行任何操作 ➜ ch10 traceopt=T ➜ ch10 echo options: ${traceopt:+\"Trae mode\"} options: Trae mode ➜ ch10 traceopt= ➜ ch10 echo options: ${traceopt:+\"Trae mode\"} options: set作用： 设置各种Shell选项 重新为$1、$2、$3等位置参数赋值 示例： ➜ ch11 git:(master) ✗ set one two three four ➜ ch11 git:(master) ✗ echo $1 $2 $3 $4 one two three four ➜ ch11 git:(master) ✗ echo $# 4 ➜ ch11 git:(master) ✗ echo $@ one two three fou 编写一个word程序，用于统计一行中的单词个数 ➜ ch11 git:(master) ✗ cat word.sh ───────┬───────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: word.sh ───────┼───────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ ######################################################################### 2 │ # File Name: word.sh 3 │ # Author: weikunkun 4 │ # mail: kongwiki@163.com 5 │ # Created Time: 六 11/27 15:45:22 2021 6 │ ######################################################################### 7 │ #!/bin/bash 8 │ read line 9 │ set $line 10 │ echo $# # 输出参数个数 ───────┴───────────────────────────────────────────────────────────────────────────────────────────────────────── 执行结果： ➜ ch11 git:(master) ✗ word.sh Hello world my name is kwk 6 一些以外结果： 当我们不做任何输入时 ➜ ch11 git:(master) ✗ word.sh AUTOJUMP_ERROR_PATH=/Users/weikunkun/Library/autojump/errors.log AUTOJUMP_SOURCED=1 BASH=/bin/sh BASH_ARGC=() BASH_ARGV=() BASH_LINENO=([0]=\"0\") BASH_SOURCE=([0]=\"word.sh\") BASH_VERSINFO=([0]=\"3\" [1]=\"2\" [2]=\"57\" [3]=\"1\" [4]=\"release\" [5]=\"x86_64-apple-darwin21\") BASH_VERSION='3.2.57(1)-release' DIRSTACK=() EUID=501 GOROOT=/usr/local/go GROUPS=() HOME=/Users/weikunkun ... # 不做任何输入时，set就会执行无参数的执行，也就是输出所有的环境变量 输入以-开头的内容 ➜ ch11 git:(master) ✗ word.sh -11111+423 word.sh: line 9: set: -1: invalid option set: usage: set [--abefhkmnptuvxBCHP] [-o option] [arg ...] # 将-1视为了一个选项， 然后因为并未有任何设置，所以报错 解决方式： 使用--解决无参数输入时，打印当前所有的参数 使用while，实现正常统计单词数量 ➜ ch11 git:(master) ✗ vim word.sh count=0 while read line do set -- $line count=$((count + $#)) done echo $count ➜ ch11 git:(master) ✗ word.sh &lt; /etc/passwd 329 IFS作用： 指定分隔符，在Shell解析输入、命令替换、输出以及执行变量替换时，就会使用IFS指定的分隔符 示例： ➜ ch11 git:(master) ✗ IFS=: ➜ ch11 git:(master) ✗ read x y z 123:456:789 ➜ ch11 git:(master) ✗ echo $x $y $z 123 456 789 ➜ ch11 git:(master) ✗ list=\"one:two:three\" ➜ ch11 git:(master) ✗ for x in $list; do echo $x; done one two three ## set和IFS的搭配示例 ch12拓展内容wait命令 和父进程调用waitpid类似，在Shell中通过wait，当前Shell等待子Shell完成后，后续操作 使用： wait process=id 例子： ➜ ch11 git:(master) ✗ sort big-data &gt; sorted_data &amp; [1] 29625 ➜ ch11 git:(master) ✗ echo $$ ➜ ch11 git:(master) ✗ wait 29625 trap命令我们在编写Shell程序时，当发现运行不符合预期时，会直接中断执行，一般来说没啥问题，但是期间运行的一些临时文件就会特别多，所以我们可以使用trap进行操作 信号 助记名 产生原因 0 EXIT 退出SHELL 1 HUP 挂起 2 INT 中断（Ctrl + c） 15 TERM 软终端信号（默认kill） 实例： trap \"rm $WORKDIR/work1$$ $WORKDIR/dataout$$; eixt\" INT I/O内容我们已经知道 &lt; 输出重定向 &gt; 输出重定向 &gt;&gt; 追加输出重定向 同时我们也可以使用2&gt;来实现标准错误的重定向 command 2&gt; file 有时我们也可以这样 command &gt;&amp;2 &gt;&amp;指名将输出重定向到和指定文件描述符相关联的文件中。 文件描述符0表示标准输入 文件描述符1对应标准输出 文件描述符2对应标准错误 示例： echo \"Invalid number of arguments\" &gt;&amp;2 command &gt; foo 2 &gt;&gt; foo #将标准输出和标准错误输出到同一个文件 command &gt; foo 2&gt;&amp;1 # 和上述同理 ch13 rolo终极进化版 不再强行要求一开始用户的主目录下有phone book，同时会检测PHONEBOOK变量是否被设置，如果设置，则不再进行设置，如果没有设置，则将其设置为$HOME/phonebook 检测phonebook文件是否存在，不存在进行交互，是否创建 新增选项：display功能 做了撤销判断 抽出add脚本，做更好的交互 对于查找、删除、修改选项，做了判空判断 rolo 使用export设置临时环境环境变量，同时PHONEBOOK使用${paramter:=variable}的形式进行设置（变量已设置不做任何操作，未设置，通过交互判断是新建文件） ######################################################################### # File Name: rolo.sh # Author: weikunkun # mail: kongwiki@163.com # Created Time: 一 11/22 21:09:23 2021 ######################################################################### #!/bin/bash # 如果PHONEBOOK已经设置，不做任何变动 : ${PHONEBOOK:=$HOME/phonebook} export PHONEBOOK if [ ! -e \"$PHONEBOOK\" ]; then echo \"$PHONEBOOK does not exit\" echo \"Should I create it for you （y/n）? \\c\" read anwser if [ \"$anwser\" != y ]; then exit 1 fi &gt;&gt; $PHONEBOOK || exit 1 # 创建失败 退出 fi # 如果提供了参数，则执行查询操作 if [ \"$#\" -ne 0 ]; then lu \"$@\" exit fi # 设置中断信号 trap \"continue\" SIGINT # 循环 直到用户已经做出有效选择 while true; do # 显示菜单 echo \" Would you like to: 1. Look someone up 2. Add someone to the phone book 3. Remove someone fomr the phone book 4. Change an entry in the phone book 5. List all names and numbers in the phone 6. Exit this program Please select one of the above (1-6): \\c \" # 查找 read choice echo case \"$choice\" in 1) echo \"Enter name to look up: \\c\" read name # 判断是否为空 if [ -z \"$name\" ]; then echo \"Lookup ingnored\" else lu \"$name\" fi ;; 2) add ;; 3) echo \"Enter name to be removed: \\c\" read name if [ -z \"$name\" ]; then echo \"Remove all ignored\" else rem \"$name\" fi ;; 4) echo \"Enter name to change: \\c\" read name if [ -z \"$name\" ]; then echo \"Change ignored\" else change \"$name\" fi ;; 5) listall ;; 6) exit 0 ;; *) echo \"Bad choice\" ;; esac done add ######################################################################### # File Name: add.sh # Author: weikunkun # mail: kongwiki@163.com # Created Time: 一 11/22 21:19:22 2021 ######################################################################### #!/bin/bash echo \"Type in you new entry\" echo \"When you are done, type just a single Enter on the line\" first= entriy= while true; do echo \"&gt;&gt; \\c\" read line if [ -n \"$line\" ]; then entry=\"$entry$line^\" if [ -z \"$first\" ]; then first=$line fi else break fi done echo \"$entry\" &gt;&gt; $PHONEBOOK sort -o $PHONEBOOK $PHONEBOOK echo echo \"$first has been added to the phone book\" rem######################################################################### # File Name: rem.sh # Author: weikunkun # mail: kongwiki@163.com # Created Time: 一 11/22 21:23:32 2021 ######################################################################### #!/bin/bash # 删 name=$1 grep -i \"$name\" $PHONEBOOK &gt; /tmp/matches$$ if [ ! -s /tmp/matches$$ ]; then echo \"I can not find $name int the phone book\" exit 1 fi while read line do display \"$line\" echo \"Remove this entry (y/n) ? \\c\" read anwser &lt; /dev/tty if [ \"$anwser\" = y ]; then break fi done &lt; /tmp/matches$$ rm /tmp/matches$$ if [ \"$anwser\" = y ]; then if grep -i -v \"^$line$\" $PHONEBOOK &gt; /tmp/phonebook$$ then mv /tmp/phonebook$$ $PHONEBOOK echo \"Selected entry has been removed\" elif [ ! -s $PHONEBOOK ]; then echo \"Note: You now have an empty phone book\" else echo \"Entry not removed\" fi fi lu######################################################################### # File Name: lu.sh # Author: weikunkun # mail: kongwiki@163.com # Created Time: 一 11/22 21:21:17 2021 ######################################################################### #!/bin/bash # 查 name=\"$1\" grep \"$name\" $PHONEBOOK &gt; /tmp/matches$$ if [ ! -s /tmp/matches$$ ]; then echo \"I can not fine $name in the phone book\" else while read line; do display \"$line\" done &lt; /tmp/matches$$ fi rm /tmp/matches$$ change######################################################################### # File Name: change.sh # Author: weikunkun # mail: kongwiki@163.com # Created Time: 二 11/23 22:00:55 2021 ######################################################################### #!/bin/bash name=$1 grep -i \"$name\" $PHONEBOOK &gt; /tmp/mathches$$ if [ ! -s /tmp/mathches$$ ]; then echo \"I can not find $name in the phone book\" exit 1 fi # 显示匹配出联系人的信息并确认是否要修改 while read line do display \"$line\" echo \"Change this entry (y/n) ? \\c\" read anwser &lt; /dev/tty if [ \"$anwser\" = y ]; then break fi done &lt; /tmp/mathches$$ rm /tmp/mathches$$ if [ \"$anwser\" != y ]; then exit fi # 针对已经确定修改的联系人 启动编辑器 echo \"$line\\c\" | tr '^' '\\012' &gt; /tmp/ed$$ echo \"Enter changes whith ${EDITOR:=$(which vim)}\" trap \"\" 2 # 撤销也不终止 $EDITOR /tmp/ed$$ # 删除旧信息，插入新信息 grep -i -v \"^$line$\" $PHONEBOOK &gt; /tmp/phonebook$$ { tr '\\012' '^' &lt; /tmp/ed$$; echo; } &gt;&gt; /tmp/phonebook$$ # 最后的echo被回收到tr转换后的结尾换行符 sort /tmp/phonebook$$ -o $PHONEBOOK rm /tmp/ed$$ /tmp/phonebook$$ listall######################################################################### # File Name: listall.sh # Author: weikunkun # mail: kongwiki@163.com # Created Time: 二 11/23 22:09:11 2021 ######################################################################### #!/bin/bash IFS='^' echo \"-----------------------------------------------------\" while read line do # 获取第一个和最后一个字段 set $line # 显示第一个和最后一个字段（相反的顺序） eval printf \"\\\"%-40.40s %s\\\\n\\\"\" \"\\\"$1\\\"\" \"\\\"\\${$#}\\\"\" done &lt; $PHONEBOOK echo \"-----------------------------------------------------\" display######################################################################### # File Name: display.sh # Author: weikunkun # mail: kongwiki@163.com # Created Time: 二 11/23 21:50:53 2021 ######################################################################### #!/bin/bash echo echo \"--------------------------------------\" entry=$1 IFS=\"^\" set $entry for line in \"$1\" \"$2\" \"$3\" \"$4\" \"$5\" \"$6\" do printf \"| %-34.34s |\\n\" $line done echo \"| o o |\" echo \"--------------------------------------\" echo 实战小项目—-一键配置助手 有时候，我们在切换不同设备时，对于同类型的环境，经常需要我们进行重复的配置，由此，个人计划编写一个配置助手，用于一键配置自己所需要的环境 详见我的配置中心 ######################################################################### # File Name: configs.sh # Author: weikunkun # mail: kongwiki@163.com # Created Time: Tue 16 Nov 2021 04:20:09 PM CST ######################################################################### #!/bin/bash echo \"\" echo \" ========================================================= \" echo \" | Linux init.sh 环境部署脚本 V 1.1 | \" echo \" ========================================================= \" echo \" author：weikunkun \" echo \" https://github.com/Winniekun \" echo -e \"\\n\" # 由于学艺不精，经常把自己的服务器搞崩，并且定位不到root case # 所以经常会重装系统，痛定思痛，决定写一个一劳永逸的初始化安装配置脚本 # LEVEL=base/dev/hacker/full # base: 基础配置（zsh、vim、git、wget、curl等） # dev: 开发环境配置（Java、Go、Kafka、MySQL、Redis等） # hacker: 常见的网络安全工具（sqlmap、nmap、httpx、xray等） # full: 一把梭哈 LEVEL='full' CUR_PATH=$(pwd) # zsh &amp; oh-my-zsh安装 config_zsh() { if command -v zsh &gt;/dev/null 2&gt;&amp;1 then echo -e \"检测到zsh 已安装\" else apt install -y zsh &gt;/dev/null 2&gt;&amp;1 fi # install_ohmyzsh sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" # sh -c \"$(wget -O- https://pastebin.com/raw/FAFw08G6)\" echo -e \"shell切换为zsh\" chsh -s $(which zsh) # 设置主题，新增插件 sed -i 's@ZSH_THEME=\"robbyrussell\"@ZSH_THEME=\"awesomepanda\"@g' ~/.zshrc sed -i 's@plugins=(.*)@plugins=(git extract zsh-syntax-highlighting autojump zsh-autosuggestions)@g' ~/.zshrc { # 使用bat替代cat echo 'alias cat=\"/usr/bin/batcat\"' echo 'alias myip=\"curl ifconfig.io/ip\"' echo 'alias c=clear' } &gt;&gt; ~/.zshrc if [ -d \"$HOME/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting\" ] then echo -e \"zsh-highlighting 已经安装\" else echo -e \"下载安装zsh-highlighting\" git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting fi if [ -d \"$HOME/.oh-my-zsh/custom/plugins/zsh-autosuggestions\" ] then echo -e \"zsh-autosuggestions 已经安装\" else echo -e \"下载安装zsh-autosuggestions\" git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions fi # 声明终端类型 echo \"export TERM=xterm-256color\" &gt;&gt; ~/.zshrc # 设置建议命令的颜色 echo ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=10'\" &gt;&gt; ~/.zshrc # 重载配置 source ~/.zshrc } # oh-my-zsh安装 install_ohmyzsh() { echo -e \"开始配置oh-my-zsh\" if [ -d \"$HOME/.oh-my-zsh/\" ] then test fi if [ -e \"install.sh\" ] then rm install.sh fi wget -O install.sh https://pastebin.com/raw/FAFw08G6 sed -i 's@REPO=${REPO:-ohmyzsh/ohmyzsh}@REPO=${REPO:-mirrors/oh-my-zsh}@g' install.sh sed -i 's@REMOTE=${REMOTE:-https://github.com/${REPO}.git}@REMOTE=${REMOTE:-https://gitee.com/${REPO}.git}@g' install.sh sh install.sh } # Vim 安装 &amp; 配置 install_vim() { if [ ! -d \"$CUR_PATH/PowerVim\" ] then git clone https://github.com/youngyangyang04/PowerVim.git else VIM_PATH=$CUR_PATH/PowerVim cd $VIM_PATH &amp;&amp; sh install.sh # 一些问题修复 （语言问题、ctag等） fix_powervim fi cd $CUR_PATH } # PowerVim的一些小问题修复 fix_powervim() { # 系统中添加中文包 echo -e \"修复PowerVim一些小问题ing\" LOCAL_FILE=/var/lib/locales/supported.d/local if [ ! -e \"$LOCAL_FILE\" ] then echo -e \"创建 $LOCAL_FILE\" touch $LOCAL_FILE else rm $LOCAL_FILE fi { echo \"en_US.UTF-8 UTF-8\" echo \"zh_CN.UTF-8 UTF-8\" echo \"zh_CN.GBK GBK\" echo \"zh_CN GB2312\" } &gt;&gt; $LOCAL_FILE sudo locale-gen { echo 'let Tlist_Show_One_File=1 \"不同时显示多个文件的tag，只显示当前文件的' echo 'let Tlist_Exit_OnlyWindow=1 \"如果taglist窗口是最后一个窗口，则退出vim' echo 'let Tlist_Ctags_Cmd=\"/usr/bin/ctags\" \"将taglist与ctags关联' } &gt;&gt; ~/.vimrc echo -e \"修复成功\" } # Git 安装 &amp; 配置 intall_git() { if command -v git &gt;/dev/null 2&gt;&amp;1 then # 配置 echo -e \"检测到已经安装Git，开始Git配置\" config_git else # 安装 apt install -y git &gt;/dev/null 2&gt;&amp;1 # 配置 echo -e \"开始Git配置\" config_git fi } # git相关的配置 config_git() { # 用户信息 git config --global user.name \"weikunkun\" git config --global user.email \"kongwiki@163.com\" # core git config --global core.editor vim # color git config --global color.ui true git config --global color.status \"auto\" git config --global color.branch \"auto\" # merge git config --global merge.tool \"vimdiff\" # alias git config --global alias.co \"checkout\" git config --global alias.br \"branch\" git config --global alias.ci \"commit\" git config --global alias.st \"status\" git config --global alias.last \"log -1 HEAD\" } # python3 配置 install_python3() { if [ -d \"$HOME/.pip\" ] then echo -e \"$HOME/.pip 已经创建\" else mkdir ~/.pip/ fi echo -e \"[global]\\n\" &gt;~/.pip/pip.conf # 替换PIP源 速度更快 echo -e \"index-url = https://pypi.tuna.tsinghua.edu.cn/simple\" &gt;&gt;~/.pip/pip.conf echo -e \"开始安装Python常见库\" pip3 install lxml &gt;/dev/null 2&gt;&amp;1 pip3 install ipaddress &gt;/dev/null 2&gt;&amp;1 pip3 install python-dateutil &gt;/dev/null 2&gt;&amp;1 pip3 install apscheduler &gt;/dev/null 2&gt;&amp;1 pip3 install mycli &gt;/dev/null 2&gt;&amp;1 pip3 install aiohttp &gt;/dev/null 2&gt;&amp;1 pip3 install datetime &gt;/dev/null 2&gt;&amp;1 pip3 install timeit &gt;/dev/null 2&gt;&amp;1 pip3 install docker-compose &gt;/dev/null 2&gt;&amp;1 pip3 install chardet &gt;/dev/null 2&gt;&amp;1 pip3 install supervisor &gt;/dev/null 2&gt;&amp;1 pip3 install python-dateutil &gt;/dev/null 2&gt;&amp;1 pip3 install requests &gt;/dev/null 2&gt;&amp;1 } # Java 配置 install_java() { echo -e \"开始配置Java环境\" if command -v java &gt;/dev/null 2&gt;&amp;1 then # 已经配置，不做操作 echo -e \"Java环境已经配置，即将跳过\" test else echo -e \"手动配置Java环境\" if [ ! -e \"jdk-11_linux-x64_bin.tar.gz\" ] then wget https://repo.huaweicloud.com/java/jdk/11+28/jdk-11_linux-x64_bin.tar.gz fi tar -xzvf jdk-11_linux-x64_bin.tar.gz -C /opt &gt;/dev/null 2&gt;&amp;1 echo \"export JAVA_HOME=/opt/jdk-11\" &gt;&gt; /etc/zsh/zprofile echo \"export PATH=${JAVA_HOME}/bin:$PATH\" &gt;&gt; /etc/zsh/zprofile source /etc/zsh/zprofile echo -e \"Java环境配置完成\" fi } # 系统配置 base_config() { echo -e \"apt install ag ...\" apt install -y silversearcher-ag &gt;/dev/null 2&gt;&amp;1 echo -e \"apt install zh-hans 语言库\" apt install -y language-pack-zh-hans &gt;/dev/null 2&gt;&amp;1 sudo apt-get install fonts-droid-fallback ttf-wqy-zenhei ttf-wqy-microhei fonts-arphic-ukai fonts-arphic-uming &gt;/dev/null 2&gt;&amp;1 ulimit -n 10240 echo -e \"开始配置随机SSH 端口\" SSH_PORT=$(cat /etc/ssh/sshd_config | ag -o '(?&lt;=Port )\\d+') if [ $SSH_PORT -eq 22 ] then SSH_NEW_PORT=$(shuf -i 10000-30000 -n1) echo -e \"SSHD Port: ${SSH_NEW_PORT}\" | tee -a ssh_port.txt sed -E -i \"s/(Port|#\\sPort|#Port)\\s.{1,5}$/Port ${SSH_NEW_PORT}/g\" /etc/ssh/sshd_config fi # apt更新 echo -e \"apt update ...\" apt update &gt;/dev/null 2&gt;&amp;1 # 常用软件安装 cmdline=( \"which lsof\" \"which man\" \"which tmux\" \"which htop\" \"which autojump\" \"which iotop\" \"which ncdu\" \"which jq\" \"which telnet\" \"which p7zip\" \"which axel\" \"which rename\" \"which vim\" \"which sqlite3\" \"which lrzsz\" \"which git\" \"which curl\" \"which wget\" \"which bat\" \"which autojump\" ) for prog in \"${cmdline[@]}\"; do soft=$($prog) if [ \"$soft\" ] &gt;/dev/null 2&gt;&amp;1; then echo -e \"$soft 已安装！\" else name=$(echo -e \"$prog\" | ag -o '[\\w-]+$') apt install -y ${name} &gt;/dev/null 2&gt;&amp;1 echo -e \"${name} 安装中......\" fi done # git/vim/zsh/cur/wget配置 echo -e \"正在配置git\" config_git echo -e \"正在配置vim\" install_vim echo -e \"正在配置zsh\" cd $CUR_PATH config_zsh echo -e \"正在配置curl\" #curl https://raw.githubusercontent.com/al0ne/vim-for-server/master/.curlrc &gt;~/.curlrc &gt;/dev/null 2&gt;&amp;1 echo -e \"正在配置wget\" #curl https://raw.githubusercontent.com/al0ne/vim-for-server/master/.wgetrc &gt;~/.wgetrc &gt;/dev/null 2&gt;&amp;1 } # 开发环境配置 dev_config() { # 常见库配置 echo -e \"apt-get install -y libgeoip1\" apt-get install -y libgeoip1 &gt;/dev/null 2&gt;&amp;1 echo -e \"apt-get install -y libgeoip-dev\" apt-get install -y libgeoip-dev &gt;/dev/null 2&gt;&amp;1 echo -e \"apt-get install -y openssl\" apt-get install -y openssl &gt;/dev/null 2&gt;&amp;1 echo -e \"apt-get install -y libcurl3-dev\" apt-get install -y libcurl3-dev &gt;/dev/null 2&gt;&amp;1 echo -e \"apt-get install -y libssl-dev\" apt-get install -y libssl-dev &gt;/dev/null 2&gt;&amp;1 echo -e \"apt-get install -y php\" apt-get install -y php &gt;/dev/null 2&gt;&amp;1 echo -e \"apt-get install -y net-tools\" apt-get install -y net-tools &gt;/dev/null 2&gt;&amp;1 echo -e \"apt-get install -y ifupdown\" apt-get install -y ifupdown &gt;/dev/null 2&gt;&amp;1 echo -e \"apt-get install -y tree\" apt-get install -y tree &gt;/dev/null 2&gt;&amp;1 echo -e \"apt-get install -y cloc\" apt-get install -y cloc &gt;/dev/null 2&gt;&amp;1 echo -e \"apt-get install -y python3-pip\" apt-get install -y python3-pip &gt;/dev/null 2&gt;&amp;1 echo -e \"apt-get install -y gcc\" apt-get install -y gcc &gt;/dev/null 2&gt;&amp;1 echo -e \"apt-get install -y gdb\" apt-get install -y gdb &gt;/dev/null 2&gt;&amp;1 echo -e \"apt-get install -y g++\" apt-get install -y g++ &gt;/dev/null 2&gt;&amp;1 echo -e \"apt-get install -y locate\" apt-get install -y locate &gt;/dev/null 2&gt;&amp;1 echo -e \"apt-get install -y shellcheck\" apt-get install -y shellcheck &gt;/dev/null 2&gt;&amp;1 echo -e \"apt-get install -y redis-cli\" apt-get install -y redis-cli &gt;/dev/null 2&gt;&amp;1 echo -e \"apt-get install -y redis-server\" apt-get install -y redis-server &gt;/dev/null 2&gt;&amp;1 install_java install_python3 if command -v docker &gt;/dev/null 2&gt;&amp;1 then echo \"检测到已经安装docker 将跳过Docker的安装\" else echo -e \"开始安装Docker\" curl -fsSL https://get.docker.com -o get-docker.sh fi # Go 安装和配置 if command -v go &gt;/dev/null 2&gt;&amp;1 then echo -e \"检测到已经安装Go 将跳过Go的安装\" else echo -e \"开始安装Go\" sh -c \"$(wget -O- https://raw.githubusercontent.com/canha/golang-tools-install-script/master/goinstall.sh)\" fi # Nodejs 配置 if command -v node &gt;/dev/null 2&gt;&amp;1; then echo -e \"检测到已安装Nodejs 将跳过！\" else echo -e \"开始安装Nodejs\" curl -fsSL https://deb.nodesource.com/setup_10.x -o nodesource_setup.sh apt install -y nodejs &gt;/dev/null 2&gt;&amp;1 fi # TODO Redis、MySQL } # 网安配置 hacker_config() { echo -e \"正在安装 nmap ...\" apt install -y nmap &gt;/dev/null 2&gt;&amp;1 echo -e \"正在安装 netcat ...\" apt install -y netcat &gt;/dev/null 2&gt;&amp;1 echo -e \"正在安装 masscan ...\" apt install -y masscan &gt;/dev/null 2&gt;&amp;1 echo -e \"正在安装 zmap ...\" apt install -y zmap &gt;/dev/null 2&gt;&amp;1 echo -e \"正在安装 dnsutils ...\" apt install -y dnsutils &gt;/dev/null 2&gt;&amp;1 echo -e \"正在安装 wfuzz ...\" pip install wfuzz &gt;/dev/null 2&gt;&amp;1 # 安装 weevely3 if [ -d \"/opt/weevely3\" ]; then echo -e \"检测到weevely3已安装将跳过\" else echo -e \"正在克隆 weevely3 ...\" cd /opt &amp;&amp; git clone https://github.com/epinna/weevely3.git &gt;/dev/null 2&gt;&amp;1 echo 'alias weevely=/opt/weevely3/weevely.py' &gt;&gt;~/.zshrc fi # 安装 whatweb if [ -d \"/opt/whatweb\" ]; then echo -e \"检测到whatweb已安装将跳过\" else echo -e \"正在克隆 whatweb ...\" cd /opt &amp;&amp; git clone https://github.com/urbanadventurer/WhatWeb.git &gt;/dev/null 2&gt;&amp;1 echo 'alias whatweb=/opt/WhatWeb/whatweb' &gt;&gt;~/.zshrc fi # 安装 OneForAll if [ -d \"/opt/OneForAll\" ]; then echo -e \"检测到OneForAll已安装将跳过\" else echo -e \"正在克隆 OneForAll ...\" cd /opt &amp;&amp; git clone https://github.com/shmilylty/OneForAll.git &gt;/dev/null 2&gt;&amp;1 fi # 安装 dirsearch if [ -d \"/opt/dirsearch\" ]; then echo -e \"检测到dirsearch已安装将跳过\" else echo -e \"正在克隆 dirsearch ...\" cd /opt &amp;&amp; git clone https://github.com/shmilylty/OneForAll.git &gt;/dev/null 2&gt;&amp;1 fi # 安装 httpx if command -v httpx &gt;/dev/null 2&gt;&amp;1; then echo -e \"检测到已安装httpx 将跳过！\" else echo -e \"开始安装Httpx\" GO111MODULE=on go get -u -v github.com/projectdiscovery/httpx/cmd/httpx &gt;/dev/null 2&gt;&amp;1 fi # 安装 subfinder if command -v subfinder &gt;/dev/null 2&gt;&amp;1; then echo -e \"检测到已安装subfinder 将跳过！\" else echo -e \"开始安装subfinder\" GO111MODULE=on go get -u -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder &gt;/dev/null 2&gt;&amp;1 fi # 安装 nuclei if command -v nuclei &gt;/dev/null 2&gt;&amp;1; then echo -e \"检测到已安装nuclei 将跳过！\" else echo -e \"开始安装nuclei\" GO111MODULE=on go get -u -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei &gt;/dev/null 2&gt;&amp;1 fi # 安装 naabu if command -v naabu &gt;/dev/null 2&gt;&amp;1; then echo -e \"检测到已安装 naabu 将跳过！\" else echo -e \"开始安装 naabu\" GO111MODULE=on go get -u -v github.com/projectdiscovery/naabu/v2/cmd/naabu &gt;/dev/null 2&gt;&amp;1 fi # 安装 dnsx if command -v dnsx &gt;/dev/null 2&gt;&amp;1; then echo -e \"检测到已安装 dnsx 将跳过！\" else echo -e \"开始安装 dnsx\" GO111MODULE=on go get -u -v github.com/projectdiscovery/dnsx/cmd/dnsx &gt;/dev/null 2&gt;&amp;1 fi # 安装 subjack if command -v subjack &gt;/dev/null 2&gt;&amp;1; then echo -e \"检测到已安装 subjack 将跳过！\" else echo -e \"开始安装 subjack\" go get github.com/haccer/subjack &gt;/dev/null 2&gt;&amp;1 fi # 安装 ffuf if command -v ffuf &gt;/dev/null 2&gt;&amp;1; then echo -e \"检测到已安装 ffuf 将跳过！\" else echo -e \"开始安装 ffuf\" go get -u github.com/ffuf/ffuf &gt;/dev/null 2&gt;&amp;1 fi } CUR_USER=$(whoami) if [ $CUR_USER != 'root' ] then echo \"请切换到root用户再执行该脚本\" fi if [ $LEVEL = 'base' ] then base_config chsh -s /bin/zsh fi if [ $LEVEL = 'dev' ] then base_config dev_config chsh -s /bin/zsh fi if [ $LEVEL = 'hacker' ] then hacker_config fi if [ $LEVEL = 'full' ] then base_config dev_config hacker_config chsh -s /bin/zsh fi echo -e \"环境全部配置完成，开始玩儿吧\" TODO [ ] zsh 一直没有成功配置 [x] vim [x] git [x] Java [ ] MySQL [x] Redis [ ] Kafka 开发中的遇到的问题$@和$*在没有双引号括起来的时候行为是一样的，而当使用双引号括起来的时候是不一样的。 空值问题：shell中可能经常能看到：&gt;/dev/null 2&gt;&amp;1 命令的结果可以通过%&gt;的形式来定义输出 分解这个组合：“&gt;/dev/null 2&gt;&amp;1” 为五部分。 1：&gt; 代表重定向到哪里，例如：echo \"123\" &gt; /home/123.txt 2：/dev/null 代表空设备文件 3：2&gt; 表示stderr标准错误 4：&amp; 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1 5：1 表示stdout标准输出，系统默认值是1，所以\"&gt;/dev/null\"等同于 \"1&gt;/dev/null\" 因此，&gt;/dev/null 2&gt;&amp;1 也可以写成“1&gt; /dev/null 2&gt; &amp;1” 那么本文标题的语句执行过程为： 1&gt;/dev/null ：首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。 2&gt;&amp;1 ：接着，标准错误输出重定向 到 标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。 tee 从标准输入读取数据并重定向到标准输出和文件。 tee -a ssh_port.txt shuf 产生随机的排列。 # 随机输出10000~30000内的一个数字 shuf -i 10000-30000 -n 1 判断文件是否存在if [ -d \"/filenam\" ] then 自己逻辑 if references Unix Shell编程（第三版） Bash 脚本教程 Think You Understand Wildcards? Think Again Advanced Wildcard Patterns Most People Don’t Know Shell变量的作用域：Shell全局变量、环境变量和局部变量","categories":[{"name":"shell","slug":"shell","permalink":"https://winniekun.github.io/categories/shell/"}],"tags":[{"name":"效率工具","slug":"效率工具","permalink":"https://winniekun.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"}]},{"title":"程序员进阶攻略","slug":"碎碎念/better-programmer","date":"2021-11-02T14:00:17.000Z","updated":"2021-11-02T14:02:18.425Z","comments":true,"path":"better-programmer/","link":"","permalink":"https://winniekun.github.io/better-programmer/","excerpt":"","text":"程序员进阶攻略01 初心：为什么成为一名程序员？在走上程序的道路前，你不妨先问问自己成为程序员的初心是什么。回首往昔，我似乎是阴差阳错地走上了这条路，正因初心未明，所以早期的路上就多了很多迟疑和曲折。 人生路漫漫，在专栏的第一个模块里，我会和你讲讲自己走上程序道路的故事，希望这些故事能够给迷茫或者奋进中的你以启发。在人生的不同阶段里，我都喜欢做“复盘”，一方面审视过去的自己，另外一方面思索未来的方向。现在看来，这些有节奏的复盘也给我自己留下了深深的印记，也让我在某些关键节点的决策更加坚决。 首次接触说起我和程序的渊源，大概可以回溯到二十多年前。 那时，我还在读初中二年级，那是四川一所少数民族中学，硬件条件不是太好。那是 1995 年，国际友人赞助赠送了学校几台苹果 II 代电脑。作为学校成绩名列前茅的学生，在比较重视分数排名的背景下我还算有点 “小特权”。这点“小特权”就是可以接触这批电脑，所以在那时我为了搞懂怎么 “玩” 这些电脑去学了下 BASIC 语言，然后在上面编程并在单调的绿色屏幕上画出了一些几何图形。 当时还挺有成就感的，一度畅想将来要考清华的计算机专业。可能，那时觉得清华就是最好的学校，而计算机和编程是当时的最爱。然而，实际情况是上了高中以后学习压力大增，再也没时间去 “玩” 这些电脑了，光应对考试已然应接不暇，渐渐就忘了初中那时的想法。 现在回想起来第一次接触程序的时候，感觉它们还算是好 “玩” 的，有一种智力上的挑战，但当时也不太可能想到十年后我将会以此为生，走上程序之路。 彼时，初心未有。 选择专业对我们 80 后这一代人，高考算是人生第一次重要的选择了吧。 我那时高考填志愿，都是在考试前进行。高中三年，我都再没接触过程序了，早已忘记当年的想法。高考前，当时觉得自己对物理最有兴趣就填报了南京大学的物理系，应该也考虑过清华什么的，但没什么信心。 关于兴趣有一个有趣的说法：“往往并不是有兴趣才能做好，而是做好了才有兴趣。”高中后可能觉得当时物理学得还不错，所以就有了兴趣，并在填报高考志愿时选择了物理专业。 后来高考的结果，一方面信心不是很足，另一方面单科数学发挥也失常。南大的物理系没能上成，落到了第二志愿东北大学，调剂成了机械工程专业。这是一个随机调剂的专业，着实让我无比苦闷，学了一年后，我非常清楚，我并不喜欢这个专业，也看不清未来的职业前景。 再回首时你总会发现，有些最重要的人生路径选择，就这么有点 “无厘头” 地完成了。在面临人生重要路径的选择时，当时只考虑了兴趣，如今看来也没那么靠谱。应该多听听众人的看法，参考前人的路径，最后再自己做出决定。人生路径还是需要自己来主动、有意识地掌舵的。 彼时，初心已有，但却是混乱的。 转换专业机械专业煎熬了两年，迎来了第二次选择专业的机会。 在我读完大二的时候，国家开始兴办软件学院，新开软件工程专业。我当时在机械专业也会学一门编程课：C 语言。那时对 C 语言比较感兴趣，而对专业课机械制图则完全无感，所以当机会出现时就义无反顾去转了专业。 新专业面向所有非计算机的工程专业招生，但有一个门槛是：高学费。当时，机械专业一年学费四千多点，而软件工程本科一年一万六，学费读一年就抵得上别人读四年了，这对一个工薪家庭的压力不算小。 总之，我就是这么阴差阳错地又绕到了计算机专业这条路上。作为一门新开专业，软件工程相对计算机专业更偏应用，对接企业用人需求。可见，当时（2002 年）整个 IT 行业已经面临人才缺乏的问题，国家之所以新开软件工程专业，恐怕也是经济规律在发挥作用，平衡供需两端。 于我而言，转换专业算是时代给予的机遇，我在懵懂中做出了一次正确的选择。当时并不明了，但如今回顾却是如此清晰：面对新开的软件工程专业，其实表明了一个信息，这个行业发展很快，前景很好。 人生路很长，走了一段，也需要时不时重新审视当前的路径是否适合，是否无意错过了前途更好的岔路口。 我如今会感到庆幸没有错过这个路口，当时的确是没想过从机械专业换到软件工程会有更好的发展前景，但就是这样，我绕绕弯弯、曲曲折折地入了行，成为了一名程序员。 彼时，初心虽已不乱，但依然未明。 转换行业人的一生面临很多重要选择，除了高考选专业，我想转行也是其中之一。 入行后，一路走来也碰到过很多从其他行业转行成为程序员的人。曾经在招聘面试时碰到过两个程序员，他们一个是毕业于中医药大学，在药房工作两年后转行并干了 3 年；另外一个主修环境工程专业，在该行业工作 9 年后才转行程序员，并在这行干了 5 年。 那时我就在想，为什么他们都要转行做一名程序员呢？也许，客观上来说，行业的景气度让程序员的薪酬水平水涨船高。需求的持续上涨，吸引着更多的人进入，这也是经济规律。但主观上来说，可能我们也没有想好为什么就要转行成为一名程序员。 我转换到软件工程专业，毕业后顺利进入程序这行。早期一开始就是为一些传统行业公司写企业应用程序，提供 IT 服务，完成一份合同。工作五年后，我才渐渐明白，同样写程序，但为不同的行业写的程序价值真是完全不同。因此，我选择了切换到电商互联网行业来写程序。 而这一次的选择我很确定的是，至少我模糊地看到了这条路的前景，并坚定地在众多选项中排除其他路径。转行，不同的跨度，代价或大或小。但不转变就没代价吗？不见得，因为有时不做选择的代价可能更大。 此时，初心才算渐渐明了。 心明行远在成长的路上，我先后经历了换专业、换城市、换行业。 去年底（2017）我适时地驻足回顾了一下从进入大学到如今这些年的学习、工作和成长经历。其中有一些重要的时间事件节点，我把它们连接起来，就成了我们大多数人的成长线。下图，是我过去 18 年的成长线： img 在这张图上，选专业、换专业、换城市、换行业，这几个重要的人生选择点，我都用红色字体标记了。把过往的 18 年浓缩到一张图上后，我就清晰地看出了趋势，在切换行业之前，初心未明，成长的路上起起伏伏，波动很大，也因为不成熟的选择带来过巨大的落差感。 在工作的前几年，图上也有一段快速的自然成长期。因为这时我们就像一张白纸，只要是在认真地做事儿，总是能成长。这段时期，心其实是乱的，但因为忙而充实，也获得了很多成长，但它的问题是：这样的自然成长期有多长取决于你所做事情的天花板，所以才有了后面的一次切换城市带来的落差。 切换了行业，一路走到现在，前路不尽，心已明，行将远。 为什么成为一名程序员，初心若何？有人有天赋，有人凭兴趣，有人看前景。也许，你上路之初还未曾明了，但在路上不时叩问内心，找到初心，会走得更坚定，更长远。 闭上眼睛，你可以试着问自己走上程序道路的初心是否已经明了呢？欢迎给我留言，我们一起分享和讨论。 02 初惑：技术方向的选择初入职场或还在校的同学想必都会有些共同的疑惑，比如：“到底我该选哪个技术方向？”“现在该学哪门语言？”“未来 Java 语言的发展趋势如何？”这些问题的本质其实都是技术的投资决策问题，也即现在我该把时间精力花在哪个方向上，未来的收益才可能最大。 这个问题并不好回答，因为这个问题的本质和 “我现在应该投资哪只股票” 一样。没有人能回答好这个问题，我觉得最好的做法就是：从投资的出发点而非终点来选择一条路径。 至于这样选择的路径是否能在未来获得很好的收益，这是没法预测的。但选择技术方向和选择股票不同的是，只要你在这条路径上持续努力、学习与进步，基本可以保证能和 “大盘” 持平而不至于有亏损，但是否能取得超过 “大盘” 的收益，其实是看运气的。 选择语言选择技术方向，从某种意义上讲就是选择语言。 虽然有一些流传的说法，类似于：“语言并不重要，必要的时候可以在各种语言间自由切换。”但实际情况是，能做到自由切换的前提是你得对一门语言掌握到通透之后，再学习其他语言才可能触类旁通。 计算机程序语言虽然很多，但种类其实有限。2018 TIOBE 程序语言排行榜（见下图）上的前三位（Java、C、C++），本质上其实是一类语言。但大部分人只能选择去熟悉并通透其中一种，因为这些语言背后都有庞大的生态圈。 img 2018 TIOBE 程序语言排行榜 要做到通透，只熟悉语言本身是远远不够的，其实是要熟悉整个生态圈。而三门语言中最年轻的 Java 都有二十多年历史了，足够你耗费数年时光去熟悉其整个生态圈，而且目前其生态圈还处在不断扩张的状态，展现出一种蓬勃的生命力。 那么，要是我来选，我会如何选择语言呢？我会选择那些展现出蓬勃生命力的语言。 但其实十多年前我只是凑巧选择了 Java，它就像是被潮水推到我脚边的漂流瓶，顺手捡了起来。没想到居然蓬勃地发展了十多年，还没见衰退迹象。 那时的 Java 刚诞生不过七八年，和今天的 Go 语言很像。Go 语言在排行榜上的位置蹿升得很快，而且在云计算时代的基础设施上大放异彩，号称是：易用性要超越 PHP，而性能要超越 Java。 那么在 Java 之前我学的是什么？是 Visual Basic、ASP 和 Delphi / Object Pascal。我想今天不少年轻的程序员都未必听过这些语言了。但神奇的是，在 TIOBE 的排行榜上，VB 加了个 .NET 排名竟在世界最广泛的 Web 语言 PHP 和 JavaScript 之上。而十五年前我用的 Delphi / Object Pascal 居然落后 JavaScript 也不远，且远高于 Go、Objective-C，力压 Swift。 这些老牌语言还值得学吗？当然不值得了。因为它们早已进入暮年，没了蓬勃的生命力。但为什么排名还这么高？也许是因为它们也曾有过蓬勃生命力的热血青春，留下了大量的软件系统和程序遗产，至今还没能退出历史的舞台吧。 美国作家纳西姆·塔勒布（《黑天鹅》《反脆弱》等书作者）曾说： 信息或者想法的预期寿命，和它的现有寿命成正比。 而编程语言以及由它编写的所有软件系统和程序，本质就是信息了。换句话说就是，如果你想预测一门语言还会存在多久，就看看它已经存在了多久。存活时间足够长的语言，可以预期，它未来也还可能存活这么长时间。当然这一论断并不绝对，但它更多想说明越是新的语言或技术，升级换代越快，也越容易被取代。 这一点在 Delphi 这门语言上已经得到了体现，进入二十一世纪后，这种编写 C/S 架构软件的语言，居然还存活了这么久。 选择回报选择技术方向，选择语言，本质都是一种投资。 我们为此感到焦虑的原因在于，技术变化那么快，就怕自己选了一个方向，投了几年的时间、精力，最后却被技术迭代的浪潮拍在了沙滩上。 按上面塔勒布的说法，越年轻的语言和方向，风险越高。一个今年刚出现的新方向、新语言，你怎么知道它能在明年幸存下来？所以，考虑确定性的回报和更低的风险，你应该选择有一定历史的方向或语言，也许不能带来超额的回报，但最起码能带来稳定的回报，让你先在这个行业里立稳脚跟。在此基础上，再去关注新潮流、新方向或新技术，观察它们的可持续性。 有一句投资箴言：“高风险未必带来高回报。”在选择职业方向的路上，你甚至没法像分散投资一样来控制风险，所以选择确定性的回报，要比抱着赌一把的心态更可取。看看当前的市场需求是什么，最需要什么，以及长期需要什么。 比如，今天技术的热潮在人工智能、机器学习、区块链等上面，这是市场最需要的，而市场给的价格也是最高的。所以，你应该投入这里么？先别头脑发热，看看自己的基础，能否翻越门槛，及时上得了车吗？ 世纪之初，互联网时代的到临，网络的爆发，你会写个 HTML 就能月薪上万。上万，似乎不多，但那时北京房价均价也才 5000 多啊。2010 年左右，移动互联网兴起，一年移动开发经验者的平均待遇达到了五到十年 Java 开发的水平。如今，你只会 HTML 基本找不到工作，你有五年移动开发经验和有五年 Java 开发经验的同学，薪资待遇也变得相差不多了。 关于技术，有一句流行的话：“技术总是短期被高估，但长期被低估。”今天，在人工智能领域获得超额回报的顶级专家，实际数十年前在其被低估时就进入了这个领域，数十年的持续投入，才在如今迎来了人工智能的 “牛市” ，有了所谓的超额回报。所以，不妨投入到一些可能在长期被低估的基础技术上，而不是被技术潮流的短期波动所左右。 技术的选择，都是赚取长期回报，短期的波动放在长期来看终将被抵消掉，成为时代的一朵小浪花。 选择行业搞清楚了语言、技术方向和回报的关系后，最后做出选择的立足点通常会落在行业上。 当你问别人该选什么语言时，有人会告诉你，你应该学习 JavaScript，因为这是互联网 Web 时代的通用语言，到了移动互联网时代依然通用，而且现阶段生命力旺盛得就像再年轻十岁的 Java。也有人告诉你也许从 Python 开始更合适，语法简单，上手容易。还有人告诉你，现在学 Java 找工作最容易，平均工资也蛮高。这各种各样的说法充斥在你的耳边，让你犹豫不决，左右为难。 一个问题就像一把锁，开锁的钥匙肯定不会在锁上。否则这个问题也就不是问题了，太容易就解开了，不是吗？所以，选择什么语言通常不在于语言本身的特性。 选语言，就是选职业，而选职业首先选行业。 先想想自己想从事哪个行业的软件开发；然后，再看看：这个行业的现状如何？行业的平均增速如何？和其他行业相比如何？这个行业里最好的公司相比行业平均增速又如何？最后，再看看这些最好的公司都用些什么样的技术栈和语言。如果你想进入这样的公司，那就很简单了，就选择学这样的技术和语言。 这样选择是不是太功利了？选择不是应该看兴趣么？注意，这里选择的前提可不是发展什么业余爱好，而是为了获得安身立命的本领，获得竞争的相对优势。而兴趣，就是这件事里有些吸引你的东西，让你觉这是 “很好玩” 的事。但有个通常的说法是：“一旦把兴趣变成了职业也就失去了兴趣。”因为，职业里面还有很多 “不好玩” 的事。 兴趣能轻松驱动你做到前 50%，但按二八原则，要进入前 20% 的高手领域，仅仅靠兴趣就不够了。兴趣给你的奖励是 “好玩”，但继续往前走就会遇到很多 “不好玩” 的事，这是一种前进的障碍，这时功利，也算是给予你越过障碍所经历痛苦的补偿吧。 以上，就是我关于技术方向选择的一些原则与方法。无论你当初是如何选择走上技术道路的，都可以再想想你为什么要选择学习一门编程语言，学习编程的一部分是学习语言的语法结构，但更大的一部分，同时也是耗时更久且更让你头痛的部分：学习如何像一个工程师一样解决问题。 有时这样的选择确实很难，因为我们缺乏足够的信息来做出最优选择。赫伯特·西蒙说：“当你无法获得决策所需的所有信息时，不要追求最优决策，而要追求满意决策。”定下自己的满意标准，找到一个符合满意标准的折中方案，就开始行动吧。 而停留在原地纠结，什么也不会改变。 03 初程：带上一份技能地图程序世界是一片广阔的大地，相比我十多年前进入这个世界时，这片大地的边界又扩大了很多倍。初入程序世界难免迷茫，要在这个世界立足、生存，并得到很好的发展，应首要具备怎样的技能呢？未来的程序之路，先给自己准备一份基本的技能地图，先有图，再上路。 在程序的技能地图中，需要先开启和点亮哪些部分呢？回顾我过去的经历并结合现实的需要，可以从如下两个不同程度的维度来说明： 掌握 了解 掌握，意味着是一开始就要求熟练掌握的硬技能，这是生存之本。而至于掌握的深度，是动态的，倒是可以在行进过程中不断去迭代加深。了解，相对掌握不是必需，但也需要达到知其然的程度，甚至知其所以然更好。 一、掌握上路之初，需要掌握的核心生存技能有哪些呢？ 1. 开发平台开发平台，它包括一种编程语言、附带的平台生态及相关的技术。在如今这个专业化分工越来越细的时代，开发平台决定了你会成为什么类型和方向的程序员。比如：服务端、客户端或前端开发等。其中进一步细分客户端还可以有 Windows、Mac、iOS 和 Android 等不同的平台。 编程语言 语言的选择基本决定了开发平台的性质，但有些语言可能例外，如：C++、JS、C# 等，这些语言都可以跨多个平台。但即使你选的是这些语言，基本也会归属到某一类平台上。好比你选了 C++，如果你去做了客户端开发，就很少可能再去用 C++ 写服务端程序了。 关于语言的选择，前面我已经写过了选择的逻辑，便不再多说。但选择了语言，我们不仅仅是熟悉语言自身的特性，还需要掌握支撑语言的平台库。Java 若仅从语言特性上来说，有其优点，但其瑕疵和缺陷也一直被吐槽，要是没有 JDK 强大的平台库支撑，想必也不会有今天的繁荣。 平台生态 与语言平台关联的还有其技术生态以及各种技术框架的繁荣程度。这些平台技术生态的存在让使用这门语言编程完成特定的任务变得容易和简单得多。Java 的生命力除了 JDK 的强大支撑，实际还有其平台生态的繁荣，也起了决定性的作用。 在选择了开发平台后，除了语言和平台库之外，其生态体系内主流的技术框架和解决方案也是必选的掌握内容。 2. 常用算法在学校学习的算法，基本是解决各种计算机科学问题的通用方法。 还记得在学校时看过一本算法经典书《算法导论》。刚又把这本书的目录翻了出来过了一遍，发现已经忘记了百分之七、八十的内容。因为忘记的这部分内容，在过去的十多年工作中我基本都没机会用上。那么掌握算法的目的是为了什么呢？ 有时候你可能会觉得学校教科书上学习的经典算法，在实际工作中根本就用不上。我还记得考研的时候，专业考试课就是算法与数据结构，在考卷上随手写个排序、树遍历手到擒来。但到研究生毕业去参加腾讯校招面试时，让在白纸上手写一个快排算法，我被卡住了，自然也就没通过。因为好久已经没有进行这样的练习了，而在研究生阶段一年期的公司实习工作场景也没有这样的需求。 那么为什么还要学习这些经典算法？ 算法，表达的是一个计算的动态过程，它引入了一个度量标准：时空复杂度。当我回思时，发现这个度量标准思维在工作十余年中一直在发挥作用。如今，几乎所有的经典算法都能在开发平台库里找到实现，不会再需要自己从头写。但结合工作实际的业务场景，我们需要去设计更贴合需求的算法，而只要是算法它都受到时空复杂度的约束，而我们只是在其中进行平衡与折衷。 学校教科书的经典算法，是剥离了业务场景的高度抽象，当时学来有种不知道用在哪里的感觉；如今回头结合真实的业务场景需求再看，会有一种恍然大悟之感。 3. 数据结构数据结构通常都和算法一起出现，但算法表达的是动态特性，而数据结构表达的是一种静态的结构特性。大部分开发平台库都提供了最基础和常用的数据结构实现，这些都是我们需要熟悉并掌握的，包括： 数组 Array 链表 Linked List 队列 Queues 堆栈 Stacks 散列 Hashes 集合 Sets 另外，还有两种数据结构不属于基础结构，但在现实中有非常广泛的直接映射场景。 树 Trees 图 Graphs 每种结构都有各种变体，适用于不同的场景，甚至很多时候你还需要会组合不同的结构去解决一些更复杂的问题。 二、了解需要了解的内容比需要掌握的更广泛，但了解了这些方面会让你更高效地协作并解决问题。 1. 数据存储不管你写什么样的程序系统，估计都离不开数据存储。数据是一个业务系统的核心价值所在，所以怎么存储不同类型的生产数据，是你必须要了解的。如今广泛流行的数据存储系统有下面三类： SQL 关系型数据库（如：MySQL、Oracle） NoSQL 非关系型数据库（如：HBase、MongoDB） Cache 缓存（如：Redis、Memcached） 每一种数据存储系统都有其特定的特性和应用场景。作为程序员，我们通常的需求就是最有效地用好各类数据存储，那么按了解的深度需要依次知道如下几点： 如何用？在什么场景下，用什么数据存储的什么特性？ 它们是如何工作的？ 如何优化你的使用方式？ 它们的量化指标，并能够进行量化分析？ 这 4 点虽不要求一开始就能掌握到一定程度，但你最好一开始就有这个层次思维，在日后的工作中不断去迭代它的深度。 2. 测试方法为什么我们做开发还需要了解测试？ 测试思维是一种与开发完全不同的思维模式。有一种流行的开发方法论叫 “测试驱动开发（TDD）”，它的流行不是没有道理的。在写代码的时候，用测试的思维与方式（提供单元测试）去审视和检测代码，也就是说明确要开发某个功能后，先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。 开发与测试这两种相反视角的切入维度，能真正长期地提高你写代码的效率和水平。 3. 工程规范每一种开发平台和语言，估计都有其相应约定俗成的一些工程规范要求。最基础的工程规范是代码规范，包括两个方面： 代码结构 代码风格 像 Java 这么多年下来，逐渐形成了一种基于 Maven 的代码组织结构规范，这种约定俗成的代码结构规范省却了很多没必要的沟通。有时候，同样的内容，有更规范的结构，其可阅读性、理解性就能得到提升。 而至于代码风格，相对没那么标准化。但为了写出更清晰、易读的代码，我们至少要坚持自己写的代码具有某种一致性的风格。另外，除了风格问题，也可以借助静态代码检查工具来规避一些新手爱犯的低级错误，而老手也可以通过这些工具来找到自己的认知与习惯盲点。 4. 开发流程在开发流程方法论上，敏捷基本已经横扫天下，所以我们至少要了解下敏捷开发方法论。 虽然敏捷方法论定义了一些参考实践，但它依然是一组非常松散的概念。每个实践敏捷的开发团队，估计都会根据自己的理解和摸索建立一整套逐渐约定成型的开发流程规范。而为了和团队其他成员更好地协作，估计每个新加入团队的成员都需要了解团队演进形成的开发流程规范。 先了解，再优化。 5. 源码管理既然我们生产代码，自然也需要了解如何管理好代码。 在我的从业经历中，源码管理工具经历了从 CVS 到 SVN 再到 Git 的变迁。Git 诞生的背景是为 Linux 这样超大规模的开源项目准备的，自然决定了其能应对各种复杂场景的源码管理需求。所以，你至少要了解 Git，并用好它。 当工具变得越来越强大时，工具背后的思想其实更重要，对其的理解决定了我们应用工具的模式。而对源码进行管理的最基本诉求有以下三点： 并行：以支持多特性，多人的并行开发 协作：以协调多人对同一份代码的编写 版本：以支持不同历史的代码版本切换 最后，我把以上内容总结为如下一张图：红色区域相对更小而聚焦，是需要掌握的部分，要求深度；蓝色区域的部分更广而泛，需要广度。 img 程序员的基础技能图 以上就是我回顾走过的路径后，觉得需要具备的一份基础技能图。十多年后，这张图上的每一个分类都出现了新的技术迭代，有了新的框架、算法和产品等，但它们并不过时，依然可以为你的技能点亮之路提供方向指引。也许，你程序生涯的第一个一万小时你就会花在这张图上了。 04 初感：别了校园，入了江湖每年七月，盛夏，一种火辣兼有闷润的热，但在这份热辣中也有一丝略显冰凉的愁绪。一批刚毕业的学生，将要告别校园，进入职场：一个新的江湖。 一到毕业季，就会经常看到一些转发给新入行程序员的“老司机”指南，老实说，这些指南不少都是金玉良言。当年我毕业新入行时可不像现在有这么多发蒙解惑的“老司机”指南，所以坑都没少踩，若说有什么坑没掉进去，那一定都是因为运气。 当毕业生们看到前路如此多坑时，其实也不必有太大的心理压力，毕竟成长之路不可能是轻松的。我也是这样一路走过来的。所以，这篇就不写关于坑的指南了，而是分享一些我的故事和感悟，给刚踏上征程的你或你们吧。 重剑无锋作为一名新入职的程序员，首要之事就是配备一台电脑。 这个时代基本都是标配笔记本了，近年公司给配的电脑都很不错了，程序员全是高配大屏的 Macbook Pro 了。遥想我第一份工作，领到的是一个二手华硕笔记本，应该是上一个离职的前辈用了好几年的，这也是我的第一个笔记本电脑。 程序员就应该配笔记本电脑，为什么必须是笔记本电脑？不可以是台式机吗？笔记本电脑之于程序员，就像剑之于剑客。剑客的剑是不应该离开身边的，稍有风吹草动，听风辨器，拔剑出鞘（程序员一声不发就掏出笔记本开始写代码）。 当招程序员时，若来者不问公司配备什么笔记本，一般也就属于大多数的普通程序员啦，不太可能是那种 “不滞于物，草木竹石均可为剑” 的独孤求败级高手。 但也会有少数人问公司配什么笔记本电脑的，当对公司提供的笔记本感觉不满意时，就会要求是否可以自备笔记本电脑，而由公司给予补贴。 后一类同学，对环境、工具和效率是敏感的，我觉着就会比前面那类要强，当然我没有具体统计数据，也是纯凭感觉。 我毕业那年，腾讯来学校招聘，本科年薪六万，硕士八万，博士十万，都是税前。那时我心中最好的笔记本应该还是 IBM 的 ThinkPad T 系列，最差也得 10000+ 起的价格吧。但现在年薪十万在一线的北上广深算相当普遍了吧？而笔记本还是一万，所以能买到很不错的笔记本已经不是什么难事了。若现在的公司再在程序员的 “剑” 上琢磨省钱那绝对是得不偿失了。 我的第一个二手华硕笔记本相比现在的超薄轻快的笔记本，那绝对算是相反的厚重慢了。所以我把它称为 “重剑”，和独孤前辈不同的是，他老人家是先用轻剑，再用重剑，而我是先用重剑，然后越用越轻了。 但只是一年后我换了公司，这把 “重剑” 就还了回去。到了第二家公司，入职后才发现公司不配笔记本电脑，全是台式机。你看，当年我就是那种没问公司配什么电脑的普通程序员，考虑那时确实台式机占据主流，并且笔记本还属于一般程序员至少要两三个月工资才能买得起一台趁手的奢侈品范畴，我也就忍了。 新入职没多久，熟悉了公司环境和老同事交接过来的一个旧系统，公司派我出差去客户现场开发调试。我满心以为出差至少得配个笔记本吧，但组长过来说我们这边出差都带台式机的。然后我看看组长一脸正气不带开玩笑的表情，再看看桌上台式机硕大的机箱和 17 寸的 CRT 显示器，瞠目结舌。 “显示器也要带去？” 我问。 “噢，显示器可以让公司 IT 部给你寄过去，但主机箱要自带，因为快递很容易弄坏。” 组长说。 “好吧…” 对话结束，我立马奔去广州太平洋电脑城，花了之前一年工作攒下来的一万块中的七千，买了一台只有 ThinkPad T 系价位零头的 R 系笔记本，之后这把 “剑” 陪伴了我五年。 初入职场的同学，既然选择了某个公司，最大的因素除了薪酬外，想必每个人都还有这样或那样的在意点。当年我最不满意的就是笔记本这个问题，但从工作第二年开始我一直都是自备笔记本工作，持续多年，没花多少钱，但少了很多折腾和不便。 再后来，我挣得稍微多了些，就又自己换了大内存加固态硬盘（SSD）的 Mac。刚换上 Mac 就惊喜地发现，以前一个 Java 工程编译打包下要 50 多秒，在 Mac 下只需要 20 秒了。考虑写程序的这么多年，每天我要执行多少次编译打包命令，虽然每次节省的时间不多，但总体来看它大大提高了我的效率。 为什么我要单独谈谈笔记本这件小事？因为这是我们程序员每天使用最多的工具，如果你不在乎你的工具，可能你也就不会在乎你的时间和效率。 野蛮生长现在的公司基本都会给新入职的同学配备一个老员工，俗称 “导师”。 导师制的主要目的是帮助新员工迅速熟悉公司环境和融入团队中。这个初衷自然是没问题的，只是因为导师制其实不算正式的规章制度，更多是一种文化上的强制介入，但很多时候又没有绑定任何利益机制，所以它的效果实际上和个体差异有很大关系。 我觉着新入行的同学，尽量不要去依赖此类导师制。我并不是否定这种机制，而是提醒你不要形成心理依赖，觉着面临问题时，总是有人可以询问和帮忙。职场的第一个台阶就是形成独立性：独立承担职责的能力。这和协作没有冲突，团队协作可以算是履行职责的一种途径和手段。 就以简单的问问题为例，如果只抱着获得答案搞定自己的事情为出发点，一次、两次也就罢了，长此以往是不可行的。因为通过你问出什么样的问题，就可以看出你对这个问题做出了怎样的探索与思考，以及让你困惑的矛盾点在哪里。有些人就喜欢不假思索地问些 Google 都能够轻易回答的问题，形成路径依赖，虽然最终搞定了问题，但换得的评价却不会高，特别要省之戒之。 当你能够问出 Google 都不容易回答的问题时，这可能才是你真正走上职业程序员的开端。 知乎上有个问题：“普通人到底跟职业运动员有多大差距？”里面有个回答，以篮球运动为例给出一个生动的评分体系。假如巅峰时的迈克尔·乔丹算满分 100，那么国内顶级的球员，巅峰时的易建联可能刚刚及格得分在 60～70 之间，而大部分业余选手基本就在 0.1～0.N 之间波动了。 幸运的是程序员这个职业不像运动员那么惨烈，借用上面的评分标准，假如把奠定计算机行业基础的那一批图灵奖得主级别的程序员定义在 90～100 分档，那么我们很多靠编码为生的程序员基本都在 1～10 分档间分布，而业余的只是写写 Demo 的程序员可能就是在 0.1～0.N 之间了。 所以，进入职场后，你需要先把得分从小数提高到整数，再持续努努力提升到两位数，搞不好就成了行业某个垂直细分领域小有名气的专家了。 都不需要及格的分数，程序员就能获得不错的成就感和回报。只需要是巅峰者的十分之一或二十分之一，基本就能超越身边绝大多数人了。望着遥远的巅峰不停地去靠近，翻越身前脚下的一座座小山包，然后不知不觉就超越了自己。 总之，应像野草一样野蛮而快速地生长起来。 青春有价青春，到底是无价，还是有价？ 电影《寒战》里面有个情节，劫匪劫持了一辆警方的冲锋车和五名警员，勒索赎金时让警方自己算一辆冲锋车及其装备外加五名警员的性命值多少钱。然后电影里一阵眼花缭乱的计算得出了最终价格，大约九千多万港币。 后来采访导演问是怎么个算法，导演如是说： 五个警员，若不在事件中死去，由现在到退休期间的十多二十年任职的每月薪酬、房屋及子女医疗津贴、加上假设退休前的职位升迁，香港市民平均年龄以男方 79 岁，女方 85.9 岁的生存上限而计算的长俸，并加上冲锋车流动武器库内的价值、冲锋车本身的车价及保险等最后算出来的总值。 按这么一算，其实一生值不了多少钱啊。 年轻时候嘴边爱唠叨一句话叫：青春无价。其实从我们挣到第一份工资开始，人生就是有价的了。而最黄金时段的青春就在毕业后的十年内，这是大部分人心理和心智走向成熟的阶段，但这十年的价值从市场价格衡量来看是十分有限的。 对于 2018 年的毕业生， BAT 三家给出的年薪大约二十万左右，换算到月上每月接近两万了。而另外很大一部分进不了 BAT 三家的毕业生可能平均拿不到那么高，但估计在一线城市一万是差不多的。这样一算，未来十年你觉得能挣多少钱？ 喜欢从静止的视角看问题的人一算大概一年十来万，十年也就一百多万，这个收入相对目前一线城市的房价，还能安居乐业吗？ 另外思考一个问题：你能在十年后做到相比刚毕业时稳定收入增长十倍吗？也就是说现在月薪一万的人，十年后能月入十万吗？难，非常难。不信我们下面仔细算算。 我们回到用动态的视角看前面那个问题，你持续学习，努力工作，年年涨薪 20%（注意我说的是年年，这很不容易，也许你会说跳一次槽就可能翻倍，但你能年年跳槽翻倍么），十年后你年的收入将是十年前的 6.2 倍，离十倍还有距离，但换算为年薪也有七八十万了。所以要想靠加薪加到月入十万真的是一件极难的事情，而且即使做到了也离我们心中的无价青春，还差很远吧？ 认清了这个现实，我们明白了这十年的青春是十分有价的。所以这时有人说了，要去创业，才有可能突破。前两年（2015）都在鼓励万众创业，但真实的现实是，你要给目前的万众创业者一个稳定的七八十万年薪，80%+ 的创业者表示就会放弃创业了，这数据是来自 TOMsInsight 深度观察文《互联网乱世之下，那些人才流动中的心酸和无奈》对 100 个创业者的抽样调查。 img TOMsInsight 创业者放弃公司的薪水额度抽样调查 那么持续努力的学习还有意义吗？我只是说你很难做到每年加薪 20%，但是却可以做到每年比去年的自己多增长 20% 的知识、见识和能力。而关于知识、见识和能力的积累与相应价值的变现，理论与现实的对比可能如下图，纵坐标：年薪（单位万），横坐标：工作年限。 img 年薪与工作年限概念图 现实不太可能因为你的能力每增长 20% 就会立刻体现在你的收入上。现实有两种可能：一种存在一个拐点让你的积累获得相应的价格体现，另一种也可能不存在这个拐点，停留在某个水平位。其中拐点就是我们现实中常说的机遇吧。 无论怎样，要想获得拐点出现的机遇，可能你也只能持续努力地积累下去。 关于人生的选择，从来都是 All In，可没有股票那种分批建仓的办法，写到这里想起了曾经在网上记录下来的几句话，现分享给你： 我不停的擦拭手中的利剑，不是因为我喜欢它，也不是因为它能带来安全，只是因为，每当下一次冲锋的号角响起时，我能够迅速拔出，纵横厮杀，直至战斗结束，不让自己倒下。 …… 生活在这样的时代，与其被迫上场，心怀恐惧，不如主动征伐，加入时代的滚滚大潮当中，去见识一下时代的风采，写下自己的故事。 这个江湖会有你的故事吗？ 在这里我分享了一些我刚入江湖的故事，那你有怎样的精彩故事呢？欢迎你留言，和我一起分享。 05 架构与实现：它们的连接与分界？把一种想法、一个需求变成代码，这叫 “实现”，而在此之前，技术上有一个过程称为设计，设计中有个特别的阶段叫 “架构”。 程序员成长的很长一段路上，一直是在 “实现”，当有一天，需要承担起 “架构” 的责任时，可能会有一点搞不清两者的差异与界线。 是什么架构是什么？众说纷纭。 架构（Architecture）一词最早源自建筑学术语，后来才被计算机科学领域借用。以下是其在维基百科（Wikipedia）中的定义： 架构是规划、设计和构建建筑及其物理结构的过程与产物。在计算机工程中，架构是描述功能、组织和计算机系统实现的一组规则与方法。 Architecture is both the process and the product of planning, designing, and constructing buildings and other physical structures. In computer engineering, “computer architecture” is a set of rules and methods that describe the functionality, organization, and implementation of computer systems. 在建筑学领域，有一组清晰的规则和方法来定义建筑架构。但可惜，到目前为止，在计算机软件工程领域并没有如此清晰的一组规则与方法来定义软件架构。 好在经过多年的实践，行业里逐渐形成了关于软件架构的共同认知：软件系统的结构与行为设计。而实现就是围绕这种已定义的宏观结构去开发程序的过程。 做什么架构做什么？很多人会感觉糊里糊涂的。 我刚获得“架构师”称号时，也并不很明确架构到底在做什么，交付的是什么。后来不断在工作中去反思、实践和迭代，我才慢慢搞清楚架构工作和实现工作的差异与分界线。 从定义上，你已知道架构是一种结构设计，但它同时可能存在于不同的维度和层次上： 高维度：指系统、子系统或服务之间的切分与交互结构。 中维度：指系统、服务内部模块的切分与交互结构。 低维度：指模块组成的代码结构、数据结构、库表结构等。 在不同规模的团队中，存在不同维度的架构师，但不论工作在哪个维度的架构师，他们工作的共同点包括下面 4 个方面： 确定边界：划定问题域、系统域的边界。 切分协作：切分系统和服务，目的是建立分工与协作，并行以获得效率。 连接交互：在切分的各部分之间建立连接交互的原则和机制。 组装整合：把切分的各部分按预期定义的规则和方法组装整合为一体，完成系统目标。 有时，你会认为架构师的职责是要交付 “一种架构”，而这“一种架构” 的载体通常又会以某种文档的形式体现。所以，很容易误解架构师的工作就是写文档。但实际上架构师的交付成果是一整套决策流，文档仅仅是交付载体，而且仅仅是过程交付产物，最终的技术决策流实际体现在线上系统的运行结构中。 而对于实现，你应该已经很清楚是在做什么了。但我在这里不妨更清晰地分解一下。实现的最终交付物是程序代码，但这个过程中会发生什么？一般会有下面 6 个方面的考虑：选型评估；程序设计；执行效率；稳定健壮；维护运维；集成部署。 下表为其对应的详细内容： img 我以交付一个功能需求为例，讲述下这个过程。 实现一个功能，可能全部自己徒手做，也可能选择一些合适的库或框架，再从中找到需要的 API。 确定了合适的选型后，需要从逻辑、控制与数据这三个方面进一步考虑程序设计： 逻辑，即功能的业务逻辑，反映了真实业务场景流程与分支，包含大量业务领域知识。 控制，即考虑业务逻辑的执行策略，哪些可以并行执行，哪些可以异步执行，哪些地方又必须同步等待结果并串行执行？ 数据，包括数据结构、数据状态变化和存取方式。 开始编码实现时，你进一步要考虑代码的执行效率，需要运行多长时间？要求的最大等待响应时间能否满足？并发吞吐能力如何？运行的稳定性和各种边界条件、异常处理是否考虑到了？上线后，出现 Bug，相关的监控、日志能否帮助快速定位？是否有动态线上配置和变更能力，可以快速修复一些问题？新上线版本时，你的程序是否考虑了兼容老版本的问题等？ 最后你开发的代码是以什么形态交付？如果是提供一个程序库，则需要考虑相关的依赖复杂度和使用便利性，以及未来的升级管理。如果是提供服务，就需要考虑服务调用的管理、服务使用的统计监控，以及相关的 SLA 服务保障承诺。 以上，就是我针对整个实现过程自己总结的一个思维框架。如果你每次写代码时，都能有一个完善的思维框架，应该就能写出更好的代码。这个思维框架是在过去多年的编程经验中逐步形成的，在过去每次写代码时如果漏掉了其中某个部分，后来都以某种线上 Bug 或问题的形式，让我付出了代价，做出了偿还。 “实现”作为一个过程，就是不断地在交付代码流。而完成的每一行代码，都包含了上面这些方面的考虑，而这些方面的所有判断也是一整套决策流，然后固化在了一块块的代码中。 因为实现是围绕架构来进行的，所以架构的决策流在先，一定程度上决定了实现决策流的方向与复杂度，而架构决策的失误，后续会成倍地放大实现的成本。 关注点架构与实现过程中，有很多很多的点值得关注，若要选择一个核心点，会是什么？ 架构的一个核心关注点，如果只能是一个点，我想有一个很适合的字可以表达： 熵。“熵”是一个物理学术语，在热力学中表达系统的混乱程度，最早是“信息论之父”克劳德·艾尔伍德·香农借用了这个词，并将其引入了信息科学领域，用以表达系统的混乱程度。 软件系统或架构，不像建筑物会因为时间的流逝而自然损耗腐坏，它只会因为变化而腐坏。一开始清晰整洁的架构与实现随着需求的变化而不断变得浑浊、混乱。这也就意味着系统的“熵”在不断增高。 这里我用一个图展示软件系统“熵”值的生命周期变化，如下： img 系统只要是活跃的，“熵”值就会在生命周期中不断波动。需求的增加和改变，就是在不断增加“熵”值（系统的混乱程度）。但软件系统的“熵”有个临界值，当达到并超过临界值后，软件系统的生命也基本到头了。这时，你可能将迫不得已采取一种行动：重写或对系统做架构升级。 如果你不关注、也不管理系统的“熵”值，它最终的发展趋势就如图中的蓝线，一直升高，达到临界点，届时你就不得不付出巨大的代价来进行系统架构升级。 而实现中重构与优化的动作则是在不断进行减“熵”，作出平衡，让系统的“熵”值在安全的范围内波动。 那么，关于实现的核心关注点，也就呼之欲出了，我们也可以用一个字表达：简。 简，是简单、简洁、简明、简化，都是在做减法，但不是简陋。关于实现的全部智慧都浓缩在了这一个字里，它不仅减少代码量，也减少了开发时间，减少了测试时间，减少了潜在 Bug 的数量，甚至减少了未来的维护、理解与沟通成本。 架构关注复杂度的变化，自然就会带来简化，而实现则应当顺着把“简”做到极致。 断裂带架构与实现之间，存在一条鸿沟，这是它们之间的断裂带。 断裂带出现在架构执行过程之中，落在文档上的架构决策实际上是静态的，但真正的架构执行过程却是动态的。架构师如何准确地传递架构决策？而开发实施的效果又如何能与架构决策保持一致？在这个过程中出现实施与决策的冲突，就又需要重新协调沟通讨论以取得新的一致。 当系统规模比较小时，有些架构师一个人就能把全部的设计决策在交付期限内开发完成，这就避免了很多沟通协调的问题。好些年前，我就曾这样做过一个小系统的架构升级改造，但后来的系统越来越大，慢慢就需要几十人的团队来分工协作。光是准确传递决策信息，并维持住大体的一致性，就是一件非常有挑战的工作了。 当系统规模足够大了，没有任何架构师能够把控住全部的细节。在实践中，我的做法是定期对系统的状态做快照，而非去把握每一次大大小小的变化，因为那样直接就会让我过载。在做快照的过程中我会发现很多的细节，也许和我当初想的完全不一样，会产生出一种“要是我来实现，绝对不会是这样”的感慨。 但在我发现和掌握的所有细节中，我需要做一个判断，哪些细节上的问题会是战略性的，而我有限的时间和注意力，必须放在这样的战略性细节上。而其他大量的实现细节也许和我想的不同，但只要没有越出顶层宏观结构定义的边界即可。系统是活的，控制演化的方向是可行的，而妄图掌控演化过程的每一步是不现实的。 关注与把控边界，这就比掌控整个领地的范围小了很多，再确认领地中的战略要地，那么掌控的能力也就有了支撑。架构与实现的鸿沟会始终存在，在这条鸿沟上选择合适的地方建设桥梁，建设桥梁的地方必是战略要地。 等效性架构升级中，经常被问到一个问题：“这个架构能实现么？” 其实，这根本不是一个值得疑惑的问题。相对于建筑架构，软件架构过程其实更像是城市的规划与演变过程。有一定历史的城市，慢慢都会演变出所谓的旧城和新城。而新城相对于旧城，就是一次架构升级的过程。 城市规划师会对城市的分区、功能划分进行重新定位与规划。一个旧城所拥有的所有功能，如：社区、学校、医院、商业中心，难道新城会没有，或者说 “实现” 不了吗？ 任何架构的可实现性，是完全等效的，但实现本身却不是等效的，对不同的人或不同的团队可实现性的可能、成本、效率是绝对不等效的。 近些年，微服务架构火了，很多人都在从曾经的单体应用架构升级到微服务架构。以前能实现的功能，换成微服务架构肯定也可以实现，只是编写代码的方式不同，信息交互的方式也不同。 架构升级，仅仅是一次系统的重新布局与规划，成本和效率的重新计算与设计，“熵”的重新分布与管理。 最后我归纳下：架构是关注系统结构与行为的决策流，而实现是围绕架构的程序开发过程；架构核心关注系统的“熵”，而实现则顺应“简”；架构注重把控系统的边界与 “要塞”，而实现则去建立 “领地”；所有架构的可实现性都是等效的，但实现的成本、效率绝不会相同。 文中提到，架构和实现之间有一条断裂带，而让架构与实现分道扬镳的原因有： 沟通问题：如信息传递障碍。 水平问题：如技术能力不足。 态度问题：如偷懒走捷径。 现实问题：如无法变更的截止日期（Deadline）。 06 模式与框架：它们的关系与误区？在学习程序设计的路上，你一定会碰到“设计模式”，它或者给你启发，或者让你疑惑，并且你还会发现在不同的阶段遇到它，感受是不同的。而“开发框架”呢？似乎已是现在写程序的必备品。那么框架和模式又有何不同？它们有什么关系？在程序设计中又各自扮演什么角色呢？ 设计模式设计模式，最早源自 GoF 那本已成经典的《设计模式：可复用面向对象软件的基础》一书。该书自诞生以来，在程序设计领域已被捧为“圣经”。 软件设计模式也是参考了建筑学领域的经验，早在建筑大师克里斯托弗·亚历山大（Christopher Alexander）的著作《建筑的永恒之道》中，已给出了关于“模式”的定义： 每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次地重用那些已有的成功的解决方案，无须再重复相同的工作。 而《设计模式》一书借鉴了建筑领域的定义和形式，原书中是这么说的： 本书中涉及的设计模式并不描述新的或未经证实的设计，我们只收录那些在不同系统中多次使用过的成功设计；尽管这些设计不包括新的思路，但我们用一种新的、便于理解的方式将其展现给读者。 虽然该书采用了清晰且分门别类的方式讲述各种设计模式，但我相信很多新入门的程序员在看完该书后还是会\b像我当年一样有困扰，无法真正理解也不知道这东西到底有啥用。 早年我刚开始学习 Java 和面向对象编程，并编写 JSP 程序。当我把一个 JSP 文件写到一万行代码时，自己终于受不了了，然后上网大量搜索到底怎样写 JSP 才是对的。之后，我就碰到了《设计模式》一书，读完了，感觉若有所悟，但再去写程序时，反而更加困扰了。 因为学 “设计模式” 之前，写程序是无所顾忌，属于拿剑就刺，虽无章法却还算迅捷。但学了一大堆 “招式” 后反而变得有点瞻前顾后，每次出剑都在考虑招式用对没，挥剑反倒滞涩不少。有人说：“设计模式，对于初窥门径的程序员，带来的麻烦简直不逊于它所解决的问题。”回顾往昔，我表示深有同感。 后来回想，那个阶段我把《设计模式》用成了一本 “菜谱” 配方书。现实是，没做过什么菜只是看菜谱，也只能是照猫画虎，缺少好厨师的那种能力——火候。初窥门径的程序员其实缺乏的就是这样的“火候”能力，所以在看《设计模式》时必然遭遇困惑。而这种“火候”能力则源自大量的编程设计实践，在具体的实践中抽象出模式的思维。 “设计模式” 是在描述一些抽象的概念，甚至还给它们起了一些专有名字，这又增加了一道弯儿、一层抽象。初窥门径的程序员，具体的实践太少，面临抽象的模式描述时难免困惑。但实践中，经验积累到一定程度的程序员，哪怕之前就没看过《设计模式》，他们却可能已经基于经验直觉地用起了某种模式。 前面我说过我刚学习编程时看过一遍《设计模式》，看完后反而带来更多的干扰，不过后来倒也慢慢就忘了。好些年后，我又重读了一遍，竟然豁然开朗起来，因为其中一些模式我已经在过往的编程中使用过很多次，另一些模式虽未碰到，但理解起来已不见困惑。到了这个阶段，其实我已经熟练掌握了从具体到抽象之间切换的思维模式，设计模式的 “招数” 看来就亲切了很多。 在我看来，模式是前人解决某类问题方式的总结，是一种解决问题域的优化路径。但引入模式也是有代价的。设计模式描述了抽象的概念，也就在代码层面引入了抽象，它会导致代码量和复杂度的增加。而衡量应用设计模式付出的代价和带来的益处是否值得，这也是程序员 “火候” 能力另一层面的体现。 有人说，设计模式是招数；也有人说，设计模式是内功。我想用一种大家耳熟能详的武功来类比：降龙十八掌。以其中一掌“飞龙在天”为例，看其描述： 气走督脉，行手阳明大肠经商阳…此式跃起凌空，居高下击，以一飞冲天之式上跃，双膝微曲，提气丹田，急发掌劲取敌首、肩、胸上三路。 以上，前半句是关于内功的抽象描述，后半部分是具体招数的描述，而设计模式的描述表达就与此有异曲同工之妙。所以，设计模式是内功和招数并重、相辅相成的 “武功”。 当你解决了一个前人从没有解决的问题，并把解决套路抽象成模式，你就创造了一招新的 “武功”，后来的追随者也许会给它起个新名字叫：某某模式。 开发框架不知从何时起，写程序就越来越离不开框架了。 记得我还在学校时，刚学习 Java 不久，那时 Java 的重点是 J2EE（现在叫 Java EE 了），而 J2EE 的核心是 EJB。当我终于用“JSP + EJB + WebLogic（EJB 容器）+ Oracle 数据库”搭起一个 Web 系统时，感觉终于掌握了 Java 的核心。 后来不久，我去到一家公司实习，去了以后发现那里的前辈们都在谈论什么 DI（依赖注入）和 IoC（控制反转）等新概念。他们正在把老一套的 OA 系统从基于 EJB 的架构升级到一套全新的框架上，而那套框架包含了一堆我完全没听过的新名词。 然后有前辈给我推荐了一本书叫 J2EE Development Without EJB，看完后让我十分沮丧，因为我刚刚掌握的 Java 核心技术 EJB 还没机会出手就已过时了。 从那时起，我开始知道了框架（Framework）这个词，然后学习了一整套的基于开源框架的程序开发方式，知道了为什么 EJB 是重量级的，而框架是轻量级的。当时 EJB 已步入暮年，而框架的春天才刚开始来临，彼时最有名的框架正好也叫 Spring。如今框架已经枝繁叶茂，遍地开花。 现在的编程活动中，已是大量应用框架，而框架就像是给程序员定制的开发脚手架。一个框架是一个可复用的设计组件，它统一定义了高层设计和接口，使得从框架构建应用程序变得非常容易。因此，框架可以算是打开“快速开发”与“代码复用”这两扇门的钥匙。 在如今这个框架遍地开花的时代，正因为框架过于好用、易于复用，所以也可能被过度利用。 在 Java 中，框架很多时候就是由一个或一些 jar 包组成的。早在前几年（2012 年的样子）接触到一个 Web 应用系统，当时我尝试去拷贝一份工程目录时，意外发现居然有接近 500M 大小，再去看依赖的 jar 包多达 117 个，着实吓了一跳。在 500M 工程目录拷贝进度条缓慢移动中，我在想：“如今的程序开发是不是患上了框架过度依赖症？” 我想那时应该没有人能解释清楚为什么这个系统需要依赖 117 个 jar 包之多，也许只是为了完成一个功能，引入了一个开源框架，而这个框架又依赖了其他 20 个 jar 包。 有时候，框架确实帮我们解决了大部分的脏活累活，如果运气好，这些框架的质量很高或系统的调用量不大，那么它们可能也就从来没引发过什么问题，我们也就不需要了解它们是怎么去解决那些脏活、累活的。但若不巧，哪天某个框架在某些情况下出现了问题，在搞不懂框架原理的情况下，就总会有人惊慌失措。 如今，框架带来的束缚在于，同一个问题，会有很多不同框架可供选择。如何了解、评估、选择与取舍框架，成了新的束缚。 一些知名框架都是从解决一个特定领域问题的微小代码集合开始发展到提供解决方案、绑定概念、限定编程模式，并尝试不断通用化来扩大适用范围。 这样的框架自然不断变得庞大、复杂、高抽象度。 我一直不太喜欢通用型的框架，因为通用则意味着至少要适用于大于两种或以上的场景，场景越多我们的选择和取舍成本越高。另外，通用意味着抽象度更高，而现实是越高的抽象度，越不容易被理解。例如，人生活在三维世界，理解三维空间是直观的，完全没有抽象，理解四维空间稍微困难点，那五维或以上理解起来就很困难了。 框架，既是钥匙，也是枷锁，既解放了我们，也束缚着我们。 两者关系分析了模式，解读了框架，那么框架和模式有什么关系呢？ 框架和模式的共同点在于，它们都提供了一种问题的重用解决方案。其中，框架是代码复用，模式是设计复用。 软件开发是一种知识与智力的活动，知识的积累很关键。框架采用了一种结构化的方式来对特定的编程领域进行了规范化，在框架中直接就会包含很多模式的应用、模式的设计概念、领域的优化实践等，都被固化在了框架之中。框架是程序代码，而模式是关于这些程序代码的知识。 比如像 Spring 这样的综合性框架的使用与最佳实践，就隐含了大量设计模式的套路，即使是不懂设计模式的初学者，也可以按照这些固定的编程框架写出符合规范模式的程序。但写出代码完成功能是一回事，理解真正的程序设计又是另外一回事了。 小时候，看过一部漫画叫《圣斗士》。程序员就像是圣斗士，框架是“圣衣”，模式是“流星拳“，但最重要的还是自身的“小宇宙”啊。 我相信在编程学习与实践的路上，你对设计模式与开发框架也有过自己的思考。欢迎给我留言，说说你有过怎样的认识变化和体会，我们一起讨论。 07 多维与视图：系统设计的思考维度与展现视图大学上机械设计课程时学习了 “三视图” 。三视图是观测者从三个不同位置观察同一个空间几何体所画出的图形，是正确反映物体长宽高尺寸正投影的工程图，在工程设计领域十分有用。三视图也是精确的，任何现实世界中的立体物都必然能被 “三视图” 投影到二维的平面，有了这张图就能准确制作出相应的机械零部件。 但在软件设计领域，则有较大的不同，软件系统是抽象的，而且维度更多。20 世纪 90 年代，软件行业诞生了 UML（Unified Modeling Language）： 统一建模语言，一种涵盖软件设计开发所有阶段的模型化与可视化支持的建模语言。 从 UML 的出现中就可以知道，软件先驱们一直在不懈地努力，使软件系统设计从不可直观感受触摸的抽象思维空间向现实空间进行投影。 UML 是一种类似于传统工程设计领域 “三视图” 的尝试，但却又远没有达到 “三视图” 的精准。虽然 UML 没能在工程实施领域内广泛流行起来，但其提供的建模思想给了我启发。让我一直在思考应该需要有哪些维度的视图，才能很好地表达一个软件系统的设计。 而在多年的工程实践中，我逐渐得到了一些维度的视图，下面就以我近些年一直在持续维护、设计、演进的系统（京东咚咚）为例来简单说明下。 一、组成视图组成视图，表达了系统由哪些子系统、服务、组件部分构成。 2015 年，我写过一篇关于咚咚的文章：《京东咚咚架构演进》。当时我们团队对系统进行了一次微服务化的架构升级，而微服务的第一步就是拆分服务，并表达清楚拆分后整个系统到底由哪些服务构成，所以有了下面这张系统服务组成图。 如下图示例，它对服务进行大类划分，图中用了不同的颜色来表达这种分类： img 组成视图示例 每一类服务提供逻辑概念上比较相关的功能，而每一个微服务又按照如下两大原则进行了更细的划分： 单一化：每个服务提供单一内聚的功能集。 正交化：任何一个功能仅由一个服务提供，无提供多个类似功能的服务。 如上，就是我们系统的服务组成视图，用于帮助团队理解整体系统的宏观组成，以及个人的具体工作内容在整个系统中的位置。 了解了服务的组成，进一步自然就需要了解服务之间的关系与交互。 二、交互视图交互视图，表达了系统或服务与外部系统或服务的协作关系，也即：依赖与被依赖。 由于咚咚系统的业务场景繁多，拆分出来的服务种类也比较多，交互关系复杂。所以可以像地图一样通过不同倍率的缩放视角来表达和观察服务之间的交互关系。 如下图，是一张宏观大倍率的整体交互视图示例。它隐藏了内部众多服务的交互细节，强调了终端和服务端，以及服务端内部交互的主要过程。这里依然以地图作类比，它体现了整体系统主干道场景的运动过程。而每一个服务本身，在整体的交互图中，都会有其位置，有些在主干道上，而有些则在支线上。 img 交互视图示例 如果我们把目光聚焦在一个服务上，以其为中心的表达方式，就体现了该服务的依赖协作关系。所以，可以从不同服务为中心点出发，得到关注点和细节更明确的局部交互细节图，而这样的细节图一般掌握在每个服务开发者的脑中。当我们需要写关于某个服务的设计文档时，这样的局部细节交互图也应该是必不可少的。 在逻辑的层面了解了服务间的协作与交互后，则需要更进一步了解这些服务的部署环境与物理结构。 三、部署视图部署视图，表达系统的部署结构与环境。 部署视图，从不同的人员角色出发，关注点其实不一样，不过从应用开发和架构的角度来看，会更关注应用服务实际部署的主机环境、网络结构和其他一些环境元素依赖。下面是一张强调服务部署的机房结构、网络和依赖元素的部署图示例。 img 部署视图示例 部署视图本身也可以从不同的视角来画，这取决于你想强调什么元素。上面这张示例图，强调的是应用部署的 IDC 及其之间的网络关系，和一些关键的网络通讯延时指标。因为这些内容可能影响系统的架构设计和开发实现方式。 至此，组成、交互和部署图更多是表达系统的宏观视图：关注系统组合、协作和依存的关系。但还缺乏关于系统设计或实现本身的表达，这就引出了流程和状态两类视图。 四、流程视图流程视图，表达系统内部实现的功能和控制逻辑流程。 可能有人喜欢用常见的流程图来表达系统设计与实现的流程，但我更偏好使用 UML 的序列图，个人感觉更清晰些。 下图是咚咚消息投递的一个功能逻辑流程表达，看起来就像是 UML 的序列图，但并没有完全遵循 UML 的图例语法（主要是我习惯的画图工具不支持）。而且，我想更多人即使是程序员也并不一定会清楚地了解和记得住 UML 的各种图例语法，所以都用文字做了补充说明，也就没必要一定要遵循其语法了，重点还是在于要把逻辑表达清楚。 img 流程视图示例 逻辑流程一般分两种：业务与控制。有些系统业务逻辑很复杂，而有些系统业务逻辑不复杂但请求并发很高，导致对性能、安全与稳定的要求高，所以控制逻辑就复杂了。这两类复杂的逻辑处理流程都需要表达清楚，而上图就是对业务功能逻辑的表达示例。 除了逻辑流程的复杂性，系统维持的状态变迁很可能也是另一个复杂性之源。 五、状态视图状态视图，表达系统内部管理了哪些状态以及状态的变迁转移路径。 像咚咚这样的 IM 消息系统，就自带一个复杂的状态管理场景：消息的已读 / 未读状态。它的复杂性体现在，它本身就处在一个不可控的分布式场景下，在用户的多个终端和服务端之间，需要保持尽可能的最终一致性。 为什么没法满足绝对严格的最终一致性？如下图所示，IM 的 “已读 / 未读” 状态需要在用户的多个终端和服务端之间进行分布式的同步。按照分布式 CAP 原理，IM 的业务场景限定了 AP 是必须满足的，所以 C 自然就是受限的了。 img 状态视图示例 所有的业务系统都一定会有状态，因为那就是业务的核心价值，并且这个系统只要有用户使用，用户就会产生行为，行为导致系统状态的变迁。比如，IM 中用户发出的消息，用户的上下线等等都是行为引发的状态变化。 但无状态服务相比有状态的服务和系统要简单很多，一个系统中不是所有的服务都有状态，只会有部分服务需要状态，我们的设计仅仅是围绕在，如何尽可能地把状态限制在系统的有限范围内，控制其复杂性的区域边界。 至此，关于软件系统设计，我感觉通用的维度与视图就这些，但每个具体的系统可能也还有其独特的维度，也会有自己独有的视图。 用更系统化的视图去观察和思考，想必也会让你得到更成体系化的系统设计。 以上就是我关于系统设计的一些通用维度与视图的思考，那么你平时都用怎样的方式来表达程序系统设计呢？ 08 代码与分类：工业级编程的代码分类与特征编程，就是写代码，那么在真实的行业项目中你编写的这些代码可以如何分类呢？回顾我曾经写过的各种系统代码，按代码的作用，大概都可以分为如下三类： 功能 控制 运维 如果你想提高编程水平，写出优雅的代码，那么就必须要清晰地认识清楚这三类代码。 一、功能功能代码，是实现需求的业务逻辑代码，反映真实业务场景，包含大量领域知识。 一个程序软件系统，拥有完备的功能性代码仅是基本要求。因为业务逻辑的复杂度决定了功能性代码的复杂度，所以要把功能代码写好，最难的不是编码本身，而是搞清楚功能背后的需求并得到正确的理解。之后的编码活动，就仅是一个“翻译”工作了：把需求“翻译”为代码。 当然，“翻译” 也有自己独有的技术和积累，并不简单。而且 “翻译” 的第一步要求是 “忠于原文”，也即真正地理解并满足用户的原始需求。可这个第一步的要求实现起来就很困难。 为什么搞清楚用户需求很困难？因为从用户心里想要的，到他最后得到的之间有一条长长的链条，如下所示： 用户心理诉求 -&gt; 用户表达需求 -&gt; 产品定义需求 -&gt; 开发实现 -&gt; 测试验证 -&gt; 上线发布 -&gt; 用户验收 需求信息源自用户的内心，然后通过表达显性地在这个链条上传递，最终固化成了代码，以程序系统的形态反馈给了用户。 但信息在这个链条中的每个环节都可能会出现偏差与丢失，即使最终整个链条上的各个角色都貌似达成了一致，完成了系统开发、测试和发布，但最终也可能发现用户的心理诉求要么表达错了，要么被理解错了。 因为我近些年一直在做即时通讯产品（IM），所以在这儿我就以微信这样一个国民级的大家都熟悉的即时通讯产品为样本，举个例子。 微信里有个功能叫：消息删除。你该如何理解这个功能背后的用户心理诉求呢？用户进行删除操作的期待和反馈又是什么呢？从用户发消息的角度，我理解其删除消息可能的诉求有如下几种： 消息发错了，不想对方收到。 消息发了后，不想留下发过的痕迹，但期望对方收到。 消息已发了，对于已经收到的用户就算了，未收到的最好就别收到了，控制其传播范围。 对于第一点，微信提供了两分钟内撤回的功能；而第二点，微信提供的删除功能正好满足；第三点，微信并没有满足。我觉着第三点其实是一个伪需求，它其实是第一点不能被满足情况下用户的一种妥协。 用户经常会把他们的需要，表达成对你的行为的要求，也就是说不真正告诉你要什么，而是告诉你要做什么。所以你才需要对被要求开发的功能进行更深入的思考。有时，即使是日常高频使用的产品背后的需求，你也未必能很好地理解清楚，而更多的业务系统其实离你的生活更远，努力去理解业务及其背后用户的真实需求，才是写好功能代码的基本能力。 程序存在的意义就在于实现功能，满足需求。而一直以来我们习惯于把完成客户需求作为程序开发的主要任务，当功能实现了便感觉已经完成了开发，但这仅仅是第一步。 二、控制控制代码，是控制业务功能逻辑代码执行的代码，即业务逻辑的执行策略。 编程领域熟悉的各类设计模式，都是在讲关于控制代码的逻辑。而如今，很多这些常用的设计模式基本都被各类开源框架固化了进去。比如，在 Java 中，Spring 框架提供的控制反转（IoC）、依赖注入（DI）就固化了工厂模式。 通用控制型代码由各种开源框架来提供，程序员就被解放出来专注写好功能业务逻辑。而现今分布式领域流行的微服务架构，各种架构模式和最佳实践也开始出现在各类开源组件中。比如微服务架构模式下关注的控制领域，包括：通信、负载、限流、隔离、熔断、异步、并行、重试、降级。 以上每个领域都有相应的开源组件代码解决方案，而进一步将控制和功能分离的 “服务网格（Service Mesh）” 架构模式则做到了极致，控制和功能代码甚至运行在了不同的进程中。 控制代码，都是与业务功能逻辑不直接相关的，但它们和程序运行的性能、稳定性、可用性直接相关。提供一项服务，功能代码满足了服务的功能需求，而控制代码则保障了服务的稳定可靠。 有了控制和功能代码，程序系统终于能正常且稳定可靠地运行了，但难保不出现异常，这时最后一类 “运维” 型代码便要登场了。 三、运维运维代码，就是方便程序检测、诊断和运行时处理的代码。它们的存在，才让系统具备了真正工业级的可运维性。 最常见的检测诊断性代码，应该就是日志了，打日志太过简单，因此我们通常也就疏于考虑。其实即使是打日志也需要有意识的设计，评估到底应该输出多少日志，在什么位置输出日志，以及输出什么级别的日志。 检测诊断代码有一个终极目标，就是让程序系统完成运行时的自检诊断。这是完美的理想状态，却很难在现实中完全做到。 因为它不仅仅受限于技术实现水平，也与实现的成本和效益比有关。所以，我们可以退而求其次，至少在系统异常时可以具备主动运行状态汇报能力，由开发和运维人员来完成诊断分析，这也是我们常见的各类系统或终端软件提供的机制。 在现实中，检测诊断类代码经常不是一开始就主动设计的。但生产环境上的程序系统可能会偶然出现异常或故障，而因为一开始缺乏检测诊断代码输出，所以很难找到真实的故障原因。现实就这样一步一步逼着你去找到真实原因，于是检测诊断代码就这么被一次又一次地追问为什么而逐渐完善起来了。 但如果一开始你就进行有意识地检测诊断设计，后面就会得到更优雅的实现。有一种编程模式：面向切面编程（AOP），通过早期的有意设计，可以把相当范围的检测诊断代码放入切面之中，和功能、控制代码分离，保持优雅的边界与距离。 而对于特定的编程语言平台，比如 Java 平台，有字节码增强相关的技术，可以完全干净地把这类检测诊断代码和功能、控制代码彻底分离。 运维类代码的另一种类，是方便在运行时，对系统行为进行改变的代码。通常这一类代码提供方便运维操作的 API 服务，甚至还会有专门针对运维提供的服务和应用，例如：备份与恢复数据、实时流量调度等。 功能、控制、运维，三类代码，在现实的开发场景中优先级这样依次排序。有时你可能仅仅完成了第一类功能代码就迫于各种压力上线发布了，但你要在内心谨记，少了后两类代码，将来都会是负债，甚至是灾难。而一个满足工业级强度的程序系统，这三类代码，一个也不能少。 而对三类代码的设计和实现，越是优雅的程序，这三类代码在程序实现中就越是能看出明显的边界。为什么需要边界？因为，“码以类聚，人以群分”。功能代码易变化，控制代码固复杂，运维代码偏繁琐，这三类不同的代码，不仅特征不同，而且编写它们的人（程序员）也可能分属不同群组，有足够的边界与距离才能避免耦合与混乱。 而在程序这个理性世界中，优雅有时就是边界与距离。 09 粗放与精益：编程的两种思路与方式几年前，我给团队负责的整个系统写过一些公共库，有一次同事发现这个库里存在一个 Bug，并告诉了我出错的现象。然后我便去修复这个 Bug，最终只修改了一行代码，但发现一上午就这么过去了。 一上午只修复了一个 Bug，而且只改了一行代码，到底发生了什么？时间都去哪里了？以前觉得自己写代码很快，怎么后来越来越慢了？我认真地思考了这个问题，开始认识到我的编程方式和习惯在那几年已经慢慢发生了变化，形成了明显的两个阶段的转变。这两个阶段是： 写得粗放，写得多 写得精益，写得好 多与粗放粗放，在软件开发这个年轻的行业里其实没有确切的定义，但在传统行业中确实存在相近的关于 “粗放经营” 的概念可类比。引用其百科词条定义如下： 粗放经营（Extensive Management），泛指技术和管理水平不高，生产要素利用效率低，产品粗制滥造，物质和劳动消耗高的生产经营方式。 若把上面这段话里面的 “经营” 二字改成 “编程”，就很明确地道出了我想表达的粗放式编程的含义。 一个典型的粗放式编程场景大概是这样的：需求到开发手上后，开始编码，编码完成，人肉测试，没问题后快速发布到线上，然后进入下一个迭代。 我早期参与的大量项目过程都与此类似，不停地重复接需求，快速开发，发布上线。在这个过程中，我只是在不停地堆砌功能代码，每天产出的代码量不算少，但感觉都很类似，也很粗糙。这样的过程持续了挺长一个阶段，一度让我怀疑：这样大量而粗放地写代码到底有什么作用和意义？ 后来读到一个故事，我逐渐明白这个阶段是必要的，它因人、因环境而异，或长或短。而那个给我启发的故事，是这样的。 有一个陶艺老师在第一堂课上说，他会把班上学生分成两组，一组的成绩将会以最终完成的陶器作品数量来评定；而另一组，则会以最终完成的陶器品质来评定。 在交作业的时候，一个很有趣的现象出现了：“数量” 组如预期一般拿出了很多作品，但出乎意料的是质量最好的作品也全部是由 “数量” 组制作出来的。 按 “数量” 组的评定标准，他们似乎应该忙于粗制滥造大量的陶器呀。但实际情况是他们每做出一个垃圾作品，都会吸取上一次制作的错误教训，然后在做下一个作品时得到改进。 而 “品质” 组一开始就追求完美的作品，他们花费了大量的时间从理论上不断论证如何才能做出一个完美的作品，而到了最后拿出来的东西，似乎只是一堆建立在宏大理论上的陶土。 读完这个故事，我陷入了沉思，感觉故事里的制作陶器和编程提升之路是如此类似。很显然，“品质” 组的同学一开始就在追求理想上的 “好与精益” ，而 “数量” 组同学的完成方式则似我早期堆砌代码时的“多与粗放”，但他们正是通过做得多，不断尝试，快速迭代 ，最后取得到了更好的结果。 庆幸的是，我在初学编程时，就是在不断通过编程训练来解答一个又一个书本上得来的困惑；后来工作时，则是在不断写程序来解决一个又一个工作中遇到的问题。看到书上探讨各种优雅的代码之道、编程的艺术哲学，那时的我也完全不知道该如何通往这座编程的 “圣杯”，只能看着自己写出的蹩脚代码，然后继续不断重复去制作下一个丑陋的 “陶器”，不断尝试，不断精进和进阶。 《黑客与画家》书里说：“编程和画画近乎异曲同工。”所以，你看那些成名画家的作品，如果按时间顺序来排列展示，你会发现每幅画所用的技巧，都是建立在上一幅作品学到的东西之上；如果某幅作品特别出众，你往往也能在更早期的作品中找到类似的版本。而编程的精进过程也是类似的。 总之，这些故事和经历都印证了一个道理：在通往 “更好” 的路上，总会经过 “更多” 这条路。 好与精益精益，也是借鉴自传统行业里的一个类比：精益生产。 精益生产（Lean Production），简言之，就是一种以满足用户需求为目标、力求降低成本、提高产品的质量、不断创新的资源节约型生产方式。 若将定义中的 “生产” 二字换成 “编程”，也就道出了精益编程的内涵。它有几个关键点：质量、成本与效率。但要注意：在编程路上，如果一开始就像 “品质” 组同学那样去追求完美，也许你就会被定义 “完美” 的品质所绊住，而忽视了制作的成本与效率。 因为编程的难点是，无论你在开始动手编程时看过多少有关编程理论、方法、哲学与艺术的书，一开始你还是无法领悟到什么是编程的正确方法，以及什么是“完美” 的程序。毕竟纸上得来终觉浅，绝知此事要躬行。 曾经，还在学校学习编程时，有一次老师布置了一个期中课程设计，我很快完成了这个课程设计中的编程作业。而另一位同学，刚刚看完了那本经典的《设计模式》书。 他尝试用书里学到的新概念来设计这个编程作业，并且又用 UML 画了一大堆交互和类图，去推导设计的完美与优雅。然后兴致勃勃向我（因为我刚好坐在他旁边）讲解他的完美设计，我若有所悟，觉得里面确实有值得我借鉴的地方，就准备吸收一些我能听明白的东西，重构一遍已经写好的作业程序。 后来，这位同学在动手实现他的完美设计时，发现程序越写越复杂，交作业的时间已经不够了，只好借用我的不完美的第一版代码改改凑合交了。而我在这第一版代码基础上，又按领悟到的正确思路重构了一次、改进了一番后交了作业。 所以，别被所谓 “完美“ 的程序所困扰，只管先去盯住你要用编程解决的问题，把问题解决，把任务完成。 编程，其实一开始哪有什么完美，只有不断变得更好。 工作后，我做了大量的项目，发现这些项目都有很多类似之处。每次，即使项目上线后，我也必然重构项目代码，提取其中可复用的代码，然后在下一个项目中使用。循环往复，一直干了七八年。每次提炼重构，都是一次从 “更多” 走向 “更好” 的过程。我想，很多程序员都有类似的经历吧？ 回到开头修改 Bug 的例子，我用半天的时间改一个 Bug，感觉效率不算高，这符合精益编程的思路吗？先来回顾下这半天改这个 Bug 的过程。 由于出问题的那个公共库是我接到 Bug 时的半年前开发的，所以发现那个 Bug 后，我花了一些时间来回忆整个公共库的代码结构设计。然后我研究了一下，发现其出现的场景比较罕见，要不不至于线上运行了很久也没人发现，属于重要但不紧急。 因此，我没有立刻着手去修改代码，而是先在公共库的单元测试集中新写了一组单元测试案例。单元测试构建了该 Bug 的重现场景，并顺利让单元测试运行失败了，之后我再开始去修改代码，并找到了出问题的那一行，修改后重新运行了单元测试集，并顺利看见了测试通过的绿色进度条。 而作为一个公共库，修改完成后我还要为本次修改更新发布版本，编写对应的文档，并上传到 Maven 仓库中，才算完成。回想这一系列的步骤，我发现时间主要花在了构建重现 Bug 的测试案例场景中，有时为了构建一个测试场景编写代码的难度可能比开发功能本身更困难。 为修改一个 Bug 付出的额外单元测试时间成本，算一种浪费吗？虽说这确实提高了代码的修复成本，但也带来了程序质量的提升。按前面精益的定义，这似乎是矛盾的，但其实更是一种权衡与取舍。 就是在这样的过程与反复中，我渐渐形成了属于自己的编程价值观：世上没有完美的解决方案，任何方案总是有这样或那样一些因子可以优化。一些方案可能面临的权衡取舍会少些，而另一些方案则会更纠结一些，但最终都要做取舍。 以上，也说明了一个道理：好不是完美，好是一个过程，一个不断精益化的过程。 编程，当写得足够多了，也足够好了，你才可能自如地在 “多” 与 “好” 之间做出平衡。 编程的背后是交付程序系统，交付关心的是三点：功能多少，质量好坏，效率快慢。真实的编程环境下， 你需要在三者间取得平衡，哪些部分可能是多而粗放的交付，哪些部分是好而精益的完成，同时还要考虑效率快慢（时间）的需求。 编程路上，“粗放的多” 是 “精益的好和快” 的前提，而好和快则是你的取舍：是追求好的极致，还是快的极致，或者二者的平衡？ 在多而粗放和好而精益之间，现在你处在哪个阶段了？欢迎留言谈谈你的看法。 10 炫技与克制：代码的两种味道与态度虽然你代码可能已经写得不少了，但要真正提高代码水平，其实还需要多读代码。就像写作，写得再多，不多读书，思维和认知水平其实是很难提高的。 代码读得多了，慢慢就会感受到好代码中有一种味道和品质：克制。但也会发现另一种代码，它也会散发出一种味道：炫技。 炫技什么是炫技的代码？ 我先从一个读代码的故事说起。几年前我因为工作需要，去研究一个开源项目的源代码。这是一个国外知名互联网公司开源的工具项目，据说已在内部孵化了 6 年之久，这才开源出来。从其设计文档与代码结构来看，它高层设计的一致性还是比较好的，但到了源代码实现就显得凌乱了些，而且发现了一些炫技的痕迹。 代码中炫技的地方，具体来说就是关于状态机的使用。状态机程序本是不符合线性逻辑思维的，有点类似goto语句，程序执行会突然发生跳转，所以理解状态机程序的代码要比一般程序困难些。除此之外，它的状态机程序实现又是通过自定义的内存消息机制来驱动，这又额外添加了一层抽象复杂度。 而在我看来，状态机程序最适合的场景是一种真实领域状态变迁的映射。那什么叫真实领域状态呢？比如，红绿灯就表达了真实交通领域中的三种状态。而另一种场景，是网络编程领域，广泛应用在网络协议解析上，表达解析器当前的运行状态。 而但凡使用状态机来表达程序设计实现中引入的 “伪” 状态，往往都添加了不必要的复杂性，这就有点炫技的感觉了。但是我还是能常常在一些开源项目中看到一些过度设计和实现的复杂性，而这些项目往往还都是一些行业内头部大公司开源的。 在程序员的成长路径上，攀登公司的晋升阶梯时，通常会采用同行评审制度，而作为技术人就容易倾向性地关注项目或工程中的技术含量与难点。 这样的制度倾向性，有可能导致人为制造技术含量，也就是炫技了。就像体操运动中，你完成一个高难度动作，能加的分数有限，而一旦搞砸了，付出的代价则要惨重很多。所以，在比赛中高难度动作都是在关键的合适时刻才会选择。同样，项目中的炫技，未必能加分，还有可能导致减分，比如其维护与理解成本变高了。 而除了增加不必要的复杂性外，炫技的代码，也可能更容易出 Bug。 刚工作的头一年，我在广东省中国银行写过一个小程序，就是给所有广东省中国银行的信用卡客户发邮件账单。由于当时广东中行信用卡刚起步，第一个月只有不到 10 万客户，所以算是小程序。 这个小程序就是个单机程序，为了方便业务人员操作，我写了个 GUI 界面。这是我第一次用 Java Swing 库来写 GUI，为了展示发送进度，后台线程每发送成功一封邮件，就通知页面线程更新进度条。 为什么这么设计呢？因为那时我正在学习 Java 线程编程，感觉这个技术很高端，而当时的 Java JDK 都还没标配线程 concurrent 包。所以，我选择线程间通信的方案来让后台发送线程和前端界面刷新线程通信，这就有了一股浓浓的炫技味道。 之后，就出现了界面动不动就卡住等一系列问题，因为各种线程提前通知、遗漏通知等情况没考虑到，代码也越改越难懂。其实后来想想，用个共享状态，定时轮询即可满足需要，而且代码实现会简单很多（前面《架构与实现》一文中，关于实现的核心我总结了一个字：简。这都是血泪教训啊），出 Bug 的概率也小了很多。 回头想想，成长的路上不免见猎心喜，手上拿个锤子看到哪里都是钉子。 炫技是因为你想表达得不一样，就像平常说话，你要故意说得引经据典去彰显自己有文化，但其实效果不一定佳，因为我们更需要的是平实、易懂的表达。 克制在说克制之前，先说说什么叫不克制，写代码的不克制。 刚工作的第二年，我接手了一个比较大的项目中的一个主要子系统。在熟悉了整个系统后，我开始往里面增加功能时，有点受不了原本系统设计分层中的 DAO（Data Access Object， 数据访问对象）层，那是基于原生的 JDBC 封装的。每次新增一个 DAO 对象都需要复制粘贴一串看起来很类似的代码，难免生出厌烦的感觉。 当时开源框架 Hibernate 刚兴起，我觉得它的设计理念优雅，代码写出来也简洁，所以就决定用 Hibernate 的方式来取代原本的实现。原来的旧系统里，说多不多，说少也不少，好几百个 DAO 类，而重新实现整个 DAO 层，让我连续加了一周的班。 这个替换过程，是个纯粹的搬砖体力活，弄完了还没松口气就又有了新问题：Hibernate 在某些场景下出现了性能问题。陆陆续续把这些新问题处理好，着实让我累了一阵子。后来反思这个决策感觉确实不太妥当，替换带来的好处仅仅是每次新增一个 DAO 类时少写几行代码，却带来很多当时未知的风险。 那时年轻，有激情啊，对新技术充满好奇与冲动。其实对于新技术，即使从我知道、我了解到我熟悉、我深谙，这时也还需要克制，要等待合适的时机。这让我想起了电影《勇敢的心》中的一个场景，是战场上华莱士看着对方冲过来，高喊：“Hold！Hold！”新技术的应用，也需要等待一个合适的出击时刻，也许是应用在新的服务上，也许是下一次架构升级。 不克制的一种形态是容易做出臆想的、通用化的假设，而且我们还会给这种假设安一个非常正当的理由：扩展性。不可否认，扩展性很重要，但扩展性也应当来自真实的需求，而非假设将来的某天可能需要扩展，因为扩展性的反面就是带来设计抽象的复杂性以及代码量的增加。 那么，如何才是克制的编程方式？我想可能有这样一些方面： 克制的编码，是每次写完代码，需要去反思和提炼它，代码应当是直观的，可读的，高效的。 克制的代码，是即使站在远远的地方去看屏幕上的代码，甚至看不清代码的具体内容时，也能感受到它的结构是干净整齐的，而非 “意大利面条” 似的混乱无序。 克制的重构，是每次看到 “坏” 代码不是立刻就动手去改，而是先标记圈定它，然后通读代码，掌握全局，重新设计，最后再等待一个合适的时机，来一气呵成地完成重构。 总之，克制是不要留下多余的想象，是不炫技、不追新，且恰到好处地满足需要，是一种平实、清晰、易懂的表达。 克制与炫技，匹配与适度，代码的技术深度未必体现在技巧上。有句话是这么说的：“看山是山，看水是水；看山不是山，看水不是水；看山还是山，看水还是水。”转了一圈回来，机锋尽敛，大巧若拙，深在深处，浅在浅处。 11 三阶段进化：调试，编写与运行代码刚开始学编程写代码，总会碰到一些困惑。比如，曾经就有刚入行的同学问我：“写程序是想到哪写到哪，边写边改边验证好，还是先整体梳理出思路，有步骤、有计划地分析后，再写更好？” 老实说，我刚入行时走的是前一条路，因为没有什么人或方法论来指导我，都是自己瞎摸索。一路走来十多年后，再回溯编程之路的经历，总结编程的进化过程，大概会经历下面三个阶段。 阶段一：调试代码 Debugging编程，是把用自然语言描述的现实问题，转变为用程序语言来描述并解决问题的过程；翻译，也是把一种语言的文字转变为另一种语言的文字，所以我想编程和翻译应该是有相通之处的。 好些年前，我曾偶然读到一篇关于性能的英文文章，读完不禁拍案叫绝，就忍不住想翻译过来。那是我第一次尝试翻译长篇英文，老实说翻得很痛苦，断断续续花了好几周的业余时间。那时的我，之于翻译，就是一个刚入门的初学者。 初次翻译，免不了遇到不少不熟悉的单词或词组，一路磕磕碰碰地查词典或 Google。一些似乎能理解含义的句子，却感觉无法很好地用中文来表达，如果直白地译出来感觉又不像正常的中文句子表达方式。 如是种种的磕碰之处，难道不像你刚学编程时候的情形吗？刚开始写代码，对语法掌握得不熟，对各种库和 API 不知道，不了解，也不熟悉。一路写代码，翻翻书，查查 Google，搜搜 API 文档，好不容易写完一段代码，却又不知道能否执行，执行能否正确等等。 小心翼翼地点击 Debug 按钮开始了单步调试之旅，一步步验证所有的变量或执行结果是否符合预期。如果出错了，是在哪一步开始或哪个变量出错的？一段不到一屏的代码，足足单步走了半小时，反复改了好几次，终于顺利执行完毕，按预期输出了执行结果。 如果不是自己写全新的代码，而是一来就接手了别人的代码，没有文档，前辈稍微给你介绍两句，你就很快又开始了 Debug 的单步调试之旅，一步步搞清代码运行的所有步骤和内部逻辑。根据你接手代码的规模，这个阶段可能持续数天到数周不等。 这就是我感觉可以划为编程第一阶段的 “调试代码 Debugging” 时期。这个时期或长或短，也许你曾经为各种编程工具或 IDE 提供的高级 Debug 功能激动不已，但如果你不逐渐降低使用 Debug 功能的频率，那么你可能很难走入第二阶段。 阶段二：编写代码 Coding翻译讲究 “信、达、雅”，编码亦如此。 那么何谓 “信、达、雅” ？它是由我国清末新兴启蒙思想家严复提出的，他在《天演论》中的 “译例言” 讲到： 译事三难：信、达、雅。求其信已大难矣，顾信矣，不达，虽译犹不译也，则达尚焉。 信，指不违背原文，不偏离原文，不篡改，不增不减，要求准确可信地表达原文描述的事实。 这条应用在编程上就是：程序员需要深刻地理解用户的原始需求。虽然需求很多时候来自于需求（产品）文档，但需求（产品）文档上写的并不一定真正体现了用户的原始需求。关于用户需求的“提炼”，早已有流传甚广的“福特之问”。 福特：您需要一个什么样的更好的交通工具？ 用户：我要一匹更快的马。 用户说需要一匹更快的马，你就跑去 “养” 只更壮、更快的马；后来用户需求又变了，说要让马能在天上飞，你可能就傻眼了，只能拒绝用户说：“这需求不合理，技术上实现不了。”可见，用户所说的也不可 “信” 矣。只有真正挖掘并理解了用户的原始需求，最后通过编程实现的程序系统才是符合 “信” 的标准的。 但在这一条的修行上几乎没有止境，因为要做到 “信” 的标准，编写行业软件程序的程序员需要在一个行业长期沉淀，才能慢慢搞明白用户的真实需求。 达，指不拘泥于原文的形式，表达通顺明白，让读者对所述内容明达。 这条应用在编程上就是在说程序的可读性、可理解性和可维护性。 按严复的标准，只满足 “信” 一条的翻译，还不如不译，至少还需要满足 “达” 这条才算尚可。 同样，只满足 “信” 这一条的程序虽然能准确地满足用户的需要，但没有 “达” 则很难维护下去。因为程序固然是写给机器去执行的，但其实也是给人看的。 所有关于代码规范和风格的编程约束都是在约定 “达” 的标准。个人可以通过编程实践用时间来积累经验，逐渐达到 “达” 的标准。但一个团队中程序员们的代码风格差异如何解决？这就像如果一本书由一群人来翻译，你会发现每章的文字风格都有差异，所以我是不太喜欢读由一群人一起翻译的书。 一些流行建议的解决方案是：多沟通，深入理解别人的代码思路和风格，不要轻易盲目地修改。但这些年实践下来，这个方法在现实中走得并不顺畅。 随着微服务架构的流行，倒是提供了另一种解决方案：每个服务对应一个唯一的负责人（Owner）。长期由一个人来维护的代码，就不会那么容易腐烂，因为一个人不存在沟通问题。而一个人所能 “达” 到的层次，完全由个人的经验水平和追求来决定。 雅，指选用的词语要得体，追求文章本身的古雅，简明优雅。 雅的标准，应用在编程上已经从技艺上升到了艺术的追求，这当然是很高的要求与自我追求了，难以强求。而只有先满足于 “信” 和 “达” 的要求，你才有余力来追求 “雅” 。 举个例子来说明下从 “达” 到 “雅” 的追求与差异。 下面是一段程序片段，同一个方法，实现完全一样的功能，都符合 “信” 的要求；而方法很短小，命名也完全符合规范，可理解性和维护性都没问题，符合 “达” 的要求；差别就在对 “雅” 的追求上。 private String generateKey(String service, String method) { String head = \"DBO$\"; String key = \"\"; int len = head.length() + service.length() + method.length(); if (len &lt;= 50) { key = head + service + method; } else { service = service.substring(service.lastIndexOf(\".\") + 1); len = head.length() + service.length() + method.length(); key = head + service + method; if (len &gt; 50) { key = head + method; if (key.length() &gt; 50) { key = key.substring(0, 48) + \".~\"; } } } return key; } 该方法的目标是生成一个字符串 key 值，传入两个参数：服务名和方法名，然后返回 key 值，key 的长度受外部条件约束不能超过 50 个字符。方法实现不复杂，很短，看起来也还不错，分析下其中的逻辑： 先 key 由固定的头（head）+ service（全类名）+ method（方法）组成，若小于 50 字符，直接返回。 若超过 50 字符限制，则去掉包名，保留类名，再判断一次，若此时小于 50 字符则返回。 若还是超过 50 字符限制，则连类名一起去掉，保留头和方法再判断一次，若小于 50 字符则返回。 最后如果有个变态长的方法名（46+ 个字符），没办法，只好暴力截断到 50 字符返回。 这个实现最大限度地在生成的 key 中保留全部有用的信息，对超过限制的情况依次按信息重要程度的不同进行丢弃。这里只有一个问题，这个业务规则只有 4 个判断，实现进行了三次 if 语句嵌套，还好这个方法比较短，可读性还不成问题。 而现实中很多业务规则比这复杂得多，以前看过一些实现的 if 嵌套多达 10 层的，方法也长得要命。当然一开始没有嵌套那么多层，只是后来随着时间的演变，业务规则发生了变化，慢慢增加了。之后接手的程序员就按照这种方式继续嵌套下去，慢慢演变至此，到我看到的时候就有 10 层了。 程序员有一种编程的惯性，特别是进行维护性编程时。一开始接手一个别人做的系统，不可能一下能了解和掌控全局。当要增加新功能时，在原有代码上添加逻辑，很容易保持原来程序的写法惯性，因为这样写也更安全。 所以一个 10 层嵌套 if 的业务逻辑方法实现，第一个程序员也许只写了 3 次嵌套，感觉还不错，也不失简洁。后来写 4、5、6 层的程序员则是懒惰不愿再改，到了写第 8、9、10 层的程序员时，基本很可能就是不敢再乱动了。 那么如何让这个小程序在未来的生命周期内，更优雅地演变下去？下面是另一个版本的实现： private String generateKey(String service, String method) { String head = \"DBO$\"; String key = head + service + method; // head + service(with package) + method if (key.length() &lt;= 50) { return key; } // head + service(without package) + method service = service.substring(service.lastIndexOf(\".\") + 1); key = head + service + method; if (key.length() &lt;= 50) { return key; } // head + method key = head + method; if (key.length() &lt;= 50) { return key; } // last, we cut the string to 50 characters limit. key = key.substring(0, 48) + \".~\"; return key; } 从嵌套变成了顺序逻辑，这样可以为未来的程序员留下更优雅地编程惯性方向。 阶段三：运行代码 Running编程相对翻译，其超越 “信、达、雅” 的部分在于：翻译出来的文字能让人读懂，读爽就够了；但代码写出来还需要运行，才能产生最终的价值。 写程序我们追求 “又快又好”，并且写出来的代码要符合 “信、达、雅” 的标准，但清晰定义 “多快多好” 则是指运行时的效率和效果。为准确评估代码的运行效率和效果，每个程序员可能都需要深刻记住并理解下面这张关于程序延迟数字的图： img 每个程序员都应该知道的延迟数字 只有深刻记住并理解了程序运行各环节的效率数据，你才有可能接近准确地评估程序运行的最终效果。当然，上面这张图只是最基础的程序运行效率数据，实际的生产运行环节会需要更多的基准效率数据才可能做出更准确的预估。 说一个例子，曾经我所在团队的一个高级程序员和我讨论要在所有的微服务中引入一个限流开源工具。这对于他和我们团队都是一个新东西，如何进行引入后线上运行效果的评估呢？ 第一步，他去阅读资料和代码搞懂该工具的实现原理与机制并能清晰地描述出来。第二步，去对该工具进行效果测试，又称功能可用性验证。第三步，进行基准性能测试，或者又叫基准效率测试（Benchmark），以确定符合预期的标准。 做完上述三步，他拿出一个该工具的原理性描述说明文档，一份样例使用代码和一份基准效率测试结果，如下： img 上图中有个红色字体部分，当阀值设置为 100 万而请求数超过 100 万时，发生了很大偏差。这是一个很奇怪的测试结果，但如果心里对各种基准效率数据有谱的话，会知道这实际绝不会影响线上服务的运行。 因为我们的服务主要由两部分组成：RPC 和业务逻辑。而 RPC 又由网络通信加上编解码序列化组成。服务都是 Java 实现的，而目前 Java 中最高效且吞吐最大的网络通信方式是基于 NIO 的方式，而我们服务使用的 RPC 框架正是基于 Netty（一个基于 Java NIO 的开源网络通信框架）的。 我曾经单独在一组 4 核的物理主机上测试过 Java 原生 NIO 与 Netty v3 和 v4 两个版本的基准性能对比，经过 Netty 封装后，大约有 10% 的性能损耗。在 1K 大小报文时，原生的 Java NIO 在当时的测试环境所能达到 TPS（每秒事务数） 的极限大约 5 万出头（极限，就是继续加压，但 TPS 不再上升，CPU 也消耗不上去，延时却在增加），而 Netty 在 4.5 万附近。增加了 RPC 的编解码后，TPS 极限下降至 1.3 万左右。 所以，实际一个服务在类似基准测试的环境下单实例所能承载的 TPS 极限不可能超过 RPC 的上限，因为 RPC 是没有包含业务逻辑的部分。加上不算简单的业务逻辑，我能预期的单实例真实 TPS 也许只有 1 千 ～2 千。 因此，上面 100 万的阀值偏差是绝对影响不到单实例的服务的。当然最后我们也搞明白了，100 万的阀值偏差来自于时间精度的大小，那个限流工具采用了微秒作为最小时间精度，所以只能在百万级的范围内保证准确。 讲完上述例子，就是想说明一个程序员要想精确评估程序的运行效率和效果，就得自己动手做大量的基准测试。 基准测试和测试人员做的性能测试不同。测试人员做的性能测试都是针对真实业务综合场景的模拟，测试的是整体系统的运行；而基准测试是开发人员自己做来帮助准确理解程序运行效率和效果的方式，当测试人员在性能测试发现了系统的性能问题时，开发人员才可能一步步拆解根据基准测试的标尺效果找到真正的瓶颈点，否则大部分的性能优化都是在靠猜测。 到了这个阶段，一段代码写出来，基本就该在你头脑中跑过一遍了。等上线进入真实生产环境跑起来，你就可以拿真实的运行数据和头脑中的预期做出对比，如果差距较大，那可能就掩藏着问题，值得你去分析和思考。 最后，文章开头那个问题有答案了吗？在第一阶段，你是想到哪就写到哪；而到了第三阶段，写到哪，一段鲜活的代码就成为了你想的那样。 12 Bug的空间属性：环境依赖与过敏反应从今天开始，咱们专栏进入 “程序之术” 中关于写代码的一个你可能非常熟悉，却也常苦恼的小主题：Bug。 写程序的路上，会有一个长期伴随你的 “同伴”：Bug，它就像程序里的寄生虫。不过，Bug 最早真的是一只虫子。 1947 年，哈佛大学的计算机哈佛二代（Harvard Mark II）突然停止了运行，程序员在电路板编号为 70 的中继器触点旁发现了一只飞蛾。然后把飞蛾贴在了计算机维护日志上，并写下了首个发现 Bug 的实际案例。程序错误从此被称作 Bug。 这只飞蛾也就成了人类历史上的第一个程序 Bug。 回想下，在编程路上你遇到得最多的 Bug 是哪类？我的个人感受是，经常被测试或产品经理要求修改和返工的 Bug。这类 Bug 都来自于对需求理解的误差，其实属于沟通理解问题，我并不将其归类为真正的技术性 Bug。 技术性 Bug 可以从很多维度分类，而我则习惯于从 Bug 出现的 “时空” 特征角度来分类。可划为如下两类： 空间：环境过敏 时间：周期规律 我们就先看看 Bug 的空间维度特征。 环境过敏环境，即程序运行时的空间与依赖。 程序运行的依赖环境是很复杂的，而且一般没那么可靠，总是可能出现这样或那样的问题。曾经我经历过一次因为运行环境导致的故障案例：一开始系统异常表现出来的现象是，有个功能出现时不时的不可用；不久之后，系统开始报警，不停地接到系统的报警短信。 这是一个大规模部署的线上分布式系统，从一开始能感知到的个别系统功能异常到逐渐演变成大面积的报警和业务异常，这让我们陷入了一个困境：到底异常根源在哪里？为了迅速恢复系统功能的可用性，我们先把线上流量切到备用集群后，开始紧急地动员全体团队成员各自排查其负责的子系统和服务，终于找到了原因。 只是因为有个别服务器容器的磁盘故障，导致写日志阻塞，进程挂起，然后引发调用链路处理上的连锁雪崩效应，其影响效果就是整个链路上的系统都在报警。 互联网企业多采用普通的 PC Server 作为服务器，而这类服务器的可靠性大约在 99.9%，换言之就是出故障的概率是千分之一。而实际在服务器上，出问题概率最高的可能就是其机械硬盘。 Backblaze 2014 年发布的硬盘统计报告指出，根据对其数据中心 38000 块硬盘（共存储 100PB 数据）的统计，消费级硬盘头三年出故障的几率是 15%。而在一个足够大规模的分布式集群部署上，比如 Google 这种百万级服务器规模的部署级别上，几乎每时每刻都有硬盘故障发生。 我们的部署规模自是没有 Google 那么大，但也不算小了，运气不好，正好赶上我们的系统碰上磁盘故障，而程序的编写又并未考虑硬盘 I/O 阻塞导致的挂起异常问题，引发了连锁效应。 这就是当时程序编写缺乏对环境问题的考虑，引发了故障。人有时换了环境，会产生一些从生理到心理的过敏反应，程序亦然。运行环境发生变化，程序就出现异常的现象，我称其为 “程序过敏反应”。 以前看过一部美剧《豪斯医生》，有一集是这样的：一个手上出现红色疱疹的病人来到豪斯医生的医院，豪斯医生根据病症现象初步诊断为对某种肥皂产生了过敏，然后开了片抗过敏药，吃过后疱疹症状就减轻了。但一会儿后，病人开始出现呼吸困难兼并发哮喘，豪斯医生立刻给病人注射了 1cc 肾上腺素，之后病人呼吸开始变得平稳。但不久后病人又出现心动过速，而且很快心跳便停止了，经过一番抢救后，最终又回到原点，病人手上的红色疱疹开始在全身出现。 这个剧情中表现了在治疗病人时发生的身体过敏反应，然后引发了连锁效应的问题，这和我之前描述的例子有相通之处：都是局部的小问题，引发程序过敏反应，再到连锁效应。 过敏在医学上的解释是：“有机体将正常无害的物质误认为是有害的东西。”而我对 “程序过敏反应” 的定义是：“程序将存在问题的环境当作正常处理，从而产生的异常。”而潜在的环境问题通常就成了程序的 “过敏原”。 该如何应对这样的环境过敏引发的 Bug 呢？ 应对之道应对环境过敏，自然要先从了解环境开始。 不同的程序部署和运行的环境千差万别，有的受控，有的不受控。比如，服务端运行的环境，一般都在数据中心（IDC）机房内网中，相对受控；而客户端运行的环境是在用户的设备上，存在不同的品牌、不同的操作系统、不同的浏览器等等，多种多样，不可控。 环境那么复杂，你需要了解到何种程度呢？我觉得你至少必须关心与程序运行直接相关联的那一层环境。怎么理解呢？以后端 Java 程序的运行为例，Java 是运行在 JVM 中，那么 JVM 提供的运行时配置和特性就是你必须要关心的一层环境了。而 JVM 可能是运行在 Linux 操作系统或者是像 Docker 这样的虚拟化容器中，那么 Linux 或 Docker 这一层，理论上你的关心程度就没太多要求，当然，学有余力去了解到这一层次，自是更好的。 那么前文案例中的磁盘故障，已经到了硬件的层面，这个环境层次比操作系统还更低一层，这也属于我们该关心的？虽说故障的根源是磁盘故障，但直接连接程序运行的那一层，其实是日志库依赖的 I/O 特性，这才是我们团队应该关心、但实际却被忽略掉的部分。 同理，现今从互联网到移动互联网时代，几乎所有的程序系统都和网络有关，所以网络环境也必须是你关心的。但网络本身也有很多层次，而对于在网络上面开发应用程序的你我来说，可以把网络模糊抽象为一个层次，只用关心网络距离延时，以及应用程序依赖的具体平台相关网络库的 I/O 特性。 当然，如果能对网络的具体层次有更深刻的理解，自然也是更好的。事实上，如果你和一个对网络具体层次缺乏理解的人调试两端的网络程序，碰到问题时，经常会发现沟通不在一个层面上，产生理解困难。（这里推荐下隔壁的“趣谈网络协议”专栏） 了解了环境，也难免不出 Bug。因为我们对环境的理解是渐进式的，不可能一下子就完整掌握，全方位，无死角。当出现了因为环境产生的过敏反应时，收集足够多相关的信息才能帮助快速定位和解决问题，这就是前面《代码与分类》文章中 “运维” 类代码需要提供的服务。 收集信息，不仅仅局限于相关直接依赖环境的配置和参数，也包括用户输入的一些数据。真实场景确实大量存在这样一种情况：同样的环境只针对个别用户发生异常过敏反应。 有一种药叫抗过敏药，那么也可以有一种代码叫 “抗过敏代码”。在收集了足够的信息后，你才能编写这样的代码，因为现实中，程序最终会运行在一些一开始你可能没考虑到的环境中。收集到了这样的环境信息，你才能写出针对这种环境的 “抗过敏代码”。 这样的场景针对客户端编程特别常见，比如客户端针对运行环境进行的自检测和自适应代码。检测和适应范围包括：CPU、网络、存储、屏幕、操作系统、权限、安全等各方面，这些都属于环境抗过敏类代码。 而服务端相对环境一致性更好，可控，但面临的环境复杂性更多体现在 “三高” 要求，即：高可用、高性能、高扩展。针对 “三高” 的要求，服务端程序生产运行环境的可靠性并不如你想象的高，虽然平时的开发、调试中你可能很难遇到这些环境故障，但大规模的分布式程序系统，面向失败设计和编码（Design For Failure）则是服务端的 “抗过敏代码” 了。 整体简单总结一下就是：空间即环境，包括了程序的运行和依赖环境；环境是多维度、多层次的，你对环境的理解越全面、越深入，那么出现空间类 Bug 的几率也就越低；对环境的掌控有广度和深度两个方向，更有效的方法是先广度全面了解，再同步与程序直接相连的一层去深度理解，最后逐层深入，“各个击破”。 文章开头的第一只飞蛾 Bug，按我的分类就应该属于空间类 Bug 了，空间类 Bug 感觉麻烦，但若单独出现时，相对有形（异常现场容易捕捉）；如果加上时间的属性，就变得微妙多了。 13 Bug的时间属性：周期特点与非规律性在上一篇文章中，我说明了“技术性 Bug 可以从很多维度分类，而我则习惯于从 Bug 出现的 ‘时空’ 特征角度来分类”。并且我也已讲解了 Bug 的空间维度特征：程序对运行环境的依赖、反应及应对。 接下来我再继续分解 Bug 的时间维度特征。 Bug 有了时间属性，Bug 的出现就是一个概率性问题了，它体现出如下特征。 周期特点周期特点，是一定频率出现的 Bug 的特征。 这类 Bug 因为会周期性地复现，相对还是容易捕捉和解决。比较典型的呈现此类特征的 Bug 一般是资源泄漏问题。比如，Java 程序员都不陌生的 OutOfMemory 错误，就属于内存泄漏问题，而且一定会周期性地出现。 好多年前，我才刚参加工作不久，就碰到这么一个周期性出现的 Bug。但它的特殊之处在于，出现 Bug 的程序已经稳定运行了十多年了，突然某天开始就崩溃（进程 Crash）了。而程序的原作者，早已不知去向，十多年下来想必也已换了好几代程序员来维护了。 一开始项目组内经验老到的高工认为也许这只是一个意外事件，毕竟这个程序已经稳定运行了十来年了，而且检查了一遍程序编译后的二进制文件，更新时间都还停留在那遥远的十多年前。所以，我们先把程序重启起来让业务恢复，重启后的程序又恢复了平稳运行，但只是安稳了这么一天，第二天上班没多久，进程又莫名地崩溃了，我们再次重启，但没多久后就又崩溃了。这下没人再怀疑这是意外了，肯定有 Bug。 当时想想能找出一个隐藏了这么多年的 Bug，还挺让人兴奋的，就好像发现了埋藏在地下久远的宝藏。 寻找这个 Bug 的过程有点像《盗墓笔记》中描述的盗墓过程：项目经理（三叔）带着两个高级工程师（小哥和胖子）连续奋战了好几天，而我则是个新手，主要负责 “看门”，在他们潜入跟踪分析探索的过程中，我就盯着那个随时有可能崩溃的进程，一崩掉就重启。他们“埋伏”在那里，系统崩溃后抓住现场，定位到对应的源代码处，最后终于找到了原因并顺利修复。 依稀记得，最后定位到的原因与网络连接数有关，也是属于资源泄漏的一种，只是因为过去十来年交易量一直不大且稳定，所以没有显现出来。但在我参加工作那年（2006 年），中国股市悄然引来一场有史以来最大的牛市，这个处理银行和证券公司之间资金进出的程序的“工作量”突然出现了爆发性增长，从而引发了该 Bug。 我可以理解上世纪九十年代初那个编写该服务进程的程序员，他可能也难以预料到当初写的用者寥寥的程序，最终在十多年后的一天会服务于成百上千万的用户。 周期性的 Bug，虽然乍一看很难解决的样子，但它总会重复出现，就像可以重新倒带的 “案发现场”，找到真凶也就简单了。案例中这个 Bug 隐藏的时间很长，但它所暴露出的周期特点很明显，解决起来也就没那么困难。 其实主要麻烦的是那种这次出现了，但不知道下次会在什么时候出现的 Bug。 非规律性没有规律性的 Bug，才是让人抓狂的。 曾经我接手过一个系统，是一个典型的生产者、消费者模型系统。系统接过来就发现一个比较明显的性能瓶颈问题，生产者的数据源来自数据库，生产者按规则提取数据，经过系统产生一系列的转换渲染后发送到多个外部系统。这里的瓶颈就在数据库上，生产能力不足，从而导致消费者饥饿。 问题比较明显，我们先优化 SQL，但效果不佳，遂改造设计实现，在数据库和系统之间增加一个内存缓冲区从而缓解了数据库的负载压力。缓冲区的效果，类似大河之上的堤坝，旱时积水，涝时泄洪。引入缓冲区后，生产者的生产能力得到了有效保障，生产能力高效且稳定。 本以为至此解决了该系统的瓶颈问题，但在生产环境运行了一段时间后，系统表现为速度时快时慢，这时真正的 Bug 才显形了。 这个系统有个特点，就是 I/O 密集型。消费者要与多达 30 个外部系统并发通信，所以猜测极有可能导致系统性能不稳定的 Bug 就在此，于是我把目光锁定在了消费者与外部系统的 I/O 通信上。既然锁定了怀疑区域，接下来就该用证据来证明，并给出合理的解释原因了。一开始假设在某些情况下触碰到了阈值极限，当达到临界点时程序性能则急剧下降，不过这还停留在怀疑假设阶段，接下来必须量化验证这个推测。 那时的生产环境不太方便直接验证测试，我便在测试环境模拟。用一台主机模拟外部系统，一台主机模拟消费者。模拟主机上的线程池配置等参数完全保持和生产环境一致，以模仿一致的并发数。通过不断改变通信数据包的大小，发现在数据包接近 100k 大小时，两台主机之间直连的千兆网络 I/O 达到满负载。 于是，再回头去观察生产环境的运行状况，当一出现性能突然急剧下降的情况时，立刻分析了生产者的数据来源。其中果然有不少大报文数据，有些甚至高达 200k，至此基本确定了与外部系统的 I/O 通信瓶颈。解决办法是增加了数据压缩功能，以牺牲 CPU 换取 I/O。 增加了压缩功能重新上线后，问题却依然存在，系统性能仍然时不时地急剧降低，而且这个时不时很没有时间规律，但关联上了一个 “嫌疑犯”：它的出现和大报文数据有关，这样复现起来就容易多了。I/O 瓶颈的怀疑被证伪后，只好对程序执行路径增加了大量跟踪调试诊断代码，包含了每个步骤的时间度量。 在完整的程序执行路径中，每个步骤的代码块的执行时间独立求和结果仅有几十毫秒，最高也就在一百毫秒左右，但多线程执行该路径的汇总平均时间达到了 4.5 秒，这比我预期值整整高了两个量级。通过这两个时间度量的巨大差异，我意识到线程执行该代码路径的时间其实并不长，但花在等待 CPU 调度的时间似乎很长。 那么是 CPU 达到了瓶颈么？通过观察服务器的 CPU 消耗，平均负载却不高。只好再次分析代码实现机制，终于在数据转换渲染子程序中找到了一段可疑的代码实现。为了验证疑点，再次做了一下实验测试：用 150k 的线上数据报文作为该程序输入，单线程运行了下，发现耗时居然接近 50 毫秒，我意识到这可能是整个代码路径中最耗时的一个代码片段。 由于这个子程序来自上上代程序员的遗留代码，包含一些稀奇古怪且复杂的渲染逻辑判断和业务规则，很久没人动过了。仔细分析了其中实现，基本就是大量的文本匹配和替换，还包含一些加密、Hash 操作，这明显是一个 CPU 密集型的函数啊。那么在多线程环境下，运行这个函数大概平均每个线程需要多少时间呢？ 先从理论上来分析下，我们的服务器是 4 核，设置了 64 个线程，那么理想情况下同一时间可以运行 4 个线程，而每个线程执行该函数约为 50 毫秒。这里我们假设 CPU 50 毫秒才进行线程上下文切换，那么这个调度模型就被简化了。第一组 4 个线程会立刻执行，第二组 4 个线程会等待 50 毫秒，第三组会等待 100 毫秒，依此类推，第 16 组线程执行时会等待 750 毫秒。平均下来，每组线程执行前的平均等待时间应该是在 300 到 350 毫秒之间。这只是一个理论值，实际运行测试结果，平均每个线程花费了 2.6 秒左右。 实际值比理论值慢一个量级，这是为什么呢？因为上面理论的调度模型简化了 CPU 的调度机制，在线程执行过程的 50 毫秒中，CPU 将发生非常多次的线程上下文切换。50 毫秒对于 CPU 的时间分片来说，实在是太长了，因为线程上下文的多次切换和 CPU 争夺带来了额外的开销，导致在生产环境上，实际的监测值达到了 4.5 秒，因为整个代码路径中除了这个非常耗时的子程序函数，还有额外的线程同步、通知和 I/O 等操作。 分析清楚后，通过简单优化该子程序的渲染算法，从近 50 毫秒降低到 3、4 毫秒后，整个代码路径的线程平均执行时间下降到 100 毫秒左右。收益是明显的，该子程序函数性能得到了 10 倍的提高，而整体执行时间从 4.5 秒降低为 100 毫秒，性能提高了 45 倍。 至此，这个非规律性的 Bug 得到了解决。 虽然案例中最终解决了 Bug，但用的方法却非正道，更多依靠的是一些经验性的怀疑与猜测，再去反过来求证。这样的方法局限性非常明显，完全依赖程序员的经验，然后就是运气了。如今再来反思，一方面由于是刚接手的项目，所以我对整体代码库掌握还不够熟悉；另一方面也说明当时对程序性能的分析工具了解有限。 而更好的办法就应该是采用工具，直接引入代码 Profiler 等性能剖析工具，就可以准确地找到有性能问题的代码段，从而避免了看似有理却无效的猜测。 面对非规律性的 Bug，最困难的是不知道它的出现时机，但一旦找到它重现的条件，解决起来也没那么困难了。 神出鬼没能称得上神出鬼没的 Bug 只有一种：海森堡 Bug（Heisenbug）。 这个 Bug 的名字来自量子物理学的 “海森堡不确定性原理”，其认为观测者观测粒子的行为会最终影响观测结果。所以，我们借用这个效应来指代那些无法进行观测的 Bug，也就是在生产环境下不经意出现，费尽心力却无法重现的 Bug。 海森堡 Bug 的出现场景通常都是和分布式的并发编程有关。我曾经在写一个网络服务端程序时就碰到过一次海森堡 Bug。这个程序在稳定性负载测试时，连续跑了十多个小时才出现了一次异常，然后在之后的数天内就再也不出现了。 第一次出现时捕捉到的现场信息太少，然后增加了更多诊断日志后，怎么测都不出现了。最后是怎么定位到的？还好那个程序的代码量不大，就天天反复盯着那些代码，好几天过去还真就灵光一现发现了一个逻辑漏洞，而且从逻辑推导，这个漏洞如果出现的话，其场景和当时测试发现的情况是吻合的。 究其根源，该 Bug 复现的场景与网络协议包的线程执行时序有关。所以，一方面比较难复现，另一方面通过常用的调试和诊断手段，诸如插入日志语句或是挂接调试器，往往会修改程序代码，或是更改变量的内存地址，或是改变其执行时序。这都影响了程序的行为，如果正好影响到了 Bug，就可能诞生了一个海森堡 Bug。 关于海森堡 Bug，一方面很少有机会碰到，另一方面随着你编程经验的增加，掌握了很多编码的优化实践方法，也会大大降低撞上海森堡 Bug 的几率。 综上所述，每一个 Bug 都是具体的，每一个具体的 Bug 都有具体的解法。但所有 Bug 的解决之道只有两类：事后和事前。 事后，就是指 Bug 出现后容易捕捉现场并定位解决的，比如第一类周期特点的 Bug。但对于没有明显重现规律，甚至神出鬼没的海森堡 Bug，靠抓现场重现的事后方法就比较困难了。针对这类 Bug，更通用和有效的方法就是在事前预防与埋伏。 之前在讲编程时说过一类代码：运维代码，它们提供的一种能力就像人体血液中的白细胞，可以帮助发现、诊断、甚至抵御 Bug 的 “入侵”。 而为了得到一个更健康、更健壮的程序，运维类代码需要写到何种程度，这又是编程的 “智慧” 领域了，充满了权衡选择。 程序员不断地和 Bug 对抗，正如医生不断和病菌对抗。不过 Bug 的存在意味着这是一段活着的、有价值的代码，而死掉的代码也就无所谓 Bug 了。 14 Bug的反复出现：重蹈覆辙与吸取教训Bug 除了时间和空间两种属性，还有一个特点是和程序员直接相关的。在编程的路上，想必你也曾犯过一些形态各异、但本质重复的错误，导致一些 Bug 总是以不同的形态反复出现。在你捶胸顿足懊恼之时，不妨试着反思一下：为什么你总会写出有 Bug 的程序，而且有些同类型的 Bug 还会反复出现？ 1. 重蹈覆辙重蹈覆辙的错误，老实说曾经我经历过不止一次。 也许每次具体的形态可能有些差异，但仔细究其本质却是类似的。想要写出没有 Bug 的程序是不可能的，因为所有的程序员都受到自身能力水平的局限。而我所经历的重蹈覆辙型错误，总结下来大概都可以归为以下三类原因。 1.1 粗心大意人人都会犯粗心大意的错误，因为这就是 “人” 这个系统的普遍固有缺陷（Bug）之一。所以，作为人的程序员一定会犯一些非常低级的、因为粗心大意而导致的 Bug。 这就好比写文章、写书都会有错别字，即使经历过三审三校后正式出版的书籍，都无法完全避免错别字的存在。 而程序中也有这类 “错别字” 类型的低级错误，比如：条件if 后面没有大括号导致的语义变化，==、= 和 === 的数量差别，++ 或-- 的位置，甚至 ;的有无在某些编程语言中带来的语义差别。即使通过反复检查也可能有遗漏，而自己检查自己的代码会更难发现这些缺陷，这和自己不容易发现自己的错别字是一个道理。 心理学家汤姆·斯塔福德（Tom Stafford）曾在英国谢菲尔德大学研究拼写错误，他说：“当你在书写的时候，你试图传达想法，这是非常高级的任务。而在做高级任务时，大脑将简单、零碎的部分（拼词和造句）概化，这样就可以更专注于更复杂的任务，比如将句子变成复杂的观点。” 而在阅读时，他解释说：“我们不会抓住每个细节，相反，我们吸收感官信息，将感觉和期望融合，并且从中提炼意思。”这样，如果我们读的是他人的作品，就能帮助我们用更少的脑力更快地理解含义。 但当我们验证自己的文章时，我们知道想表达的东西是什么。因为我们预期这些含义都存在，所以很容易忽略掉某些感官（视觉）表达上的缺失。我们眼睛看到的，在与我们脑子里的印象交战。这，便是我们对自己的错误视而不见的原因。 写程序时，我们是在进行一项高级的复杂任务：将复杂的需求或产品逻辑翻译为程序逻辑，并且还要补充上程序固有的非业务类控制逻辑。因而，一旦我们完成了程序，再来复审写好的代码，这时我们预期的逻辑含义都预先存在于脑中，同样也就容易忽略掉某些视觉感官表达上的问题。 从进化角度看，粗心写错别字，还看不出来，不是因为我们太笨，而恰恰还是进化上的权衡优化选择。 1.2 认知偏差认知偏差，是重蹈覆辙类错误的最大来源。 曾经，我就对 Java 类库中的线程 API 产生过认知偏差，导致反复出现问题。Java 自带线程池有三个重要参数：核心线程数（core）、最大线程数（max）和队列长度（queues）。我曾想当然地以为当核心线程数（core）不够了，就会继续创建线程达到最大线程数（max），此时如果还有任务需要处理但已经没有线程了就会放进队列等待。 但实际却不是这样工作的，类库的实现是核心线程（core）满了就会进队列（queues）等待，直到队列也满了再创建新线程直至达到最大线程数（max）的限制。这类认知偏差曾带来线上系统的偶然性异常故障，然后还怎么都找不到原因。因为这进入了我的认知盲区，我以为的和真正的现象之间的差异一度让我困惑不解。 还有一个来自生活中的小例子，虽然不是关于程序的，但本质是一个性质。 有时互联网上，朋友圈中小道消息满天飞，与此类现象有关的一个成语叫 “空穴来风”，现在很多媒体文章有好多是像下面这样用这个成语的： 他俩要离婚了？看来空穴来风，事出有因啊！ 物价上涨的传闻恐怕不是空穴来风。 第一句是用的成语原意：指有根据、有来由，“空”发三声读 kǒng，意同 “孔”。第二句是表达：没有根据和由来，“空”发一声读 kōnɡ。第二种的新意很多名作者和普通大众沿用已久，约定俗成，所以又有辞书与时俱进增加了这个新的义项，允许这两种完全相反的解释并存，自然发展，这在语义学史上也不多见。 而关于程序上有些 API 的定义和实现也犯过 “空穴来风” 的问题，一个 API 可以表达两种完全相反的含义和行为。不过这样的 API 就很容易引发认知偏差导致的 Bug，所以在设计和实现 API 时我们就要避免这种情况的出现，而是要提供单一原子化的设计。 1.3 熵增问题熵增，是借用了物理热力学的比喻，表达更复杂混乱的现象；程序规模变大，复杂度变高之后，再去修改程序或添加功能就更容易引发未知的 Bug。 腾讯曾经分享过 QQ 的架构演进变化，到了 3.5 版本 QQ 的用户在线规模进入亿时代，此时在原有架构下去新增一些功能，比如： “昵称” 长度增加一半，需要两个月； 增加 “故乡” 字段，需要两个月； 最大好友数从 500 变成 1000，需要三个月。 后端系统的高度复杂性和耦合作用导致即使增加一些小功能特性，也可能带来巨大的牵连影响，所以一个小改动才需要数月时间。 我们不断进行架构升级的本质，就在于随着业务和场景功能的增加，去控制住程序系统整体 “熵” 的增加。而复杂且耦合度高（熵很高）的系统，正是容易滋生 Bug 的温床。 2. 吸取教训为了避免重蹈覆辙，我们有什么办法来吸取曾经犯错的教训么？ 2.1 优化方法粗心大意，可以通过开发规范、代码风格、流程约束，代码评审和工具检查等工程手段来加以避免。甚至相对写错别字，代码更进一步，通过补充单元测试在运行时做一个正确性后验，反过来去发现这类我们视而不见的低级错误。 认知偏差，一般没什么太好的自我发现机制，但可以依赖团队和技术手段来纠偏。每次掉坑里爬出来后的经验教训总结和团队内部分享，另外就是像一些静态代码扫描工具也提供了内置的优化实践，通过它们的提示来发现与你的认知产生碰撞纠偏。 熵增问题，业界不断迭代更新流行的架构模式就是在解决这个问题。比如，微服务架构相对曾经的单体应用架构模式，就是通过增加开发协作，部署测试和运维上的复杂度来换取系统开发的敏捷性。在协作方式、部署运维等方面付出的代价都可以通过提升自动化水平来降低成本，但只有编程活动是没法自动化的，依赖程序员来完成，而每个程序员对复杂度的驾驭能力是有不同上限的。 所以，微服务本质上就是将一个大系统的熵增问题，局部化在一个又一个的小服务中。而每个微服务都有一个熵增的极限值，而这个极限值一般是要低于该服务负责人的驾驭能力上限的。对于一个熵增接近极限附近的微服务，服务负责人就需要及时重构优化，降低熵的水平。而高水平和低水平程序员负责的服务本质差别在于熵的大小。 而熵增问题若不及时重构优化，最后可能会付出巨大的代价。 丰田曾陷入的 “刹车门” 事件，就是因为其汽车动力控制系统软件存在缺陷。而为追查其原因，在十八个月中，有 12 位嵌入式系统专家受原告诉讼团所托，被关在马里兰州一间高度保安的房间内对丰田动力控制系统软件（主要是 2005 年的凯美瑞）源代码进行深度审查。最后得到的结论把丰田的软件缺陷分为三类： 非常业余的结构设计 不符合软件开发规范 对关键变量缺乏保护 第一类属于熵增问题，导致系统规模不断变大、变复杂，结果驾驭不了而失控；第二类属于开发过程的认知与管理问题；第三类才是程序员实现上的水平与粗心大意问题。 2.2 塑造环境为了修正真正的错误，而不是头痛医头、脚痛医脚，我们需要更深刻地认识问题的本质，再来开出 “处方单”。 在亚马逊（Amazon），严重的故障需要写一个 COE（Correction of Errors）的文档，这是一种帮助去总结经验教训，加深印象避免再犯的形式。其目的也是为了帮助认识问题的本质，修正真正的错误。 但一旦这个东西和 KPI 之类的挂上钩，引起的负面作用是 COE 的数量会变少，但真正的问题并没有减少，只是被隐藏了。而其正面的效应像总结经验、吸取教训、找出真正问题等，就会被大大削弱。 关于如何构造一个鼓励修正错误的环境，我们可以看看来自《异类》一书讲述的大韩航空的例子，大韩航空曾一度困扰于它的飞机损失率： 美国联合航空 1988 年到 1998 年的飞机损失率为百万分之 0.27，也就是说联合航空每飞行 400 万次，会在一次事故中损失一架飞机；而大韩航空同期的飞机损失率为百万分之 4.79，是前者的 17 倍之多。 事实上大韩航空的飞机也是买自美国，和联合航空并无多大差别。它的飞行员们的飞行时长，经验和训练水平从统计数据看也差别不大，那为什么飞机损失率会如此地高于其他航空公司的平均水平呢？在《异类》这本书中，作者以此为案例做了详细分析，我这里直接引用结论。 现代商业客机，就目前发展水平而言，跟家用烤面包机一样可靠。空难很多时候是一系列人为的小失误、机械的小故障累加的结果，一个典型空难通常包括 7 个人为的错误。 一个飞机上有正副两个机长，副机长的作用是帮助发现、提醒和纠正机长在飞行过程中可能发生的一些人为小错误。大韩航空的问题正在于副机长是否敢于以及如何提醒纠正机长的错误。其背后的理论依据源自荷兰心理学家吉尔特·霍夫斯泰德（Geert Hofstede）对不同族裔之间文化差异的研究，就是今天被社会广泛接受的跨文化心理学经典理论框架：霍夫斯泰德文化纬度（Hofstede’s Dimensions）。 在霍夫斯泰德的几个文化维度中，最引人注目的大概就是 “权力距离指数（Power Distance Index）”。权力距离是指人们对待比自己更高等级阶层的态度，特别是指对权威的重视和尊重程度。 而霍夫斯泰德的研究也提出了一个航空界专家从未想到过的问题：让副机长在机长面前维护自己的意见，必须帮助他们克服所处文化的权力距离。 想想我们看过的韩国电影或电视剧中，职场上后辈对前辈、下级对上级的态度，就能感知到韩国文化相比美国所崇尚的自由精神所表现出来的权力距离是特别远的。因而造成了大韩航空未被纠正的人为小错误比例更高，最终的影响是空难率也更高，而空难就是航空界的终极系统故障，而且结果不可挽回。 吸取大韩航空的教训应用到软件系统开发和维护上，就是：需要建立和维护有利于程序员及时暴露并修正错误，挑战权威和主动改善系统的低权力距离文化氛围，这其实就是推崇扁平化管理和 “工程师文化” 的关键所在。 一旦系统出了故障非技术背景的管理者通常喜欢用流程、制度甚至价值观来应对问题，而技术背景的管理者则喜欢从技术本身的角度去解决当下的问题。我觉着两者需要结合，站在更高的维度去考虑问题：规则、流程或评价体系的制定所造成的文化氛围，对于错误是否以及何时被暴露，如何被修正有着决定性的影响。 我们常与错误相伴，查理·芒格说： 世界上不存在不犯错误的学习或行事方式，只是我们可以通过学习，比其他人少犯一些错误，也能够在犯了错误之后，更快地纠正错误。但既要过上富足的生活又不犯很多错误是不可能的。实际上，生活之所以如此，是为了让你们能够处理错误。 人固有缺陷，程序固有 Bug；吸取教训避免重蹈覆辙，除了不断提升方法，也要创造环境。你觉得呢？欢迎你留言和我分享。 15 根源：计划的愿景——仰望星空在前面第 2 章节 “程序之术” 中，我已把对“设计”“编程”和“Bug”的思考与理解都分享给你了。今天开始进入第 3 章节，是关于成长修行中 “由术入道” 的部分，而“道”的维度众多，我就先从和个人成长最直接相关的 “计划体系” 讲起。它会有助于你一步一步走向你“理想的自己”，所以可别小看它的重要性。 我想你肯定做过计划，我也不例外。一般在开始一件中长期的活动前，我都会做计划，但更重要的是反问为什么要做这个计划，因为计划是抵达愿望的途径。如果不能清晰地看见计划之路前方的愿景，计划半途而废的概率就很大了。 古希腊哲学家苏格拉底有一句名言：“未经检视的人生不值得活。”那么我们为什么要检视自己的人生呢？正是因为我们有成长的愿望，那么愿望的根源又到底是什么呢？ 需求模型上世纪四十年代（1943 年）美国心理学家亚伯拉罕·马斯洛在《人类激励理论》中提出了需求层次理论模型，它是行为科学的理论之一。 该理论认为个体成长发展的内在力量是动机，而动机是由多种不同性质的需要所组成，各种需要之间，有先后顺序与高低层次之分，每一层次的需要与满足，将决定个体人格发展的境界或程度。 其层次模型的经典金字塔图示如下： img 马斯洛的经典金字塔图：需求层次模型 在人生的不同阶段，会产生不同层次的目标需求。 在人生的早期，我们努力学习，考一个好大学，拥有一技之长，找一份好工作，带来更高薪的收入，这很大程度都是为了满足图中最底层的生存需求，让生活变得更舒适美好。 成长拼搏数年，事业小成，工作稳定，有房，有车，有娃后，第二层次，也就是安全的需求开始凸显。有人在这阶段开始给自己、父母、老婆、孩子都买人寿保险，开始考虑理财，投资甚至强身健体。然而处在这个阶段时，我却有一种强烈的不安全感，这也许和长年的程序员职业经历养成的习惯也有关系。 我们做系统应用服务时总是需要考虑各种意外和异常事件发生，一般至少提供主备方案。于人生而言，保持持续学习，与时俱进，追求成长，这其实也是一种主备方案：主，指当前支撑生活的工作；备，是通过持续学习，同步成长，保持核心能力的不断积累与时间的付出来获得一份备份保障，以避免 “主” 出现意外时，“备” 的能力已被时代淘汰。 需求金字塔底部两层属于物质层次的 “经济基础”，而再往上则进入了更高精神层次的 “上层建筑”。就个体而言，高层次需求要比低层次需求具有更大的价值。在 “生存” 和 “安全” 基本满足的保障基础之上，我们才会更从容地向内求，更多地探求内心，进而向外索，对外去探索、发现和建立不同的圈层关系，以满足上层的社交 “归属”、获得 “尊重” 与 “自我实现” 的需求。 马斯洛把底层的四类需求：生存、安全、归属、尊重归类为 “缺失性” 需求，它们的满足需要从外部环境去获得。而最顶层的“自我实现” 则属于 “成长性” 需求。成长就是自我实现的过程，成长的动机也来自于 “自我实现” 的吸引。就像很多植物具有天生的向阳性，而对于人，我感觉也有天生的 “自我实现” 趋向性。 人生最激荡人心的时刻，就在于自我实现的创造性过程中，产生出的一种 “高峰体验” 感。正因为人所固有的需求层次模型，我们才有了愿望，愿望产生目标，目标则引发计划。 生涯发展在攀登需求金字塔的过程中，我们创造了关于人生的 “生涯”。而 “生涯” 一词最早来自庄子语： 吾生也有涯，而知也无涯。以有涯随无涯，殆已。 “涯” 字的原意是水边，隐喻人生道路的尽头，尽头已经没了路，是终点，是边界。正因如此，人生有限，才需要计划。著名生涯规划师古典有一篇文章《你的生命有什么可能？》对生涯提出了四个维度：高度、宽度、深度和温度。这里就借他山之玉，来谈谈我的理解。 高度：背后的价值观是影响与权力。代表性关键词有：追逐竞争、改变世界。 深度：背后的价值观是卓越与智慧。代表性关键词有：专业主义、工匠精神。 宽度：背后的价值观是博爱与和谐。代表性关键词有：多种角色、丰富平衡。 温度：背后的价值观是自由与快乐。代表性关键词有：自我认同、精彩程度。 每个人的人生发展路线都会有这四个维度，只是不同人的偏好、愿望和阶段不同导致了在四个维度分布重心的差异。在不同维度的选择，都代表了不一样的 “生涯”，每一种 “生涯” 都需要一定程度的计划与努力。 虽有四种维度，四个方向，但不代表只能选其一。虽然我们不太可能同时去追求这四个维度，但可以在特定的人生不同阶段，在其中一个维度上，给自己一个去尝试和探索的周期。所以，这就有了选择，有了计划。而计划会有开始，也会有结束，我们需要计划在人生的不同阶段，重点开始哪个维度的追求，以及大概需要持续的周期。 人生本是多维的，你会有多努力、多投入来设计并实现自己的生涯规划呢？不计划和努力一下，也许你永远无法知道自己的边界和所能达到的程度。 上世纪七十年代初，一个文学专业成绩很一般的学生毕业了。他虽然喜欢读文学作品却没写出过什么东西，毕业后就结了婚，和老婆开了个酒吧，生意不错，生活无忧。到了七十年代末，他似乎感受到某种 “召唤”，觉得应该写点什么东西了，于是每天酒吧打烊后，他就在餐桌上写两小时的小说，这一写就写了三十多年。熟悉的人想必已经知道他是谁了？对，就是村上春树。 所以，总要开始计划做点啥，你才能知道自己的 “涯” 到底有多远；而计划就是在系统地探索生涯，甚至人生的无限可能性。 回首无悔关于后悔，有研究说：“我们最后悔的是没做什么，而不是做过什么。”回味一下，这个结论也确实符合我们的感觉。 万维钢写过一篇文章《决策理性批判》，里面引用了一个最新（2018）的关于后悔的研究，这个研究从 “理想的自己” 与 “义务的自己” 两个角度来说明： “理想的自己” 就是你想要成为什么人。 “义务的自己” 就是你应该干什么。 若放到前面马斯洛需求金字塔中，“理想的自己” 就是站在顶端 “自我实现” 位置的那个自己；而 “义务的自己” 正在金字塔下面四层，挣扎于现实的处境。如果你从来没有去向 “理想的自己” 望上一眼，走上一步，将来终究会后悔的。事实上，研究结论也证明了这点：70% 以上的人都会后悔没有成为 “理想的自己”。 当我把自己进入大学以后的这十八年分作几个阶段来回顾时，有那么一段的好多时间我就是那样浑浑噩噩地混过去了，以至于现在回忆那段日子发现记忆是如此的粘连与模糊。后悔么？当然。 如果我能好好计划一下那段日子，也许会得到一个更 “理想的自己”。而在最近的这一段，我也感谢好些年前 “曾经的我”，幸运兼有意地做了一些计划。虽然一路走来，有些辛苦，但感觉会充实很多，而且如今再去回首，就没有太多后悔没做的事了。 计划，就是做选择，你在为未来的你做出选择，你在选择未来变成 “谁”。如果你还在为今天的自己而后悔，那就该为明天的自己做出计划了。 人生的征程中，先是恐惧驱动，地狱震颤了你，想要逃离黑暗深渊；后来才是愿望驱动，星空吸引了你，想要征服星辰大海。 逃离与征服的路，是一条计划的路，也是一条更困难的路，而 “你内心肯定有着某种火焰，能把你和其他人区别开来” 才让你选择了它。 16 方式：计划的方法——脚踏实地当你内心成长的火焰被点燃，有成长的愿望，也形成了清晰的成长愿景，但却可能苦恼于不知道如何确定目标、制定计划，以达成愿景。 就拿我来说，每年结束我都会做一次全年总结，然后再做好新一年的计划，一开始这个过程确实挺艰难且漫长的，因为毕竟要想清楚一年的计划还是挺难的。但慢慢的，我开始摸索和学习到了一套制定富有成效计划的方法，成为了我成长的捷径。现借此机会我将其总结、分享给你。 目标富有成效的计划的第一步，便是确定目标。 在设定目标这个领域，国外一位研究者马克·墨菲（Mark Murphy）曾提出过一种 HARD 方法。HARD 是 4 个英文词的首字母缩写： Heartfelt 衷心的，源自内心的 Animated 活生生，有画面感的 Required 必须的，需求明确的 Difficult 困难的，有难度的 如其解释，这是一种强调内心愿望驱动的方法。按这个标准，一种源自内心的强烈需求在你头脑中形成很具体的画面感，其难度和挑战会让你感到既颤栗又激动，那么这也许就是一个好目标。 应用到个人身上，HARD 目标中的 H 体现了你的兴趣、偏好与心灵深处的内核。就拿写作这个事情来说吧，于我而言，兴趣只是驱动它的一种燃料，而另一种燃料是内心深处的表达欲望。写作本身不是目标，通过写作去完成一部作品才是目标，就像通过写代码去实现一个系统，它们都是作品，其驱动内核就是一种 “创造者之心”。 而 A 是你对这个目标形成的愿景是否足够清晰，在头脑中是否直接就能视觉化、具象化。就拿我个人来说，我非常喜欢读书，常在夜深人静的时候，默默潜读，掩卷而思，和作者产生一种无声的交流。这样一种画面，慢慢烙在脑海中，渐渐就激发起了想要拥有一部作品的目标。 R 则是由上一篇文章中的马斯洛需求模型层次决定的。写作一方面本是自带属于第三层次的社交属性，但另一方面更多是一种成长性的自我实现需求在激发。完成一部作品，需要明确一个主题，持续地写作，一开始我从每月写，到每周写，再到写这个专栏，作品也就渐渐成型。 而最后的 D 是其难度，决定了目标的挑战门槛。太容易的目标不值得设定，太难或离你现实太远的目标也不合适。基于现实的边界，选择舒适圈外的一两步，可能就是合适的目标。于我，从写代码到写作，其实也真就只有那么一两步的距离。 以 HARD 目标法为指导，我回顾了我工作以来的成长发展阶段，根据目标的清晰度，大概可以划分为如下三个阶段： 目标缺乏，随波逐流 目标模糊，走走停停 目标清晰，步履坚定 第一个阶段，属于工作的前三、四年，虽然每天都很忙，感觉也充实，一直在低头做事。但突然某一天一抬头，就迷茫了，发现不知道自己要去向哪里，原来在过去的几年里，虽然充实，但却没有形成自己明确的目标，一直在随波逐流。 在那时，人生的浪花把我推到了彼时彼地，我停在岸边，花了半年的时间重新开始思考方向。当然这样的思考依然逃不脱现实的引力，它顶多是我当时工作与生活的延伸，我知道我还会继续走在程序这条路上，但我开始问自己想要成为一个怎样的程序员，想要在什么行业，什么公司，写怎样的程序。就这样，渐渐确立了一个模糊的目标。 重新上路，比之前好了不少，虽然当时定的目标不够清晰，但至少有了大致方向，一路也越走越清晰。从模糊到清晰的过程中，难免走走停停，但停下迷茫与徘徊的时间相对以前要少了很多，模糊的目标就像一张绘画的草图，逐渐变得清晰、丰富、立体起来。当目标变得越来越清晰时，步履自然也就变得越发坚定。 回顾目标在我身上形成的经历，我在想即使当时我想一开始就要去定一个目标，想必也不可能和如今的想法完全一致。毕竟当时受限于眼界和视野，思维与认知也颇多局限，所立的目标可能也高明不到哪里去；但有了目标，就有了方向去迭代与进化，让我更快地摆脱了一些人生路上的漩涡。 假如，你觉得现状不好，无法基于现状延伸出目标。那么也许可以试试这样想：假如我不做现在的事情，那么你最想做的是什么？通常你当前最想做的可能并不能解决你的谋生问题，那么在这两者之间的鸿沟，如何去搭建一条桥梁，可能就是一个值得考虑的目标。 我们为什么要立 HARD 目标？有一句话是这么说的： Easy choices, hard life. Hard choices, easy life. 容易的选择，艰难的生活；艰难的选择，轻松的生活。 方法目标是愿望层面的，计划是执行层面的，而计划的方式也有不同的认识维度。 从时间维度，可以拟定 “短、中、长” 三阶段的计划： 短期：拟定一年内的几个主要事项、行动周期和检查标准。 中期：近 2～3 年内的规划，对一年内不足以取得最终成果的事项，可以分成每年的阶段性结果。 长期：我的长期一般也就在 5～7 年周期，属于我的 “一辈子” 的概念范围了，而 “一辈子” 当有一个愿景。 短期一年可以完成几件事或任务，中期两三年可以掌握精熟一门技能，长期的 “一辈子” 达成一个愿景，实现一个成长的里程碑。 从路径维度，订计划可以用一种 SMART 方法，该方法是百年老店通用电气创造的。在 20 世纪 40 年代的时候，通用电气就要求每一个员工把自己的年度目标、实现方法及标准写信告诉自己的上级。上级也会根据这个年度目标来考核员工。这种方法进化到了 20 世纪 80 年代，就成了著名的 SMART 原则。 SMART 也是 5 个英文词的首字母缩写： Specific 具体的 Measurable 可衡量的 Achievable 可实现的 Relevant 相关的 Time-bound 有时限的 今天 SMART 已经非常流行和常见，我就不解释其具体含义了，而是讲讲我如何通过 SMART 来跟踪个人年度计划执行的。按 SMART 方式定义的计划执行起来都是可以量化跟踪的，我通常用如下格式的一张表来跟踪： img 计划跟踪表示意图 其实，一年值得放进这张表的就那么几件事，每件事又可以分解为具体的几个可量化的任务，再分解到一年 50 周，就可以很明显地看出理想计划和现实路径的曲线对比。如下，是我 2017 年的一张计划与实际执行的对比曲线图： img 计划与实际执行对比示意图 按 SMART 原则方法使用计划跟踪表的优点是：简单、直接、清晰。但缺点也明显：即使百分百完成了所有的计划，也都是预期内的，会缺乏一些惊喜感。而因为制定目标和计划会有意识地选择有一定难度的来挑战，所以实际还很难达成百分百。 说到目标的难度与挑战，使用 SMART 方法最值得注意的点就是关于目标的设定和方法的选择。鉴于人性和现实的因素，制定计划时很可能是这样一种情况：基于现实掌握的方法，考虑计划的可达性。这样制定出来的计划看起来靠谱，但却失去了真正挑战与创新的可能。 通用电气传奇 CEO 杰克·韦尔奇执掌时期，有一个飞机引擎工厂制定了一个减少 25% 产品缺陷的目标。韦尔奇当时就觉得这个 SMART 目标很普通，没什么挑战，但工厂负责人却觉得已经很有难度了。韦尔奇执意坚持，把目标提高到了减少 70% 的缺陷，工厂负责人一开始很焦虑，认为这根本不可能完成。 没办法，标准是韦尔奇定的，改不了。工厂负责人知道按以前的方法根本达不成，只好去寻找新方法。在寻找的过程中，他们发现，要想如此大幅度地减少缺陷，不能只靠质检人员，而是必须让每名员工都有质检意识。 于是，工厂开始大规模进行培训；同时，工厂开始有意识招聘综合素质更高的技术工人。为了吸引并留住这些工人，工厂必须改变以前的管理方式，给他们更多的自主权，因为这些工人普遍受过很好的教育，而且很容易找到工作。最后，一个拔高的目标计划改变了整个工厂的培训、招聘和运行方式。 SMART 计划，正如其名，需要聪明且智慧地设定并使用它。 有时你可能会觉得计划没有变化快，或者计划好的人生，过起来好机械，没劲。其实计划是准备，变化才是永恒，而计划就是为了应对变化。为此，我经常会把计划表按优先级排得满满的，但我永远只做那些计划表顶部最让自己感到 HARD 的事情。 变化来了，就把它装进计划表中，看这样的变化会排在哪个位置，和之前计划表前列的事情相比又如何。如果变化的事总能排在顶上，那么说明你的人生实际就在不断变得更精彩，做的事情也会让你更激动。而如果变化老是那些并不重要却还总是紧急的事情，老打断当下的计划，那么也许你就要重新审视下你当前的环境和自身的问题了。 这样，计划表就成了变化表，人生无法机械执行，只有准备应对。 最后，找到属于你的 HARD 目标，开始有计划且 SMART 的每一天；这样的每一天，走的每一步也许会更重些、累些，但留下的脚印却很深、很长。 17 检视：计划的可行——时间与承诺有了愿景，也有了具体的计划，但经常还是一年过去，发现实际和计划相比，总是有差距。是的，这是普遍现象，你可能并不孤独和例外：统计数字表明，在年初制定了计划的人中，只有 8% 实现了这些计划。 老实说，我回顾了近几年的个人年度计划完成情况，也只完成了约 70% 的样子。但我个人把这 70% 的比例算作“完成”，毕竟一年中谁还没个变化呢？于是，我把另外的 30% 留给变化，毕竟一成不变地按计划来的人生，感觉太过枯燥，有 30% 的变化还可能会碰到 “惊喜”；而如果 70% 都是变化，那可能就是 “惊吓”了。 程序员啊，有一个特点就是偏乐观，所以对于计划的估计总是过于乐观，乐观地期待 “惊喜”，然后又“惊吓”地接受现实。那如何才能让计划更具可行性呢？又可以从哪些方面来检视呢？ 时间与周期计划的第一个影响因素是和时间有关。 在过去的人类社会生活中，人们已经习惯了以年为单位来进行时间分界，所以我们都会习惯于做年度计划。在个人的时间感觉中，一年，似乎也算是挺长一段时间了，但在过去这么些年的计划与实践中，我学到的经验是：做计划不能靠模糊的感觉，而是需要精确理性的计算。 先来计算下，一年，我们到底有多少时间？一个正常参与社会工作的人，时间大约会被平均分成三份。 其中的 1/3（约 8 小时）会被睡过去了，这里假设一个正常人的生理睡眠需求大约 8 小时。虽然有一些讲述成功人士关于睡眠的说法，比如：“你见过凌晨四点钟的…”，似乎在暗示他们之所以成功，是因为每天都很努力只睡四个小时。但这个说法并没有提每天几点入睡，只是说四点起床而已。而我写这篇文字也是在周末的早晨五点开始的，但前一晚十点之前便睡了过去，至少我对睡眠时间的要求是没法长期低于 8 小时的。 另一个 1/3 你会贡献到和你的工作有关的各种事项中，虽然国家法律规定了每周只用上 5 天班，每天 8 小时，似乎用不了 1/3 的时间。但如果你的工作不是那种 “混日子” 的清闲工作的话，实际占用的时间基本总会多于法律规定的，至少程序员这份工作肯定是这样了。不过值得庆幸的是程序员的工作是可以随着时间积累起相应的知识、技能和经验，那么这份时间投入就是很有价值的了，随着时间积累，慢慢你就会成为工作领域内的行家。 最后的 1/3 就是我们常说的决定人生的业余 8 小时。可能有人会说我根本就没有业余 8 小时，天天都在加班。实际上工作和业余的 8 小时有时不太那么具有明显的分界线。程序员的工作，是一份知识性工作，很可能工作时间你在学习，也有很多情况是你在业余时间处理工作的事务。对于严格区分工作和业余时间的思维，我碰到过一种人：上厕所都要忍着，到了公司利用工作时间再去，以达成变相在工作时间偷懒的感觉。但，其实时间总是自己的。 一年 52 周，会有一些法定的长假和个人的休假安排，我们先扣除两周用于休假。那么一天业余 8 小时，一年算 350 天，那么一年总共有 2800 小时的业余时间。但实际这 2800 小时里还包括了你全部的周末和一些零星的假期，再预扣除每周 8 小时用于休闲娱乐、处理各种社会关系事务等等，那么你还剩下 2400 小时。 这 2400 小时就是你可以比较自由地用来安排的全部业余时间了，这就是理性计算的结果。这样看来，一年实际能用来计划的时间并不多，需要仔细挑选合理的事项，放进计划表，并真正地执行。而实际，一年中你还需要把时间合理地分配在 “短、中、长” 三种不同周期的计划上。 短期：完成事项，获取结果，得到即时反馈与成就感（比如：写这个专栏）。 中期：学习技能，实践经验，积累能力（比如：学一门语言）。 长期：建立信念，达成愿景（比如：成长为一名架构师）。 你可以从时间的维度，看看你计划的时间安排是否合理分配在了不同周期的计划事项上。如果计划的事项和周期匹配错了，计划的执行就容易产生挫败感从而导致半途而废，曾经的我就犯过这样的错误。 这个错误就是在学习英语的计划上。两年多以前，工作十年后的我又重启了英语提升计划，希望能通过每天 3 ～ 4 小时的英语学习，一年内使自己的英语听读都能达到接近汉语的水平。但实际情况是，我用了两年（接近 1500 小时吧）才勉强比刚从学校毕业时上了一个台阶，离母语水平，我不知道前面还有多少个台阶。 英语提升计划，我搞错了周期，一度颇受打击。英语技能，实际就是一个 10000 小时技能，虽然我是从初中开始学习，然后至大学毕业拿到六级证，差不多有十年时间。但实际真正有效的学习时间有多少呢？假如每天一节课算 1 小时，一周 6 小时，每年 50 周，十年上课下来也就 3000 小时，再考虑为了考试自己的主动复习时间，再加 2000 小时，那么过去在学校总共投入了 5000 小时。 但从学校毕业后的十年，实际工作环境中，除了技术英语阅读，我几乎很少再接触英语了。而语言基本就是用进废退的技能，所以再重启学习提升计划时，我对此计划的周期完全估算错误，最后得到的效果也远低于我的预期。其实这应该是一个长期的计划，定一个合理的愿景，循序渐进成为一名熟练的英语使用者。 要让计划可行，就是选择合适的事项，匹配正确的周期，建立合理的预期，得到不断进步的反馈。 兴趣与承诺既然时间有限，那该如何选择有限的事项，才可能更有效地被执行下去呢？ 其中有一个很重要的因素：兴趣。有的人兴趣可能广泛些，有的人兴趣可能少一些，但每个人多多少少都会有些个人的兴趣爱好。对于兴趣广泛的人来说，这就有个选择取舍问题，若不取舍，都由着兴趣来驱动，计划个十几、二十件事，每样都浅尝辄止。实际从理性上来说价值不大，从感性上来说只能算是丰富了个人生活吧。 彼得·蒂尔在《从 0 到 1 》这本书里批判了现在的一个观点：过程胜于实效。他解释说：“当人们缺乏一些具体的计划去执行时，就会用很正式的规则来建立一些可做的事情选项的组合。就像今天美国中学里一样，鼓励学生参与各种各样的课外活动，表现的似乎全面发展。到了大学，再准备好一份看似非常多元化的简历来应对完全不确定的将来。言外之意，不管将来如何变化，都在这个组合内能找到可以应对的准备。但实际情况是，他们在任何一个特定方面都没有准备好。” 因此，在有限的学校生涯中，你就得做出选择。就好像我大学那时，学校开了几十门（记得大概有 45 门）各类专业课，这就是一个组合。但其中真正重要的课程实际只有个位数，重心应该放在少数课程上，其他的只起到一个开阔眼界和凑够学分的作用。 几十门课是学校给的选项，你可以从中做出选择。那应该选择哪些事项放进计划表呢？我建议你可以从兴趣作为出发点，因为这样更容易启动；而对于中期目标，像学习提升一项技能，只靠兴趣是不足以驱动去有效执行的，甚至达不到预期效果。关于此，吴军有一个观点： 凡事从 0 分做到 50 分，靠的是直觉和经验；从 50 分到 90 分，就要靠技艺了。 凭借兴趣驱动的尝试，结合直觉和经验就能达成 50 分的效果，而要到 90 分就需要靠技艺了。而技艺的习得是靠刻意练习的，而刻意练习通常来说都不太有趣。要坚持长期的刻意练习，唯一可靠的办法就是对其做出郑重的承诺。 通过兴趣来启动，但要靠承诺才能有效地执行下去。感兴趣和做承诺的差别在于，只是感兴趣的事，到了执行的时候，总可以给自己找出各种各样的原因、借口或外部因素的影响去延期执行；而承诺就是这件事是每天的最高优先级，除非不可抗力的因素，都应该优先执行。 比如，写作本是我的兴趣，但接下 “极客时间” 的专栏后，这就是承诺了，所以为此我就只能放弃很多可以用于休闲、娱乐的时间。 兴趣让计划更容易启动，而承诺让计划得以完成。 而在现实生活中，让计划不可行或半途而废的常见错误有： 以为一年之内自己有足够多的自由支配时间； 对计划的事情误判了其开发与成长的周期； 兴趣很多，一直在尝试，却不见有结果。 放进计划表的事项是你精心识别、选择并做出的承诺，而承诺也是一种负担，若承诺太多，负担可能就太重，会让你感觉自己不堪重负，最后就可能放弃了，到头来又是一场空。其实，一年下来，重要的不是开启了多少计划，而是完成了几个计划。 所以，可行的计划应该是：有限的时间，适合的周期，兴趣的选择，郑重的承诺。 18 评估：计划的收获——成本与收益做计划自是为了有收获，实现愿景也好，获得成长也罢，每一份计划背后都有付出与收获的关系。如果计划的收益不能高于执行它付出的成本，那么其实这种的计划就几乎没有执行价值。 执行计划的成本通常是你付出的时间或金钱，但收益则没那么明确，这就需要你去仔细评估和取舍。 而有些计划本身从成本和收益的角度看就不是一个好计划，比如，我见过一些计划是：今年计划读 20 本书。读书本是好事，但读书的数量并不是关键点，关键是计划今年读哪些书。因为只有明确了读哪些书，才能评估是否值得和适合在这阶段去读。 值得与否，就是关于成本与收益的评估，而为了更好制定有价值的计划，你就需要去仔细权衡这种关系。 成本与机会计划即选择，而但凡选择就有成本。 从经济学思维的角度，做计划就是做选择，选择了某些事情；而选择了这些事情，就意味着放弃了另外可能做的事情，这里面的成本就是机会成本。机会成本是放弃的代价，选择这些事情从而放弃的其他可能选项中拥有最高价值的事情。 就好像同样一个晚上，有人选择了用来玩网络游戏，你以为的成本是几小时的点卡钱，但实际你放弃的是用来学习、看书等其他事项的潜在价值与收益。青少年时代谁还没玩过游戏，我也玩过十多年的游戏，虽不能简单地认为游戏毫无意义，但十年前，我明白了机会成本的概念后，就做出了选择。 我的长期计划中有一项是写作。从我 2011 年开始写下第一篇博客放在网上到现在，已经过去了七年。那写作的成本和收益又是怎样的呢？ 一开始总有一些人愿意免费写一些优质内容放在网上，从读者的角度来看，他们总是希望作者能长期免费地创造优质内容。但从花费的时间成本来看，这是不太现实的，也很难长久持续下去。 从作者的角度，时间成本其实是越来越高，而且很刚性。比如，七年前我写一篇文章的时间其实和现在差不太多，时间成本按说是增加的（因为单位成本随时间增加了）；但是写作会持续创造价值，我可以在持续写作中不断总结获得成长，而成长的价值都会通过职业生涯发展获得收益，这是间接收益。而一些成功的作者，可能还可以通过写作获得直接收益，比如目前蒸蒸日上的各类知识付费专栏。 在中国互联网快速发展的这十多年间，我的学习路径也发生了转变。前期，我都是从网上去扒各种免费的电子书，看免费的博客，读开源的代码；但今天我几乎不会再去网上找免费的学习材料了，而是直接付费购买。 而且你应该也发现了现在知识和内容付费的趋势在扩大，这是为什么？因为大家都意识到了时间的成本，是选择花费自己的时间去搜索、甄别和筛选内容，还是付出一点点费用得到更成体系的优质内容？大家已经做出了选择。 学习计划是个人成长计划中的一部分，而成长计划中，最大的成本依然是时间。在你早期的学习阶段，虽然时间没那么值钱，但把钱和时间都花在加速成长上，其实是“成本有限，潜在收益巨大”的选择。 而计划，就是对你的时间做分配。时间在不同的阶段，价值不同，那么成本也就不同。你要敏感地去感知自己时间的成本，去提升时间的价值，根据时间的价值再去调整自己的计划和行动。成长过程中，早期的成本低而选项多，后期的成本高且选项少。 文艺复兴时期法国作家蒙田曾说过： 真正的自由，是在所有时候都能控制自己。 如蒙田所说，计划才能给你真正的自由，你对计划的控制力越强，离自由也就更近了。 结果与收益计划得到了执行，产生了预期的结果，才会有期望的收益。 但据抽样统计，制定了年度计划的人里面，仅有 8% 的人能完成他们的年度计划。年度计划通常都是一份从未向任何人公布的计划，从某种意义上来说，除了你自己自律，并没有任何约束可言。这个世界的外部环境变化那么快，你很容易找到一个理由说服自己：计划赶不上变化。 变化之后的计划，只是一份更契合实际的计划，而非不再存在。很多外部因素是你无法预测和控制的，总会来干扰你的计划，所以这给了你足够的客观原因。但无论有多少客观原因，你做计划的初衷是：一点点尝试去控制自己的生活，然后得到自己想要的结果。 在获得结果的路上，这个世界上似乎有两类人： 第一类人，自己给自己施加约束，保持自律并建立期望； 第二类人，需要外部环境给予其约束和期望。 在我读高中时，现实中就有一种巨大的社会期望和约束施加己身，那就是高考。在这种巨大的社会外部约束和期望下，第二类人可以表现得非常好，好到可以考出状元的分数。但进入大学后，这样的外部约束和期望会瞬间下降，最后可能也就泯然众人之间了。 心理学上有个皮格马利翁效应： 人们基于对某种情境的知觉而形成的期望或预言，会使该情境产生适应这一期望或预言的效应。 通俗点说就是，如果有人（可以是别人或自己）对你的期望很高，你会不自觉地行动去满足并符合这种期望；若周围没有这样的期望，最终你可能就是一个符合周围人群平均期望的人。而所谓的自驱力，就是你对自己的期望所形成的推动力量。 要获得好的结果，你就要做第一类人，需要对自己有更高的期望，需要有自驱力。 进入大学或工作以后，周围环境对你的期望已经降到很低。于我而言，来自父辈的那一代人，也就是上世纪四五十年代那一代，经历了饥荒甚至战争，他们的期望通常代表一代人，都是平平安安、健健康康，有个稳定的工作就够了。 这样的期望对于大部分读了大学、有个工作的人来说都不足以形成驱动力了，更何况我们大多数人每日工作忙里忙外，不外乎忧心柴米油盐，困于当下。少了外部足够强大的期望推动，多数第二类人的内心驱动从此也就熄火了，但还是有少数的第一类人在 “仰望星空”，比如科幻小说《三体》的作者大刘（刘慈欣）。 我是 1999 年在四川成都的一本科幻杂志《科幻世界》（现已停刊）上读到他的首部短篇小说的。实际他 85 年毕业，在电厂任工程师，89 年开始写科幻小说，直到 99 年才见到他的第一部作品公开发表。从 89 年到 99 年这十年间基本就是独自“仰望星空”来完成了写作这门技艺的打磨过程，并留下了自己的第一部作品，再之后到写完《三体》，这又是另一个十年了。 而于我，除了写作，还有另一项长期计划：学好英语。快三年前了，我重启了英语提升计划，付出的成本是每天至少一到数小时不等的学习和听读文章的时间成本，那么收益呢？学好英语是能产生直接收益的，比如通过翻译就能赚钱，但这就落入了一种狭隘的思维。 一方面，翻译的时间单价市场行情是非常低的，目前英译中的普通文章，恐怕不到 100 元每千字，相比一个初中级程序员的市场价，时间成本是很不划算的。所以，学好英语从我的角度来说，赚取的不是直接的经济收益，而是间接的结构性收益，增强直接收益结构价值。 那么如何理解收益结构？以我现阶段的状态来说，已有三个直接收益结构： 专业 写作 理财 专业，自然是指程序专业技能，通过出售自己的时间和人力资源来获取一份相对稳定的工资收入来源。写作，到今天这个专栏出品后，终于可以通过作品的形式产生直接收益，它只需一次性投入时间来完成作品。而理财属于资产性收益，就是任何等价于钱的家庭动产或不动产，能产生利息、分红或租金的收入，它需要长期的收入结余积累。 而英语技能的提升对这三个直接收益结构，都能产生增益作用。程序行业自不必多说，行业里最好的文章、书籍或专业论文材料等可能都是英文的，只有少部分被翻译了过来，但翻译总是有损失、有偏差、有歧义，能直接高效地阅读英语对提升你的专业技能和能力帮助巨大。 而写作，英语给我提供了另外一个更广阔世界的写作素材和看待世界的角度。所以，我在时间分配上不仅看中文文章，也看一些英文媒体文章和书籍。 至于理财，英语让我更直接高效地接收中文世界以外的信息，从某种角度来说，具备了更多元化的视角和思维结构。而思维和视角是投资理财的核心能力，在这个领域全是选择题，只有做对选择的概率高于做错的概率，才可能获得正收益。 这就是我选择一项长期计划时关于结果与收益的思考，而成长计划的收益，从经济价值来说，都是远期收益，是为了变得更值钱。也许期望的结果达成，目标实现，真的会变得更值钱，就像上面例子里的大刘。但也可能没能实现目标，那么你还能收获什么？也许有来自过程的体验，这也是选择目标时，源自内心和兴趣是如此重要的原因。 在考虑付出与收获时，后来读到一句话，大意如下： 生活也许不会像计划那样发生，但对待生活的态度可以是：期待伟大的事情发生，同时也要保持快乐和幸福，即使它没能发生。 如此，面对真实的生活，也当释然了。 最后，留个思考题：关于计划你感觉是束缚了你的生活，还是让你更自由了？ 19 障碍：从计划到坚持，再到坚持不下去的时候设定一个计划并不困难，真正的困难在于执行计划。若你能够坚持把计划执行下去，想必就能超越绝大部分人，因为大部分人的计划最终都半途而废了。 为什么那么多计划都半途而废了？在执行计划时，你会碰到怎样的障碍？我想从计划生命周期的各个阶段来分析下。 酝酿酝酿期，是计划的早期雏形阶段；这阶段最大的障碍来自内心：理性与感性的冲突。 计划的目标是源自内心的，但也是有难度的，若是轻而易举的事情，也就不用计划了。这些需要坚持的事情，通常都 “不好玩”，而人是有惰性的，内心里其实并不愿意去做，这是我们感性的部分。但理性告诉我们，去完成这些计划，对自己是有长远好处的。这，就是冲突的地方。 就以我自己写作的例子来看，我不是一开始就写作的，我是工作了 5 年后，碰到了平台期，撞上了天花板，感觉颇为迷茫。于是就跑到网上到处看看有没有人分享些经验，找找道路。然后，看到了一些 “大神” 们写的博客，分享了他们一路走过的经历，在我迷茫与灰暗的那个阶段的航行中，就像一盏灯塔指引着前进方向。 于是我在想，也许我也可以开始写写东西。那时，内心里出现了两个声音，一个声音说：“你现在能写什么呢？有什么值得写的吗？有人看吗？”而另一个声音反驳说：“写，好过不写，写作是一件正确的事，就算没人看，也是对自己一个时期的思考和总结。” 最终，理性占了上风，开启了写作计划，然后注册了一个博客，想了一句签名：“写下、记下、留下”。 启动启动期，是计划从静止到运动的早期阶段；这阶段的最大障碍是所谓的“最大静摩擦力”。 我们都学过初中物理，知道 “最大静摩擦力” 是大于 “滑动摩擦力” 的，也就是说要让一个物体动起来所需要的推力，比它开始运动后要大一些。这个现象，放在启动一个计划上时，也有类似的感觉，所以才有一句俗语叫：“万事开头难”。 还是回到我开始写作那个例子，我的第 1 篇博客的写作过程，至今还记得很清楚：一个周六的下午，在租的小房间里整整写了一下午。写得很艰苦，总感觉写得不好，不满意。最后一看天都黑了，肚子也饿了，就勉勉强强把它发了出去。 发出去后的前两天，我也会经常去刷新，看看阅读量有多少，有没有人评论啊。让人失望的是，前一个声音的说法变成了事实：的确没什么人看。两天的点击量不到一百，一条评论也没有，而且这一百的阅读计数里，搞不好还有些是搜索引擎的爬虫抓取留下的。 但是，写完了第一篇，我终于克服了写作的 “最大静摩擦力” 开始动了起来，一直写到了今天，这已经过去了 7 年。 执行执行期，是计划实现过程中最漫长的阶段；这阶段的最大障碍就是容易困倦与乏味。 漫长的坚持过程期，大部分时候都是很无聊、乏味的，因为真实的人生就是这样，并没有那么多戏剧性的故事。所以，我在想这也许就是为什么那么多人爱看小说、电视剧和电影的原因吧，戏中的人物经历，总是更有戏剧性。 美国当代著名作家库尔特·冯内古特在一次谈话中谈及人生，他用了一组形象的类比来描述人生。我翻译过来并演绎了一下，如下面系列图示： 其中，纵坐标表示生活的幸福程度。越往上，代表幸福指数越高；越往下，代表幸福指数越低。中间的横线表示普通大众的平凡人生。 img 那么先来看一个大家都很熟悉的从 “丑小鸭” 变 “白天鹅”的故事：灰姑娘 。 img 我们从小就听过这个故事，人们喜欢这样的故事。同样的故事内核，被用在不同的故事里书写了上千次，传诵了上千年。这是一个皆大欢喜的故事，而下面则是一个稍微悲伤点的故事。 img 故事虽以悲剧开始，但好在以喜剧结束。人们也喜欢这样的故事，生活不就该这样吗？问题是，真实的生活可能是下面这样的。 img 没有那么多大起大落，我们大部分人的生活只是在经历一些平平凡凡的琐事。也许其中有些会让你感到高兴与兴奋，有些又让你感到烦躁与郁闷。但这些琐事都不会沉淀进历史中，被人们传诵上千年，它仅仅对你自己有意义。 所以呢，你明白为什么你感觉你的坚持那么无聊、单调与乏味了吧，大多数时候它都缺乏像 “灰姑娘” 故事曲线的戏剧性。而对抗这种过程的无聊，恰恰需要的就是故事。你看人类的历史上为什么要创造这么多戏剧性的故事，让这些戏剧性的故事包围了我们的生活，让人们想象生活充满了戏剧性，这种想象是治疗乏味的良药，也成为了创造更美好生活的动力。 万维钢的一篇文章《坚持坚持再坚持》里也提到： 故事的价值不在于真实准确，而在于提供人生的意义。 坚持，特别是长期的坚持，是需要动力的，而动力来自目标和意义。而获得目标与意义的最好方式是讲好一个故事。你看，成功的企业家会把未来的愿景包进一个美好的故事里，让自己深信不疑；然后再把这个故事传播出去，把所有相信这个故事的人聚在一起去追寻这个故事；最后，这个关于未来的故事就这样在现实中发生了。 漫长的人生，你需要为自己讲好一个故事。 挫败挫败，不是一个阶段，而是坚持路上的一些点；正是在这些点上你遭遇了巨大的挫败感。 为什么会产生挫败感？可能的原因有，一开始你就不知道这件事有多难，直到走了一段后才发现这太难了。一开始就评估清楚一个计划的难度，需要投入大量的时间、经历和金钱，甚或有更高的技能与能力要求，这本身就是一件不容易的事。 而如果你计划的是一件从来没做过的事情，这就更难准确评估了。在路上，行至中途遭遇 “低估” 的挫败感就再正常不过了，而不少人，因为挫败过一两次后，就会放弃了计划。有时，遭遇挫败，选择了放弃，这个未必就是不合适的，但这要看这个放弃的决策是在什么情况下做出的。 遭遇挫败，你会进入一种心情与情绪的低谷，这个时候有很高的概率做出放弃的决策。而我的经验是，不要在挫败的情绪低谷期进行任何的选择与决策。可以暂时放下这件事，等待情绪回归到正常，再重新理性地评估计划还是否该坚持。 每经历一次挫败之后，你还选择坚持，那么就已经收获了成长。 最后总结来说，就是：你为了做成一件事，定一个计划，在执行计划的过程中，在 “酝酿”“启动” 和 “执行” 的不同阶段都会碰到各种障碍，可能都会让你产生一种快坚持不下去了的感觉。每到此时，你都要想想清楚，哪些是真正客观的障碍？哪些是主观的退却？ 从坚持到持续，就是试图让现实的生活进入童话的过程，而后童话又变成了现实。 本文分析了计划的执行障碍，最后我也想问问你，在你成长的路上，遭遇过哪些障碍？是什么原因让你坚持不下去了的？ 20 执行：从坚持到持续，再到形成自己的节奏有了一个目标后，我们通常会做好全方位的计划，并满心期待启动它，本想着朝着既定目标“一骑红尘飞奔而去”。但计划赶不上变化，很多时候，执行了一段时间后，我们可能会觉得比较累，有种快坚持不下去了的感觉，然后就半途而废了。这种场景我们每个人应该都不陌生。 其实，在执行过程中，容易半途而废的一个很可能的原因在于节奏出了问题。 计划的节奏一个计划被制定出来后，我们通常会根据它的周期设定一个执行的节奏。 长期，就像长跑，跑五千米是长跑，跑马拉松（四万多米）也是长跑，但我们知道跑五千米和跑拉松肯定是用不同的节奏在跑。 一个长期的目标可以是五年，也可以是十年，因目标而异。要精熟一门技能领域，比如编程，确切地说应该是编程中的某一分支领域，对于一般人来说，可能就需要三五年不等了。而像精通一门外语，可能需要的时间更长，我是从初中开始学习英语的，如今二十多年过去了，别说精，可能连熟都谈不上。 于我而言，可能因为编程技能是要解决吃饭温饱的需要，刚需比较强烈；而英语这么多年，都是考试的需要，刚需太弱，故二者的学习和练习节奏完全不同，最后学习掌握的能力也相差甚远。 一个中期的目标，也许是一年。比如，计划用一年时间写一本书，假如一本书 20 万字，那每周大约需要完成 4000 字，再细化到每天就是 800 字左右。这就是我们做一年计划的方式，计划成型后，相应做出分解，分解到周这个级别后，基本的计划节奏就出来了。 一个短期的目标，可能是几个月。比如，我这个 “极客时间” 专栏，计划就是几个月内完成的事情。它上面已经形成了每周三篇更新的节奏，这样的写作节奏对于我来说基本已经算是全力冲刺了，所以时间就不能拉得太长。 不同周期的计划，都会有一个共同的问题：计划总是过于乐观了，现实的执行很难完全符合计划。 你可能也遇到过，计划的节奏总是会被现实的“意外”打断，每次计划的节奏被打断后，都会陷入一种内疚的挫败感中；然后就强迫自己去完成每日计划列表中的每一项，否则不休息，最终也许是获得了数量，但失去了质量。在这样的挫败中纠结了几次后，你慢慢就会发现，现实总是比计划中的理想情况复杂多变。 不过，这才是真实的人生。偶尔错过计划没什么大不了的，如果人生都是按计划来实现，那岂不也有些无聊。 万维钢有篇文章叫《喜欢 = 熟悉 + 意外》，这篇文章下有位读者留言说： 贾宝玉第一次见到林黛玉说的第一句话就是 “这个妹妹好像在哪儿见过似的”。有点熟悉，也有点意外，这就是喜欢了。 所以，当“意外”出现时你不必感到太过闹心，试着换个角度来看，这偶尔出现的“意外”也许会反而让你更喜欢这样的人生呢。 计划更多是给予预期和方向，去锚定现实的走向，但在行进的过程中，“意外” 难免会出现。所以，你要从心理上接受它，并从行为上合理地应对它。 下面我就来说说我是怎么应对这些“意外”的。 按程序员的思考方式，我会为所有计划中的事情创建了一个优先级队列，每次都只取一件最高优先级的事情来做。而现实总会有临时更高优先级的 “意外” 紧急事件插入，处理完临时的紧急事件，队列中经常还满满地排着很多本来计划当天要做的事情。 以前，我总是尝试去清空队列，不清空不休息，但实际上这很容易让人产生精疲力竭的感觉。如今，我对每个计划内的事情对应了一个大致的时间段，如果被现实干扰，错过了这个时间段，没能做成这件计划内的事情，就跳过了，一天下来到点就休息，也不再内疚了。 举例来说，我计划今晚会看看书或写篇文章，但如果这天加班了，或者被其他活动耽误了，这件计划中的事情也就不做了。但第二天，这件事依然会进入队列中，并不会因为中断过就放弃了。只要在队列里，没有其他事情干扰，到了对应的时间段就会去执行。 计划的节奏，就像中学物理课上假设的理想的无摩擦力环境，而现实中，摩擦力则总是难以避免的，所以你要学会慢慢习惯并适应这真实而有点“意外”的节奏。 他人的节奏跑马拉松的时候，一大群人一起出发，最后到达终点时却是稀稀拉拉。这说明每个人的节奏是不同的，即便同一人在不同阶段的节奏也是不一样。 同理，就拿我的写作节奏来说，在七年中也慢慢从每月一篇提升到了每周一篇。当然，有些微信公众号的作者写作速度一直都很快，可能是每天一篇。但如果我要用他们的节奏去写作，可能一开始坚持不了多久就会放弃写作这件事了。 所以，从写作这件长期的事情中，我收获的关于节奏的体会是：每个人都会有自己不同的节奏，这需要自己去摸索、练习，并慢慢提升。如果开始的节奏太快，可能很快就会疲惫、倦怠，很容易放弃；但如果一直节奏都很慢，则会达不到练习与提升的效果，变成了浪费时间。 执行长期计划，就如同跑马拉松，本来是一群人一起出发，慢慢地大家拉开了距离，再之后你甚至前后都看不到人了。是的，正如《那些匀速奔跑的人你永远都追不上》那篇文章所说： 匀速奔跑的人是那些可以耐住寂寞的人，试想当你按照自己的节奏持之以恒默默努力地去做一件事情时，是极少会有伙伴同行的，因为大家的节奏各不一样，即便偶尔会有也只是陪你走过一段。 但有时，我们看见别人跑得太快没了踪影，心里会很是焦急。我们身边有太多这样的人，把一切都当成是任务，必须要在某个确定的时间做完它，必须要在一个规定的时间内取得它应有的效益。 的确，我们的世界变化太快了，快到我们都怕浪费一分一秒，快到我们被这个世界的节奏所裹挟，所以就逼迫自己去努力，去完成，去改变，但却完全失去了自己的节奏，直到我们决定随它去吧，和大家随波逐流就好。 有时太急迫地“追赶”，最后反而阻挡了你稳步前进的步伐和节奏。 自己的节奏找到并控制好自己的节奏，才能长期匀速地奔跑，才能更高效地利用好自己的时间和注意力。 对于每日计划的执行节奏，我自己的经验是：把自己的时间安排成一段一段的，高度集中和高度分心交叉分布。 假如某段时间需要高度集中注意力，就可以处理或思考一些比较难的事情。比如，50 ～ 60 分钟，集中注意力处理工作事务，远离手机信息推送及其他各种环境的打扰；然后休息一会儿，10 ～ 15 分钟左右，回复一些聊天或邮件这类其实不需要那么高注意力的事情。 有时，当你想去处理一件复杂困难的事情，比如写作，这是一种短时间内需要高度集中注意力的活动，但这时脑中总是在同时想着其他很多事情或者被动地接收一些环境信息（周围的谈话声之类的），还控制不住，很难集中注意力。这种情况下，就不用勉强开始，我通常会通过切换环境，从外部去排除一些干扰。 另外，如果感觉是比较疲惫，则更不能马上开始了，这种状态下，一般我都是立刻去小憩片刻或者闭目养神一段时间（20 ～ 30 分钟），进入一种浅睡眠状态再恢复过来，精力的恢复感会比较好。 恢复精力，我的感觉是浅睡优于深度睡眠，一是因为进入深度睡眠需要更长的时间，二是因为从中恢复过来也需要更长时间。所以，一旦进入深度睡眠，中途被人打断叫醒，会感觉非常困倦，我想很多人都有过这种感觉，俗称：睡过头了。 而另外一种中长期目标的执行节奏，控制起来可能要更困难一些。 比如，我们大部分人人生中第一阶段的奔跑目标：高考。为了奔向高考这个目标，我们有十二年时间进入学校，按照固定的节奏学习。一开始轻松些，跑得随意些；慢慢长大后，学业的压力开始明显起来，竞争的味道开始浓厚起来。特别是进入高中后，所有的同学都开始加速奔跑，以这样一种被设计好的节奏奔向目标。 这高考之前的学习节奏，更多是被整个社会和教育体系设计好的。我们只是在适应这个节奏，适应得很好的学生，高考一般都会取得不错的成绩；当然也有适应不了的同学，甚至有到不了参加高考就已经离开了赛道的。 在这个过程中，外界会给予我们一些期望的节奏压力，但要取得最好的效果，我们还是要找到自己的节奏。节奏是我们能长期持续奔跑的很重要的因素。还好高考结束后，再没有一个固定的时间点，也没有那么强大的外部环境去制约甚至强迫改变我们的节奏。 有时，只需要有一个目标，制一个计划，然后持续按自己的节奏跑下去。 找到自己的节奏，就是在每天略感挑战的状态下，形成不断加速前行，直到一个最终接近匀速的状态。匀速是我们能长期坚持的临界点，它能让我们跑得更久，跑得更远。 至此，关于计划一节的内容就全部结束了，我在文中分享了一些我的长期计划。那你有怎样的计划呢？是在用怎样的节奏去执行并完成它呢？ 21 信息：过载与有效至此，专栏已用 6 篇文章讲完了我关于“计划体系”这个主题的理解与思考 ，你是不是已经有点按捺不住想要赶快上路实践了？不急，接下来分享的主题是关于 “精进思维” 的，它会让你在按计划上路时，会有更好的跑步姿态，从而跑得更轻松、更有效率。 在我刚开始学编程时，国内还没有互联网，去到书店，发现偌大的书店就只能找到两本关于程序语言的书。那时感觉，想学点新东西，信息真是相当匮乏。而现如今，国内互联网已经发展了二十余年，信息早已不再匮乏，甚至是到了让人感觉过载的时代。 现状：信息过载信息时代，作为离信息距离最近的职业之一，程序员应该最能感受这个时代的信息洪流与知识迭代的速度有多快。 据 IDC（国际数据公司）研究报告：现在每 48 小时所产生的数据量，相当于从人类文明开始到 2003 年累计的数据总量。而每年产生的信息数据量还在不断增长，但我们处理信息的能力，特别是大脑接收信息，并将其消化为知识的能力，这么多年来并没有多少提升。 信息数据量的高速增长，也带来了处理信息技术的快速发展，所以新技术层出不穷，而且现有的技术也开始在其深度和广度领域不断地开疆拓土。 这样的发展状况说明了一个现实：我们没办法掌握这一切。别说“一切”，其实更符合实际的情况是，我们仅仅掌握了已有信息和知识领域中非常微小的一部分。 在信息大爆炸的时代，我们对信息越发敏锐，信息就越会主动吸引我们，让我们产生一种过载的感觉。 状态：疲于奔命在面对这股信息与知识的洪流时，有时我们会不自觉地就进入到了 “疲于奔命”模式中。 因为每天感觉有太多的信息要处理，太多的知识想学习。计划表排得满满的，似乎每天没能完成当天的计划，就会产生焦虑感，造成了日复一日的 “疲于奔命” 状态。 曾经，我就处在过这样的状态中，逼得过于紧迫，再奔命也只能被这股洪流远远抛下。总是焦虑着完成更多，划掉 TODO List 上更多的事项，希望每日带着超额完成计划的充实与满足感入睡，最后这一切不过是一种疲于奔命带来的虚幻满足感。 如今算是搞清楚了，这种紧绷的状态并不利于我们的学习和成长，这可以从大脑工作的生理机制得到侧面的佐证。 2017 年 2 月，国外著名《科学》期刊发表的一个研究成果表明，我们的大脑中存在约 860 亿神经元，神经元之间会形成连接，连接的点有个专有名词：突触，而每个神经元会和别的神经元形成大约 1000 个突触；大脑不断接收并输入信息，突触就会变强大，体积也会变大。但突触不能无限加强、变大，要不然就会饱和，甚至 “烧毁”，这就是大脑生理层面的 “信息过载”。 突触饱和了，再继续摄入和接收信息，此时我们就很难再学习到并留存下新的东西了，所以为了保持大脑学习新事物的能力，就必须要休息，而最好的休息则是睡眠。在睡眠中，突触会被修剪，神经连接会被削弱。美国威斯康星大学麦迪逊分校的两位研究者发现，睡觉的时候，大脑里的突触会缩小将近 20%。 所以，在感觉大脑处于 “过载” 的疲倦中时，别“疲于奔命”，别硬撑，最好的办法就是去小憩片刻。 记得大学时代，那时喜欢玩组装机 DIY。当时穷，买不起或舍不得买高配的 CPU，就买低配的 CPU，然后自己跳线超频，让 CPU 工作在过载状态中。然后弄个软件，再跑个分，一种妥妥的性价比超高的满足感。 而大脑的工作模式就有点像 CPU，而人只要活着，大脑会一直工作，从不停止。 即使我们感觉并没有使用大脑，我们的大脑也会处于一种 “默认模式网络” 状态。这可类比于电脑 CPU 的空闲（Idle）模式：电脑 CPU 倒是可以进入接近 100% 的空闲，但大脑不会，它最低也会保持 20% 左右的利用率，即便我们在睡眠中。 在 “默认模式网络” 下，大脑还会有 20% 左右的利用率，它在做什么？实际上，这个状态下，大脑会去发掘过去的记忆，去畅想未来，在过去和未来之间建立连接。而在生理层面，大脑中会有新的神经连接形成，这样的新连接，就是我们创造力的来源。 进入了疲于奔命状态，其实我们就在不断给大脑喂任务，且不停地切换大脑任务，让它永远处于繁忙甚至超频状态。这样每个任务的执行效率都会下降且效果也不佳，所以导致执行任务的时间反而延长了，这就给我们营造了一种“忙碌、充实而疲倦”的虚幻假象。 人脑毕竟不是 CPU，它需要休息，持续的过载与奔命，并不能让我们学会更多，但却会减少我们创造新的可能。 筛选：心智模型面对大量的信息和知识，我们该如何应对？这可以从两个角度来考虑： 信息和知识本身的价值 我需要怎样的信息和知识 第一点，信息和知识的价值是一个主观的判断，有一个客观点的因子是获取门槛。如果一个信息或知识随处可得，大家都能接触到，甚至变得很热门，那么其价值可能就不大。吴军老师有一篇文章讲了个道理叫：“众利勿为，众争勿往”，这在对信息和知识价值的主观判断上也是通用的。 第二点，就提出了一个关于如何筛选信息和知识的问题。心理学上有一个 “心智模型” ： “心智模型” 是用于解释个体对现实世界中某事所运作的内在认知历程，它在有限的领域知识和有限的信息处理能力上，产生合理的解释。 每个人都有这样的 “心智模型”，用来处理信息，解释行为，做出决策。不过只有少部分人会更理性地认知到这个模型的存在，而且不断通过吸收相关信息和知识来完善这个模型；更多的众人依赖的是所谓的 “感觉” 和 “直觉”。但实际上 “感觉” 和 “直觉” 也是 “心智模型” 产生的一种快捷方式，只是他们没有理性地认知到这一点。 理解了如上对 “心智模型” 的描述，是不是感觉它和如今人工智能领域的机器学习模型有点异曲同工之处？我们可以将这两者作以类比。它们都是接收信息和数据，得到模型，再对未知做出预测和判断。只不过人的 “心智模型” 却又比现在所有的人工智能模型都高级，高级到如今还无法用科学来清晰地描述与解释清楚。 理解了以上两点，再把大量的信息和知识限定在我们所处的程序领域，就会得到一个合理的答案。 当我刚进入程序员这行时，就一直存在有关 “超级程序员” 的传说，似乎 “超级程序员” 无所不能，各种语言信手拈来，所到之处，Bug 都要退避三舍。江湖总有他们的传闻，但谁也没见过。 后来慢慢开始明白了，那些 “超级程序员” 也仅仅是在一两个专业知识领域深耕的年头比较久，做出了一些脍炙人口且享誉程序界的好作品，他们在其专业领域拥有精深的专业知识和技能，同时也有大量通用的一般知识储备，适用于跨专业范围的程序领域中。因此，在这个信息过载的洪流中，需要的就是在这股洪流中筛选信息并建立自己中流砥柱般的 “知识磐石”。 “心智” 这两个字合在一起是一个意思，分开为 “心” 和 “智” 两个字又可以分别解释为：“心” 是你对需要的选择，从心出发；“智” 是对价值的判断，智力的匹配。 应用：一击中的储备了信息，建立了知识，最终都是为了应用。 囤积信息，学习知识，如果不能被应用在改变自己上，那还有什么意义？ 没有目的的学习是徒劳的，它仅仅是在我们的头脑中流过一遍，流过的痕迹很快又会被新的信息冲刷干净。不管我们拥有怎样的 “最强大脑”，在面对这股信息与知识洪流时，都几乎可忽略不计。 大脑确实和计算机的 CPU 有很多类似之处，比如它也有一个缓存单元：长短期记忆，类似 CPU 的多级缓存；它还有一个计算单元，用于任务处理与决策。这让我联想到像 Java JVM 的实现中有一种实时编译技术叫 JIT（Just-In-Time），它会根据代码的调用量来决定是否进行编译执行。而对于知识学习，我们也可以采用类似的策略，到底哪些知识需要提前编译储备在大脑中，哪些仅在特定场景触发下才需要 “实时编译”去边学边用。 毕竟未来充满了太多的未知和意外，我们没法提前储备太多。 而前文也提到大脑不适合长期持续地满负荷运转，这与我自己的真实感受是一致的。我感觉如果一次性让大脑满负荷（100%）运转达到 4 小时左右，就会感到很疲劳。而做不同的事情对大脑的利用率是不同的，下图结合自身感受画出了一个我自己的大脑消耗率示意图： img 所以，这里就要有选择和取舍。万维钢的一篇文章中有句话是这么说的： 注意力是一种有限的资源，你要是不擅长不集中注意力，你就不擅长集中注意力。 你得挑选那些真正值得做和学的东西去让大脑满负荷运转，但凡投入决心去做的事情，就需要百分百投入。这就是专注于少而精的东西，深入了解这些东西，进入到更深的层次上。深可以无止境，那到底多深才合适？我的答案是：让你的内心对取得的效果感受到满意的深度层次上。它的反面是：但凡心存疑虑，不是那么确定要全力投入的事情，干脆就不做了。 以前写一篇文章，我会给一个合理的时限要求。比如高考作文 800 字，要在 50 ～ 60 分钟内完成。而我每篇文章一般在 2000 ～ 3000 字，我给的时限也就在 3 小时左右。因为安排了这 3 小时，其他时间按计划还要干别的，但这个安排一直让我很焦虑，因为经常性写超时。 现在明白了，写作本来是一件创造性的活动，一件 “脑耗率” 100% 的活动，需要百分百的投入，最终效果远重于时限。即便我在 2 小时写完了，但效果能达到让我内心取得满意的深度层次么？（题外话，每篇专栏文章的写作和反复修改，平均要 6 ～ 10 小时。） 做得多和做得好的感觉很不一样。就像拳击，多，好似不停挥拳，很快就精疲力竭；好，则是看准目标，抓住机会全力出击，一击中的。 最后，总结下在信息爆炸的时代，我们该如何有效处理、吸收和消化信息： 信息过载是现实； 疲于奔命是陷阱； 心智模型是方法； 一击中的是策略。 那关于信息处理的有效方法和模型，你目前采用的是怎样的好办法呢？欢迎留言分享，我们相互学习下。 22 领域：知识与体系今年年初，我学习了梁宁的《产品思维》课，其中有一篇叫《点线面体的战略选择》，我觉得特别有感触。虽然是讲产品，但假如把个人的成长当成产品演进一样来发展，会有一种异曲同工、殊途同归之感。 在我工作的经历中就曾碰到过这么一个人，他一开始做了几年开发，从前端到后端，后来又转做测试，接触的“点”倒是不少，但却没能连接起来形成自己的体系，那他个人最大的价值就局限在最后所在的“点”上了。 其实个人的成长有很多方面，但对于程序员的成长最重要的就是知识体系的构建，这其实就是一个 “点线面体” 的演进过程。 下面我会结合自己的成长路线来梳理下这个体系的建立过程。 点进入任何一个知识领域，都是从一个点开始的。 如下图，是我从大学进入软件开发领域所接触的一系列的点，我将其从左到右按时间顺序排列。红色的部分是目前还属于我 “掌握” 与 “了解” 的领域，其他灰色的部分则是要么被时代淘汰了，要么已经被我放弃了维持与更新。 img 我的成长时间线上相关技术领域知识点 我入行的年代，流行的是 C/S 架构的软件开发模型。当时客户端开发三剑客是 PB（PowerBuilder）、VB（Visual Basic）和 Delphi，而我只是顺势选了其中的一两个点，然后开启了程序员生涯。 没过两年 B/S 架构开始流行，并逐步取代了 C/S 架构。于我，只是因为研究生阶段学校开了一门面向对象语言课，老师用 Java 做教学语言，所以我后来就又顺势成了一名 Java 程序员。而又只是因为 Java 的生命力特别旺盛，所以也就延续至今。 早些年，前后端还没太分离时，因为项目需要，所以我又去涉猎了一些前端 JS 开发；之后移动互联网崛起，又去学习了些移动开发的东西；再之后就是 ABC 的时代（其中 A 是 AI ，人工智能；B 是 Big Data，大数据；C 是 Cloud，云计算），就又被潮流裹挟去追逐新的技术浪潮。 如今回过头再看，每一个技术点，似乎都是自己选择的，但又感觉只是一种被趋势推动的一次次无意“捡起”。有些点之间有先后的承接关系，而更多点都慢慢变成了孤点，从这片技术的星空中暗淡了下去。 在你入行后，我想你可能也会因为时代、公司或项目的原因，有很大的随机性去接触很多不同的技术点。但如果你总是这样被客观的原因驱动去随机点亮不同的 “点”，那么你终究会感到有点疲于奔命，永远追不上技术的浪潮。 线当形成的点足够多了后，一部分点开始形成线，而另一些点则在技术趋势的演进中被自然淘汰或自己主动战略放弃。 那你到底该如何把这些零散的点串成线，形成自己的体系与方向呢？如下图，是我的一个成长 “T 线图”，它串联了如今我沉淀下来的和一些新发展的 “点”。 img 我个人的成长发展 “T 线图” 我从成为了一名 Java 程序员开始，在这条 “T 线” 上，先向下走，专注于解决业务需求碰到的技术问题。先自然地要向下至少走一层，接触 Java 的运行平台 JVM。而又因为早期做了几年电信项目，要和很多网络设备（包括各类网元和交换机等）通信，接触网络协议编程；后来又做了即时消息（IM）领域的工作，网络这一块就又继续增强了。而网络编程依赖于操作系统提供的 I/O 模型和 API，自然绕不过 OS 这一块。 在 Java 领域走了多年以后，以前涉猎的技术点就逐步暗淡了。而再从程序员到架构师，就开始往上走，进入更纯粹的 “架构与设计” 领域，在更宽的范围和更高的维度评估技术方案，做出技术决策与权衡，设定技术演进路线。 但是，再好的技术方案，再完美的架构，如果没有承载更有意义的业务与产品形态，它们的价值和作用就体现不了。所以不可避免，再往上走时就会去了解并评估 “业务与产品”，关注目标的价值、路径的有效性与合理性。 在整个纵向的技术线上，最终汇总到顶点，会形成一种新的能力，也就是我对这条纵向线的 “掌控力”。到了这个 “点” 后，在这里可以横向发展，如图中，也就有了新的能力域：领导力和组织力。 一个个点，构成了基本的价值点，这些点串起来，就形成了更大的价值输出链条。在这条路上，你也会有一条属于自己的 “T 线”，当这条线成型后，你的价值也将变得更大。 面线的交织，将形成面。 当我试着把我最近六年多在电商客服和即时通讯领域的工作画出来后，它就织就了下面（如图所示）的这个“面”。 img 我近些年工作面的分层图 我从最早的聚焦于某个业务点和技术栈，逐步延伸扩展到整个面。因为 IM 这个产品本身具备很深的技术栈，而且也有足够多元化的应用场景，这样整个面就可以铺得特别宽广。这也是为什么我已经在这个面上耕耘了六年多之久。 但事实上，我并不掌握这个面上的每个点，整个团队才会分布工作在整个面上，每个个体贡献者也只会具体工作在这个面上的某个或某些点。但我们需要去认清整个面的价值体系，这样才能更好地选择和切入工作的点，创造更大的价值。 而有时候，我也了解到有些程序员的一些说法是这样的：在相对传统的行业，做偏业务的开发，技术栈相对固定且老化，难度和深度都不高，看不到发展方向，期望找到突破口。若你也出现这样的情况，那就说明你从事的业务开发，其单个技术点的价值上限较低，而选择更新、更流行的技术，你就是期望提升单个技术点的价值，但单个技术点的价值是相对有限的。 反过来，如果很难跳脱出自身环境的局限，那么也可以不局限于技术，去考虑这些传统的业务价值，从技术到业务，再上升到用户的接入触达，考虑产品的场景、形态和人群是如何去为这些用户提供的服务、产生的价值。 当你对整个业务面上的价值点掌握的更多，能抓住和把握核心的价值链条，去为更广、更大的价值负责，那么你就能克服自己的成长发展困境，找到了另外一条出路了。 同时，你也为自己织就了一张更大的领域之网。在整个面形成了一个领域，在这个面上你所能掌控的每条线就是你的体系。在这条线的 “点” 上，你解决具体问题，是做解答题；但在整个面上你选择 “线”，是做选择题。 体体是经济体或其中的单元。 你的 “面” 附着在什么 “体” 上决定了它的价值上限。如果 “体” 在高速增长并形成趋势，你就可能获得更快的发展。 从电力时代到信息时代再到智能时代，互联网、电商、移动互联网，这些都是 “体” 的变化。今天互联网行业的软件工程师，他们面临的挑战和难度不见得比传统的机械或电力工程师更大，只不过他们所从事的 “点” 所属的 “面”，附着于一个快速崛起的 “体” 上，获得了更大的加速度。 “体” 的崛起，是时代的机遇。 总结来说，就是：在领域知识体系中，“点” 是利器，“线” 是路径，“面” 是地图；而就我们个体而言，“点” 是孤立知识点的学习掌握，而 “线” 是对这些点的连接，“面” 则构成了完整的知识体系网。 以上就是我建立知识体系并形成自己领域的思考。而在每个不同的阶段，你都可以先做到心中有图，再来画“线”，然后再在每个“点”上去努力。 23 转化：能力与输出个人，建立好了知识体系，各方面都明了了，但有时做起事来却还会感觉发挥不出来；团队，牛人众多，但感觉做出的事情效果却很一般。 这类问题的症结，多就出在从体系积累到输出转化的环节，它涉及两个实体的转化问题： 个体 团队 个体关于个体的能力转化，我想先讲一个发生在我自己身上的故事，通过类比想必你就能很快明白这个道理。 前几年有几部华语电影，比如《叶问》《一代宗师》等，都是和一个人、一套功夫有关；而从前年到去年的一段时间，在我身上正好就发生了这么一件计划外的事情，我去接触学习了一下咏春。练拳这个事，一开始就不在我计划内，甚至也不算是兴趣内的事，但它就这么发生了，然后还意外地让我有了一些收获。 在刚开始时，我的确对咏春有很多疑惑，但好在并不排斥。一开始老师并没有教什么招式套路，而是从架构开始。既然是功夫，当然这个 “架构” 就是指身体架构了。为什么不讲招式，而是讲架构？这也是我最初的疑惑。随后，老师用一个生动的示例说明了缘由。 老师先拿上一个挡在胸前上的沙包，让我们挥拳全力击打，他来挡住。然后我们就全力挥拳了，阵势倒是挺大，打在沙包上也砰砰脆响，但老师纹丝不动。反过来，该我拿沙包挡在胸前了，老师出拳，拳头接触沙包后发出沉闷的响声，我用尽全身力气也站不住，连连后退，直到碰到墙边才止住退势，并且胸口还隐隐作痛。 好吧，以上描写，有点武侠小说的感觉了，但实际并无夸张。以后每次老师演示沙包架构教学，各位同学都连连谦让起来。这里面的原理后来听老师讲解才算明了：我们平常出拳基本都是用的臂力，力量不会太大；而老师出拳用的是身体之力，借助身体架构发全身之力。 力，从脚底触地而起，由腿上腰，扭腰推至背肩，再甩肩推臂，经腕至拳，最后触及被击打之物。在这个过程中，全身都会随这股力量而动，借助全身体重的推动力，会大幅度地放大这股力量。这股力量甚至超过了他的体重，试想一个成年人那么重的力量推向你，你如何能接得住？ 后来，我了解到，经过职业训练的拳击手，正常挥出重拳的力量可以是体重的好几倍。而我们普通人挥拳只用手臂发力，只有体重的几分之一。因为我们没有经过身体架构的训练，所以身体架构各自配合脱节，力量便耗散在了过程之中，而发不出全身之力。 身体是一个系统，身体架构是一个体系，这个体系的输出能力便是出拳的力量。 要放大这个力量，就需要不断反复地去协调应用这个体系，并不断得到反馈修正，最后形成肌肉记忆的习惯，就像老师一挥拳就能爆发全身之力一样。而我练习了几个月，估计也没到半身之力，这个过程和所有技能的刻意练习过程一样，快不了。 同理，我们从学会一个知识，到能够熟练应用其去输出能力，大概会经历如下过程： img 所以，对于个体而言，刚建立起一个初步的知识体系，到能真正充分发挥出这个体系的力量，才仅仅是刚开始。 团队如果说个体的能力输出像出拳，那么团队的输出就像战争了。 在近年来大热的美剧《权力的游戏》中，一开始有两个家族，北方的狼家族和南方的狮家族，他们爆发了一场战争。战争之初，狼家族在战场上连战连胜，甚至一度俘虏了狮家族的重要人物，但后来突然急转直下，竟被人在战场之外全灭。 而战争其实是发生在两个体系（这里的体系是国家、家族和部落）之间的能力较量。每一个战场、每一场战役仅仅是体系中一些“点”的较量，虽然北境的狼家族一开始在战场上连连获胜，但他们这个内部体系的薄弱环节和问题远多于狮家族这个体系，因而在被人抓住关键节点后，一下就瓦解了。 团队这个体系比较复杂，即使个体的点很强，但仅仅是点的强化，也有可能不断赢了战役，但最后却输了整个战争。 去年也有一本大热的翻译书籍《原则》，该书的作者是雷·达里奥，他是世界最大对冲基金——桥水联合基金——的创始人。这本书描述了他的一个思想和实践，就是把公司当作 “机器” （原文是 Machine）来管理运转。 所以，在他看来管理者就像是工程师，而工程师维护机器运转的工作状态我们都能想象到，或通过机器的运行仪表盘监控机器的运转状态，或通过指标优化机器的运行效率。而达里奥的 “机器” 就是他建立的管理公司的体系。 曾经，我们团队有个高级测试工程师，在他晋升测试架构师级别的述职时，提到他的一项工作就是搭建测试体系来帮助团队改善测试工作的效率和效果。在进行阐述时，他完整地描述了这个体系 “机器” 的各个零部件组成，他制造的很多工具和系统，却缺失了关于体系的一些最重要的方面：这个体系是如何运转的？它提供了哪些系统和仪表盘监控指标来支撑和反映其运转状态？为什么这个体系能在团队里运转？ 以上三个问题，就反映了 “机器” 体系的三个核心点： 流程规则 工具系统 规范共识 没有流程规则，“机器” 体系就不知该如何运转；缺乏工具系统支撑，就没法监视和控制这个体系的运转效率与效果；而如果未能在团队形成共识并达成规范，“机器” 体系就不可能“和谐”运转起来。所以，流程规则，建立其运行轨道；工具系统，支撑其高效运行；规范共识，形成了协调合奏。 团队能力输出就是这样一个 “机器” 体系运行的过程。那么团队的强弱就由两方面决定，一是团队中所有个体形成的体系力量之和，二是由流程规则、工具系统和规范共识共同决定的转化效率。 转化从个体到团队，都是通过搭建体系来积蓄力量，再通过体系的运转来输出能力。 这里的共同思维方式是：体系化、工具化。这是一种标准的工程师思维模式，巧妙的是它依然可以用在非工程的领域。体系，从工程维度看就像生产流水线，而体系的运转就是开动了生产流水线。搭建并调校出一条高转化输出能力的体系生产线，是真正具有核心竞争力和护城河的事情。 前阵子，看到新闻说台积电计划投资 250 亿美元研发建设 5 纳米制造生产线，这个投资额很好地说明了搭建一个真正具有护城河级别竞争力的生产体系所需要的成本。而台积电正是靠着这样具有核心竞争力的生产体系，成为全球半导体生产制造的霸主，制造了全球 60% 的芯片。 所以我们也要像台积电学习，好好打磨出适合自己的体系，使其真正成为自己的核心竞争力。 要想产生更大的成果，取得更大的成功，我们需要找到放大个体或团队能力的杠杆支点。曾经，也许我们也做出过好的产品，产生过好的结果，可能是我们能力不错，但也有可能只是运气不错。也就是说，好产品或好结果并不能成为支点，不断产出好结果或好产品的 “体系流水线” 才是。 我们需要做的就是不断打磨这条流水线，提升转化输出好产品或好结果的效率与良品率。 个体和团队的强弱，一方面取决于我们在体系中积蓄的力量的总量，另一方面在于体系运作的转化输出率。体系决定了力量的总量，而转化决定了拳拳到肉的痛感。 每个人做事都存在转化输出率，读完本文，你对自己或所在团队的转化输出率的提升是否有了大概的方向？ 24 并行：工作与学习在工作中，你应该碰到过一些这样的情况，有同事工作的时间不短，经常加班加点，工作也很勤勉，但每每晋升时却碰壁了。你可能还会为其打抱不平过。难道这真的只是不公平或者运气不佳吗？ 其实这种情况，隐藏在背后更深层次的原因是：工作陷入了循环与重复，从此停止了成长。 那么，你该如何在工作的同时，保持学习，并持续成长与进阶呢？我想，可以先从分析“程序员的工作本质是什么”开始着手。 工作程序员的主要工作是：编程，产出代码，完成需求，交付程序系统。 程序员按其工作技能和经验，大体又分为三个阶段：初级、中级和高级。这三个级别的程序员的主要工作都是编程与产出代码，产出代码的数量也许相差不大，但产出的代码属性就可能有明显差别。 什么是代码属性？它包括资产与负债两类。由大量初级程序员产出的代码并以此构建的软件系统，如果最终能完成交付，那么很可能资产和负债性基本持平。这是很多早期创业公司产出代码的属性特征，因为创业公司早期缺乏资金和足够的知名度，难以吸引到又多又好的中、高级程序员加入。 这样的代码构建的系统多属于勉强满足业务需要，虽看不出明显的 Bug，但一遇到特殊情况就容易宕机。整个系统虽然勉强能支撑公司运营，但其中欠下了大量的技术债；先活下来，未来再来慢慢还。 若是完成了一个债务比资产还大的系统，会是个什么样的情况呢？那这就是一个还存在明显 Bug 的系统，是基本无法完成交付和上线的。 因此，现在互联网行业创业团队的主流做法，都是先完成一个资产和负债刚好过平衡点的系统，发布上线，接受反馈，再快速迭代，最后在迭代中不断地提升其资产性，降低其负债性。 这样的方式在行业里有一个实践的榜样：Facebook。它还有一句著名的标语： Done is better than perfect. 比完美更重要的是先完成。 但如果你仅停留于此，那工作就永远在完成，并不会走向完美。而且，工作的内容还会不断地重复，让你从此陷入成长的停滞区。 从初、中级走向高级程序员，就不仅仅是交付代码，完成工作，还要有后续的更高要求。如：达成品质、优化效率。而在不断晋级的路上，跨越的门槛就在于此，很多人比较容易被卡在不断地在完成工作，但却没有去反思、沉淀、迭代并改进，导致一直停留在了不断重复的怪圈之中。 程序员，工作以产出代码为主，从初级到高级，代码的负债属性逐步降低，资产属性不断提升，最终成为高品质的个人贡献者。而从完成到追求品质和完美的路上，不仅仅是靠工作实践的经验积累，还需要有意识地持续学习。 学习持续学习，是让你突破不断循环怪圈的不二法门。 在工作中，我一直有观察到一个现象，很多人因为离开学校后，工作任务多，压力大，从此就停止了系统地学习。在《浪潮之巅》一书中，吴军写道： 国内: 小时候努力，到大学后就不努力了。 国外: 到大学后才开始努力，很快就超过国内学生。 吴军这对比国内外的教育，也反映了我们教育中作为学生的一种心态，觉得毕业了，离开学校后就不需要多努力学习了。但目前程序员这个职业所面临的技术发展和更迭远超其他行业，你即便只是为了能够保质保量地完成任务，也需要保持持续学习的节奏。 现如今是个信息爆炸与知识过载时代，所以学习必须要有选择性。 我读大学那阵儿，学程序期间喜欢电脑，就爱帮同学人肉组装（DIY）个机什么的，而且还反复折腾安装操作系统。那时的 Windows 系统的特点之一就是越用越慢，一年半载就需要重装一次，所以可没少反复和折腾，分散了不少我的时间和精力，原本以为能主动学到新东西，但结果发现其实都是被动的。所以，学习还是要聚焦和主动选择，毕竟你的精力和时间都是有限的。 而有选择性的学习就需要找出真正与你近期规划有关的学习路径。 假如你工作入职后公司使用 Java 为主要开发语言，而大学里你一直学习使用 C 或 C++ 编程练习，这里再假设你对计算机相关的基础性学科和知识掌握良好，比如：操作系统、数据库、网络、组成原理、编译原理、算法基础、数据结构等等。那么为了更好地完成工作任务，就需要你先主动学习 Java 编程语言、开发框架等编程技术相关的知识。 而对于学习语言本身我觉得最高效的方法就是看一本该领域的经典入门书。比如，对于 Java 就是《Java 核心技术》或《Java 编程思想》，这是我称之为第一维度的书，聚焦于一个技术领域并讲得透彻清晰。 在有了该语言的一些实际编程和工程经验后，就可以看一些该领域第二维度的书，比如：《Effective Java》《UNIX 编程艺术》等，这些是聚焦于特定领域经验总结型的书，这类书最有价值的地方是其聚焦于领域的思想和思路。 如果过早地看这类书反而没什么帮助，甚至还会可能造成误解与困扰。例如，我看豆瓣上关于《UNIX 编程艺术》的书评，有这么一条：“很多例子和概念已经成了古董，当历史书看，无所获。”这显然就是过早接触了第二维度的书，却预期得到第一维度的收获，自然无所获了。 而另外一些技能，像 Java 开发工作需要大量使用的开源框架又该如何学习？张铁蕾曾写过一篇《技术的正宗与野路子》，其中介绍了如何用真正 “正宗” 的方式去学习并快速掌握这些层出不穷的开源新框架和技术。 这里就借用原文里的一张图（重新按统一风格绘制了下），每一项开源框架或技术相关的学习资料可以组织成下面这张金字塔形的结构图。 img 技术学习资料的层次结构示例图 Tutorial（指南） 和 API Reference（应用编程接口参考） 层次的信息资料能帮助你快速上手开发，而 Spec（技术规范）和 Code（源代码）会帮助你深刻地理解这门技术。而其他相关的技术书籍和文章其实是作为一种补充阅读，好的技术书籍和文章应该有官方资料中未涵盖的特定经验或实践才算值得一读。 张铁蕾在文中如是说： 每当我们接触一项新技术的时候，都要把手头的资料按照类似这样的一个金字塔结构进行分类。如果我们阅读了一些技术博客和技术书籍，那么也要清楚地知道它们涉及到的是金字塔中的哪些部分。 我深以为然，关于技术学习我们不能简单地蜻蜓点水、复制粘贴、拿来主义，应是去建立你的知识 “金字塔”，形成体系结构，而每次的学习实践都是在不断完善你的 “金字塔”。至于更多技术性学习的细节，若你感兴趣的话，也可以去看看那篇文章。 路径保持学习，不断成长，工作也许还在重复，但成长却在迭代上升，然后才会有机会面临更多可选择的路径。 程序员在攀登职场阶梯的道路上，走过了高级，后面还会有好些分叉路线。比如，转到脱离技术的纯管理岗或者技术管理岗。技术主管或架构师某种意义上都属于技术管理岗，不懂技术是做不了这两个角色的；或者继续沿着深度领域走，成为细分领域专家。 这后面哪条路适合你呢？你是随大流，还是自己认真思考和决定？这是做选择题。如果一生要工作三十多年，前十年你多在做解答题，解决一个又一个问题。那么在大约走过这三分之一后，你就会开始做越来越多的选择题。为什么呢？因为一开始可能没有太多可供你选择的机会。而后续做好选择题，则需要大量学习，还需要不断地试错。 面对怎么选路的问题，我近些年学习的收获是这样的：选择走最适合实现个人价值的路。这就是我的基础选择价值观。程序员的个人价值该怎么实现？该如何最大化？程序员作为个人贡献者，到了一定的熟练阶段，产出基本就稳定了，而技能的成长却呈现对数曲线的增长特征。 任何一个你所尝试提升的事情都有一个增长曲线，这个曲线有两种形态： 对数增长形态：这种类型在初期增长很快，但随后进展就越发困难； 指数增长形态：这种类型在初期增长很慢，但存在积累的复利效应。 增长要么是对数形态，要么是指数形态，很少有线性的。 对数增长也意味着更容易退步，因为起步阶段是如此陡峭（见对数曲线示例图）。比如，学习一门新的技能，不持续去应用，很快就忘了，退回原点。那你应该如何应对这种“窘况”呢？我建议你在起初的高增长阶段，学习和工作的关注点需放在养成长期习惯上，因为虽然开始增长很快，但需要小心一旦停止努力它可能会向下滑落，所以一定要慎之又慎，坚持形成自己的习惯和节奏。 img 对数增长曲线示例 而指数增长则意味着存在一个拐点的 “突变” 时刻。很多人期望线性增长，但实际却是按指数增长的，这让许多人在拐点发生前就放弃了。比如，写作，在呈指数增长的领域内，到处都是半途而废者。所以，做本质是指数增长曲线的事情时，柔韧且持久的思维模式是关键。 img 指数增长曲线示例 工作多年后，技能的增长就又进入了对数的平缓区域，通常其回报呈现递减趋势。也就是说你在其上花的功夫越来越多，但你感到越来越难产生洞察以获得新的收益。其难处在于找到新的突破点，重新回到曲线陡峭上升的部分。 这就是所谓成长的瓶颈，你要学会应用指数增长的方法，找到价值贡献的放大器。作为程序员，你有可能很幸运地编写服务于数千万或数亿人的软件服务，这是产品自带的价值放大器。这样同是写一份代码，你的价值就是要比别人大很多。而转管理者或架构师，这些角色无非都是自带杠杆因子的，所以也有价值放大的作用。但个人能否适应得了这样的角色转换，又是另一回事了。 拉姆·查兰有本书叫《领导梯队》，书里把人才潜能分成三种：熟练潜能、成长潜能和转型潜能。原书对这三点做了详细的特征描述，我简单提炼下主要特点： 熟练潜能：关注当前专业领域且十分熟练，但没有显示出在开发新能力上的努力，竭力维持现有技能。 成长潜能：按需开发新能力，显示出高于当前层级要求的其他技能，如：专业、管理、领导。 转型潜能：持续有规律地开发新能力，追求跨层级的挑战和机会，展现雄心壮志。 人力资源管理中的高潜人才盘点，基本就来自这套模型，主要就是识别出这三类潜能人才。“熟练潜能” 已是我们这行对学习的最低要求，在程序员这个技术日新月异的行业里，维持现有技能确实已经让不少人感觉很竭力了。 那你拥有怎样的潜能呢？它不一定都是天赋，可能也是选择。 成长这条路从来都不是笔直的，你的“奔跑速度”也不会一直是匀速的。在每一个拐弯处，都应减速，思考，学习，然后再加速，进步。 到此我总结下今天的分享： 程序员的工作形式是编程产出代码，本质是完成需求，交付系统；但在工作中容易陷入不断完成的循环怪圈，要打破它，就需要你持续学习并有意识地关注交付代码的品质和属性，一方面提升了交付质量，另一方面也获得了个人成长。 而学习的路在时间上是永远持续的，在空间上也是有路径的；有效的学习需要你关注学习曲线的变化，遵循有体系的技术学习框架，匹配适合当前阶段的学习资源。 最后，关于工作和学习，有人总感觉有些冲突，忙起来就没时间学了。那你是怎么看待这件事呢？欢迎留言分享你的观点，我们一起探讨。 25 时间：塑造基石习惯（上）——感知与测量至此，咱们专栏已用 4 篇文章分享了我关于“精进思维”这个主题的理解与思考，期待以后你能得心应手并游刃有余地持续进阶。 接下来，咱们专栏又会进入一个新的主题：习惯。习惯的重要性想必你也很了然于胸了，习惯的养成，是让成长无意识自然发生的关键。然而习惯对于成长的具体作用是怎样的呢？ 想必你也知道，养成好的习惯能帮助我们更快地成长，而在所有的好习惯中，关于时间的习惯是其中的基础，我称之为 “基石” 习惯。如果你的时间习惯不好，那你做其他事情的效率往往也就不高。 那么，该如何塑造好时间这块 “基石”呢？我觉得在有效地应用之前，先需要精确地感知与测量。 感知时间有时，我们觉得时间过得很慢，慢如从周一到周五；有时，又会觉得时间飞逝，快到十年间一恍惚就过去了。 当我站在十年后的这端看十年前的那一端，会惊讶地感叹：啊，时间过得真快！再把时间往前推一点，十多年前，将从学校毕业，走上社会工作岗位，我当时有想过十年后会如何吗？有过怎样的畅想呢？我依稀记得应该是畅想过的，才刚毕业怎么可能不畅想一下即将走出校园，怀揣理想，人生豪迈，激情万丈的未来之路呢？ 对，我确实畅想过，可遗憾的是我只能模糊记得有过畅想这回事，而到底畅想过什么具体的内容，却大多记不太清了。唯一还有印象的是，毕业前夕的一个凌晨，月挂高空，星光惆怅，一屋子的室友在校园的花台前，喝着啤酒，畅谈明日的分离，未来将会如何如何，十年后我们还会相约在此见面，再分享一下彼此的人生。 十年过后，当时也有同学记起这个约定，就号召大家再回校园共聚一场。而我却未能赴约，当时正好孩子出生尚在医院，现实的粘连总会拖住理想的浪漫。江湖侠客分别时总喜欢说句：十年之后我们再会于此，就此别过，后会有期。可实际，很多别过都是后会无期的，我们从来不是侠客只是凡人，谁又能轻易承诺得了十年之约。 我还能记起这个看似简单的十年之约，却已然记不起当初对未来十年之路作过何样的畅想与规划。苦苦回忆之后，只觉得当初作为一名软件工程专业的毕业生是清晰地知道最近的将来是会成为一名程序员的，而对于程序员的未来我当初应该想的就是架构师吧。 也许当时我觉得架构师就是一个程序员的顶点，是我能看得到的顶点。而实际情况是这个架构师的称呼也只是当时我从几本翻译的国外技术书籍中的人物介绍中看来的，到我实际工作后却发现前三、四年所在的两个公司都没有架构师这个职位。理论上来说当时我应该感到迷茫，实际却没有，可能因为觉着还太遥远，所以我就不管不顾地走在当下的路上，活在当下。 当你对生活有某种期待与畅想，却又觉得明天实现不了，三个月也实现不了，一年后大概还是实现不了，然后可能你就会不由自主地想大概十年后也许就能实现了。你会以为十年很长，把现在的期望与畅想交托给十年后的未来。 十年也许是一个足够长的时间，长到对个人来说很难去做一个十年的计划，所以我们就这样经常把很多很多的期待放在了十年后，把期待交给了时间。 所以，当我再次回顾彼时彼刻，虽然想不起太具体的当初对十年后期待的内容，但我依然能感受到当初对十年后充满期待的感觉到今天并没有实现。虽然今天我已经是一名架构师了，但这只是我昨日期待中的很小一部分，是我还能记得的具体的一部分。 更大的一部分只剩下一个感觉，我甚至怀疑当初从未仔细地把这部分感觉具象化，所以导致我现在的记忆中只剩下一种感觉。这里再打个比方，若十年时间是一个人，我当初把一个期待的感觉托付给了她，十年后再见时，她依然还了我一个一样的感觉；如今我知道这怪不了她，她并非无所不能，只是我未曾很好地了解她。 “时间如流水，从我们的指缝间悄悄流走；如轻烟，被微风吹散了；如薄雾，被初阳蒸融了”，这些中学语文课本上的关于时间的比喻，突然就从我的脑海中冒出来。时光无形，如流水、轻烟、薄雾，要想精确地感知它可不容易。 从 30 到 40 岁的这十年我已经行程大半，突然就生出一种这十年似乎走得更快了的感觉，怎么一下就过了大半了，而 20 到 30 岁却明明觉得过了好久呀。20 岁之前我们才刚刚经历对中学的告别，此后很多小伙伴可能就将永远只活在我们的记忆中了。但没过几年我们又将经历另一次告别，对校园的告别。曾经的青春呼啸，江河奔流，未曾来得及说一声道别已志在四方了。 一段又一段的校园恋情开始又结束，也许每一段我们都曾觉得刻骨铭心像延续了一生一般，实际不过匆匆几年。后来终于在职场上找到了最后的归属，走入婚姻的殿堂，安置幸福的蜗居，生下一个让你头疼的要命却又羡慕的要死的小家伙，人生的大事就这样一件接一件地完成了。然后一回首发现站在了 30 岁的门槛边，感慨原来这十年我做了这么多事啊，生出一种 “而立” 的感觉。 迈过三十之后，七年瞬息而过，一回首却想不起什么激动人心的大事了呢？曾经在知乎上看到个问题：“为何人随着年龄的增大觉得时间过得越来越快？”这个问题的几句答案，解答了我多年以来的困惑： 有共性的回忆趋向粘合在一起，标志性的回忆倾向于鹤立鸡群。心理学家认为：我们对时间的感知同时和我们的经历有关。如果一件事对于我们来说是 “激动人心” 的，这样的记忆在我们脑海中感觉到的时间会更长。 确实，从 20 到 30 岁经历的每一件人生大事之于我们都是激动人心且独一无二的，自然在我们的记忆中就 “鹤立鸡群” 了，而三十之后就好像缺少了一些这样的大事。生命的精彩程度在慢慢下降，自然没有那么多激动人心的记忆了。 对时间的感觉就这样，粘连在一起，如轻烟般飘走了。 测量时间正因为我们对时间的感知非常模糊而不精确，若想更有效率地用好时间，就需要更精确地测量它。 有一本书叫《奇特的一生》，主要是关于一位苏联科学家柳比歇夫的故事，他通过自创的 “时间统计法” 在一生内取得了惊人的成就。而我在遇到这本书之前，已经在使用一种类似的方法：我会记下一年来经历的所有有意义的事件（除去每日的例行工作），我称之为 “时间日志”。 我按每周来记录，每周里面有每天的事件记录和所花费的时间。这个 “时间日志” 的习惯其实源自我小时候养成的记账习惯，那时钱不多就想知道钱花在哪里去了。现在其实都不怎么记金钱的账了，而是记时间的账。方法类似，把记金额明细改成了记时间明细，借此以追踪我的时间都花在哪里去了。 记金钱的消费明细的一个副作用是容易让人变得 “小气”，所以我也一直担心记时间明细是否也有什么不好的副作用。但实践了好几年下来，发现并没有什么明显的坏处，唯一需要的是额外多付出一点点微小的时间成本，但这个记录与测量时间的实践好处却是明显的： 它会使你对时间的感觉越来越精确。每个人都感觉 “时间越过越快”，为什么会有这样的感觉？这种感觉会使得我们产生很多不必要的焦虑。而基于 “事件 - 时间日志” 的记录可以调整你对时间的感觉。在估算任何工作时，都更容易确定 “真正现实可行的目标”。 是的，这就是关于时间的第一个 “基石” 习惯，在精确地感知与测量时间之后，你才可能更准确地“预知” 未来。 站在当下这端实际是很难看清未来的另一端的，因为存在太多的可能情况。在一部叫《彗星来的那一夜》的电影中假设了这种场景，一个人有很多种平行分支的存在，时间经过的部分形成了稳定的唯一一个版本。 也许，过去的十年你也像我一样，曾站在起点却看不清十年后的终点。而现今，我总会想象站在每一个未来可能的终点去审视当前的自己、当下的决策与行动，就会得到一个完全不一样的理解，从此开启完全不一样的平行分支。 过去的你也许不曾是时间的旧爱，但未来的你可以成为时间的新欢。 26 时间：塑造基石习惯（下）——切割与构建上篇，我讲述了关于建立时间习惯的第一步：感知与测量；之所以需要先感知与测量，就是为了更好地了解你的时间都花在哪里去了。 下一步，为了更有效地利用好你每天有限的时间，就需要你重新审视并调整你的时间切割与构建方式。 切割时间时间无形，逝去匆匆，如流水、轻烟、薄雾，类似这样的比喻把时间看成无形的东西，不容易抓住和把握。但这样的比喻把时间看作了物质，物质有三态，所以轻烟也好，流水也罢，总是可以变成固态来使之更容易把握与塑造。 是的，我想说的就是转换一下你看待时间的方式，有人把它看作流水，任其从指间溜走，你却可以把它看作石头，用它去塑造什么。 一般二十岁出头我们离开校园开始工作，十年穿梭而过后，就至三十岁。古人说，“三十而立”，“立”的又是什么？无意间翻到一本旧书《大教堂与集市》，这是一本探讨程序员如何构建软件系统的书，颠覆传统，影响深远。但作为一名工程师、创建者，难道心里没有一座属于自己的大教堂？三十而立，有人也许三十已经立起了属于自己的大教堂，而有人，也许如你我，才刚刚为心中的大教堂破土奠基。 程序员有时爱把自己的工作比作 “搬砖”，有个流行的关于“搬砖”的故事，大概是这样的： 两个工人正在工地搬石头，一个路人正好走过，就问他们在做什么？ 第一个工人说：“我在把石头从这边搬过来，并垒在一起。” 第二个工人说：“我在盖一座华丽的教堂，盖好后，你再来欣赏我的作品。” 这个故事想说明的是，虽然两个工人都在干同样的 “搬砖” 工作，但第二个工人心中有一座大教堂，也许 “搬砖” 对他的意义就会有所不同。有时想想，过去的每一天、每一刻，难道我们不是都在搬石头吗？只不过，有些石头会被用来修建心中的大教堂，而另一些石头，我们只是拿起来把玩、欣赏。 璀璨剔透的钻石，五彩斑斓的宝石，所有这些美丽、诱人的石头吸引着我们把时间花在去欣赏、迷恋它们，渐渐地就遗忘了，原来曾经我心中还有一座大教堂要建造啊，最后我们无意或有意地避开去搬起那些建造大教堂的沉重石块。 后来当时间过去，我回过头来看，在感叹别人雄奇的大教堂时，发现自己曾经把时间这块原石，切割成了一些看上去漂亮却没用的鹅卵石，更甚者只是切成了一堆土块，最后风化为一堆沙尘。所以，如今我再来看时间时，我更愿把它们切割成用来建造大教堂的石材。 记录测量时间，让我对时间的感知更精确，而面对自然产生的每天一块的“时间原石”，每个清晨就要确定：把它切成什么样？由哪些石块组成？哪些是用来建造大教堂的石材？确定后，将其压在心上，临睡前再记录下今天从心上搬走了哪些石块，以及花了多少时间。这样时间于我就真的变成了一块块石头，比轻烟、流水、薄雾更有形，更易抓住，也没那么容易悄悄地溜走了。 每天搬的石头，不一定都适合建造大教堂，而建造大教堂的时间也可能比我们预期的要长。 位于梵蒂冈的圣彼得大教堂的建造过程前后历时 120 年，由米开朗基罗设计，而文艺复兴时期的大师基本都曾参与其设计。 img 圣彼得大教堂 而建造历时最长的是德国的科隆大教堂，于公元 1248 年 8 月 15 日动工，从这天起，漫长的修建科隆大教堂的道路开启。600 多年后，到 1880 年 10 月 15 日，这座荣膺当时世界最高建筑物的科隆大教堂举行了盛大的竣工典礼，成为建筑史上最杰出的成就之一。 img 科隆大教堂 如今看到这些雄奇、壮观、让人赞叹的大教堂，再感受到建造它们的历史过程，就能真切地感觉到时间是如何被切割成了一块块的石材，构建成了最后的大教堂。 这就是关于时间的第二个 “基石” 习惯：将时间切割成建造你心中“大教堂”的合适“石材”。 构建方式切割了时间，得到了合适的“石材”，你还需要确定适当的构建方式。 而适当的构建方式，是指在时间的 “基石” 习惯之上，建立其他的习惯。比如，好些年前开始，我会从每周的时间里切出来一块，专用于写作，慢慢就形成了写作的习惯。这意味着，我从现有的 “时间石材” 中拿出了一部分，用于构建写作的习惯，然而 “时间石材” 的总量是有限的，我必须在其上建立有限数量的习惯，我得做出选择。 每一个习惯的构建成本是不同的，甚至同样的习惯对不同的人来讲，构建成本也是不同的。比如，跑步这个事，对有些爱运动的人来说就是每天跑或每周跑几次的习惯，而于我而言，建立跑步这个习惯，从心理到生理都有更大的消耗。 任何行动的发生，都需要两种努力才有可能：第一种，是行动本身固有需要的努力，如跑步，跑一公里和跑十公里固有需要的努力是不等量的；第二种，指决策是否执行这种行动的努力，决定跑一公里还是跑十公里的决策意志力消耗，我想也不会一样。 构建习惯的目的，以及它们能起作用的原因在于：它能消除行动中第二种努力的决策消耗。 我之所以选择构建写作习惯而不是跑步习惯的原因是，对一个像我这样的程序员而言，写文章和写代码的感觉很接近，它就好像是一种刚好在程序员的能力边界线外不远处的事情。这样，写作行动所需要付出的两种努力，感觉都还在可以应对的范围，属于能力边界附近不远的事情，也是正适合用来扩张能力边界的事，有一种挑战的刺激感，又不至于望而生畏。 电影《功夫熊猫 3》里，师父对阿宝说： 如果你只做能力范围内的事，就不会成长。 所以，在时间 “基石” 习惯之上构建的习惯应该是你能力范围之外的行动。如果一项行动通过习惯慢慢变成了能力范围之内的事，那么你以后再去做类似的事，其实就不需要再付出什么决策努力了，也就不再需要习惯来帮忙了。 有时，习惯会让你产生日复一日、年复一年做一件事的感觉，这样日积月累下来消耗了大量的时间，但付出了这么多未必会产生真正的收获。怎么会这样呢？ 习惯，它的表象和形式给人的感觉是在重复一件事，但它的内在与核心其实是不断产生交付，持续的交付。 好多万年前，人类的蛮荒时期，还没有进入农业社会，人类是如何生存的？那时的人类，以采集和狩猎为生，每天年轻力壮的男人负责出去狩猎和采集野果，女人则在部落内照料一家老小。这就是进化史上，自然选择让人类养成的共同习惯，并且这个习惯持续了数十万年。 采集与狩猎这个行动习惯的核心就是必须每天产生交付，得有收获，否则一家老小都得饿肚子。而像狩猎这样的活动，就需要高度集中的注意力、熟练的技能运用和瞬间的爆发，它需要狩猎者所有的感官都高度专注在猎物的运动上，并随时调整适应猎物的运动变化。而采集，就需要采集者不断扩大或走出熟悉的边界，因为熟悉的地方可能早就没了果实，而陌生的地界又可能潜藏着未知的危险。 这样的行动习惯，通过数十万年的进化，甚至已经刻画在了我们的基因中。这就是我想说的，如果你要构建一个习惯，就要运用好基因中本已存在的关于 “采集和狩猎” 的本能：高度专注，跨出边界，持续交付。 末了，我把上、下两篇的内容一起提炼总结为如下： 要形成时间习惯，要通过有意识的感知和测量来发现时间是怎么流失的。 要完成建设你心中 “大教堂”，要通过切割 “时间原石” 来完成 “时间石材” 的准备。 在养成了时间的基石习惯之上，挑选和构建其他习惯来完成 “大教堂” 的持续建设与交付。 世界上多一些 “大教堂” 会变得更美好，不是吗？ 27 试试：一种“坏”习惯曾经，我碰到一些程序员问我：“我以前是做安卓的，现在想试着学下后端服务开发，你觉得怎样？”我一下子就卡住了，不知该如何回答才好。原因是：学习本是个好事，但前面加个 “试着” 似乎感觉就不太好了。 好的出发点“试一试” 的初衷本来就该是好的，它表达了一种好奇心，以及尝试走出舒适区的勇气。 程序员这个职业，会带来一些职业习惯。比如，可能会经常性地去尝试一些新东西，然后看看它是否如预期般那样被应用或实现。 这里，我就拿程序员“调试程序”这项日常工作来举例。调试，就是这样一种需要不断去试的过程。 还记得我在前面《炫技与克制》一文中讲了我早年刚开始工作时的那个小故事吗？那时我带着炫技的心态应用了刚刚接触的 Java 线程编程通信来实现一个客户端小程序。结果后来程序出了 Bug，而我不断修改，Bug 从这里消失，又从那里冒出来，让那时的我产生了巨大的挫败感。 当时，我花了很长时间一直在“抓”这个 Bug，用的方法就是调试技术。但因为这是一个机率性出现的 Bug，一步步调试反而从来没出现过，但真正运行起来又总是偶然出现，实在让人抓狂。在这样的单步调试中，我就是怀着一种期望凑巧能碰到的心态，做了很多无用功，最后也没能解决真正的问题。 这个案例虽然已经过去了十几年，但还是给我留下了深刻的印象，久久不能忘怀。我把它分享出来，就是感觉想必这条路上曾经的我不会是特例。 表面上看，是当时那种炫技的心态致使我选择了不恰当的实现方案，也最终导致出现了对于那时的我来讲很难解决的 Bug。但其实这里真正的症结是：我对于线程间通信的知识出现了认知性盲点，这属于 “我以为自己知道，其实不知道” 的问题。 我习惯性地用调试去找 Bug，这就是一种 “试一试” 的方法，出发点（找到 Bug）是好的，过程也是很艰辛的，但最终结果却是无功而返。即便用这样的方法最终找到了 Bug，也有一定的运气因素，并不具备可重复性。 当时，我正在读一本有关线程编程的书，后来读到某个部分时，关于这个问题的根源我突然就恍然大悟了，因为这个部分正好弥补了“我以为自己知道，实际却不知道”的认知盲点。我习惯性的调试方法，虽然有一个好的出发点，但问题是，我不知道我在调试什么。也许是想通过调试证明程序逻辑本不该出错的，或是通过调试发现其他的疏漏，但在这样的盲目调试中最终也没能定义清楚我调试的终点到底是怎样的。 那时的我就是一个刚进入编程领域的小白，喜欢调试，然后在看上去很复杂的调试界面忙忙碌碌，感觉很专业，但最终收获的仅仅是对调试器的熟悉程度。而且一不留神，就自觉不自觉地养成了这种“试一试”的“坏”习惯。 模糊的终点这里，“试一试”的“坏”习惯的“坏”字之所以加上双引号，就在于它的出发点本是好的，但如果终点是模糊的，那就“坏”了。 近些年来，就出现过几轮的技术热，比如，刚进入移动互联网时代就大热、但如今已经回归常温的移动开发，曾经大热现已降温的云计算与大数据，以及还在热度中的人工智能、机器学习和区块链等。面对这些技术热，很多人都跃跃欲学之、试之。可能你也不例外。那么，到底为什么你会想去尝试一种新技术？是你仔细思考后的主动选择，还是说或多或少又被技术潮流所裹挟？ 好些年前，移动开发还在升温阶段时，我也不可避免地被这样一种潮流所裹挟过。我开始看一些关于 iOS 开发的书，从语言到工具。其实，尝试学习一种新技术并不是坏事，即使是被技术潮流所裹挟，但问题出在，这次尝试的终点在哪里？ 我是想转型成为一名移动开发工程师吗？还是说我有一个想法，需要开发一个 App 来达成？抑或我仅仅是想学习并了解下移动开发是怎么回事，从而进一步提升下技术的广度理解与视野？ 然而以上皆不是，我当时的尝试完全没想清楚终点在哪儿。后来热度下来了，其他工作任务也多了，也就慢慢遗忘了。回过头来看，这只是浪费了一些时间和精力罢了。 几年后，人工智能与机器学习又热了起来，我又开始尝试学习起来，但较上次不同的是，这次我把尝试的终点定义得很清楚。我不是想转型成为一名机器学习领域的算法工程师，也不是因为它很热就“随波逐流”地被潮流裹挟，我这次尝试的终点就是想搞清楚关于人工智能与机器学习的三件事： 它的原理与应用场景； 它的前世今生； 它如今已抵达的边界。 搞清楚这三件事，虽不会让我成为机器学习的专家，但会提升我对于这个热门技术的判断力。因为，现实中我需要判断一些真实的业务场景该如何结合这样的技术，这就需要了解它们的应用场景和一些原理。 另外，一门新技术很少是凭空冒出来的，了解它们的前世今生，会更有效地知道，哪些方面已经有了成熟的方案，哪些地方还在青涩的探索期。再结合它当前的边界，就知道如何定义清楚需要，形成合理的技术方案，而不会产生过度的妄想。 试一试，需要有更清晰的终点。关于终点，你也可以从下面一些方面来考虑： 验证猜想。这个部分程序员就很熟悉了，因为编程中的调试其实最重要的目的就是验证猜想。引入一种新技术或框架，验证 API 的调用结果或运行输出是否如你所想，即使最终否决了，那你也获得了判断的依据与知识。 收获结果。定义清楚你尝试的这件事，到底能收获怎样具体的结果。比如：考试，尝试的收获就是要通过。 体验过程。有时候结果并不确定，比如，创业的结果未必就一定是成功，那么这样的尝试难道就没有意义了吗？有的，因为创业的超低成功率，所以，体验过程恐怕多于收获最终结果。 理解现实。你尝试一个新东西或学习一个新知识，有时未必真是为了将来有朝一日能用上它，而主要是为了完善你的知识与认知体系，然后再去理解现实为什么是这样的。 现实的路径“试一试” 的路径是有限的，毕竟终究离不开现实的约束。 有时候，你因为现实工作需要，可能需要不停地在各种技术栈上切换。而很多技术可能过了那段时间，就再也用不上了，这样的技术尝试难免会让人感觉可惜。但通过我前面列出的关于 “终点” 的方面，再来分析下这个现实场景。 首先，你得面对现实，这样的技术尝试在现实中太多太多了，有时就是没得选择。当年，我也因为工作原因，从客户端桌面编程的 VB、PB、Delphi 到 Web 编程的 JS 语言和一堆相关框架，再到后端编程的 C 和 Java，而如今很多当年学习的技能早已过时了。但这样的技术切换尝试，从 “收获结果” 的维度看还是解决了当时的问题，满足了需要，获得了结果。 其次，如果觉得仅仅一次性收获的结果，不值得你投入的时间和精力，那就可以从 “理解现实” 的角度去挖掘。这些知识，从学以致用的角度很快就过时了，但它们并不是完全孤立的，事实上计算机程序体系内的很多知识都不是完全孤立的，它们都有相互的联系与连接点。 从理解的角度，这类技术切换的尝试事实上扩大了你的知识边界，尝试的也许是孤点，但你可以进一步找到它们的连接处，形成体系。因为很多现实的原因，每个人的起点和路径都不会一样，但我们都是从某一点开始去慢慢摸索、尝试，最终走出一个属于自己的体系来的。 最后，当你有了自己的体系，也可能有了更多的尝试选择权，就可以体系为中心，去有选择地尝试对你更有意义或价值的事了。 总结来说： 试一试，是走出舒适区的一次行动，这本是一个好的出发点，但若只有一个模糊的终点，那么它带来的更可能就是无谓的浪费。 试一试，不仅要有一个好的出发点，还需要一个清晰的终点，在这个终点你可能：验证猜想、收获结果、体验过程、理解现实。而在起点和终点之间，你需要选择一条更现实的路径，通过不断地尝试，走出自己的体系。 试一试，本该是个好习惯，可别把它用坏了。 28 提问：从技术到人生的习惯无论做什么工作，一路上你总会碰到各种各样的问题，而提问应是你解决问题的一种有效途径。更进一步，如果能把提问固化成为你的一种习惯，那它就不仅仅是一个解决问题的“工具”，甚至还能引导你的人生选择。 提问这个习惯，我有三个层面的理解： 如何问？ 问什么？ 为何问？ 如何问？提问之术大部分情况，我们碰到的都是已经有了问题，但却问不好，从而得不到答案或得不到好的答案。 比如说吧，我经常碰到的一种情况是：有同学常拿着一个具体的问题跑来，向我发问，他大概会交代一下想解决的场景，然后就会接着描述他的思路，以及解决这个问题的思路的一些其他约束，但这中间会有一个障碍，然后就问我该怎么解决这个障碍。 这样的发问一般都会让我陷入两种困扰之中：一种是，问题的业务背景交代得太泛化，所以我只好跟着他的思路，感觉解决这个问题似乎只能有这一条路可走；另一种则正好相反，问题的业务背景描述得过于细致，让人最后陷入对复杂业务领域的理解中，迷失在细节的讨论里。 即使是同一个场景，其实不同人还会产生不同的思路。比如：你想去一个十公里外的地方，对方也许会问你怎么套马鞍的问题，这时你就很困扰，因为你的思路是坐车或开车。这就是一个针对技术人员面对同一场景问题，所选取的不同技术方案可能处在不同的时代背景下的类比。所以，面对这类具体的障碍问题，我经常很难回答。 再看看国内网上技术问答社区的情况，我有时会去看看，发现上面的问题大部分类似下面两种模式： 某某出错了，怎么办？ 如何针对某某封装一个库？ 某某可以是一种具体的技术或框架，这两种提问模式代表了两个方向，都让人无法回答。第一种太模糊而无法回答，而第二种太庞大则不愿回答。 如果你能绕过这两个提问的大坑，提出一个具体的问题，那么算是前进了一大步。但具体问题也有一个陷阱，就如前面套马鞍的那个例子，也许有人回答了你怎么正确地套马鞍，但你可能依然走在落后的道路上，因为你的工具本身就是落后的。所以就具体问题提问，除了问及手段，还最好跟上你的目的和你就此目的是怎样提出的手段，然后才走到了这一步的障碍，让你不得不在此提问的。 一个能够回答的具体问题，一般都是解答题形式，表达清楚你的解答目的，也许你的困扰在高手那里根本就不存在。你只是走了一个弯路而已，这样不仅绕过了障碍，还获得了一条近（先进的）路，这就是有意义的提问。 至此，就得到了提问的第一个原则：提供足够的信息，让人能够回答。 草率的问题是懒惰的问题，通过搜索引擎就能简单获得；草率的问题是模糊的问题，让人没法回答。而更有意义的提问是把解答题变成选择题，提供你的选项，展现你探索了哪些路径，省去了可能产生的反问。也许你的某条路径已经非常接近答案了，只是卡在了某个点上，知道答案的人一看就明白了，也很容易回答。 这就是提问的第二个原则：提供更多的选项，让人方便回答。 即使你的问题能够回答，也方便回答，但也可能得不到回答。因为，回答问题需要有驱动力。提问本是一种索取，要让人有更多的回答动力，还需要付出。付出一种态度，表达感谢；付出一份可供交换的视角，建立讨论的基础。 这就是提问的第三个原则：提供交换价值，建立讨论基础，表达感谢态度，让人乐于回答。 《大教堂与集市》一书的作者埃里克·史蒂文·雷蒙德（Eric Steven Raymond）曾就如何提技术问题写过一篇影响颇大的文章：How To Ask Questions The Smart Way（中文名是《提问的智慧》），距今已经十多年了，修订了十多次，也被翻译成了十多个国家的文字，很值得一读。 最后，我归纳下关于提问之术的三个方面： 提让人能够回答的问题：草率的问题，只能得到一个草率的答案。 提让人方便回答的问题：你得到的答案的好坏取决于提问的方式和开发答案的难度。 提让人乐于回答的问题：只索取而不愿思考和付出的提问者，要么什么也得不到，要么只会得到 RTFM（Read The Fucking Manual） 或 STFW（Search The Fucking Web）。 问什么？求解之惑有时一个好问题，比如何问更有价值和意义。 我觉着，前面一节关于如何提问本身也算是一个好问题，因为当你面对这个问题，找到了答案，并严肃地对待后，从此就会改变你提问的习惯。提出好问题比寻找已有问题的答案可能更有意义和价值。寻找答案，通向的是已有的结果；而提出新问题，也许会导向未知的宝藏，它可能是获得新知的起点。 有时候，你会碰到一个问题不知道该问什么，甚至该如何提问，即使这个问题是一个非常具体的技术问题。而这一类具体的技术问题，我称之为答案藏在问题中，属于无法提问的问题。 这可能说得比较抽象，下面我举个具体的例子：曾经碰到过一个线上问题，系统间隙性出现超时，只有重启能解决；而且出现的很无规律性，不和什么流量之类成正比，就是莫名其妙偶然出现，还不能恢复，只能重启。这个问题曾经困扰了我很久。这类问题虽然很具体，但你可能会发现，你竟找不到一个好方式来描述这个问题。 如果我就把上面这段描述的关键现象，偶现超时并结合使用的具体技术，如：JVM、开源框架配置和业务场景一起抛出来问人，你觉得有人能回答吗？这类就属于答案藏在问题中的问题，唯一的办法只能是找和你一起共事的同事从各人不同的思维视角去分析，抽丝剥茧。当你能找出提问的方式，基本上答案也就出来了。 后来，终于定位到上面现象的根源是服务线程池的配置有误，结合在某些慢业务场景下会引发连锁超时。这时的问题就是怎么配置服务线程池才最合理，这个问题本身就简单到完全无需再问了，自然就有了答案。 在成长的路上，我碰到过好多问题，但早年还没有形成记录与写作的习惯，所以未能把这些问题记录下来，很多就遗忘散落了。这就是我想说的第二个需要建立的习惯：当遇到暂时没有答案的问题时，先记录下来。在成长这条路上，不是碰到了问题，就能立刻或很快找到答案的。 当我开始写作后，就开始养成了这个习惯。大部分过去写的文章都来自于这些问题记录，定期地回顾下，曾经困扰我的问题，今天能解决了吗？一开始有很多具体的技术性问题，就因此写了很多技术文章。后来又有了更多复杂的问题，也就又写了不少思考性的文章。每写一篇，意味着当下的我对这个问题至少有了答案。无论这个答案如何，从某种意义上说，今天的我相比当时面临问题没有答案的我，就已经成长了。 先从一个记录问题，积攒 “问什么” 的习惯开始，不断去积累并留下一些东西，将来再定时去回顾这些问题，也许就会得到意外的收获。对于程序员，总会碰到各种技术问题，就从这些最具体的问题开始，把暂时这阶段还没法回答的问题按一种模式记录下来，比如下面这样： 问题的上、下文； 问题的具体描述； 问题的解决思考和思路； 问题的解决方案和具体技术或办法； 问题解决后留下的思考或其他延伸的疑问。 这就是你积累的 “宝藏”，将来如果能回答了，就把答案分享出来。这就是我所认同的积累价值和传递价值的方式，分享你从中学到的一切（Share what you learn），最后自身的价值也就得到了提升。 保持积累，持续给予，终有所获。 为何问？价值之道提问的目标是获得答案，而答案于我们自己而言是一种价值；为何而问，就是发问于我们的价值之道，最终指向的目的是：认清自我。 值得问 “为何” 的问题不多，但总会遇到，它是一道选择题，有关我们的价值选择。我们最关心的是自己的命运，而关于命运有一句话是这么说的： 选择决定命运，什么来决定选择？价值观。 价值观，是我们对事情做出判断，进行选择取舍的标准。每个人都有价值观，无论你能否清晰地定义与表述它，这些观念都决定了你的行为标准。这么说有些抽象了，下面我通过一个故事来将其具象化。 这个故事的主角叫比尔（Bill）。21 岁时他成为一名程序员，获得了第一份正式工作，在加拿大多伦多的一家互动营销公司写程序，这家公司的主要客户都是一些大型药企。而在加拿大，法律限制药企直接对普通消费者做处方药的广告。 所以，药企客户提出了需求，做个网站来展示公司的药品，对于浏览网站的用户，如果能提供处方就会被引导到一个病人的专属页面。在这个专属页面上，提供了一系列的测验问题，然后通过病人的回答来推荐相关的药品。 这个网站仅仅是展示公司产品，提供通用说明的信息网站，这显然不是任何特定药物的广告。一切显得很合理，比尔收到了需求，它们包含了针对病人的测验问题，每个问题的答案，以及对答案的处理规则。 比尔完成了开发，在交付给客户之前，他的项目经理决定对网站做个简单的快速验收测试。经理试了这个针对病人的小测验，然后走到了比尔的桌前： “测验不管用！” 经理说。 “哦，出了什么问题？” 比尔问。 “嗯，看来无论我填什么，测验都给我推荐同一种药物，唯一的例外是我回答过敏或者已经吃过了。” “是的，这就是客户要求的处理规则，其他情况都会把病人引导到这种药。” “哦，好吧。酷～” 经理没再说什么，他们一起交付了网站给客户，客户对这个网站很满意。项目结束后，客户的代表还邀请比尔和整个团队一起去吃一顿丰盛的牛排大餐。就在吃大餐的当晚，一位同事给他发了一封电子邮件，链接到网上的一篇新闻报道：是关于一个年轻女孩，服用了他（创建）的网站推荐的药物，然后自杀了。 网站推荐的药，其目标用户就是年轻女孩。比尔后来想明白了，他们所做的一切，建设这个网站的真正目的就是广告一种特定的药物。那时，作为团队中最年轻的开发人员，他虽然觉得客户需求的规则就是为了 “戏耍” 年轻女孩而设计的，编写的代码是 “错误” 的，但却没有多想，只是觉得这就是他的一份工作，有个开发任务要完成，而且他完成的很好。 结果后来发现，这种药物的主要副作用之一就是会让人产生严重的抑郁和自杀念头。比尔说，他可以找到无数的方法来使自己在这个事情中的角色自我合理化，但当时他依然觉得自己的代码写“错”了。那顿大餐后不久，比尔辞职了。 这就是比尔的价值观选择，他一开始是不清晰的，但这个事情让他问了自己为何，就变得越来越清晰了。我能知道这个故事，自然是比尔多年后自己写出来的。他说，“今天的代码（人工智能程序）已经开始接管你的驾驶，帮助医生诊断疾病，不难想象，它们很快也会推荐处方药。” 比尔现在依然还写代码，但自从牛排大餐那一天起，比尔都会仔细考虑代码的作用，多问一个为何？因为程序已经越来越多地占据着我们生活的方方面面，那代码背后需要价值观吗？ 这就是第三个习惯：为何而问？获得答案，认清自我，选择自己的价值之道。 关于提问，今天就分享到这里，我总结提炼下： 如何问，是关于提问的 “术”，考虑让人能够回答，方便回答和乐于回答； 问什么，是关于成长的 “惑”，去积累问题，寻找答案，并分享出来，从而完成了价值的积累、传递与交换； 为何问，是关于选择的 “道”，价值观的选择决定了不同的道。 成长的过程，一般都是从提出一个问题开始，找到答案，再融入自身的价值观，完成下一次更好的选择，周而复始，形成习惯，化作天性。 29 偏好：个人习惯的局限与反思经过长时间的工作实践，我们会逐步养成一些做事的个人喜好或习惯，并且会自我感觉这种个人习惯会是很好的方法。 不可否认，每个人做事情都有些个人习惯，有些特别强烈的，可能其程度还会上升到 “癖” 这个字。明朝散文家张岱在其文《陶庵梦忆》中留有名句：“人无癖不可与交，以其无深情也。”这里的 “癖” 就是指一个人强烈的个人喜好与习惯。 作为程序员，过去这么些年干得最多的事情自然就是写程序，关于写程序也会形成一些个人习惯或者说癖好。自己的习惯或癖好对别人本该是无所谓的，但在团队合作中，有些时候，我们可能会不自觉地去维护，甚至推广这种习惯。这种 “不自觉” 的行为是值得我们警惕和反思的。 习惯形成工作中的一些习惯是如何悄悄形成的呢？ 记得毕业几年后，我也成了需要带新毕业学生的 “老” 程序员。其中，带学生的主要任务之一就是一起做项目，指导他们上手开始写真正的项目代码，而不再是实验性质的课程作业。 我开始工作的头几年，可以说是我写程序最多的几年，基本也就写出了我个人的一些习惯和喜好。比如，工程的目录结构、类的命名模式、接口的参数定义，甚至注释和签名的方式，都是我特别在意的地方。每当看到新同学们各自按自己的想象写得随心所欲，就感到非常地焦心。 那时候像 Java Maven 这种约定优于配置的工具还没有流行起来，大家都是按自己的喜好使用 Ant（一种 Java 构建工具）来定义工程项目结构，所以最终导致结构千差万别。 因而，我就忍不住去把新同学们的工程按我自己的定义喜好进行修改，以一种权威的说辞来强调自己的偏好：“我们要统一下，免得像以前旧项目一样差异太大，换个项目熟悉起来都要好半天，也不利于相互之间的代码交流。” 如今回想起来，当时这种 “约定优于配置” 的个人习惯在行业里还并没有成为共识，而我仅仅是出于自己对代码的 “洁癖” 或者说强迫症，就产生了这种强加于人的冲动行为。一些年后，Maven 崛起逐步取代了 Ant，这种约定优于配置的方式就变成了 Java 程序员的普遍共识，而我，也可以确认这个习惯基本算是一个好方法，也不再需要去强迫别人了。 以上，就是一个关于编程习惯的形成过程。从中我们可以看出，即使这样的习惯最后也许真的变成了大家认同的好方法，一开始也不该以个人的方式直接去强加于人。因为强加于人，总是容易带来分歧和争论，最终可能好习惯还没机会带来收益，却因为分歧争论直接带来了损失。 但编程中总结出来的一些方法和原则，很多可能就是始于个人习惯，最后逐渐传播并演化形成了普遍共识。 共识达成如今，很多约定俗成的代码规范，基本就是从早期一些人的习惯中加以提炼总结出来的，然后形成了大家共同认可的好方法，并在组织层面形成了规范。形成了规范的东西，就不再是从个人习惯的角度去强加于人了，而是大家的共识达成。 写代码的一些方法能形成规范，但还有一些编程的好方法可能比较难用规范去描述，这些就慢慢形成了所谓的 “编程智慧”，并在程序员之间口口相传（如今的 “口口” 可能更广义一些，也包括了互联网上的文字交流和传播）。 一些 “编程智慧” 类的好方法，不太好形成具体的规范描述。下面，我就结合我自己的工作经历和经验，列举一些规范建议： 设计模式。遵守设计模式总是能让你少踩坑的，但如何灵活地采用合适的模式又是另一种智慧了。 术语约定。约定了术语，总是能让口头的概念和落在代码上的东西保持一致，减少沟通歧义，从而更高效。 单元测试。这比任何的代码评审都来得可靠，哪里该写多少测试用例，哪里可以不写，这又是智慧了。但不要刻意为了追求覆盖率而去写，覆盖率的技术统计方法其实是很唬人的，有些覆盖率很高的项目，该有的 Bug 还是有的。 随时重构。对于技术债务，每个月付点“利息”，比好几年后“连本带息”去还要感觉轻松得多。这条的特殊点在于，这可能是大部分程序员都认可的好方法，但却不是大部分人的习惯。因为技术上的债，实在自己还不起，总是可以推脱出去给下个“倒霉的家伙”，但从长远角度看，这样的推脱不会让你获得成长，甚至还会阻碍你的发展。 在程序界形成编程共识最经典的例子来自 Unix 的发展历史，而 Unix 几十年的发展历程，不仅仅是一个软件系统的进化，也是程序设计和编程方式的进化。从它的进化历程中，形成了独特的设计原则，而且已广为流传，达成共识。 共识，意味着看待问题共同的思考方式和角度，所有能形成共识的方法都是值得关注的。 分辨反思编程中除了好方法，还有些确实只是个人习惯的东西，如果我们不去留心区分，很容易模糊了两者的界限。 举个例子，我曾经一直有个编程习惯是这样的。假如有一个查找接口方法叫 lookup()，而实现这个方法内部的逻辑要根据好几种条件来查找，按不同的参数条件来实现不同的内部逻辑分支，但最后执行时又会走同样的一段逻辑去存储里查找。这样描述起来比较绕，下面我用个简图来说明： img 我个人编码中的方法命名习惯图例 如上，lookupByXXX 表达了不同参数逻辑的差异化处理，最后的 lookup0 则是一段共享的查找执行代码。 lookup 是一个公开的接口方法，而后面再加个 0 基本就是我的个人习惯了，表达了内部私有的一种技术性实现，它一定是私有的，不对外暴露的。 这个例子中的编程方法，是让我对所有类似需要的接口实现模式保持一致。但这确实只是我个人的习惯偏好，我没办法并且也不会要求别人也用类似的方式来命名函数和编写实现，因为别人也可能有自己的习惯偏好，谈不上谁比谁更好，毕竟它并不是广泛的共识。 那大家都认同并形成共识的方法就一定能形成习惯吗？也未必，这需要我们去分辨和反思。比如程序员都不爱写文档，很多人也没有这个习惯，但大家几乎都认同提供规范的设计和接口文档是个好方法，只是因为文档的优先级长期低于完成代码功能从而被搁置了。 另外，一些流行的概念就一定是好方法吗？比如，结对编程，是一种流行的概念。它的行为要求是：两位程序员坐在同一工作台前开发软件。它的优势作用是：与两位程序员各自独立工作相比，结对编程能编写出质量更高的代码。其理论基础是：两个程序员具有相同的缺点和盲点的可能性很小，所以通过结对编程的时候会获得一个更好的代码实现。 但在实际中，结对编程也有它的缺点和劣势，比如更高的开发成本（毕竟要同时占用两个人）。而且，有些人可能从心理上就很不喜欢结对编程的，比如我，因为坐在一起编程，难免分心而无法进入完美的心流状态，所以会感觉自己的工作效率都会下降一半以上；并且我也很难接受别人在看代码讨论时，用手戳屏幕指指点点。当然，不仅仅是我，还有更甚者，除了代码洁癖，还有生活洁癖，根本接受不了任何其他人和自己共用一个键盘的。 也许稍微松散点，没有那么物理上的严格结对，而是确保每一个程序员写的每一行代码，都能有一个配对的程序员去进行检视，虽说这个过程完全是异步或远程的，但效果应该也是可以保障的。这几乎就是开源项目的协作模式。开源项目的繁荣与成功，也证明了其实践的协作模式是一种好方法。 总结来说： 在你从程序新人成长起来的过程中，要学会区分，哪些确实是值得学习与推广的好方法，哪些仅仅是自己的个人习惯，特别是在你成长到开始成为技术管理者之后。 古语有云：“己所不欲，勿施于人。”而己之所欲，若是自己特有的习惯偏好，也就请勿妄施于人了。若确实觉得是个好方法，尽量建议于人，而非强加于人，即使你手上掌握有强加的权力。 反过来看，程序行业，编程实践中，存在大量流行的概念、模式、原则，甚至哲学，它们的产生都有其历史背景和过程，并在一定范围内形成了共识。但你依然需要去对这些流行的共识进行分辨和反思，看看哪些才是适合你的好方法。若真是好方法，也可以进一步将其培养成自己的习惯。 虽是以编程为例，但习惯的偏好不限于此。 最后，在你成长的路上，都形成了哪些好习惯呢？欢迎你留言给大家分享下。 30 写作：写字如编码程序员群体有个共同的弱点，那就是写得了代码，解决得了问题，但却不能很好地展现自己的能力。从今天开始，咱们专栏即进入一个关于 “展现” 的主题，聊聊（写作、画图和演讲）三类最常见的展现手段。 其中，展现的最常见形式之一就是：写作，它是一种能随着时间去沉淀的长尾展现形式。 曾有多人问起，写作除了坚持写、持续写、长期写，还有什么其他技巧么？答案是：有的。虽说我并没有上过专业的写作课，但在长期的写作过程中，我已通过实践摸索出来了一套符合程序员这种理性逻辑思维的写作技法，简言之，就是：写字如编码。 把每一篇文字当作一个需求，把写作当成在编码的过程去完成这个需求，它会非常类似于程序开发的整个过程，包括需求、设计、实现、测试和交付五个阶段。 一、需求程序的需求，对应于写作的主题。 你之所以写程序，是因为有人给你提需求；但你业余的写作，通常就不会有人给你提相关的写作需求或主题了。所以，就需要你自己去主动寻找和发掘你自己的写作需求或主题。 对于我来说，写作主题的来源可以有很多方面：有时，是来自身边的工作和生活中的事件引发的感触；有时，是阅读过程中突然产生的启发与领悟；有时，则是曾经一直困惑的问题突然碰到或找到了答案……这些都属于灵感乍现的时刻，也是我写作主题的来源。 但只是等到写的时候去灵光一现是很难保障持续写作的主题供应的，所以为了持续写作，我很多时候在大脑的潜意识里都会考虑主题的问题，等有了灵光一闪的时刻，就随时记录下来，形成一个主题列表。这个主题列表，就有些像产品的需求特性列表了，呆在需求池里等待被 “实现”，也即，“写出来”。 所以，如果你想要持续地写作，你得养成一个习惯，也就是前面《提问：从技术到人生的习惯》一文中关于提问和记录的习惯。 随手记录的主题可能很多，但真正能写的时间和精力却有限，因此你得挑选值得写的主题。如果把每一篇文字想象成一件产品，那么定义写作的主题，就像定义产品的灵魂，你得确定一个产品的目标、定位，以及面向的读者人群。 美国作家库尔特·冯内古特说： 想一个你关心，其他人也会关心的话题来写。要记住，不论你用多么发自肺腑的情感表达，对于读者来说，除非是他们真正关心的主题，不然怎么都不会太关心，而只有主题才是读者最真切的关注点。所以，关注你的主题，而不是想办法去显摆自己的文字。 是的，一个好的主题很可能是一篇好文字的开端，毕竟如果一开始产品方向错了，实现得再好又能有多大意义呢？ 二、设计确定了本次写作的主题（需求），接下来就该进入到设计阶段了。 而程序开发的设计一般分为两个层面： 1. 概要设计在软件程序系统的设计中，这部分内容主要是架构设计，系统或子系统的拆分、交互逻辑、边界等等。而对于写作而言，这部分对应的就是设计本篇文字的逻辑结构，换言之，即在主题确定的基础上，采用怎样的逻辑去展开主题，形成合适的衔接。 比如，我写的文章多为随笔散文类，而散文的结构，上过中学语文课的我们都知道：形散而神不散。其中的 “神”，就包括了文章的核心主题观点，以及围绕主题展开的逻辑结构、文字附着的延展线条等。 2. 详细设计有了逻辑骨架后，就需要补充真正有血有肉的文字了。 围绕主题想表达的观点，考虑需要添加哪些支撑观点的素材，以及设计整理、引出和排布这些素材的方式。而为了让文字更有阅读的趣味，还需要有适当的故事，因为人们都喜欢读故事，而非说教，那故事又该如何切入与布局？这也是需要考虑的点。 另外，这些素材或故事又从哪里来？只能来自平时的阅读积累。大部分我们读过的东西很快就会被遗忘，所以为了在需要的时候找到合适的内容，就需要在平时的阅读时记录笔记，留下索引，必要时再根据笔记索引的关键词去搜索。 经过了编程强大且反复的逻辑训练后，对于你、我写作而言，逻辑结构的设计就不该有障碍了，其实最大的差异与障碍可能是在 “实现” 上。 三、实现写文字和编码在实现层面最大的差异是：实现过程的技能和要求不同。 在实现技能层面，程序是用计算机语言来表达的，文字是用自然语言来表达的。计算机语言的逻辑性和精确表达能力要比自然语言强得多，自然语言是模糊的、混沌的、不精确的。因此写得一手好程序的人，不一定能写得一手好文字，因为他们需要驾驭的语言的特性完全不同。 刚开始写文章时，即使自然语言我们从小就学会了，也能熟练使用，但用它写起文章来也会有一种磕磕碰碰的感觉。就好像刚学写程序时，好不容易才能编译通过，也是磕磕碰碰的。 对于编码，编译通过的程序才算刚刚开了头，接着还会进行程序的调测，有时还会优化重构。对于写文字也需要类似的过程，毕竟一气呵成地写出一篇完美的文章，就像是个不可实现的传说。其中，代码重构中的重命名、分拆过长的函数等，就类似于对文章重新进行文字的遣词造句、润色打磨、段落分界等过程。 另外，之于编程和写作，不同的技能应用水平，实现效果就完全不同了。写过程序的都知道同样的架构设计，选择不同的语言、框架、算法和数据结构来实现，实现的技能水平要求可谓千差万别。而同样主题和逻辑结构的文章，不同文字技能水平的作者来写，高下立见。 比如，网络小说兴起之后，我也看过一些，对男主角人物的描写，多是男神化。用词无非，帅则温润如玉、玉树临风；正则气宇轩航、丰神俊朗。但太过正的角色还不行，又会加点邪气，如狂浪不羁等描述，这样更讨读者喜欢。再对比下金庸是如何描述类似这样的人物的： 这本来面目一露，但见他形相清癯，丰姿隽爽，萧疏轩举，湛然若神。 短短四组词，一个身形清瘦、风度俊爽、洒脱轩昂、目光有神却又透出一股子高处不胜寒的人物——黄老邪——就跃然纸上了。金庸用词简练而韵味深长，境界高下立判。这就是文字技能的应用水平了，就像武功招式。金庸在文字上浸淫多年，随手用出一招，自是比普通人精妙许多。 写程序和写文章，本是两种不同的 “武功”，“心法” 可以类似，但 “招式” 自不相同。而 “招式” 的积累与应用，无论写程序还是写文字，都没有什么捷径可走，只能多看、多写、多练。 除此之外，写程序和写文字的实现过程的环境要求也有类似之处：程序员写代码的时候很讨厌被人打断，需要一段能安静且专注的时间，通常 2～4 小时不等。写作也一样。所以，我经常选择在晚上夜深人静的时候进行写作的 “实现” 阶段。 这一点，不仅程序员是这样，很多知名作家也都有自己独特的写作过程要求，他们的共性都是需要一段能实现不被打扰且专注的时间。 村上春树，当他进入创作小说的写作模式时，他通常早晨 4 点起床，连续写作 5 到 6 个小时，然后会去跑上 10 公里或游 1500 米（或者二者都有）。下午就不再写作，而是读点东西，听听音乐，晚上 9 点便上床睡觉。他日复一日地保持这样的作息时间、这样的重复过程，据称能帮助其进入一种思维的深层状态。 海明威，通常是早晨天一亮就开始动笔。在采访中，他说道：“没有人打扰你，早晨凉爽，有时候冷，你开始工作一写就暖和了。你读一遍你写好了的部分，因为你总是在你知道往下写什么的时候停笔，你写到自己还有活力、知道下面怎样写的时候停笔。”他通常每天只写 500 字，而且喜欢用一只脚站着，采取这种资势，据称可以使他处于一种紧张状态，迫使他尽可能简短地表达自己的思想。 实际上，这些年写作下来，我也尝试了在很多不同的时间段，甚至分多次写完一篇文章。这里没有一定之规，你总会找到适合自己的写作实现方式。在这个过程中，你有一段专注、忘我甚至像是做梦的过程，与自己的思维深处对话。 在这个过程中，你也可能会产生意外的大脑神经元连接，获得一些更高质量的思考，灵光乍现的启发，以及更好的文字表达。 四、测试每次写完一篇文章后，就感觉自己好像是被清空了，甚至不再想去读一遍，这时我就会把它“扔”在一边。 写作的过程中，大脑从冷的状态逐步升温，直到进入一种很热的状态，文字就是在这样的状态下自然流淌出来的。直到写完之前，大脑一直在高速运作，就像一颗 100% 利用率的 CPU，它的温度很高。写完后，CPU 终于降低了负载，但温度的降低还需要一个过程。 而对写完的文字再读一遍，进行再编辑和优化，这就像软件开发中的测试过程。但我需要在一个冷却的状态下进行，站在一个读者或编者的视角去重新审视这篇文章。所以，这个过程通常发生在写作完成后的一天或几天之后。这中间的间隔，我称之为写作后的冷却时间。只有在冷却的状态下，我才能更客观地检视自己写的文字，同时进行合适地编辑和修改，这个过程就是对文字的测试。 作为程序员，其实我并不喜欢做太多的测试工作，所以在以前我写作完，只是“履行”最简单的文字测试内容：必要的错别字、用词理解性和语句流畅性检查。和 “极客时间” 合作写专栏就给配备了专业的编辑，编辑主要会从下面几个方面进行测试或检查。 文词使用：进一步发现有时作者自己很难发现的错别字和用词的适当性、理解性问题； 逻辑结构：整体文字内容的逻辑结构，衔接过渡是否自然等； 读者感受：站在读者的角度，去考虑其感受以及能够得到的收获； …… 这就是关于文字的测试，就像一个好的测试总是能帮助开发者得到一个更好的软件一样，一个好的编辑也总是能帮助原作者形成更好的文字输出。 五、交付完成了必要的编辑测试工作后，就到了最终的交付（发布）阶段。 写作本身是一个不断积累压力的过程，而交付之后则完成了一种压力的释放与转换。关于这一点，和菜头描述得特别精确： 写作真正的压力来自于完成一件事情的压力，你要么一开始连个标题都想不出来，要么写两段之后就不知道如何继续下去。写第一篇文章会是一次漫长而痛苦的自我挣扎，你大概有 30% 的精力花在构思内容上，剩下 70% 的精力花在自我怀疑和自我否定上。 而交付，就是发布这篇新写的文字，让它面对读者，获得反馈与验证价值。 交付一篇新的文字，就像是往这个互联网的文字海洋中扔下一滴水珠，偶尔也会激起几丝涟漪。时有读者留言、评论，或有赞，或有踩，而从作者的角度出发，交付的目的之一是希望有一些更有价值、值得思考和讨论的声音出现。 写作与文字的价值实现分两部分，写完后就完成了对自我的价值实现，而交付后才算完成了对他人的价值实现。 当你把写作拆解成了类似编码的过程，也许阻碍你写作的障碍与阻力也就变得没那么大了。如果你能编写清晰有效的代码，也就应该能写出主题结构清晰的文字。至于一开始文字的好坏，技巧的高明与否，反而并不重要，在持续写的过程中，它们会自然而然地得到提升。 方法有了，还需要找到写作的源动力，而大部分作者的源动力都来自于一颗想要表达的心；再配合一部分外部的激励机制，和相应的自律约束，才有可能持续地写下去。 最后，多说一句，极客时间上的留言质量很多都不错，如果你还没有开始写点东西，不妨从留言开始记录一些你的思考和观点，留下价值。 31 画图：一图胜千言对于写作这种展现形式，有一种最好的补充手段就是画图。有时文字描述了半天还不如一张图来得清晰，正所谓：一图胜千言。这对于程序员特别需要的技术性文档或文章写作，都是最好的补充注解，有时甚至起到了画龙点睛的效果。 以前我在网上发一些技术博文，就常有读者留言问我是用什么工具画图的。其实我感觉他们很可能问错了问题，因为我曾经为了画好图尝试过各种不同的画图工具软件，但最后发现能不能画好图和工具的关系并不大。 一、为何？程序员不是主要写代码的么，为什么需要画图？ 有些程序员会认为写好代码就好，画好图有什么用？程序员成为架构师后是不是就天天画架构图，成为了所谓的 PPT 架构师？曾经读过一篇文章《在首席架构师眼里，架构的本质是…》，里面提出了一个架构师能力模型图，（我重新绘制）如下： img 架构师能力模型图 结合我自己的经历和经验，这个能力模型针对架构师这个岗位来说还是比较符合的。程序员出色到了一定程度后想成长为一名架构师，就需要看看能力模型中的其他方面。而掌握好画图技法，对这个能力模型有什么帮助吗？ 前面讲系统设计的文章《多维与视图》中我已经给出过结论：“用更系统化的视图去观察和思考，想必也会让你得到更成体系化的系统设计。” 在今天这个时代，我们都体验过各种各样的地图软件，一个国家，一个城市，一个街区，地图软件总是在不同的抽象维度上来展示地图。而对于一个复杂的软件系统，也需要类似的不同抽象维度：系统的全貌、不同子系统间的关联和交互、子系统内部模块间的接口和调用、某个关键实现点的处理流程等。一个架构师应该可以在这些不同的抽象维度上把系统或系统的一部分清晰地描绘出来。 而画图对于能力模型中的 “抽象思维” 就起到了一种锻炼，其作用就是帮助你在不同的层次上去思考系统设计，并具象化这个设计。既然具象化了设计，那么再基于此去沟通交流自是事半功倍。成为架构师之后，你自己明白还不是主要的，要让别人明白才更重要。 此外，站在一个多层次、全方位的系统架构图面前，在不同抽象维度上描绘了系统的各个重要方面，想必更容易看到问题的本质，也能更好地发现和找到系统的症结。如果解决系统的问题就像走迷宫，那么你是直接钻进去反复尝试寻找出路，还是站在更高的维度去俯视迷宫然后再找最佳的问题解决路径呢？ 想必在更宏观和全局的视野下，与系统所有相关人员进行清晰准确地交流，直击问题本质，那么再进行正确而适当的技术决策与平衡取舍也没那么难了，对吧？至于 “多领域知识” 和 “技术前瞻性” 这两方面好像确实和画图的关联性不强，但如果“多领域知识”不限于程序技术领域，那画图也算一个领域的知识吧。 二、如何？上一节探讨了画好图有什么益处，这一节我们看下如何画好图？画一个清晰易懂的技术架构或交互流程的说明图例需要什么专门的绘图知识与技巧么？另外为了画好图会花费大量的时间么？ 过去几年在关于如何画好图这个课题上，我做了好些摸索和实践，想取得效率（即，画图花费的时间不会比用文字来描述同样的内容更多）和效果（即，图例表达的效果应该比文字描述更好）的平衡，在这个过程中我收获了下面一些基本认知和感觉还不错的实践方式。 1. 图形我画技术图例时只会使用一些最基础的图形，比如：矩形、圆、三角、菱形、气泡、箭头，这些最基本的图形几乎所有的画图软件都会自带的，所以工具的依赖性很低，但真正画时的操作效率却又很高。 当然，一些著名外部系统可能都有各自知名的 Logo 图标，如果有时为了表达和这些著名外部系统间的交互，也会直接使用它们的 Logo 图标。如下面图示，就是我常用的一些画图图形元素。 img 我的一些常用画图元素 2. 颜色有时系统的组成比较复杂，只用基本图形不足以表达所有不同的系统组成部件，这时就需要用颜色来区分了。 那么下一个问题就来了，该用哪些颜色呢？我的答案是使用大部分人觉得美的颜色。那大部分人觉得美的颜色是什么呢？彩虹色，当然这一点也我没有做过专门调查，只是凭经验得来。所以我一般用的颜色就是彩虹七色，外加两种经典色：黑、白。这样就有九种颜色加上好几种基本图形，可以组合出几十种表达不同组件的图形元素，基本也就够用了。 彩虹七色包括：红、橙、黄、绿、青、蓝、紫。但七种颜色的选择也是有优先级，在一本讲设计的书中 Designing with the Mind in Mind（中文译本《认知与设计》）提出了下面一些色彩使用准则： 使用饱和度、亮度以及色相区分颜色，确保颜色的高反差，因为人的视觉是为边缘反差而优化的。 使用独特的颜色，因为人最容易区分的颜色包括：红、绿、黄、蓝、白和黑。 避免使用色盲无法区分的颜色对，比如：深红－黑，深红－深绿，蓝色－紫色，浅绿－白色。 使用颜色之外的其他提示，对有颜色视觉障碍的人友好，而且也增强了可理解性。 避免强烈的对抗色，比如：红黑，黄黑。 以你看为什么交通灯是：红、黄、绿？为什么乔布斯选择这三个颜色作为 Mac 操作系统中所有应用窗体的按纽颜色，这也是暗合人类的视觉认知原则的。所以我现在多选择的是白底、黑字、黑色线条，色块优先选择红、绿、黄、蓝，实在不够用了才会选择橙、青、紫。 当然红有好多种红，绿有好多种绿，该用哪种呢？看下图所示，给出了 RGB 三原色的配色数值，这属于个人偏好，在 Mac 的显示器下看起来很舒服。但若用在其他场合，比如投影什么的，就可能需要根据投影实际效果进行微调了。 img 个人偏好的颜色配色参数 3. 审美除了基本的图形和颜色选择之外，另外一个关注点是审美。 审美对最终的效果呈现有很大影响，这得感谢苹果总设计师乔纳森·伊夫（Jonathan Ive）把大众的审美倾向全部带入到扁平化时代，所以实际中我只需要把图形弄得扁平，去掉立体、阴影什么的，看起来就还不错了。毕竟我们画的是系统设计图，不是美术设计稿，审美方面的追求就适可而止了。 img 审美效果示例图 三、几何？探讨了如何，我们再接着看看几何。此 “几何” 不是数学里的几何，而是掌握画图技法到底代价几何？又价值几何呢？ 好些年前了，我画的技术图示（来自以前的一个分享 PPT）大概是下面这样的，总是觉得不好，不太满意，却又不知道不好在哪里，以及该怎么改进。然后就归咎于工具不好用，从一开始用 Viso 画，后来尝试了 Mac 下的专业绘图工具 OmniGraffle，觉得太复杂，后又找到个在线绘图网站 draw.io，感觉还可以，但由于是国外网站，访问效率不太好，没多久就又放弃了。 img “优化前”的技术图示 之后需要做一些胶片演示时，用了 Mac 下的 Keynote（相当于 Windows 下的 PPT），需要画技术图示时想如果直接在 Keynote 里画最省事了，然后就开始用 Keynote 画了。按 “如何” 一节的指导原则，我重新画了下上面那个技术图示，如下： img “优化后”的技术图示 这花费的时间绝对不会比画上面那个多，但呈现出的效果却要好很多。所以，学会使用一种简单的软件，使用简单的图形和配色，在最有效率的情况下画出一幅效果还不错的图例，也是很有价值的。 当然你可能会认为只有写出的代码才有价值，其实这里你可能忽视了一个大部分程序员都认同的观点：代码也是写给人看的。程序员不会认为一份机器能运行而人很难看懂的代码是好代码，而画好图就能更好地帮助你去思考代码的组织和呈现方式。 曾经问我关于画图工具的人，我知道他们差的不是一个画图工具，而是对于 “画图” 本身的思维认知与技法打磨。所以在本文我分享了我近些年一直在使用的一种极简绘制技术图例的技法，毕竟我们画图只是为了追求讲清楚一个技术方案或展示一个系统，而不需要考虑任何多余的艺术性。 最低的代价，还不错的效果，在效率和效果之间取得性价比最高的平衡。曾几何时，你想象中很麻烦的事原来也可以如此简单。 关于展现的第二种形式：画图，今天的分享就到这里。你平时是如何画技术图示的？在用什么工具？欢迎你在留言区和大家分享分享。 32 演讲：表达的技术展现的另一种形式是：演讲。其实作为程序员出身的我，演讲水平非常有限，但在职业发展与成长的道路上，演讲却是必经之路。所以，我确实有比较系统地思考和琢磨过演讲的价值、效果以及提升的方法，现在我将其分享给你，希望能对你的成长或者职业道路有所帮助。 一、价值与效果写作的展现，是一种广度路线，产生间接、长尾效应；演讲的展现，是一种深度路线，产生直接、深度连接。 为什么说写作是广度而演讲是深度的？过去几年，我读过很多的文章、书，但还能记得住只言片语的都非常少。即使当时一些给我非常多启发与触动的文字，如今也只能记得当时触动的感觉，却忘了触动的内容。但好些年前，我参加过几次行业大会，有那么几场演讲，现在回想起来，不仅记得当时深受启发的触动感，甚至还能记得当时的内容。 这就是演讲带来的深度效应，它的现场感更立体，有助于留下更深刻的记忆，持续发挥影响的时间也超过了文字。 演讲的现场立体感带来的深度效应，也只能留在现场。即使我们把整个演讲过程录制成为视频，观看视频的过程也会损失很大一部分深度影响力，也许这就是为什么有人会去看现场演唱会的原因。 所以，演讲的最大价值就在于这样的深度效应。但现场感并不一定带来深度影响，也可能是把人 “催眠” 了。那如何发挥好演讲的效果呢？这里我就先谈谈我自己的一些经历和感悟。 二、经历与感悟成长路上，终究会遇上演讲；从没遇上演讲的程序员，可能天花板就会比较低。 作为程序员，我的第一次演讲经历，当然是技术分享，团队内部的。如今回想，第一次分享暴露出了很多方面的问题。比如，材料准备时发现 PPT 技能太差，想展现的内容做出来的效果太挫；现场讲的时候容易跑偏或者陷入细节，整体节奏失控；想表达的内容太多，信息量过大。这些问题都导致第一次演讲的效果不尽如人意。 后来再有技术分享的机会时，我已经开始写作了一段时间，发现写作实际对演讲是有帮助的。写作和演讲的共通处在于：内容、观点、信息传递的目标都是要考虑的，只是最终的表达形式不同。而且因为写了不少东西，也反而获得了更多的技术分享机会。 从业这么些年，经历了从线上到线下，从组内到部门，然后再到公司或行业级的不同规模的分享演讲，挑战并不一样，其中最大的区别在于现场感的压力不同。而且除了分享式的演讲，还有另外一种汇报式的演讲，如：晋升述职。 技术分享，一般时间会长一些（一小时左右），而晋升述职，时间则要短很多（十分钟左右）。前者的压力来自对象的规模，后者的压力来自对象的角色。 而不同时长的演讲，准备的方式也不太一样。时间长的演讲，准备的内容就多，要精确地讲好这么多内容是一个挑战；而时间短的演讲，内容不多，但就需要合适地挑选和裁剪，并且精确地传递，这又是另外一种挑战。 那对于不同的演讲类型，有通用的准备方法吗？下面我们尝试梳理下。 三、准备与发挥一场演讲，包括前期准备和现场发挥两个阶段，而前期充分的准备是现场良好发挥的基础。 世界上有一个著名的演讲论坛 TED，它上面的演讲，即使仅仅是视频，很多都给人留下了深刻的印象，而且传播范围也很广。它的演讲者通常是一些知名人士或至少是业内影响力比较大的人物。 我一开始以为他们本身就已经是很好的演讲者了，但后来了解到他们为了参加 TED 短短十来分钟的演讲，需要全力以赴地投入以周为单位的时间。比如，《哈利波特》的作者罗琳去 TED 演讲时，为此全心投入准备了整整六周。 那前期可以准备的内容有哪些？我梳理了有如下维度： 1. 框架演讲的框架和程序的架构有点类似，一般我都从下面几个方面来设计： 目标：本次演讲需要达成的目标是什么？ 听众：本次演讲的受众是哪些人？ 重点：本次演讲要传递的关键点有哪些？ 那么一场技术分享的框架线，可能有如下： 引出主题：结合目标与听众来确定。 自我介绍：让听众了解你，证明你有资格讲这个主题。 重点结构 ：每一个关键点的分析、讲解，可以从以下方面来拆解。 问题：这个点上存在什么问题？ 历史：这个问题的历史由来是什么？ 方法：你是用什么方法解决这个问题的？ 原因：为什么要用这个方法，要在这个阶段，以及这样解决问题？ 细节深入：有一定细节深入，更有说服力。 总结回顾：结束前的再次总结和提炼，以加深印象。 2. 材料在框架线清晰后，就进入了演讲材料的准备阶段。其中的材料包括三类： 第一类是幻灯片。到底要准备多少页的幻灯片？这个取决于框架线和演讲时长。但这里幻灯片的最大作用在于： 辅助演讲者的结构记忆与信息表达； 辅助听众的信息吸收、理解与消化。 也就是说，演讲的主角还是讲，而幻灯片仅仅是配角。 第二类是演讲稿。讲之前你可以先写下来你所要讲的内容，这样会有助于组织信息、梳理逻辑和提炼语言。 TED 的演讲以前多是 18 分钟，而现在分长、短两种：短的约 6 分多钟，长的也缩减到了 12～15 分钟。在信息爆炸的时代，听众的注意力是一种稀缺资源，想要吸引这样的注意力，就需要提供更精确且直击人心的内容，才能收获你想要的深度影响效果。 我们的正常语速大约是每分钟 150～200 个汉字，但在演讲的压力环境下，可能会出现不自觉地加速，无意识地跑偏，甚至语无伦次。如果想要提供更精确的信息传递和表达，那么演讲稿就是必需的。 让演讲的每一个字，都体现它的价值。 第三类是小故事。人是情感动物，故事的影响效应远高于数据和逻辑，即使是在做技术分享时。 以前听过一些技术分享感觉比较枯燥、催眠，就在于技术基本都在讲逻辑、讲数据，听久了自然疲劳。而穿插一些 “小” 故事，则可以加深前面数据和逻辑的影响效应。这一点很多慈善募捐组织早就学会了，再大比例的穷困数据，也比不上一张衣不蔽体的小女孩照片来得有效。 3. 节奏一段持续时间的演讲中，有没有一些关键的时间点呢？当然是有的。 一个是开场。据研究统计，一场演讲给人留下的印象和评价，开场的数秒至关重要。这可能和一开始是否能抓住听众的注意力有关。 另一个是峰终。管理界有一个 “峰终定律（Peak-End Rule）”：在 “峰” 和 “终” 时的体验，主宰了对一段体验好或者不好的感受，而在过程中好或不好体验的比重、时间长短，对记忆的感觉差不多没有影响。也就是说，如果在一段体验的高峰和结尾，你的体验是愉悦的，那么你对整个体验的感受就是愉悦的，即使这次体验总体来看，更多是无聊和乏味的时刻。 峰终定律，在管理上决定了用户体验的资源投入分布，只需要重点投入设计好 “峰终” 体验。而演讲，也是一门体验艺术，它的 “峰” 前面说了一处——开场（抓注意力）；另一处，可能是中间某一处关键点（提供独特的高价值内容或观点）。 4. 表演演讲，包括讲和演，因而还有最后一个准备环节：演。 演，即表演和发挥；表演的准备，有三个层级，如下图（原图来自 Tim Urban’s Memorization Spectrum，翻译后重绘制）：即兴发挥、框架内发挥和严格遵从剧本。 img 表演准备的三个层级 做了前述准备的演讲，算是在框架内发挥。如果还准备了演讲稿，那么练习熟练后，基本算是接近了 3A 这个层级，但演讲稿，还算不上是剧本，所以只是接近。按 3 这个层级的准备，是把演讲当作了一出舞台剧，有严格的剧本，需要经过反复地排演练习。 这样的准备投入是巨大的，所以你一般需要判断到底多么重要的演讲，才需要用上 3 这个层级的准备。但即使达不到 3 级的标准，按这个标准来准备也有好处，当你非常熟练了你想要精确表达的内容，在现场发挥时，你的大脑就会从记忆负担中腾出空间来应对临场那些很难提前准备的状况。 “演” 需要关注和练习的东西比 “讲” 多得多，而且表演本身就是一种专业，甚至也是一种天赋。这条路上，你可以先有一个清晰的认知，但能做到何种程度，可能因人而异吧。 演讲，本是表达的艺术，但对程序员的要求远没到艺术的层次；先能表达，再求精确，技术达标，足矣。 关于展现的第三种形式：演讲，就分享到这了；而演讲也是很多程序员的一道槛，如今的你遇到这道槛没？欢迎你留言分享。 33 定义：阶梯与级别从今天开始，咱们专栏会开启一个大家可能都比较感兴趣的主题：程序员的职场阶梯，以及攀登阶梯的晋升博弈。 任何种类的职场上升通道都是一个阶梯，但程序员的阶梯有何不同呢？ 在程序员职业生涯的发展过程中，都会经历一个修炼成长、打怪升级的过程，而每个公司可能都会定义自己的升级阶梯。以 AT 为首的两大巨头，其对技术人员的级别定义在互联网业界比较公开。例如，阿里的程序员级别从 P4 到 P14，而腾讯则定义了五个大级别：从 T1 到 T5，并且 T4 之前的级别内部还会细分为若干小级别。 相对来说，腾讯的 5 个大级别与我自己一路走来经历的几个阶段感觉会比较匹配一些，而大级别之间的分界线也会更明显一些。我对升级阶梯的定义也是 5 个：初级、中级、高级、资深和专家。 至于对不同级别的定义，我选择了三个相对容易判断的维度： 具备什么能力？ 解决什么问题？ 产生多大影响？ 初级初级，多属于刚入职场的新人。 一般刚从学校毕业的同学，具备基本的专业技能和素养，能快速学习公司要求的常用开发技术、工具和框架，能理解所在的业务和产品领域，并按照设计要求来实现功能。他们通常都工作在系统中局部某个区域内，能独立或在有限指导下实现功能并解决该模块碰到的具体问题。 这个级别基本完成的都是螺丝钉级别的工作，影响很有限。但如果从这个阶段你就开始定期归纳总结这些局部的工作经验，不断优化工作内容，并能在团队小组内部做出分享，甚至帮助其他同学解决问题，那就说明你已经走上了一条快速成长的通道。 刚入职场的同学，有本科，有硕士，还有博士，这有区别嘛？我个人感觉本科和硕士进入职场相差不大。当年我是硕士毕业，进入第一家公司算初级，本科算助理工程师，有一个小级别的差异，而薪酬待遇则相差无几。 那时腾讯也来学校宣讲，本科年薪 6 万，硕士 8 万，而博士 10 万。仅仅从年收入差距来看，读硕、读博似乎不是个划算的选择，可恰恰很多人选择读硕就是为了能有一个更好的工作起点，而选择的标准也可能恰恰就是薪酬占据主导方面，这貌似是一个误区。 以前看过一期《奇葩说》，一个清华男从本科读到博士，跑去节目上说了半天就是为找什么工作而苦恼，惹得同为清华毕业的高晓松当场发飙，而同为点评嘉宾的蔡康永也说了句很中肯的“实在话”： 一直花时间求学，也许是为了拖延人生做决定的时间。 中级中级，相对初级最大的质变在于：独立性。 初级同学经过两三年工作历练，对实现各种业务功能、开发规范流程都很熟练了，摆脱了对基本指导的依赖性，这时就进入了中级阶段。中级工程师已经能够独立承担开发任务，设计实现他们负责的系统模块，以及通过搜集有效信息、资料和汲取过往经验来解决自己工作范围内遇到的问题。 中级这个层面的基本要求就是：完成动作、达成品质和优化效率，属于公司 “动作执行” 层面的中坚力量。观察下来，这个级别的工程师多数都能做到完成，但品质可能有瑕疵，效率上甚至也有很多无效耗散。不过，效率和品质总是在不断的迭代中去完善，自身也会在这个过程中不断成长并向着下一个阶梯迈进。 不少同学卡在这一阶段，就是因为虽然不断在完成工作，但却没有去反思、沉淀、迭代并改进，从而导致自己一直停留在了不断的重复中。所以，在工作中要保持迭代与改进，并把你的经验分享给新来的初级同学，这样在未来之路你不仅会走得更快，而且也可能走得更轻松。 高级高级，不仅要能独立完成工作，还要能独立负责。他们能独立负责一个大系统中的子系统或服务，并成为团队骨干或最重要的个人贡献者。 相比于中级，高级工程师在 “动作执行” 层面，不仅能独立完成高级难度的开发任务，而且在用户体验（品质提升）和性能优化（优化效率）方面还都能做出更全面的考量。也就是说，他们不仅仅可以把开发任务完成得又快又好，而且还能清晰地定义出多快、多好。比如，一个服务的响应时间 99.9% 是在 20 毫秒内，内存消耗最大不超过 1G，并发吞吐量 10000+/s，类似能用清晰的数据来定义服务品质和效率。 另外，高级别需要面对的问题就不再是单一维度的技术问题了，他们需要结合业务特性去考虑设计合理的解决方案。熟悉业务领域内的应用系统架构以及各个部分使用的技术，能根据业务特性，合理进行分层设计，实现高效率、低成本的运维或运营。 初、中级别的能力提升与影响输出是通过经验的归纳总结与分享，那么高级则需要在经验这种偏个体特性的基础上，再进行抽象提炼，沉淀方法论。换言之，通过个人的经验，研究行业的优秀实践，再结合自身实践和逻辑推导，沉淀出切合现实的方法论，并在团队内部推广应用。 资深资深，有深度和资历（即广度）两个层面，对应到职业生涯路线上，也有两个方向。 资深工程师 架构师 在偏基础研发、算法和特定技术复杂领域，会向 “资深工程师” 方向发展，属于深度优先。而在面向业务开发的领域，业务复杂度高于技术复杂度，则会向 “架构师” 方向发展，属于广度优先。 但无论深度还是广度，进入这个级别即说明你在特定领域都已经具备了相当的积累。这时你是作为相关领域的专家，深度参与和支持团队项目，在领域内进行关键的技术判断和决策，进而帮助团队项目或产品加速成功。在这个层次上，你面临的都是一些更复杂的、具备一些灰度（不是非此即彼，而是需要折中权衡）特性的问题，这时就需要你能够全方位、多层次、多角度地深入理解问题，评估每种方案的收益、成本和潜在未来的长短期影响等。 这个层次的影响方面，除了经验分享和方法论沉淀，还有产品和团队两个考虑维度：即使是做纯技术的东西，最终的影响也是通过技术产品来完成的；而另一方面则是团队的梯队建设、结构调整与协作优化，决定了团队外在表现。这两个维度，前者可能资深方向侧重多一些，后者则是架构师方向需要侧重思考实践的。 专家专家，表明了某种领域的明确建立。 也许架构师和资深工程师也具备在特定细分技术领域的深厚积累，说明他们和专家一样也有属于自己的领域，但这个领域还不算明确建立，它还需要有公认的影响力。公认影响力实际指一个范围，如果是公司的技术专家，那么范围就是公司或行业。 虽然以 “家” 冠名会让人感觉太高不可攀，遥不可及，但实际 “家” 也分大小：一般的 “大家” 可能属于稀世珍宝，举国稀有的，确实是遥不可及；但也有 “小家” ，相对来说就没那么遥远了。“大家”和“小家”的区别，就在于影响建立的范围大小。 影响力听起来可能很虚，那我换个相对实的角度来说说。作为一个 Java 程序员，在学习使用 Java 的过程中总有那么几个人，你不仅要去读他们的书还要去看并且使用他们写的代码，反正在 Java 这个领域你总是绕不过去。那么，这就是他们在这个领域实实在在的影响力，自然也是这个领域的专家。所以，专家可能就是“这个领域内你绕不过去的人”吧。 积累多年，建立体系，形成领域，他们需要解决的最重要的问题是：面向未来不确定的战略问题。这就像机器学习用过去长期积累的数据，建立起一个模型，用来预测和判断未来。未来不可测，但建立好了一个领域体系后，当未来到来时，就可以很快地将新出现的信息加入到现有的领域体系中去，从而修正模型，做出快速地调整与决策。 最后，我借用鲁迅在《故乡》里说的一句名言： 其实地上本没有路，走的人多了，也便成了路。 前面定义出来的阶梯就是那很多人已经走过的路。不管现在走到了哪个阶段，我们都走在同样的路上，但会遇见自己不同的风景。 34 晋升：评定与博弈一般来说，公司到了一定规模都会形成自己的职场阶梯，程序员在攀登这条阶梯时，肯定会涉及到一个评定的过程。那从评定者的角度，或者晋升者的角度，该如何看待你在阶梯上的位置呢？ 晋升的结果和个人利益有直接的绑定关系，而且这个过程从来都不是一个简单的是和否的选择，那你该如何看待这个“不简单”的晋升过程呢？ 标准维度先站在评定者的角度，假设你作为一名评委，你会如何去评定？又有怎样的标准呢？ 技术晋升评定是依赖人的判断，本是非常主观的一个过程，但为了规避这种过于“拍脑袋”的主观性，就需要去制定标准。制定标准的初衷也是为了给评定过程增加客观性，将人的主观判断约束在一定的客观范围内。 这让我想起了奥运会的一些打分和结果具有主观特性的项目，比如：跳水。这样的项目不像跑步、球类等有非常客观的得分标准，打分还是靠人。但跳水项目，也有一些客观的标准，如：动作代码、动作姿势和难度系数。分解出了一些客观标准后，这样对于运动员完成情况的评判相对就会更容易形成一些共识判断。 我在参考了一些行业里大公司的晋升和技术素质模型，并结合当时团队的具体现状，制定了出了一些标准维度： 通用能力，包括学习能力、沟通能力和领导能力等； 业务能力，包括业务理解和领域建模等； 技术能力，包括深度、广度和技能应用等； 影响力，如知识总结、知识传承和人才培养。 除以上 4 个大维度外，还有一项 “工作业绩” ，不属于现场技术评定的维度，直接来源于过去一年的工作业绩评价。每个大维度会占据一定的比重，然后可以针对每个大维度去打分。 曾经我在早期的实践过程中犯过一个错误，就是想在小维度上去打分，感觉这样可能会更准确。但经过一次实际操作后，发现很难在短短的晋升述职过程中去仔细判定这么多细分的维度，这对评定者会产生很高强度的判断疲劳，最后反而更可能产生更大的判定误差。后来在一本解读大脑工作原理的书上了解到，人的大脑一般只能同时记住和判断 4 到 5 个并行任务。过于细分的维度，会让人的大脑负担不过来。 虽然有了客观的标准维度去细分判断，但人打分在细微之处依然会有主观的偏好。还是以跳水运动为例，郭晶晶和一个新秀一起参加国际大赛，她们跳同样的难度，同样的组别动作，并完成得同样好，但最后可能郭晶晶会得分高一点（我印象中有届奥运会上就出现过），这就是人主观评判的细微之处了。 过程识别晋升识别过程是一条链路，而技术标准评定只是其中的一个环节。 晋升过程启动一般由 HR 部门驱动发起，经过各个部门直属领导提报候选人，再经由技术委员会进行专业线评定，再去到管理层复议，最后又回到 HR 部门最终确定。这个过程是一条过滤器链路，有没有感觉像是编程中的责任链模式？ 第一个环节，HR 部门的责任是对提报候选人进行晋升资格确认，比如是否满足上一级别或岗位要求的工作年限，是否存在公司行政处分导致失去资格等；第二个环节，部门从满足资格的员工中进行提报，部门的作用是对提报员工过去一年在本部门工作绩效的认可；第三个环节，就进入了技术委员会组织的专业线技术评定，而通过技术标准评定后，是对其专业综合能力的认可。 最后，就进入到管理层复议环节，这个环节会有一个冲突点存在。奥运会的跳水运动员，不管你得了多么突破历史记录的高分，但奖牌却只有 3 个；同样，公司每年的晋升名额也是有限的。一般公司每年的晋升名额都会有一个比例限制，这是出于控制成本与优化人才结构的考虑，因而经过前面的环节，最后到达这里的人数可能多于这个名额。所以，管理层复议其实就是对最后多出来的人数，综合考虑整体和局部的利益，进行调节筛选。 了解了评定的标准和过程，就可以反过来站在晋升者的角度想想，如何才能更有效地被识别出来？ 晋升述职过程仅仅只有 10 到 20 分钟，即使采用了前面所述的标准维度，晋升述职者也只能在有限的时间内把过去一、两年的工作成果、能力成长展示在几个点的范围内。这对于评定者来说，就像在管中窥豹了，看不到全貌，看完几个展示的特征点后就需要判断这到底是 “豹子”（符合下一级别的晋升标准）还是 “猫”（不符合）。 我在做晋升评委时，就一直被这样的判断所困扰，多数述职同事都在这几个点上表现得很好。这就像是说，如果是豹子，它确实该有这些特征点，反过来，拥有这些特征点的就一定就是豹子么？这些特征点，是豹子的唯一或足够有区分度的标志性特征吗？ 我发现靠 “点” 上的判断，准确度自己其实也完全没把握，后来就想到了一种更好的方式，靠 “域” 的判断。域，即领域，包含了：责任域和能力域。蜘蛛侠里有句台词是这样说的：“能力越大，责任越大（With great power comes great responsibility）”，能力和责任总是相辅相成的。 责任域，就是你负责什么，这个相对容易识别。而能力域则过于抽象，很难清晰识别，在述职这样的形式中，最容易判断的仅仅是表达和沟通能力；至于业务和技术能力，虽不那么容易判断，但好在其有最好的展现形式：作品。 对于程序员，作品可以是一个完整的系统，但其展现不应该是一系列的技术点，而是先有整体（面），再深入局部（点），应该是一个画龙点睛的过程。从这样的展现过程中就能很好地体现出晋升者的业务与技术能力。 识别的过程，本质是在解一个概率问题，当参与这个过程的两方（评定者和晋升者）都这样努力去考虑时，我想这样的过程就会有更高的准确率。 博弈权衡晋升过程因为涉及太多个人的利益，所以评定过程的公平性是所有参与方都关心的问题。 以上过程乍一看还算公平，里面有绝对客观的资格筛查，而对于主观的人为评定也采用了多人制评定方式，分散了个人的好恶影响，并且还由客观标准限定了人为评价范围。但这里面依然存在不公平因素，这个因素就是评定过程本身的形式。 程序员的特点是多擅长和机器打交道，编程能力强于表达能力。而评定的过程是靠述职这种形式，它偏重于表达。若一个完全不擅于表达，而编程和解决问题能力很强的人，在这样的形式下就会吃亏，这就有失公平性。但反过来说，如果要追求一个对所有人绝对的公平方式，那么可操作性和成本可能也没法很好地控制。 以前读过吴军两篇关于讲法律的文章，在传统的理解中法律应该是最在意公平和正义的，但在文章中他提及了几个概念：民意与民义，民力与民利。这四个概念的含义如下： 民意：人民的意图； 民义：人民最在乎的公平和正义； 民力：人民让渡给国家和政府维护公平和正义的必要力量； 民利：人民的利益。 吴军在文章中阐述了这些概念代表的内容与法律代表的公平和正义之间的博弈权衡过程，有如下： 在现代社会中，一切都是有成本的，绝对的正义是不存在的。当给予一部分人正义时，可能要以在其他地方付出巨大的成本为代价。如果一个判决伸张了正义，但是让受害的一方更倒霉，这就违背了司法中关于民利的原则。 这让我受到了启发，司法判定和晋升评定有异曲同工之处，都是需要判定一个事情，也都受这四个因素影响而导致博弈权衡。 评定中的 “民意” 来自会参与晋升的员工，及其相关的直属领导和所在部门。而 “民义”，依然是保证公平。但 “民力” 的来源则不同，评定的权力实际来自于组织（公司），而非员工，所以最后的 “民利” 就应该是组织（公司）的整体利益。评定判断实际就是站在授予权力的一方，兼顾公平和利益。 当绝对的公平和利益发生冲突时，法律的判定实际更站在利益一方，符合 “民利” 原则，这就是吴军文中给出的一些观点和启发。那么技术评定中的公平会和组织利益产生冲突吗？什么是更符合组织利益的呢？也许人员和团队的稳定与良性流动是有利于组织利益的，选拔出更能代表组织技术实力的技术人员是更符合组织利益的…… 当把这些因素都考虑进来后，真正的评定过程实际就是所有这些因素的博弈并达到平衡。你看，虽然评定的结果只有是或否，但过程却是多种维度的考虑与取舍。 著名管理学家劳伦斯·彼得分析了千百个有关组织中不能胜任的失败实例，归纳出彼得原理： 在一个等级制度中，每个员工趋向于上升到最终他所不能胜任的职位。 晋升的本质是承担更大的责任，而责任和能力是需要匹配的，晋升就是完成这样一种匹配关系的过程。一个公司中的责任域是有限的、发展的、变化的，那你当下具备的能力域是否匹配相应的责任域？你正在学习和开发的新能力域，是否能在组织中匹配上合适的责任域？这才是看待职场阶梯与晋升的正确方式。 保持不断学习和提升能力，找到并承担起合适的责任域，那么后续的晋升并贴上一个相应的职级标签，就是一件自然而然的事情了。 晋升、职场阶梯和级别，更多是一种形式和标签，其实最后更重要的还是自己的成长，你说呢？ 35 关系：学徒与导师现在很多公司都有一种带新人的导师（Mentor）制度，导师制的初衷是为了帮助新员工快速熟悉公司环境，并提供工作技能和个人成长的帮助，正所谓 “传帮带”。 这是用制度建立并约束了一种在新、老员工之间的关系，这本是一个很好的出发点。但想要类似这样的制度关系发挥期望的作用，恐怕就需要 “导师” 和 “学徒” 都有一个更高层次的清晰认知，毕竟制度只能在其中起到催化的作用。 起源导师制诞生于十四世纪，随之带来的是一场翻天覆地的变化。 突然之间，那时的年轻男女们可以用自己最富余的资产——时间，去交换当时最稀缺的资源——培训。在那个时代，经验丰富的手艺人，比如，铁匠、鞋匠、木匠等，他们指导这些年轻人，并承诺将来某天年轻人能学会他们的技能然后去开创属于自己的事业。作为交换，年轻人会提供低成本且廉价的劳动力。 作为学徒，年轻人可能赚不到什么钱，但却能学到关于这门手艺的各种经验和技巧。比如：一个铁匠学徒，能学会或掌握如何去建造高温火炉，组合不同的金属以产生不同熔点的合金混合物，以及制作耙、刀或犁等工作技能。这些经验和技巧，在当时的学校里是都教不了的，只能进入这行业去获得第一手的经验。 那么程序员这行的导师制，像是中世纪时期那样吗？似乎有点像，但也不完全一样。我们都知道编程这门手艺，你读的书再多、再好也不如真正动手去做。可是你一旦开始做了，也会很快掉入迷宫，因为路径千万，到底怎样才是对的？怎样才是好的呢？所以，现在好多公司都会说，“我们会为新员工或学生配备有经验的‘导师’来领路……”但，很多有经验的程序员并不能很好地理解（这也包括曾经的我），作为 “导师” 到底该做什么？要怎么做？以及做或不做于自己有什么关系？ 比如，一个有经验的程序员，走到一名新员工面前，问：“你会 Java 吗？会这个框架吗？” “学过 Java，但框架不太懂。” “来，这里是框架文档地址，你先看看，搭个 demo 先跑起来。” “恩，…” 这样的场景，也许大量存在于新手程序 “导师” 和 “学徒” 之间。 导师有经验的程序员、老员工，站在 “导师” 的视角，会如何看待这样的关系呢？ 从某种意义上来讲，经验丰富的程序员，就和中世纪的老师傅一样，他们经历了大量的时间犯过大量的错误，积累了很多难以言说的经验价值。他们已经经历过你所犯的错误，已然能够轻松应对如今让你痛苦和头疼的问题，所以他们具有能够引导你迈向正确方向的潜能。 但反过来想，他们为什么要指导你？只是因为公司有个导师制，并安排了他成为你的导师？那么这样的指导通常也就变成了上面那种场景。为什么他们要牺牲自己的工作时间，甚至私人时间来无私地指导你？也许作为新同学的你，甚至包括制度的制定者本身，可能也没从这个角度来看待该问题。 但如果不从这个角度来思考一种制度，那么很可能制度期望的是一回事，行动起来却是另一回事。若只是通过单纯的职业道德约束或价值观教育是解决不了这个问题的。毕竟中世纪的老师傅还可以靠利益交换与绑定来稳固这个机制和关系的。 大学里读研读博，也会有个导师。这样的导师，相对比职场的导师更进一步，因为你们之间有经济交换，你交了学费，所以学校导师就对你的毕业负有一定的指导责任。但你能获得多少质和量的指导与帮助，其实取决于你的态度和反馈。 所以你看，学生参加导师接的一些项目，本质上和中世纪的学徒提供廉价劳动力换取经验和指导是一样的。还有些学生，会为导师收集材料，用于发论文或写书，有些甚至干脆就是写好了论文或书，最后导师只是署个名。人品好点的导师可能还会给你留个第二作者的位置，差点的也许你连露脸的机会都没有。 而职场导师制，如果公司没有相应足够的考核、评价和激励制度支撑，那么这种师徒关系实际上没有任何约束，完全靠运气、投缘之类的。站在导师的角度，对于凑巧碰到的一个职场新人，他有什么样的利益或情感驱动要去更积极地做这件事呢？其实最直接的，还是由对方的态度和行动来驱动的。 而在没有这些更实质的驱动因素时，有人如果愿意去积极地做这件事，那一定是在更高的维度看这件事。借用一句话来说明： 取得领先的方法，就是提携你身边的人。你对待别人的态度始终会伴随你，人们会忘记你所说和所做的一切，但永远不会忘记他们对你的感觉。帮助别人就是影响别人，如果你能帮很多人，你本身就是高手，你的影响力就很大，你就能做更大的事。 这是一个气度问题。 学徒反过来，站在 “学徒” 的视角，该如何看待这样的关系？万维钢有篇文章叫《给前辈铺路的人》说得很有现实意义： 给人当学徒，就给你提供了这个机会。你现在把自己和一个高手连接在了一起，你可以从内部了解第一手的经验。这就是学徒工作的协议：用礼敬和服务，换取机会——而这个机会还不是立功露脸的机会，而是学习实践的机会。 机会，就是得到更快的成长与发展。从导师多年积累的经验中获益，能够缩短获得这些知识经验的时间，并且避免重复错误。但这里面可能还有个障碍，就是自尊心的问题，态度不够谦虚，那么也许是性格还需磨练。如果态度谦虚，双方都投入了适当的时间和精力，那么导师当年花了十数年才学会或领悟到的东西，学徒也许只用短短几年就能学到，绕过了没必要的重复路线。 从学徒方面来说，必要的、简单的、低技术含量或重复性的工作也是必须的，不应该被认为是一种浪费或牺牲。当你在免费获得大量的知识和帮助的同时，却抱怨时间投入太多，或者时间不够，其实是短视的。因为： 当你给人铺路的时候，你实际上也在左右他的前进方向。 这也是一个气度问题。 关系师徒关系有很多种，最让你期待的是哪一种？ 对我来说，联想起师徒关系，一下映入我脑中的是金庸小说《笑傲江湖》中的令狐冲和风清扬。在看这部小说时，也曾梦想遇见自己的 “风清扬”，学会绝代天下的独孤九剑。但后来随着年龄增长，我开始觉得，现实中也许终究不会存在像 “独孤九剑” 这样的绝艺，也不会有风清扬这样的师傅，直到我遇到一位美国作者德里克（Derek），他在自己的文章里分享了一个他的成长故事。 下面，我就从作者的第一人称来简述下这个故事。 学徒视角那年夏天，暑假，我 17 岁了，高中刚毕业。开学后，我就将进入伯克利音乐学院学习音乐。那时，我困惑于一些音乐问题，又找不到人解答。所以，我随机打给了一个本地的音乐工作室，工作室的主人基莫（Kimo）接起了电话。 我们聊了起来，当他听说我将去伯克利学音乐时，他说：“我就是从伯克利毕业的，之后还留在那里教了好些年的音乐。我打赌，我能在几节课内教会你学校安排了两年的音乐理论与编曲课程。另外，假如你能明白‘不要接受学校速度的限制’这个道理，我猜你也许能在两年内毕业。假如你感兴趣的话，明天上午 9 点来我的工作室上课，当然，这是免费的。” 两年内毕业？太棒了，我喜欢这个风格，实在太激动了。第二天一早，8:40 我就到了他的工作室门口，但我等到了 8:59 才按响了门铃。 导师视角一天早上的 8:59，我的门铃响了，我当时完全忘了为什么这么早会有人来。一直以来，我偶然遇见过一些孩子，他们都说想成为伟大的音乐人。我告诉他们，我能提供帮助，然后让他们早上 9 点来我的工作室，但遗憾的是从来没有人早上 9 点来过。这就是我从一堆孩子中识别出那些只是随便说说，还是真正认真严肃地想干点事的人的办法。直到那天，他来了，按响了我的门铃，一切就这么开始了。 后来的故事就是，德里克只用了两年半便从伯克利毕业了，并将这个抬高的标准和速度应用在了之后一生的事业与生活中。而他们也从师徒关系，转化成了朋友关系，维持了几十年，直到今天。 这像不像一个现实版的 “令狐冲” 与 “风清扬” 的故事？而这，就是我期待的一种师徒关系。 现实中，对于师徒关系，会有人有这样的疑问：“教会徒弟，会饿死师傅吗？”也许中世纪时期的师徒关系会有这样的担忧，但如今这个信息时代，知识根本不稀缺，也没有所谓的 “一招鲜，吃遍天” 的绝招。反过来说，带好了徒弟，接手并取代了你当前正在做的事情，你才有可能解放出来去做更高层次和更大维度的事情。 而作为学徒，你需要吸取德里克的经验：学习和成长是自己的事，严肃待之，行动起来，自助者，人亦助之。 在成长的阶梯上，无论你在阶梯上的哪个位置，都可以努力去寻找和建立这样一种关系，最好的状态，我想应该既是学徒又是导师。你觉得呢？ 36 核心：安全与效率——工程技术的两个核心维度在“修行：由术入道”模块的最后一个主题，我们聊聊工程，不是具体的工程的技术，而是抽象的工程之道。 做了很多年的工程，开发了各种各样的系统，写了无数的代码，说起这一切，我们都在谈些什么？ 我们谈过程，从需求工程到开发流程，从编码规范到同行评审，从持续集成到自动部署，从敏捷开发到极限编程；我们谈架构，从企业级到互联网，从面向服务架构（SOA）到微服务架构（Microservice）；我们谈复杂性，从高并发到高性能，从高可用到高可靠，从大数据到大容量。 那么对于这一切，你感觉这里面的核心是什么？ 核心核心，意味着最重要的，一切复杂的工程技术方案都是围绕着它来运转。 在深入核心之前，我们先讲一个电力行业的故事。虽说电力项目我没做过，但电站大概的工作原理在中学物理课上就已经学过了，原理很简单。虽理论上是这么说，但现实中看到那些大规模的电站后，还是感觉很复杂的。 故事是这样的：记得有个给我们上课的主讲老师是个须发皆白的老先生，进门后掏出一堆零件放在讲台上。一盏酒精灯、一个小水壶、一个叶片、一个铜光闪闪的小电机、一个小灯泡。老先生往壶里倒了些水，点燃酒精灯，不一会儿水开了，从壶嘴里喷出了蒸汽，带动叶片旋转，然后小灯泡就亮了。 老先生说：“这就是电厂。如果烧的是煤炭，这就是燃煤电厂；如果烧的天然气，这就是燃气电厂；如果获得热能的方式是核裂变，这就是核电厂；如果带动叶片的能量来自从高处流向低处的水流，这就是水电厂。” “你们或许会问：那我们看到的电站怎么这么复杂？答案其实很简单，电站需要复杂系统的目的：一是为了确保安全（Safety），二是为了提高效率（Efficiency）。安全与效率的平衡，是所有工程技术的核心。” 听完这个故事，我觉着所谓 “大道至简” 大概就是这样的感觉了。 安全安全，之于信息工程技术领域，包括了 “狭义” 和 “广义” 两个方面的安全范畴。如下图所示： img 工程 “安全“ 的狭义和广义分类 狭义的安全，就是传统信息安全领域的 “安全攻防” 范畴。比如，客户端的跨站脚本攻击（XSS）、服务端数据库的 SQL 注入、代码漏洞以及针对服务可用性的拒绝服务攻击（DDoS）等。这个方面的 “安全” 含义是信息技术行业独有的，但前面电站例子中指的 “安全” 更多是 “广义” 层面的。 在程序技术上的 “广义” 安全范畴，我划分了三个方面： 开发 运维 运行 安全开发，就是为了保障交付的程序代码是高质量、低 Bug 率、无漏洞的。从开发流程、编码规范到代码评审、单元测试等，都是为了保障开发过程中的 “安全”。 安全运维，就是为了保障程序系统在线上的变化过程中不出意外，无故障。但无故障是个理想状态，现实中总会有故障产生，当其发生时最好是对用户无感知或影响范围有限的。 通过自动部署来避免人为的粗心大意，资源隔离保障程序故障影响的局部化；当一定要有人参与操作时，操作规范和日志保证了操作的标准化和可追溯性；线上程序的版本化管理与灰度发布机制，保障了若有代码 Bug 出现时的影响局部化与快速恢复能力。 安全运行，就是为了应对 “峰值” 等极端或异常运行状态，提供高可靠和高可用的服务能力。 效率效率，从程序系统的角度看，同样也是从 “开发”“运维” 和 “运行” 三个方面来考虑。如下图所示： img “效率”的划分 开发效率，可以从 “个体” 和 “群体” 两个方面来看。 个体，就是程序员个人了，其开发效率除了受自身代码设计与编写能力的影响，同时还要看其利用工具的水平。更好的源码管理工具与技巧可以避免无谓的冲突与混乱；代码模板与开发框架能大幅度提升代码产出效率；而持续集成工具体系则能有助于快速推进代码进入可测试状态。 群体，就是一个团队，其开发效率最大的限制经常是架构导致的。如果你在一个工程项目上写过几年代码后，多半会碰到这样一种场景，代码库越来越大，而功能越改越困难。明明感觉是一个小功能变化，也要改上好几天，再测上好几天，这通常都是架构的问题，导致了团队群体开发效率的下降。 以后端服务架构技术演进的变化为例，从单体应用到面向服务架构思想，再到如今已成主流的微服务架构实践，它最大的作用在于有利于大规模开发团队的并行化开发，从而提升了团队整体的效率。理想情况下，每个微服务的代码库都不大，变化锁闭在每个服务内部，不会影响其他服务。 微服务化一方面提升了整体的开发效率，但因为服务多了，部署就变复杂了，所以降低了部署的效率。但部署效率可以通过自动化的手段来得到弥补，而开发则没法自动化。另一方面，每个微服务都是一个独立的进程，从而在应用进程层面隔离了资源冲突，提升了程序运行的 “安全” 性。 运维效率，可以从 “检查”“诊断” 和 “处理” 三个方面来看。 一个运行的系统，是一个有生命力的系统，并有其生命周期。在其生命周期内，我们需要定期去做检查，以得到系统的 “生命体征” 的多维度信息数据汇总，以供后续的诊断分析。 运行系统的 “体征” 数据是在实时变化的，而且数据来源是多层次的，从底层的网络、操作系统、容器到运行平台（如：JVM）、服务框架与应用服务。当异常 “体征” 指标出现时，很难简单地判断到底哪里才是根本原因，这就需要关联的因果性分析来得出结论，最后智能地发出告警，而不是被告警所淹没。 准确地诊断之后，才能进行合适地处理。和治病不同，大部分的故障都可以通过常见的处理手段解决，极少存在所谓的 “不治之症”。而常见的线上处理手段有如下三类。 恢复：重启或隔离来清除故障、恢复服务； 变更：修改配置或回滚程序版本； 限制：故障断路或过载限流。 运行效率，关键就是提高程序的 “响应性”，若是服务还包括其 “吞吐量”。 程序运行的高效率，也即高响应、高吞吐能力，所有的优化手段都可以从下面两个维度来分类： 更多 更快 负载均衡器让更多的机器或进程参与服务，并行算法策略让更多的线程同步执行。异步化、无锁化和非阻塞的算法策略让程序执行得更快，缓存与缓冲让数据的读写更快。 有时在某些方面 “安全” 和 “效率” 之间是相互冲突的，但工程技术的艺术性就恰恰体现在这冲突中的平衡上。 打个比方，如果你的程序就跑在你开的车上，那么“安全” 特性会让你开得更放心，“效率” 特性会让你开得更带劲。 做了多年程序工程的你，是如何看待工程的核心本质的呢？欢迎留言，一起探讨。 37 过程：规模与协作——规模化的过程方法在学校时，你学习编程，写写课程作业的代码，但你想过真正的行业里，公司中的规模化开发方式是怎样的吗？在上一篇[《核心：安全与效率》]的文中，你应该还记得我讲的那个电站的例子，那么编写课程作业的代码就像搭建的 “酒精灯电站”，而工业级的规模化开发才是建设 “真实电站” 的方式。 工业级规模化的程序系统开发包括了一系列的过程，而这一系列过程的起点是：需求。 需求与调度需求，有时会有很多不同的表达形式，包括：客户的诉求、用户的请求、老板的要求，但这些不同的表达形式，不一定是真正的需求。 客户的诉求，更多来自传统甲、乙方关系的场景，在软件工程过程中有一个子过程——需求工程——去对客户的诉求进行分析和提炼，并转化为需求文档。用户的请求，更多来自互联网 toC 的场景，通过洞察大量用户请求中的共性去提炼并转化为真正的产品需求。老板的要求，更多是因为老板也可能是你的产品用户之一，但这个用户的特殊之处在于，他为这个产品买单。所以，他的要求无论合理与否都能很容易地变成需要开发的需求。 正因为需求的来源多，表达形式也多，因而真实情况是 “需求” 似乎总是源源不绝，但是真正的需求往往隐藏在这些诉求、请求与要求的表象之下。这是关于 “需求” 的第一个困难点。如果我们总是能找出真正的需求，那么也许需求也就没那么多了。但现实往往是我们不能，那么需求过载的场景就会常常发生。 这时，你就会面临第二个困难，如何对过多的需求进行排序？ 为什么需要排序？我们进行需求排序的原因是，在有限的资源下我们想要达到如下目标： 最大化用户、客户和老板的整体满意度； 最大化价值与产出，让最多的资源投入到最有价值的需求上。 只有当用户需求被快速地满足时，他们才会感到满意。但在有限资源限制的条件下，我们不可能让所有用户的需求都能被快速满足。面对这样的矛盾，我们也许可以学习、借鉴下操作系统的资源调度策略。 我用了好多年的 Mac 和 iPhone，发现它们相对同等资源配置的 Windows 和 Android 机，在满足用户使用的响应性方面要好得多，特别是在使用了几年之后，这种差距会更明显。 在同等硬件资源配置的情况下，Mac 和 iPhone 表现得更好，只可能是其操作系统的资源调度策略实现更优秀。通常，操作系统需要同时执行多个应用程序时，它的执行调度策略就会在多个应用程序间不停切换，有如下几种常见的调度策略： 先来先执行 执行起来最快的先执行 占用资源最少的先执行 释放资源最多的先执行 高优先级的先执行 当资源充足，只用策略 1 就足够了，但更多情形下需要综合后 4 种策略。比如：老板的要求天生自带高优先级，需要先执行；而一些小需求，优先级不高，但执行快，占用资源少，随着它们排队的等待时间延长，优先级可以逐步提升，以免消耗完用户的等待耐心，形成负面评价。 当用户同时运行的应用程序确实太多时，操作系统发现资源无论如何调度都不够了，它有一个选项是提供了资源消耗的监视器，来提示用户主动停掉一些同时运行的应用，而最后的底线是操作系统主动杀掉一些应用程序以释放资源，以保障系统还能正常地运转下去。那么我们在调度需求时，是否也能以透明的资源消耗监视提示用户主动控制需求或选择 “杀” 掉需求，然后还不降低用户的满意度呢？ 需求调度，可以像操作系统一样运转，形成一个规模化的需求调度体系，并通过多种调度策略来平衡需求的响应性和投入产出的价值最大化。 设计与开发紧接需求之后的过程是：设计与开发。 成为程序员后，你一开始可能会习惯于一个人完成系统开发，自己做架构设计、技术选型、代码调测，最后发布上线，但这只适合代码量在一定范围内的系统开发模式。在一定范围内，你可以实现从头到尾“一条龙”做完，并对系统的每一处细节都了如指掌，但当系统规模变大后，需要更多的人共同参与时，整个设计和开发的模式就完全不一样了。 一定规模的系统，下面又会划分子系统，子系统又可能由多个服务构成，而每个服务又有多个模块，每个模块包含多个对象。比如，我现在所在团队负责的产品，就由数个系统、十数个子系统、上百个服务构成，这样规模的系统就不太可能光靠一个人来设计的，而是在不同的层次上都由不同的人来共同参与设计并开发完成的。 规模化的设计思路，一方面是自顶向下去完成顶层设计。顶层设计主要做两件事： 一是去建立系统的边界。系统提供什么？不提供什么？以怎样的形式提供？ 二是去划定系统的区域。也就是系统的层次与划分，以及它们之间的通信路径。 今年世界杯期间，读到万维钢一些关于 “足球与系统” 的文章，感慨原来系统的顶层设计和足球运动十分类似。按文中所说，足球的科学踢法是：“球员必须建立 ‘区域（zone）’ 的观念，每个球员都有一个自己的专属区域”，通过区域的跑位来形成多样化的传球路线配合。 而系统的区域划分，也是为了让系统内部各部分之间的耦合降低，从而让开发人员在属于自己的区域内更自由地发挥。而在区域内的 “控球”“传球” 与 “跑位”，就更多属于开发人员个体能力的发挥，这个过程中区域的大小、边界都可能发生变化，进而导致区域之间的通信路径也跟随变化。这样的变化，就属于自底向上的演化过程。 所以，规模化设计思路的另一面，就是要让系统具备自底向上的演化机能。因为，自顶向下的设计是前瞻性的设计，但没有人能做到完美的前瞻性设计；而自底向上的演化机能，是后验性的反应，它能调整修复前瞻性设计中可能的盲点缺陷。 记得，我曾经看过一个视频名字大概是 “梅西的十大不可思议进球”，视频里的每一个进球都体现了梅西作为超级明星球员的价值，而在前面提及的万维钢的文章中，有一个核心观点：“普通的团队指望明星，最厉害的球队依靠系统”。其实二者并不矛盾，好的系统不仅依靠 “明星” 级的前瞻顶层设计，也指望 “明星” 级的底层演化突破能力。 所以，一个规模化的系统既要靠前瞻的设计视野，也依赖后验的演化机能，这样才可能将前瞻蓝图变成美好现实。 测试与运维完成了设计与开发之后，系统将进入测试，最后发布上线进入运行与维护阶段。 在前面需求、设计与开发阶段的规模化过程中，都存在一个刚性扩展的问题，也就是说，如果提出的需求数量扩大一倍，那么需要去对接、分析和提炼需求的人员理论上也要扩大一倍；如果提炼出的需要进入开发的需求也翻倍，相应开发人员只增长一倍那已经算是理想情况了，这说明系统的正交与解耦性做得相当完美了，所有的开发都能并行工作，不产生沟通协调的消耗。 但真实的情况不会那么完美，需求的产生与爆发很可能是一种脉冲式的，而企业一般会维持满足需求平均数量的开发人员，当需求进入脉冲高峰时，开发资源总是不够，然后就会过载，进入疯狂加班模式。 开发完成后，进入测试与线上运维的循环阶段，这个阶段与前面阶段的不同之处在于：需求提炼、设计开发基本都只能由人来完成，而测试、运维的很多步骤可以通过制作工具来完成自动化过程。所以，这个阶段随着规模化过程实际可以是一个柔性扩展的阶段。 但它从来不是一开始就是柔性的，因为制作工具也有一个成本考虑。比如，在我做的这个系统发展的早期，系统架构简单、部署规模也很小，基本所有的测试与运维工作都是通过人肉来完成的，这样的效率也不算低，唯一的问题是对测试人员而言，大量的工作都是低水平的重复，不利于个人成长。 随着后来的业务快速增长，系统增长越过某个规模临界点，这时人肉负载基本饱和，效率已没法提升，制作工具是唯一的出路。你可能或多或少都知道一些现代化的工业流水线，而在软件开发过程中，“测试与运维” 的运转体系是最可能接近工业流水线方式的。 因此，以测试为例进行规模化的最佳方式，就是打造一条 “测试机器” 流水线，而我在[《转化：能力与输出》]一文中写到了关于打造 “机器” 的三个核心点，这里再强调一次： 流程规则 工具系统 规范共识 围绕这三个核心点，我们再来看看 “测试机器” 如何打造？ 从开发提测，机器自动下载提测版本分支代码，进行构建编译打包，实施代码规范性检查测试，通过后发布测试环境，进行分层次的各类自动化专项测试。如：用户终端层、通信协议层、服务接口层、数据存储层的各项测试，全部通过后，生成相应的测试报告，进入下一步发布流程。这就是测试体系的“流程”，而“规则”就是其中定义的各种测试项检查约束。 上述流程中涉及的“工具系统”包括：代码规范检查工具、终端 UI 的自动化测试工具、通信协议与服务端接口调用的模拟工具、数据一致性校验工具、测试报告生成工具、测试 Bug 统计分析与收敛趋势等可视化展现工具，等等。 最后，“规范共识” 是整个团队对这个流程环节、里面具体规则的定义以及 Bug 分类等方面达成的共识，这决定了这台 “测试机器” 运转的协调性与效率。 测试通过后，发布到线上就进入了运维阶段，行业里已经有大量的关于 DevOps 的分享内容，而它的本质也就是打造了一台 “运维机器” 流水线，这和我上面描述的 “测试机器” 运转类同，只是有不同的规范共识、流程规则和工具系统，便不再赘述了。 到了规模化的测试与运维阶段，看一个团队的水平，就是看这台 “机器” 的制作水准与运转效率。 在程序系统的开发过程中，当系统的大小和复杂度到了一定的规模临界点，就会发生从量到质的转变，规模不同，相应的需求调度、设计开发、测试运维的过程也都不同了。 量级变了，逻辑就不一样了。 每一个具备一定规模的组织都有对应的规模化工程过程，而且这个过程的形成受公司文化、团队构成、组织架构，甚至业务特性共同决定。那你所在组织的规模化过程是怎样的？这个过程系统如何运作的？欢迎你在留言区分享。 38 思维：科学与系统——两类问题的两种思维解法写了多年代码，做了好多的工程，不停地完成项目，但如果你一直仅仅停留在重复这个过程，那么就不会得到真正的成长与提高。你得从这些重复做工程的过程中，抽象提炼出真正解决问题的工程思维，用来指导未来的工程实践。 什么是工程思维？我从自己过往经验中提炼出的理解是：一种具备科学理论支撑，并成体系的系统化思维。做了多年的软件开发工程，碰到和解决了数不清的问题，最终这些问题，我发现稍微抽象一下，可以归为以下两类： 可以简单归因的问题：属于直接简单的因果关系； 难以简单归因的问题：属于间接复杂的因果关系。 上面的描述可能有点抽象，那具体该怎么理解呢？这里我分别举两个例子：线上有个 Bug，找到了有问题代码片段，需要一个优化实现方案来解决，这就是第一类问题，原因和结果非常明确清晰；线上老是出故障，而且反复总出意外故障，对于这个结果，它的原因是什么，这就很难简单归因了，就属于第二类问题。 对于这两类问题，我想讲讲两种不同的思维框架提供的解法。 科学与理论第一类问题，现象清晰，归因明确，那么它唯一的难处就是为这个问题找到最优的解决方案。求解最优化问题，就需要科学与理论的支持，也即：科学思维。 先讲一个其他行业的故事：造船工程。很早以前，关于应该造多大的船，人们都是靠感觉摸索的。后来（十九世纪中期）有个英国工程师布鲁内尔（Brunel）意识到船应该尽可能造得大些，于是他设计了当时世界上最大的船。这是一艘挑战当时工业极限的船，该设计甚至还引发了当时社会激烈的辩论。 布鲁内尔的目标是建造一艘足够大的船，大到无需中途停留，直接能从英国开到印度，那么如此远的航程就需要有足够的货物与燃料（那时的燃料主要就是煤）的装载能力。而支撑他设计背后的理论却很简单，船的装载能力是体积决定的，跟船尺寸的立方成正比，而船航行受到的阻力则是和船底的面积成正比。所以，船越大，装载能力越大，但单位载重量的动力消耗却下降了，这就是为什么布鲁内尔要尽可能地造大船。 这就是科学理论给予造船工程的方向指引。吴军老师也曾在一篇文章《计算机科学与工程的区别》里指出： 科学常常指出正确的方向，而工程则是沿着科学指出的方向建设道路；在工程中必须首先使用在科学上最好的方法，然后再作细节的改进。 我做在线客服系统时碰到一个问题和滴滴打车的匹配问题非常类似，打车是人和车的匹配，而咨询客服是人和客服的匹配。抽象来看，这个匹配的算法并不复杂，但因为涉及到非常具体且繁琐的业务规则，实现起来就有特别多业务逻辑，导致性能有问题。这就是软件工程现实中的第一类问题，需要找到优化方案。 对于这类问题的解法，就是先用计算机科学理论来分析其性能的复杂度边界与极限，而咨询分配就是在 N 个客服里进行挑选匹配，每次只匹配一个人，所以理论复杂度极限是 O(N)。只要 N 有限大，那么匹配的性能最坏情况就是清晰的。 理论分析给出了边界，工程实现则是建设道路，这就需要在边界里找到最短路径。在客服匹配问题的工程实现总考虑的方式是：最坏的情况是每次匹配都要遍历 N 次，最好的情况是 1 次，那么实现方案评估就是尽可能让最好的情况发生的概率最大化。假如你的实现方案 90% 的场景概率都发生在最好情况下，10% 的场景发生在最坏情况，那么整体性能表现可能就比最坏情况高至少一到数个量级。实际提高多少，这取决于 N 的大小。 而另一个工程实现考虑的维度是，如果每次匹配中有 M 个高消耗操作，那么进一步的优化方式就是如何减少 M 的个数或降低每次操作的消耗。 这就是用科学思维来指导工程实践，科学理论指出方向，探明边界，工程实践在边界的约束范围内修通道路，达成目标。正如前面故事中，造船理论往大的方向走也有其极限，因为除了能源利用率的经济性外，越大的船对其他建造、施工和运营方面也会带来边际成本的提高，所以也就没法一直往大里造，这就是工程现实的约束。 所以，理论的意义不在于充当蓝图，而在于为工程设计实践提供有约束力的原理；而工程设计则依循一切有约束力的理论，为实践作切实可行的筹划。 简言之，科学理论确定了上限，工程实践画出了路线。 系统与反馈第二类问题，结果明确，但归因很难，那么找到真正的原因就是第一个需要解决的难点。这时，我们就需要用另一种思维方式：系统思维。 回到前面举的例子，线上老是出故障，而且反复出意外故障。如果简单归因，查出故障直接原因，发现是代码写得不严谨，实现有不少漏洞和问题，仔细看就能分析出来，但触发条件罕见不容易测出来，于是提出解决方案是增加代码评审（Code Review）流程来保障上线代码的质量。 关于代码评审就是我从业多年来遇到的一个非常有意思的问题，大家都觉得它有用，也都说好，但很多时候就是执行不下去。因为它不是一个简单问题，而是一个系统问题。万维钢在《线性思维与系统思维》这篇文章里，给出了一些系统问题的典型特征，其中有两条是这样说的： 多次试图解决一个问题，却总是无效； 新人来了就发现问题，老人一笑了之。 我呆过的很多公司和团队，都想推行代码评审，最后都无果而终。反而是一些开源项目，还搞得有声有色。还是万维钢的那篇文章里，其对系统的定义：“所谓系统，就是一个由很多部分组成的整体，各个部分互相之间有联系，作为整体又有一个共同的目的。” 简单想想就会发现公司项目所在的 “系统” 和开源项目所在的 “系统” 其构成就完全不同，而且目的也不同。 一个系统中可以有若干个正反馈和若干个负反馈回路，正反馈回路让系统或者增长、或者崩溃，是要偏离平衡，负反馈回路则尽力保持系统的平衡。 对你想要解决的这个问题而言，可能就有一个回路，正在起主导的作用！如果你能发现在系统里起主导作用的回路是什么，你就抓住了系统的主要矛盾，你就找到了问题的关键所在。 曾有行业大牛在前公司有很好的代码评审传统和流程规范要求，自己也坚决支持代码评审。后来去了另一个同行差不多规模的公司，进入到团队后想推行代码评审时，就遭遇了巨大的阻力，不止是 “老人呵呵，一笑了之” 了，还甚至被公开地反对了。显然，对于代码评审这个问题，他的前后两家公司拥有完全不同的正、负反馈回路，以其个体之力，想要去改变已有的反馈回路，其实相当艰难。 我自己也曾在团队做过一些尝试，但一直找不到合适地建立正反馈回路的好方法。引入严格的代码评审流程，其负反馈回路立刻发生作用：更多的工作量，更多的加班等。负反馈，团队立刻就能感知到，而其正反馈回路发生作用带来好处却需要一定的时间。而且另一方面，建立新的回路或者摆脱当前的循环回路，还需要额外的能量来源，也即激励。 在解决系统问题，建设正反馈回路上也有过成功的样本。比如，在公司层面要求工程师产出专利，这对个体来说就是额外的负担，而负担就是负反馈。为了降低负反馈回路的作用，可以让专利和晋升到一定级别关联上，并增加专门培训来降低写作门槛；专利局每通过一份专利，就奖励一笔奖金（几千到上万），甚至没通过都能奖励几百块，这些就是建立正反馈循环回路的激励能量。 另外一个例子是，为了让程序工程师们更有分享的意愿和提升表达能力，就出一个规则，把分享和每年的晋升提报关联起来，本质就是提供了潜在可能的经济激励。经济学原理说：人会对激励做出反应。是的，经济学原理很有效。 软件工程，是研究和应用如何以系统性的、规范化的、可度量的过程化方法去开发和维护软件；而实际上软件开发本身就是一个系统工程，里面存在很多没法简单归因的第二类问题，它们没有通用的解法，只有通用的思维。 一个优秀的工程师应该同时具备科学思维和系统思维，它们是工程思维的两种不同表现形态：系统思维洞察问题本质，科学思维发现最优解法。 学完本章，你也可以去细心观察你周围的环境，看看都有哪些问题，属于哪类问题，以及你能发现它们的本质吗？欢迎你留言分享一二。 39 职业倦怠：如何面对？从今天起，咱们专栏即进入第 4 个大主题——“徘徊：道中彷徨”。成长的途中，我们总会面临很多的困扰与惶惑，这些困扰和彷徨很多都关乎选择，只有了解并认清这类困惑，我们才可能做出最合适的选择。 职业生涯的路上，每个人都会碰到职业倦怠期，我也不例外。曾经好几次，我都陷入其中。如今从中摆脱出来后，我就想尝试搞清楚这样一种状态的根源，思考一种方法来缩短它持续的时间，或者说增加它出现的时间间隔。 那职业倦怠到底是怎样的一种感受呢？ 倦怠感1974 年，美国临床心理学家弗罗伊登贝格尔（Herbert J. Freudenberger）首次提出“职业倦怠”的概念，用来指人面对过度工作时产生的身体和情绪的极度疲劳。 职业倦怠感想必你也不陌生，一般将可以明显感知到的分为两种。 一种是短期的倦怠感。它出现的状态，可以用两个英文单词来形象地表达：Burnout（燃尽，精疲力尽）和 Overwhelm（难以承受）。 作为程序员的我们想必最能感知这样的状态，因为我们处在现代信息工业时代的最前沿，快节奏、高压力、大变化的环境很是常见。应对这样的环境，我们就需要更多的 “燃料” 和更强的承受力。但有时，环境压力突然增加，短期内超出了我们的负载能力，难免出现“燃尽”（Burnout）的时刻，并感到难以承受（Overwhelming）。 此时，就进入了短时的倦怠期。这种短期的倦怠感觉其实和感冒差不多常见，年年都能碰上一两次，应对的办法其实也很简单：休个年假，脱离当前的环境，换换节奏，重新补充 “燃料”，恢复精力。就像感冒，其实并不需要什么治疗，自然就能恢复。人，无论生理还是心理，都是一个 “反脆弱” 体，“凡不能打垮我的，必使我更强大”。 另一种更可怕的倦怠感是长期的，它与你对当前工作的感受有关。 有些人把 “上班” 看作工作的全部，那么这样的人去上班一般都是被动的、勉强的。这样的人就是普遍存在的 “混日子” 的上班族，虽不情愿，但又没有别的办法，毕竟不能失去这份工作的收入。而这种 “混日子” 的状态，其实就是处在一种长期的职业倦怠期。 其实真正的工作，应该是一种积极的、有目标的事情，它能让我们实现对自我和他人的价值，并且乐在其中。但即使一开始我们是在做这类真正的 “工作”，时间久了后，也难免碰到职业倦怠感，这时我们可能就会困惑：难道我已不再热爱现在的工作了？对于这种状态，有一个说法是这样的： 倦怠，意味着你在这一关打到头了，而新的一关的钥匙，就在你手上。 遇到这种情况的本质，其实是我们自己的 “工作区” 发生了转移和变化，从而脱离了原来的 “工作态”，碰到了倦怠感。 当倦怠感出现时，“工作态” 就隐退了；而为了消除倦怠感，我们就需要找回 “工作态”。 工作态工作态，如其名，是一种工作的状态，一种让我们在工作中感觉到美好的状态（beautiful state）；是做我们喜欢的工作时表现出来的一种状态。 每周我们有五个工作日，但不代表我们每个工作日的工作时间都能处在 “工作态”。甚至很多时候我们都无法处在 “工作态”，但却又必须在某个时间点前完成工作。这样的日子久了，就难免会滋生倦怠。 据说有一半的人，每天下班回家上床睡觉前，都会想想诗和远方，早上起床都有一种不想再去上班的冲动；当感到这种冲动时，差不多就进入了工作倦怠期，并对当前的工作产生了倦怠感。 去年有部电影叫《魅影缝匠》，主角是一名裁缝。他每天起床后，从早餐时刻开始就进入了他的 “工作态”，排除和避免一切干扰，专注于他的服装设计工作。其实，这个电影本身的故事并不算吸引我，只是电影中这位缝匠的 “工作态” 深深地打动了我。也许，这就是一种同为创作性工作带来的共情吧。 现代心理学上有个概念叫 Flow，一般译作 “心流”，也是一种工作状态，它是人在专注进行某些行为时所表现出的心理状态，比如艺术家创作时的状态。在此状态下的人们，通常不愿被打扰，也比较抗拒中断，个人的精神力将完全投注在某种活动上，同时还会伴随高度的兴奋与充实感。 那么 “工作态” 和心流有何不同？“工作态”，其实是我自己发明的一个概念，它的定义覆盖的期限更长久，就像长跑中的节奏；而心流的定义更像是一种 “工作态” 的局部过程表现，像一次短程冲刺。你没法长时间地处于心流状态，但在相当长的一段时间周期内，你可以处在 “工作态” 中，就像电影中那位缝匠，几十年如一日的，每天早晨都会自动进入那样一种 “工作态”。 职业倦怠期，显然是与 “工作态” 互斥的一种状态。所以，要脱离职业倦怠期，最有效的方式就是进入 “工作态” ；而进入 “工作态” ，最核心的地方在于找到自己的 “工作区”。 工作区关于工作区，我想借用下面一张图来展示。 img 工作的“三区域”图 “工作区” 的概念不是我发明的，其原始概念图来自国外一个站点，我将其翻译和重绘了一下。其中定义了关于工作的三个区域，也就是说每一份工作都包含了这三个方面： 目的意义 Purpose 职业生涯 Career 工作岗位 Job 目的意义，这是工作的终极之问。它决定了你的很多选择，以及你接受什么、拒绝什么，是工作愿景背后的灵魂所在。每个人工作都会有自己的目的与意义，而且还会随着工作过程发生变化（或者说进化更合适些）。追寻目的与意义，这可能是你、我一生的工作。 职业生涯，是个人一生职业愿望的追寻过程。它由长期目标驱动，是追寻 “目的意义” 的一条你所期望的路径。而这条路径并不唯一，它因人而异，因你的 “目的意义” 而异。它构建在你工作过程中的所有经历、经验、决策、知识、技能与时运的基础之上。 工作岗位，这不过是你现在上班的地方，包括了位置、角色、关系、职责与薪酬的总和。 这三个区域会有交集，这里我举个实际的例子。假如你工作的 “目的意义” 非常现实，就是希望有更多的收入改善家庭生活，住更大的房子，开更好的车。而现在的 “工作岗位” 能够提供这样让你满意的收入水平，那么你就会感到 “快乐幸福”。 而若你对 “职业生涯” 路径的期望是从程序员到架构师，甚至再到 CTO，当前的 “工作岗位” 能提供这样的发展路径，那你就会充满 “激励驱动”。显然，职业生涯一路达到 CTO，收入水平会更高，与你的现实 “目的意义” 相符合，那你就会感到 “成就满足”。 如图中所示，这三者相交的那个位置，就是你的 “工作区”。在这个区域内，工作让你有驱动力，感到快乐，充满成就感。找到了 “工作区”，很自然就会进入 “工作态”。 当职业倦怠时，自然是远离了工作区，这时很容易产生的一个决策是：换一份工作。我曾经就做过这样的决策。换一份工作没有对错好坏之分，它能改变你的工作岗位，甚至也能改变你的职业生涯路径，但它唯一不能改变的就是你对 “目的意义” 的思考与认识。 做自己所爱，是对的；爱上自己所做，也是对的，关键就是要找到什么在真正驱动你前进。 丹麦哲学家索伦·克尔凯郭尔（Søren Kierkegaard）说过一句话： Life can only be understood backwards; but it must be lived forwards. 只有向后回首时才能理解生活，但生活却必须向前。 当你回首职业生涯的来路时，终于理解了职业倦怠，但前路之上，还会碰到它，而你已经知道该如何面对它了，对吧？ 40 局部最优：如何逃离？之前看过一些关于算法方面的书，提到了一些最优化问题。最优化问题在现实中非常常见，比如工程设计中，怎样选择设计参数，使得设计方案能以尽量低的成本预算满足设计要求。而近年来热门的机器学习建模也是一个最优化问题，基于一组已知的数据去构建一个模型，让这个模型去适配未来未知的数据达到最优，然后求解关于这个模型的参数。 在求解最优参数的算法中，很多都有一个缺陷，就是容易达到一种局部最优点，即：参数的选择尝试收敛到了一小块范围内，无论再怎么尝试变化都没法取得更优的结果。而从全局来看，这并不是最优的选择，但算法此时就进入了一种尝试的徘徊状态，这就是局部最优点，但算法并不知道这到底是不是全局最优的。 对于我们这些自诩智能的人，在成长的路上，其实也经常陷入这样的成长局部最优点。 爬山关于成长最形象的类比便是爬山，但爬到山顶的路并不总是向上的。 我长居成都，每过一阵就会去爬一回成都附近的青城山。像青城山这种著名景区的山，总有很多路标告诉你，沿着这条路一直走，你就能到达山顶。即使这条路有时会向下走，让你产生下山的感觉，但你也不会动摇，因为路标已经告诉你了，山顶就在前方，那里才是你的目的地。虽然成长这一路就像爬山，成长路上的感觉也和爬山相似，但不同的是，成长的路上并没有清晰的路标告诉你山顶在哪里。 有时你很幸运地爬上了一个高点，你并不知道这个高点是否就是山顶了，因为再往前走，无论哪个方向的路都是向下的，你会心下疑惑：这是要下山了吗？ 即便你明确知道了这个高点便是此山的山顶，有时也会遗憾地发现原来这山只有这么高啊。就像青城山名气虽大，但山并不高，海拔只有 1200 多米。你站在山顶，虽然是此山的最高点，但你知道这不过你成长路上的局部最优点，继续前行，则不可避免地先要下山。 爬山的全局最优点，应该是珠峰顶，但不是所有人都能爬得上去的。每个人都有自己期望的一个高度，比如我登高爬山是想看看云海，但青城山的高度还不够，也许峨眉山（海拔 3100 米）就够了。 我们在成长（爬山）的路上，会进入局部最优点。一方面可能是 “山形” 所致，要继续上山的路需要先向下走，而向下的疑虑又会让我们徘徊不前。另一方面，可能是此 “山” 只有这么高了，就像青城山，你想看云海，可能就得换一座山了。 徘徊所有的局部最优点，都意味着我们爬到了一定阶段，在这个位置徘徊不去，恋恋不舍。 十多年前，我刚毕业找工作那时，外企在国内的吸引力可以相比今天互联网行业的头部企业。我也想进入外企这座 “山”，屡屡尝试，但每次都卡在英语口语面试，屡屡失败。同寝室的另一位同学则顺利进入一家国外的电信行业外企，获得的 offer 薪酬比我们平均高了 50%，让人羡慕不已。 数年后，我们同学再次相聚，听闻该外企在中国已经被当时的华为、中兴竞争的步步退缩，业务缩水不少，已有裁员迹象。当时，同学会上，都劝这位同学早做打算，但他表现为瞻前顾后，徘徊不决，还想看看情况。一年后，我当时也正在做浙江省的电信项目，该同学所在公司的系统正被我当时的公司取代，没多久就听闻该公司进入了破产清算。 曾经领先的电信行业设备服务公司，就这样退出了市场。那位同学就算曾经站的位置再好，“山” 都塌了，何谈继续攀登。这样的情况，有时主动的转身，比被动的离开可能要从容得多。 而另一个朋友的故事，经历过后再回首一看，更让人扼腕叹息，可惜当时的我也是见识有限，给不了更好且更坚决的建议与支持。 那时，小米公司刚成立不到一年，第一款手机尚未发布，正处在快要井喷发展的扩张期，到处找人，正好也找到了我这位朋友。但朋友觉得自己所在公司也还不错，也能成长，正“爬山爬得不亦乐乎”，遂放弃。 过了两年，朋友又有了另一次机会，微信来了，给了机会，但她正考虑准备生孩子，同时又考虑在当前公司已经熟悉，且业务稳定，换新公司难免需要打破现状和当前的节奏，遂徘徊一阵，选择停留。 后来再看，以前公司的最高点，相比这两座 “山”，也就相当于它们的山脚下。但有时职业的路径就是这样，我们迷茫、徘徊，正是因为 “不识庐山真面目，只缘身在此山中”。跳脱不出来，看不见 “山” 的全貌。 审视下你的当下，再回顾下你的职业生涯，你花了多少时间和功夫来看清自己正在攀爬的 “山”，它的高点能让你去到你想去的地方吗？能让你看到你想看的风景吗？有时，我们大部分的努力，都没有什么进展和结果，仅仅是让我们能勉强呆在同一个地方。 看清了自己目标的高山，发现自己爬错了山，要舍得离开；停留在低矮的山上，无论再努力，看到的风景也有限。 逃离如何知道你正站在局部最优点上徘徊呢？当你知道自己做得很好，但却没有感觉到成长与进步时，那么也许你就正在徘徊了。 在我的成长路上，也经历过一些徘徊点，这里我分享几个这一路上关于逃离的故事。工作早期，我做银行业的企业软件开发，被外派到了客户公司的项目组。在那里，不仅仅需要写程序、查 Bug，还需要兼顾从售前技术咨询、需求分析谈判到售后技术支持，甚至包括客服咨询解答都要涉及。正常的白天（朝九晚五）是没有一刻安静的时间能写写代码的，都是在客户下班后才能有个安静时段做做编码的事情。 一年后，我有些困惑，因为我感觉自己做的事情太杂，但似乎又没一样东西做精、做深的。当时的想法是以技术立身，一年下来却不免惶惑。我感觉自己选错了山，没必要继续爬下去，因为我已经看到了当时大我十岁的项目经理也许就是这座山的一个局部最优点。一年后，我选择了逃离。 之后，该怎么选下一座山？第一考虑自然是想离技术更近，做的更纯粹一些，另一个无法免俗的考虑自然还是希望收入也能提高一些。如今回想起来，当时为了一千块的差距，纠结了半天也不免哑然失笑。最后的选择，其实也是马马虎虎，运气好的一面是选对了技术，这次不做项目，做产品了，作为程序员在里面做的工作更纯粹了；运气差的一面是，还是没选对行业。 从金融行业软件开发转到了电信行业软件开发，而当时一个新的行业——互联网，正方兴未艾。相比之下，当时的电信行业应该正在迅速步入成熟期，拥有成熟度最高且用户流量也最大的信息化系统。一入此 “山” 中，便埋头修炼技术，熟悉行业业务，直到数年后，蓦然发现似乎又到了一个局部最优点：技术无法再快速进步了，业务领域也已经熟得不能再熟了。 在原地徘徊了一段时间后，我选择了第二次逃离，但这次困惑更大。我换了一个城市，在这里找了好几个月工作，见了很多很多的 “山”，却发现居然没有一座 “山” 乍一看比之前的更高、更大，顶多和之前差不多。 我有些沮丧，我只是不愿又重新立刻去爬一次差不多的山。就像有次一早爬青城山，下午回到山脚，有人问“谁愿意再爬上去一次”一样，当然没人愿意。但如果山顶有一百万，再爬上去就能得到呢？我想这样也许会有不少人愿意吧。但现实的生活是，有时会让你迫不得已重新爬上刚下来的“山”，但“山顶”却没有任何额外的奖励。 在我的故事中，我一次次逃离，是为了什么？因为失去了成长的感觉。每一座 “山” 刚开始爬时，你会对它的风景充满新奇，会有一条陡峭的上升之路，之后慢慢失去了新奇感，而很多工作任务渐渐变成了自动化的处理，不需要学习新的技能，失去了有意识的反思，从而让成长停滞。 当然，逃离，不一定都是换一座 “山”，也有可能是换一种爬山的方式，找到一条新的路。 在日常工作中，你可以尝试问问自己，对于十年后而言，现在的工作和事情，哪些会是很重要的？哪些会让你的技能变得更好？这就需要你有意识地试图在一些你已经知道如何做的事情上，再去做得更好。如果没有这种有意识的尝试与努力，很可能你就还在原地依赖过往的经验和技能自动化地完成同样的事情。 算法进入了局部最优解，通常都是通过在环境参数中引入一些震动来帮助算法脱离，继续寻找更优点，而成长的路何尝不是呢？ 有时，有人会同时面对好几座山都想爬，但因为种种原因（主要还是生活所迫）只能爬其中一座。当你站在你选择的这座山的一个高点，远远看到曾经放弃的山峰，会感到徘徊遗憾么？ 进入局部最优，徘徊于局部最优，逃离局部最优，都是你的选择。而站在局部的最优点，走出徘徊的第一步，总是从下山开始，而这样的选择并不容易。 最后，能否分享一下：如今你正在爬怎样的“山”？爬到了什么位置？以及你是如何选择的？ 41 沟通之痛：如何改变？沟通问题，一直都是程序员的痛点。 隔壁专栏（左耳听风）的陈皓以前在他的博客上写过一篇文章叫《技术人员的发展之路》，里面提及职业发展到一定阶段，也许你就会碰上一些复杂的人和事，这种情况下他写道： 这个时候再也不是 Talk is cheap, show me the code! 而是，Code is cheap, talk is the matter! 这里的 Talk 其实就是沟通，在工作中你要是留心观察，就会发现很多沟通问题，比如，跨团队开会时常发生的一些分歧和争论。沟通，越发成为一件重要的事，至少和写代码同等重要；沟通清楚了，能让我们避免一些无谓的需求，少写不少无效的代码。 然而现实中， 沟通问题，有时却被作为程序员的我们有意或无意地回避与忽略了。面对沟通问题，我们该如何看待和分析这个问题，并做出一些改变呢？ 一、木讷与沉默木讷与沉默，这两个名词似乎已变成了程序员的标签，它们形象地体现了程序员在沟通中的表现。 在程序员的世界里，沟通的主要场景可能包括：与产品经理沟通需求，与测试同学推敲 Bug，与同行交流技术，给外行介绍系统，还有和同事分享工作与生活的趣闻，等等。然而，有些程序员在分享趣闻时，与谈需求或技术时的表现大相径庭，刚才明明还是一个开朗幽默的小伙，突然就变得沉默不语了。 沉默有时是因为不想说。特别在沟通需求时，有些程序员默默不言，但心里想着：“与其扯那么多，倒不如给我省些时间写代码！”然而，程序员写出的代码本应该是公司的资产，但现实中代码这东西是同时带有资产和负债双属性的。 需求没沟通清楚，写出来的代码，即使没 Bug 将来也可能是负债。因为基于沟通不充分的需求写出来的代码，大部分都是负债大于资产属性的，这最后造成的后果往往是：出来混都是要还的，不是自己还就是别人来还。 有些程序员可能会争辩道，“与人沟通本来就不是我们所擅长的，再说了我们也并不是因为热爱跟别人聊天才做软件开发这一行的。”这个言论很有迷惑性，我早年一度也是这么认为的。 我毕业去找工作那年，外企如日中天，所以我也去了当时心中很牛的 IBM 面试。面试过程中的大部分交谈过程和内容现在我都记不清了，但就有一个问题至今我还记忆犹新。面试经理问我：“你是喜欢多些跟人打交道呢，还是跟电脑打交道？”当时的我毫不犹豫地回答：“喜欢跟电脑打交道，喜欢编程写代码，而且我自觉也不擅长和人打交道。” 然后，我就被淘汰了。后来我才明白了，其实当时的这类外企挂着招工程师的名义，实际需要的更多是具有技术背景和理解的售前技术支持，因而就需要所招之人能更多地和人沟通去解决问题，而不只是写代码解决问题。 结合我自己多年的工作经历和经验来看，即便你仅仅只喜欢写代码，那么和人的沟通能力也依然是你必须跨过去的门槛。《计算机程序的结构与解释》有云：“程序写出来是给人看的，附带能在机器上运行。” 其实，写代码本身也是一种沟通，一种书面沟通。沟通从来都是个问题，书面沟通也同样困难。 二、争论与无奈程序员最容易产生沟通争论的地方：沟通需求和沟通技术方案。 在程序员的职业生涯路上，我们不可避免地会碰到和同事关于技术方案的争论。我从中得到的教训是：千万不要让两个都自我感觉很牛的程序员去同时设计一个技术方案。 假如不巧，你已经这么干了并得到了两个不同的方案，那么记住，就别再犯下一个错：让他们拿各自的方案去 PK。因为这样通常是得不到你想要的“一个更好的方案”，但却很可能会得到“两个更恼怒的程序员”。 既然分歧已经产生了，为了避免无谓的争论，该怎么解决呢？ 1. 以理服人首先，把握一个度，对事不对人，切勿意气用事。 有些程序员之间的分歧点是非常诡异的，这可能和程序员自身的洁癖、口味和偏好有关。比如：大小写啦、命名规则啦、大括号要不要独立一行啦、驼峰还是下划线啦、Tab 还是空格啦，这些都能产生分歧。 如果你是因为 “该怎么做某事或做某事的一些形式问题” 与他人产生分歧，那么在很多情况下，你最好先确定分歧点是否值得你去拼命维护。这时，你需要判断一下：技术的 “理” 在什么地方？这个 “理” 是你值得拼命坚守的底线不？用这个 “理” 能否说服对方吗？ 我所理解的技术的 “理” 包括：先进性、可验证性、和团队的匹配性、时效性、成本与收益。另外还有一些不合适的“理”，包括：风格、口味、统一、政治等。 不过有时候，有“理”也不代表就能搞定分歧，达成一致。毕竟林子大了，不讲“理”的人也是有的，那么，就需要换一种方式了。 2. 以德服人分歧进入用 “理” 都无法搞定时，那就是应了那句古词：“剪不断，理还乱”。 这时继续“理”下去，不过都是互相耍混罢了。“理” 是一个需要双方去客观认可的存在，而越“理”越乱则说明双方至少没有这种客观一致性的基础，那就找一个主观的人来做裁决吧。 这个人通常就是公司所谓的经验丰富、德高望重的“老司机”了，并且双方也都是认可的，比如架构师之类的。但是这类主观裁决也不一定能保证让双方都满意，有时实力相当的技术人也容易产生类似文人相轻的状况。不过看在“老司机”的 “德” 面上，也能勉强达成一致。 “老司机”裁决最好站在他所认同的 “理” 这个客观存在上，这是最好的，不过这也取决于“老司机”的工作素养和价值观了。 3. 以力服人最差的状况就会走到这一步，特别在跨大部门的沟通中。 技术方案无法达成一致，也没有一个跨两个部门的有德之人可以转圜化解，就会升级到这个地步。最后就是靠粗暴的权力来裁决，看双方部门老大或老大的老大，谁更有力或给力。一般来说，非关键利益之争实在没有必要走到这一步了。 三、认识与改变做出改变的第一步是要能认识到，否则改变不可能发生。 程序员会认识到沟通很重要，有时甚至会比写代码更重要吗？著名的技术型问答网站——Stack Overflow 的两位创始人杰夫·阿特伍德（Jeff Atwood）和乔尔·斯波尔斯基（Joel Spolsky）都对此有正面的认识和见解。 杰夫说： 成为一名杰出的程序员其实跟写代码没有太大关系。 做程序员确实需要一些技术能力，当然还要有坚韧不拔的精神。 但除此之外，更重要的还是要有良好的沟通技巧。 乔尔的观点是： 勉强过得去的程序员跟杰出程序员的不同之处，不在于他们掌握了多少种编程语言，也不在于他们谁更擅长 Python 或 Java。 真正关键的是，他们能不能把他们的想法表达清楚，杰出的程序员通过说服别人来达成协作。 通过清晰的注释和技术文档，他们让其他程序员能够读懂他们的代码，这也意味着其他程序员能够重用他们的代码，而不必重新写过。 要不然，他们代码的价值就大打折扣了。 按照程序员解决技术问题的习惯，就是把一个大问题拆解为多个部分的小问题，那这里我们也对沟通做下拆解，它包括三个方面： 内容 形式 风格 从内容上看，虽说你想沟通的本质是同一样东西或事情，但针对不同的人，你就需要准备不同的内容。比如，同内行与外行谈同一个技术方案，内容就是不同的。这里就需要你发挥同理心和换位思考的能力。保罗·格雷厄姆（Paul Graham）曾在他的书《黑客与画家》中写道： 判断一个程序员是否具备 “换位思考” 的能力有一个好方法，那就是看他怎样向没有技术背景的人解释技术问题。 换位思考本质上就是沟通技巧中的一种。 从形式上看，沟通其实不局限于面对面的谈话。面对面交谈是一种形式，书面写作又是另外一种形式，连写代码本身都是在和未来的自己或某个你尚未谋面的程序员沟通。 程序员确实有很多都不擅长面对面的沟通形式。面对面沟通的场景是很复杂的，因为这种沟通中交流传递的载体不仅仅是言语本身，眼神、姿态、行为、语气、语调高低，甚至一种很虚幻的所谓“气场”，都在传递着各种不同的信息。而大部分人都不具备这种同时控制好这么多传递渠道的能力，也即我们通常说的“缺乏控场能力”，这里面隐含着对你其他能力的要求，比如：临场应变、思维的活跃度与变化等。 从风格上看，不同方式和场景的沟通可以有不同的风格。比如面对面沟通，有一对一的私下沟通，风格就可以更随性柔和些；也有一对多的场景，比如演讲、汇报和会议，风格就要正式一些，语言的风格可能就需要更清晰、准确和锐利一些。 沟通之难就在于清晰地传递内容和观点。当你要向其他人详细解释某样东西的时候，你经常会惊讶地发现你有多无知，于是，你不得不开始一个全新的探索过程。这一点可以从两个方面来体会： 你只需要尝试写点你自认为已经熟悉掌握的技术，并交给读者去阅读与评价。 每过一段时间（比如，一个季度或半年）尝试去总结，然后给同事分享下你工作的核心内容，再观察同事们的反应和听取他们的反馈，你就能体会到这一点了。 所以，沟通改变的第一步就是从考虑接收方开始的，看看接收方能吸收和理解多少，而非发送了多少。而沟通问题的三个方面——内容、方式与风格——的考虑，都是为了让接收更方便和容易。 江山易改，本性难易，有时候我们做不到就在于这一点。但现实并不要求程序员成为所谓的沟通达人，只是需要主动认识到身边的沟通问题，去进行理性和逻辑地分析、拆解并做出适当的调整。 从认识我们的本性开始，控制情绪，从而去规避无奈的争论；认识清楚沟通问题的本质是要方便接收，达成共识，保持换位思考和同理心，改变自会发生。 关于沟通的各种形式，每个人可能都有自己擅长和偏好的方面，比如我就更擅长文字沟通，而不擅长一对一当面沟通，那么你呢？ 42 技术停滞：如何更新？我们从开始学习程序，到工作十来年，中间可能会出现几次自我感觉技术停滞了。而在这个过程中，我们也会不断地学习很多新技能，但而后其中的不少也会被淘汰在时间的旅程中。 一方面，我们在不断地打磨、提升技能，去解决工作中的问题，但久而久之，就会发现技能的提升速度越来越慢，竟渐至停滞，感觉不到进步了。另一方面，程序员所处的这个行业，技术的变化很快，潮流此起彼伏，难免产生技能焦虑。 有时，我们会不免幻想要是学会什么屠龙之技，从此高枕无忧，该多好！但这终究只是幻想，哪里又有什么屠龙之技呢？那面对技术停滞，技能过时，又该如何保持更新，与时俱进？ 技术停滞技术停滞是如何发生的？ 程序员，最重要的就是编程技能。每天的工作可能就是编程写代码，在早期还不够熟练时，你还能感觉到进步，这种进步就是从不熟练到熟练。进入熟练期以后，你可能感觉这项技能就提升得很慢，甚至一度停滞了。 单纯的编程实战其实并不能持续地提高一个人的编程技能，想想体育运动员，又有哪一个每天的日程就只是参加比赛。运动员平时都是在进行刻意地训练，而关于习得甚至精通一门技能，最著名的理论应该是 “刻意练习”，如果非要在这份练习上加上一个期限，那就是：一万小时。 关于 “刻意练习”，不少书或文章中都讲了很多案例来说明它的有效性，但总结起来关键就下面三点： 只在 “学习区” 练习，练习时注意力必须高度集中。 把训练的内容分成有针对性的小块，对每一个小块进行重复练习。 在整个练习过程中，随时能获得有效的反馈。 刻意练习是为习得真正的技能所设计的，它和获取知识不同，知识就是那些你知道即为知之、不知即无知的东西，这可以通过读书获得。但技能是那些你以为你知道，但如果你没做过，就永远不会真的知道的事情。 在程序员足够熟练了之后，每天的这种编程实战型工作就不会再是处于 “学习区” 的练习了，而是进入了 “舒适区” 的自动完成。真正的职业竞技体育运动员每天的日常训练都是在 “学习区” 的刻意练习，到了上场比赛则是进入 “舒适区” 的自动完成。然而很多熟练程序员的日常工作则是在 “舒适区” 的自动完成，工作之外则是另一种 “舒适区” 的娱乐休闲。 停滞，就是这样发生的。 技能保养感觉停滞的技能，如果工作依然需要它，其大的技术方向发展趋势依然明朗，那么这样的技能是值得好好保养，并继续提高的。而保养和提升技能的方法，“刻意练习” 依然是不二之选。 关于 “刻意练习”，有时我们即使一直保持在 “学习区” 的重复练习，却也可能感觉不到进步，这有可能是因为重复的次数和强度还不够。我曾经就犯过这个错：英语这门技能从毕业后就停滞了（可能还倒退了些）十年，在工作十年后我重启了学习掌握英语这门技能的练习，但刚开始阶段我完全低估了需要重复练习的次数和强度。 第一年，仅仅在每日的工作之余，我会花上大约一小时来进行听说读写的练习。但即使每日都能保障一小时的时间，一年下来也不过区区 300 多小时，更别提分散在听说读写四个分支上了。最后的结果可想而知，就是那一年结束后，并没有哪一项在让我感觉到一点点的进步。 在决策科学中有一个概念叫 “基础比率（Base Rate）”： 所谓基础比率，就是以前的人，做同样的事，做到的平均水平。 也就是说，如果别人做这件事需要那么长时间，基本上你也需要那么长时间，因为可能你没有那么特殊，只是每个人都会“觉得”自己是特殊的、例外的罢了。所以，当我调查了下学英语人群的基数和真正算是掌握并熟练运用这门技能的人数，以及他们所花费的时间，我就知道自己大大低估了需要重复练习的强度。 重复，是有针对性的强化练习，其本身是练习过程，而非练习内容。每一次的重复过程中都需要根据反馈进行有针对性的调整，以取得练习效果的进步。 而重复的刻意练习总是辛苦的，辛苦就是我们付出的技能保养成本。 技能开发技能不仅仅会停滞，还有可能会过时。 就拿我来说，我这十多年编程生涯走过来，从早年的 Basic 语言，到后来的 C，再到后来为了做 C/S 架构的项目学习了 Delphi，之后 B/S 架构开始兴起，又开始写起了 JSP，转到 Java 上来。经历了如此多艰辛的学习路线，曾经掌握过不少技能，但如今除了 Java ，其他的都过时淘汰得差不多了。 旧技术过时了，肯定是因为有另一种新的技术来取代了它，我们只需定期保持跟踪，观察现有掌握的技术是否可能被新出现的技术所取代。一般来说，新旧技术的更替都是有一定周期和一个持续的过程的，这期间给了我们足够的时间来学习和开发基于新技术的新技能。 而针对不同的学习目标，采用的学习路线也会不同。 如果需要学习新技能来解决工作上的一个具体问题，那这样的目标更适合采用深度路线学习方式，这是解决特定问题的一种捷径，属于痛点驱动式方法，能让你快速排除障碍，解决问题，而非先找到相关书籍，从头读到尾，知道一个整体大概。 一般技术书籍的组织方式都是按主题的相关性来编排的，系统体系性很强，但却不是按你解决问题需要知道的内容来组织的。所以，技术书籍更适合于在你解决问题的过程中用来参考。完整地读技术书籍能增长你的知识，但却无法快速习得技能，并解决你的问题。 反过来，另一种情况，面临一种新兴技术，比如，近年火热的人工智能与机器学习，你不是需要解决一个具体问题，而是要对这类新兴技术方向做评估、判断和决策。那么学习的方式就又完全不同，这时采用广度路线学习就更合适。 对如何开发一门新技能，《软技能》一书的作者曾在书中分享过他的一个十步学习法： 了解全局 确定范围 定义目标 寻找资源 学习计划 筛选资源 开始学习，浅尝辄止 动手操作，边玩边学 全面掌握，学以致用 乐为人师，融汇贯通 这个方法和我自己在实践中养成的习惯基本一致。在深度路线学习中，对全局、范围、目标的定向更聚焦，因此寻找、筛选的资源会更窄，学习计划的迭代期更短，很快就走完了前 6 步，并进入动手实践、反复迭代的过程中，直到把问题解决。 而在广度路线的学习中，前 6 步会花去大量的时间，因为这时你面临的问题其实是对新技术领域边界的探索。这就像以前玩《魔兽争霸》游戏中，先去把地图全开了，看清楚了全貌，后面再进军时就能选择最优路径，避免了瞎摸索。 这个类比中不太恰当的是，游戏中开地图实际挺简单的，但现实的技术领域中，地图全开基本是不太现实的，一是地图实在太大，二是地图本身也在演变中。只能说尽可能在前期的探索中，所开的地图范围覆盖更广至需要去解决的问题领域。 沉淀能力技术也许会停滞，技能也可能会过时，但其中的能力却可以沉淀下来，应用于下一代的技能之上。 汉语中容易把能力和技能混为一谈，在英语中，技能对应的词是 Skill，而能力对应的是 Ability。技能是你习得的一种工具，那么能力就是你运用工具的思考和行为方式，它是你做成一件事并取得成果的品质。 程序员爱说自己是手艺人，靠手艺总能吃口饭。五百年前，鞋匠也是手艺人，但进入工业革命后，制鞋基本就由机器取代了。手工制鞋是一门技能，它的过时用了几百年时间，但如何做一双好鞋的能力是不会过时的，五百年后人们还是要穿鞋，还要求穿更好的鞋。这时鞋匠需要应对的变化是：换一种工具（现代流水线机器生产）来制作好鞋。而现代化的制鞋机器技术实际上还进一步放大了好鞋匠的能力，提升了他们的价值。 对程序员来说，程序技能的过时周期相比制鞋技能却要短得多，每过几年可能就大幅变化了，是需要定时更新的消耗品，而能力才是伴随技能新陈代谢，更新换代的固定资产。技能用熟练了就成了工具，熟练应用工具能快速解决已碰到过的老问题。而沉淀下来的能力，是为了应对并解决新问题，甚至为了解决新问题，可以去开发新的技能或创造新的工具。 那么程序员需要去沉淀哪些能力？ 作为程序员最基本的自然是代码能力。能够写程序，只能算是技能过关吧，而能写好程序，才算具备了程序员的基本代码能力。代码能力的识别，最简单的方式就是维护一份公开可跟踪的记录，比如参与开源项目贡献，在 GitHub 上留下你的代码简历。 从程序员到架构师，“架构”显然不是一种技能，而是综合应用多种技能的能力。架构师也许不像在工程师阶段需要写大量代码，但实际没有代码能力是做不了架构的。代码能力是架构能力的底层能力要求。但仅此一项能力却也远远不足，这里就先不展开了，后面会专门有一篇文章谈架构师能力模型这个主题。 除了技术能力，如果有可能可以适当跨出技术的边界，去了解下产品、管理、运营和传播等方面的能力。为什么呢？一方面，技术能力的提升总会到达平台期，增长变得缓慢，而了解学习一下其他方面的全新能力，可能会让你找到新的成长点，重新找回快速成长的感觉。 另一方面，个人很多综合能力的差别，有时就是要靠作品来体现的。完成作品需要有一些产品思维，需要自我规划与管理能力，而推广作品需要运营和传播能力。这些相关的能力，最终都会成为你核心能力体现——作品——的放大器。 如果你是一棵树，能力是根，技能是叶；春去秋来，时过境迁，技能过时，落叶归根；沉淀下来的能力，将如春风吹又生，新的技能自会发芽。 而这一切的能力与技能之母，又叫元能力，自当是学习能力。 虽有俗语说：“技多不压身”，但实际很多技能是有保养成本的，编程技能就是一种，特别是和特定技术有关的编程技能。所以，同时保养很多技能是不太合理和现实的，更优化的选择是：持续保养主要的生存技能，合理开发辅助技能，形成自己独有的技能组合，沉淀能力模型，发展能力矩阵。 当时代发展，某些技能会过时，但能力矩阵不会过时，它当与时俱进；永不会有停滞的时候，它总是在进化。而对于过时的技能，除了既往不恋，我们还能做什么呢？ 技能如剑，金庸老爷子笔下有一 “剑魔”，一生用剑经历 “利剑无意”“软剑无常”“重剑无锋”“木剑无俦”“无剑无招”，最终剑已埋冢，人却求败。 如今你的哪些技能已过时？又沉淀下来怎样的能力呢？ 43 无法实现：困扰与反思程序员有句口头禅叫：“技术上无法实现！”这句话，在我过去多年的程序员职业生涯中经常听见，甚至我自己就曾说过很多次。如今，当我再次听到有人说出这句话时，不禁开始反思起来，为什么程序员爱说这句话呢？为什么曾经我也时不时说这句话呢？ 一仔细思考，就惊讶地发现一个事实：这句口头禅背后隐藏着一个阻碍我们成长的陷阱。 一、困扰当接到一个需求或碰到一个问题，我们回上一句：“技术上无法实现！”这是真的无法实现吗？还是隐藏着其他的困扰？ 1. 不知当我刚开始工作的第一年，我在一家银行客户现场工作。当时要给银行的出纳管理部做一个系统，这个系统有个功能就是上传各个国家的高清真假币鉴别对比图片，然后银行的出纳和柜员就可以在系统上学习各个国家纸币的鉴别方式了。 针对这些高清纸币图片，客户因为怕别人盗取乱用，就要求必须对图片做加背景水印的功能。当我们在召开需求讨论会时，我听到这个需求就懵了，因为完全不知道要怎么做。毕竟当年我才刚刚开始学习如何做 Web 化的管理系统，从来没有用程序处理过图片。 彼时，当我想起程序化的图片处理时，我就只能想起像 PhotoShop 那样高度专业化的图片处理工具软件，觉得这肯定是一个很复杂的事情。所以，当我们讨论起加背景水印的功能时，我自然脱口而出：“这在技术上无法实现！” 然后我们进一步谈起，当前客户他们是怎么做的。客户确实是找了专门的外包设计公司用 PhotoShop 来给图片一张张手工加水印。这听起来就是一个比较繁琐的过程，所以，当我回答“在技术上无法实现”时，客户都是业务人员，也不太懂程序技术上的事，听到我的答案也就略显失望。 好吧，如今回想起来，我说“技术上无法实现”时，仅仅是因为当时的我并不知道如何去实现。而且想当然地感觉要进行图片处理，必须要具备有 PhotoShop 一样的专业背景知识，而这对当时的我而言是完全不能想象的。 因此，当时我说出的那句“技术上无法实现”，仅仅是因为不知和不解而心怀畏惧。因为畏惧，所以我用了这句口头禅来回避了这个问题，甚至没有去调研一下技术可行性，就由此固步自封，在这片知识领地留下了一片空白，也不能为客户创造更进一步的价值。 “技术上无法实现” 的口头禅，此时成为了遮挡我们因不知而畏惧的面具。 2. 不愿有一年，我出差在客户现场赶项目，连续加班了四个周末，也就是大概一个月在连续上班。终于我们的项目快要如期上线了，每个通宵的早晨，看着东方慢慢变得红润透亮的天空，感觉已经快要看到胜利的曙光了。 就在这样一个曙光照耀的早晨，项目经理跑来对我们说：“原有的一块业务逻辑今天在和客户聊起时，他们说也只是试试这个流程，可能要改变。但我们的实现方式太僵硬，都是硬编码赶出来的。要不我们改成更灵活的、可以通过配置的方式，一旦上线后再改起来就更麻烦了。我可以先去和客户再沟通下，给我们再争取点时间。” 一下子，我们都被打击得不行，改成配置怎么改？逻辑那么复杂，又不是那种简单的开关式配置。当时，项目经理早已脱离技术一线时间颇久，也一时半会儿没啥方案。在沉默地思考了一阵后，我又说出了那句话：“逻辑太复杂，变动太大，这短期在技术上无法实现的。” 其实，那时我心里是有一个方案的，如今看来虽不是什么优秀的方案，但也是当时我唯一知道且可行的方案。就是通过 Java 的动态类加载机制，把业务逻辑外移，流程内置的方式以便可以动态热加载新的业务逻辑类。但这意味着可能要面临一次重大的重构，又是两周的持续加班，而我当时只是想赶快离开这沉默的讨论会，去美美地睡上一觉。 后来，这个故事在我睡醒后依然以我妥协结束。我建议了这个方案，最后当然也是我去实施了这个方案，庆幸的是并没有如“预料”那般加上两周班，只用了一周，项目就上线了。再之后的后续维护中，我又学习了新的东西，流程引擎，动态脚本，继续下一版本的重构，我们升级成了一个更好、更通用的方案。 当时我说出的那句“技术上无法实现”，只是因为觉得很麻烦，不愿意而已。后来睡醒后，回了一些血，有了能量，觉得应该接受这个挑战。因为客户的需求变化就是一个客观事实，也不会因为我的主观意愿而改变。 “技术上无法实现” 的口头禅，此时成为了我们推脱的借口。 二、反思不论是 “不知” 还是 “不愿”，“技术上无法实现” 的口头禅看来都不会给我们带来什么帮助，它反而阻碍了我们进一步做出更好的产品，从而给客户留下遗憾。 随着工作经验的增多，技能的积累，我便越来越少说这句话了。事实上，我发现大部分的用户需求，技术上总是可以实现的。这些需求的真正限制，要么是时间，要么是资源。 所以，面对一个紧迫的或不合理的客户需求，甚至诉求时，不应该再以如此苍白的一句话去应对了。这个需求背后涉及的技术实现，要么可能你现在未知，要么你至少知道一个方案，只是觉得过于复杂，而且会带来很多“副作用”，所以不愿意这样去做罢了。 但总之，你需要一个办法去应对一个让你觉得 “技术上无法实现” 的需求。我建议不要立刻像我当年那样做出如此简单的判断就推脱过去，其实我们完全可以把这样的问题放在下面这样的框架中去思考下。 1. 全局背景这一步的目的并不是要找到并确定实现方案，只是对这一问题涉及主题的相关内容有一个全局性的了解。 近年我都在做京东咚咚，一个 IM 系统，所以就以此举个例子吧。不时我们会收到用户反馈在安卓客户端应用切到后台就会收不到消息，这里用户只是提供了一个说法，甚至都不算现象。但这是一个问题，而且是一个我觉得在技术上无法百分百根除的问题，换言之就是我可能想不出一个方案能让我的所有用户都再也不会碰到类似的问题。 而用户碰到这样的问题可能的原因有： 移动弱网络，消息投递失败率高； 应用切后台就被系统杀掉，所以收不到； 第三方推送渠道，比如：某一类用户完全没有这种渠道可达； 应用本身的问题，比如：Bug，版本碎片导致的兼容性问题。 以上简单的问题分类，背后都隐藏着一个解决或优化问题所需的巨大且复杂的实现方案。针对每一类问题的方案，可以先去大概有个了解，但这里还不需要很深入。 2. 聚焦范围对上面列出的全局背景问题分析分类后，会发现没有一个是轻松容易就能解决的。而且这时还必然面临资源和时间的问题，也就是在特定的资源和时间下，我应该优先解决哪类？所以，这一步的本质就是从上面的全局分类中，聚焦一个范围，然后集中深入调研评估。 3. 定义标准前面说了用户仅仅反馈了一个说法，站在用户的角度，他们总是希望没有任何问题的。但站在我的角度，我知道我只聚焦了一部分问题，所以我需要清晰定义这部分问题解决的成功标准。 比如，针对应用切后台就被系统杀掉，对用户无感知，所以认为收不到消息是有问题的。针对这个问题的聚焦范围，我可以提供第三方推送渠道在十分钟内的推送通知补偿，重新唤醒用户重回应用，避免消息的遗漏。通过估算每日活跃用户和可能投递给第三方渠道消息通知量以及第三方渠道自己标榜的投递成功率和业界一些经验数据，就能估算出该解决方案的标准：通知唤醒到底能补偿多少用户的指标。 4. 深度评估有了范围和标准，剩下的就是深度评估方案路径问题。大体上任何一个方案，其中有些是你已经轻车熟路的实现路径，另一些则是你可能从未走过的陌生之路。 轻车熟路的部分可能更容易评估，但很多程序员还是容易高估自己；而从未走过的陌生之路，就评估得更离谱了。关于评估，可以保守一些，因为一般来说现实总是比理想的路径曲折一些的。 经过了上面四层思考框架的过滤，这时想必你已成竹在胸了，并能很好地衡量该技术实现方案的成本与收益。除此之外，进一步还需斟酌考虑的是方案是否足够优化，毕竟我们做工程就是要找到一条最优化的实现路径。 当面对任何一个需求，除非能一下从理论上发现其实现的物理限制，我们恐怕不能够再轻易说出 “技术上无法实现” 了。即使真的是无法实现的需求，也有可能通过变通需求的方式来找到一条可实现的路径。“技术上无法实现” 的口头禅仅仅是我们阻挡需求的快捷方式，但这样的思维也阻碍了我们进一步去找到真正的实现路径和优化方案。 “你看这个需求能实现么？” “哦…” 改掉了这句口头禅后，有些问题也挺难简单地回答了。 那你是否爱说这句口头禅呢？又是在怎样的情境下说的呢？ 44 完成作品：理想与现实有时工作久了，会陷入这样一种状态中，整天不停地写代码，开发业务需求，周而复始，日子长了，自然觉着厌倦，感到似乎真的有点像 “码农” 了，日出而作，月落而息。在过去的某个时期，我应该也陷入过这样的循环之中，后来又是如何脱离的呢？ 困境：代码与罗马陷入这样一种写代码的 “困境”，还是要回归到写代码这件事本身上。 写代码是因为有需求，需求来自业务的发展需要，经过产品经理再传递到程序员。刚开始，作为一个新手程序员，不停地为各种需求写代码。开发完一个，接着又是下一个，生生不息，循环不止。 一开始也许会感觉有些累，但并没有产生太多的厌倦。这是一个从不熟悉到熟悉再到熟练的过程，这里有太多的新东西可以去探索和尝试，让你在疲惫中依然能获得了好奇心的满足和成长的快感，因此不会感觉厌倦。 那技能从不熟悉到熟练需要多久呢？现在成为专家的要求已经有了共识：一万小时的刻意练习。但达成熟练要不了那么久，也许两三年足矣。有句俗语叫：“条条大道通罗马”。罗马，一座城市，包罗万象，类比到程序员这里就像一个个需要完成的业务需求。几年过去，每一条通往“罗马”的大道都被你走过了，再去往“罗马”时，自然找不到新鲜感了，困倦油然而生。 继续停留在通往“罗马”的循环往复中，已无法让你继续成长为专家。而要想跳出这循环往复的路，无非就是不再去走那熟悉的条条通往“罗马”的大道，而是选择一条离开“罗马”的路，走出去，走向未知与未来。 在一万小时的刻意练习中，“罗马”已逐渐成为过去的熟悉、熟练区，而离开“罗马”便是要进入下一个陌生的学习区。但也许还会有一种 “现实” 的困境让你不得不继续走向当前的“罗马”，那么这时就不妨换一个视角：既已对通往当前“罗马”的所有路都了然于胸，闭眼可达，那就仔细观察了解现在“罗马”的构成与运作机制，也许将来有机会去创造属于自己的“罗马”。 从走向“罗马”到创造属于你的“罗马”，这里你的 “罗马”，就是你的作品。 理想：作品与创作也许条条通往罗马的大道，堆砌罗马的砖石，有些已经消失在历史的尘埃中，但罗马作为一个时代和历史的作品，留了下来。 今天我们再看什么是作品？维基百科上对“作品”的定义是： 作品，亦称创作、创意、著作，是具有创作性，并且可以通过某种形式复制的成品。 从这个定义来看，作品最重要的特质是：创作与创意。所以，只有包含了创意和创作性质的事物才能叫作品。那对于程序而言，怎样才算作品？你从网上复制来一段代码，解决一个问题，这不是创作，也不会成为你的作品。 代码作品，可以小到一段函数、一个类，大到一个库或框架、一个服务，甚至一个系统。但打磨代码作品的方式，应该是定期对自己写完的代码进行沉淀、梳理和规整，提取可复用的功能，同样的功能只写一次，形成自己专属的编码脚手架和代码库。在以后的学习实践中定期反思，不断优化其效率和品质。 当你再碰到类似功能的实现时，能直接复用库就复用库，不能直接复用的就在脚手架代码上进行扩展，后续的重心就放在了优化实现思路上。这样日积月累下来，你的程序思维和能力才会变得科学、高效，而且产生积累效应。最终，这些留下的代码库或脚手架都成为了你的作品。 不过，同是作品，却有高下之分。吴军老师曾在文章里写过：“完成一件事，做到 50 分靠直觉和经验，做到 90 分要靠科学和技艺，而要做到 90 分以上则要靠艺术。”我是认同这个观点的，而且我们完成作品的目标应是 90 分以上，这是作品的特性决定的，因为创作就是艺术的核心所在。 到了 90 分或以上的作品，也许分数相差无几，但市场价值却可能差异巨大。iPhone 就是一个很好的例子，它当是一件 90 分以上的作品，90 分的工程技术加上几分的艺术，相比差几分的同类，在市场上的价值和价格却是遥遥领先。 作品，是创作的，创作是需要设计的，而设计是需要品味的，正如《黑客与画家》一书里所说： 优秀作品的秘诀就是：非常严格的品味，再加上实现这种品味的能力。 大多数做出优美成果的人好像只是为了修正他们眼中丑陋的东西。 也许，我们可以先从感知和修正代码中丑陋的东西来训练这样的品味和能力。 而完成作品的收益是什么？理想的情况下，也许我们期待直接从作品中获得经济收益，但这并不容易。十九世纪，有一名画家，一生作画数千幅，但只卖出过一幅，换回了四百法郎，这名画家就是梵·高。 梵·高的例子比较极端，他的作品都是 90 分以上的，但在直接换取收益方面依然困难。而对于你来说，今天的作品虽不一定能立刻给你带来经济收益，但在你打磨作品的过程中，把“条条通往罗马的大道”都走完了，甚至还反复走试图找到更优化的路线，这会让你掌握系统化的知识和体系化的能力，同时还会让你的作品变得更值钱。你可以想象这样一个场景：当你给别人介绍自己时，只需要介绍自己的作品，而不再需要介绍自己的技能。 成长的路上，写过的代码最终也许会烟消云散，但完成的作品会成为你点亮的勋章。 现实：产品与特性作品要实现直接的经济收益，必须还要走完从作品到产品之路。 产品，是指能够供给市场，被人们使用和消费，并能满足人们某种需求的任何东西，包括有形的物品，无形的服务、组织、观念或它们的组合。现实情况是，大部分时候我们的代码作品，都是存在于产品之中的，所以你需要关注包含了你的代码作品的更大范围的产品及其特性。 如果产品无法获得市场的价值认同，技术作品自然也就埋没其中了。 有个说法是：要做好技术需要懂业务和产品。这大体没什么问题，但需要提到的细节是懂的方向。技术不需要了解业务产品的每一个显性特征，一个足够大的业务产品，有无数的显性特征细节，这些全部的细节可能分散在一群各自分工的产品经理们中。所以应该说，技术需要懂的是产品提供的核心服务和流程，并清晰地将其映射到技术的支撑能力与成本上。 另外，技术不仅仅需要支撑满足产品的全部显性和隐性服务特性，这些对于技术都相当于显性服务特性。而技术还有自己的隐性服务特性，这一点恰恰也正是高级和资深程序员需要重点关注的。所谓技术的隐性特性，通俗点就是程序员常说的非功能性需求，它的产生与来源都是源自程序和程序员本身。 用一段新算法实现的函数取代了旧函数，那么多余的旧函数就变成了负债而非资产，是需要去清理的。重构代码变得更简洁和优雅，可读性增强，节省了未来的维护成本。一个能同时服务一万人的程序实例，你知道你没法加十个实例就能简单变成能同时服务十万人的系统。这些都是技术冰山下的隐性特征，显性的错误会有测试、产品甚至最终用户来帮你纠正，但隐性的错误却很难有人能及时帮你发现并纠正。 产品的显性特性就如泰坦尼克号，而技术的隐性特性则是泰坦尼克号撞上冰山后的反应。一旦隐性的错误爆发，就像泰坦尼克号撞上了冰山，一切外显的繁华最终都将沉入海底。 技术从特性到作品，去支撑产品的体验与服务，这是一条更现实的技术作品实现价值的路。 从反复写代码实现需求的重复困境中，到打磨作品实现价值的理想，再回归产品化的现实之路。 代码，有些人写着写着，就成了 “码农”；有些人写着写着，就成了作者；还有些人写着写着，就改变了你、我的生活。那你想成为哪一类人呢？ 45 代码评审：寄望与哀伤我们都知道代码评审（Code Review）很有用、很重要，但现实中我所经历的和看到的团队，很少有能把代码评审落地得很好，并发挥出其应有作用的。这个问题困扰我已久。 感性认识代码评审的作用，有一定经验的程序员们想必都会有感性认识。 它是很多软件工程理论和方法学中的重要一环，对于提升代码质量和找出一些潜在隐患很有帮助，如果你有一些正式的代码评审经历过程，想必也能感性认知到其正面作用。但在我过去工作的这些年里，经历了几家公司，数个不同的团队，却几乎没有哪一个会把代码评审作为必要的一环去执行的。 过去，我们总是在线上出现一些奇怪的疑难问题后，一群相关程序员才围坐在一起，打开相关代码来逐行分析，根据线上现场的“尸检”来做事后分析和推导。这样的事后代码分析实际上根本不是代码评审，也完全违背了代码评审的初衷。 代码评审的初衷是提高代码质量，在代码进入生产环境前经过同行评审来发现缺陷，降低损失概率。这一点程序员都好理解，提前的代码评审就像雷达扫描我们重点关注的代码领地，以期发现或明显或隐藏的危险因素。 漫画《火影忍者》里有一种忍术技能：白眼，这种技能有近 360° 的观察范围。程序员在写程序时力求思考全面，不留死角或盲点，但实际死角或盲点总是存在的。随着我们经历和经验的成长，思考和认识得越发全面（越发接近 360°），拥有了近乎 “白眼” 的能力，但即使是像 “白眼” 一样，也依然会存在盲点。 正如世界上没有两片完全一样的树叶，也许也不会有两个认知视角完全重叠的人，这样相互进行代码评审也就弥补了个人单一视角和认知思考的盲点问题。除此之外，代码评审还有一个社会性功用，如果你在编程，而且知道一定会有同事将检查你的代码，那么你编程的姿势和心态就会完全不同。这之间的微妙差异正是在于会不会有人将对你的代码做出反馈与评价。 代码评审的编程实践正是基于这样的感性认知，影响你的编码心理，并试图通过群体视角来找出个体认知盲点区域的隐患或 Bug，但到底这样的做法能降低多少出现 Bug 的概率呢？ 理性分析有人对代码评审的作用进行了更理性且量化的分析，结论如下（来自维基百科）： 卡珀斯·琼斯（Capers Jones）分析了超过 12,000 个软件开发项目，其中使用正式代码审查的项目，发现潜在缺陷率约在 60%～65% 之间；若是非正式的代码审查，发现潜在缺陷率不到 50%；而大部分的测试，发现的潜在缺陷率会在 30% 左右。 一般的代码审查速度约是一小时 150 行，对于一些关键的软件，一小时数百行代码的审查速度太快，可能无法找到程序中的问题。对于产品生命周期很长的软件公司而言，代码审查是很有效的工具。 从如上的实验分析结论来看，代码评审对于发现潜在缺陷很有用，相比测试能发现的缺陷率高一倍，但也需要投入巨大的时间成本 —— 一小时审查 150 行代码，再快就不利于发现潜在缺陷了，而且更适用于长生命周期的产品。 所以，下面这个现象就容易理解了。我发现在同一家公司做代码评审较多的都是研发通用底层技术产品或中间件的团队，而做业务开发的团队则较少做代码评审。两者对比，底层技术产品或中间件的需求较稳定，且生命周期长；而业务项目，特别是尝试性的创新业务，需求不稳定，时间要求紧迫，并且其生命周期还可能是昙花一现。 多种困境从感性和理性两个角度认知和分析了代码评审的好处，但其适用的场景和花费的成本代价也需要去平衡。除了这点，如果把代码评审作为一个必要环节引入到研发流程中，也许还有一些关于如何实施代码评审的困境。 困境一，项目期限 Deadline 已定，时间紧迫，天天加班忙成狗了，谁还愿意搞代码评审？这是一个最常见的客观阻碍因素，因为 Deadline 很多时候都不是我们自己能确定和改变的。 困境二，即使强制推行下去，如何保障其效果？团队出于应付，每次走个过场，那么也就失去了评审的初衷和意义。 困境三，团队人员结构搭配不合理，新人没经验的多，有经验的少。新人交叉评审可能效果不好，而老是安排经验多的少数人帮助 Review 多数新人的代码，新人或有收获，但对高级或资深程序员又有多大裨益？一个好的规则或制度，总是需要既符合多方参与者的个体利益又能满足组织或团队的共同利益，这样的规则或制度才能更顺畅、有效地实施和运转。 困境四，有人就是不喜欢别人 Review 他的代码，他会感觉是在找茬。比如，团队中存在一些自信超强大的程序员，觉得自己写的代码绝对没问题，不需要别人来给他 Review。 以上种种，仅仅是我过去经历的一些执行代码评审时面临的困境与障碍，我们需要找到一条路径来绕过或破除这样的障碍与困境。 参考路径在国内，我并没有看到或听闻哪家把代码评审作为一项研发制度或规则强制要求，并落地得很好的公司。 而对于一些硅谷的互联网公司，倒是听闻过一些关于代码评审的优秀实践。比如，在一篇介绍 Google 代码评审实践的文章中说道：在 Google，任何产品，任何工程的代码，在被进行严格或者明确的代码评审之前，是不允许提交的。这一点，Google 是通过工具自动就控制了未经评审的代码就没机会进入代码库。 Google 以一种强硬的姿态来制定了关于代码评审的规则，规则适用范围是全公司，对任何人都不例外。即使面对团队中超自信且强大的程序员也无例外，要么遵守规则，要么离开组织。这一点从 C 语言和 Unix 的发明者、图灵奖得主——肯·汤普森（Ken Thompson）在 Google 的趣事中可以一窥其规则的强硬性，作为 C 语言发明者之一的他因为没有参加 Google 的编程语言能力测试所以无法在 Google 提交 C 代码。 所以，像 Google 这样的公司对于代码评审属于高度认可且有公司制度和规则的强硬支持，再辅助自动检测和控制工具的严格执行，一举就破解了以上四类困境。但要实践类似 Google 这样严格的代码评审制度和规则，似乎对于大部分公司而言都有不小的挑战，这需要公司制度、团队文化和技术工具三方面都能支持到位，而且还要让各方对实施此项制度的收益和代价取得一致认可，岂是易事？ 所以，现实的情况是，大部分公司都是在各自的小团队中进行着各种各样不同形式的代码评审，或者完全没有代码评审。 现实选择以前尝试过要在团队内部做代码评审，听说兄弟团队搞得不错，然后就一起交流经验。交流开始不久就跑偏了，重心就落在了应该选个什么好用的代码评审工具来做，如今想来这完全是舍本逐末了。 这就像以为有了好的编辑器（或 IDE）就能写出好的代码一样，而事实就是有很多好用的代码评审工具我们依然做不好代码评审。这让我联想起了古龙小说《陆小凤传奇》中的一段描述，记忆尤深： 西门吹雪：此剑乃天下利器，剑锋三尺七寸，净重七斤十三两。 叶孤城：好剑。 西门吹雪：的确是好剑。 叶孤城：此剑乃海外寒剑精英，吹毛断发，剑锋三尺三，净重六斤四两。 西门吹雪：好剑。 叶孤城：本就是好剑。 剑是好剑，但还需要配合好剑客与好剑法。 即使在最差的环境下，完全没有人关心代码评审这件事，一个有追求的程序员依然可以做到一件事，自己给自己 Review。就像写文章，我写完一篇文章不会立刻发布，而是从头脑中放下（Unload），过上一段时间，也许是几天后，再自己重新细读一遍，改掉其中必然会出现的错别字或文句不通畅之处，甚或论据不充分或逻辑不准确的地方，因为我知道不管我写了多少文字，总还会有这些 Bug，这就是给自己的 Review。 给自己 Review 是一种自省，自我的成长总是从自省开始的。 代码评审，能提升质量，降低缺陷；代码评审，也能传播知识，促进沟通；代码评审，甚至还能影响心理，端正姿势。代码评审，好处多多，让人寄予希望，执行起来却又不免哀伤，也许正是因为每一次评审的收益是不确定的、模糊的，但付出的代价却是固定的，包括固定的评审时间、可能延期的发布等。 哀伤过后，我们提交了一段代码，也许没人给我们 Review，稍后我们自己给自己 Review 了，也可以得到了一段更好的代码和一个更好的自己。 最后，我曾在前文[《思维：科学与系统》]中就用代码评审作为例子说明了这是一个系统问题，每个团队面临类似的系统问题都会有具体的情况。关于代码评审，不妨谈谈你所在环境所面临的情况和你的理解？ 46 人到中年：失业与恐惧刚入行的时候，听说程序员是吃青春饭的，只能干到 30 岁。过了几年，这个说法变成了 35 岁。如今走在奔四的 “不惑” 之路上，想到如果突然丢了工作，会怎样？还是不免为此有一些惶惑。 人到中年，突然就多了一些恐惧感。 恐惧感：谋生当你感到害怕丢掉工作时，说明已经不再年轻了，一种为了谋生的恐惧感油然而生。 记得我步出学校后，刚工作满一年，攒下了约一万元的积蓄，然后裸辞了。但只休息了一个月，就开始恐慌起来了。第二个月初，拿着手上的账单计算着，当时在广州，大约每个月的生活成本需要 3000 元。再看着卡上不多的储蓄，不得不从魔幻的虚拟世界回到苟且的现实之中，开始了新一轮的找工作之路。 彼时的恐惧不是失业的恐惧，而是没钱继续生活的恐惧。并不害怕失去工作，是感觉工作随时都可以换一个，要不干嘛要傻乎乎地裸辞呢？所以反倒是想着下次应该多攒点钱才辞职的。而下次是什么时候？当时的我也不知道。 第二次裸辞，已是三年后，这次我不仅想换个工作，还想换个城市，中间休息间隔的时间更长了。辞职好几个月后，我才又在成都开始了找工作。这一次感觉到了，工作没有那么好找，看上去还行也匹配自己的工作并不多，并且工资相对原来的一线城市也整体低了一个档次，但这些也未能让当时的我产生恐惧，仅仅是困惑，看不清前路。 又过了好些年，真的到了中年后，每月都有很多账单要付，贷款要还，再也不会觉得切换工作是一件很随意的事情，裸辞也早已从我的字典里消失。不随意，但未必会恐惧，只是年龄与处境让我此刻更需要认真地面对和思考这个问题。 中年，每个月比年轻那会儿挣得更多了，职位也更高了，生活变得更安适和稳定，这时真正潜伏着的威胁开始出现：技能的上升曲线可能越过了高点，走入平缓区，甚至也许在以缓慢而不易觉察的方式下降，而我们却安之若素。 但中年，悄然而生的恐惧感，并不是阻止我们再进一步的 “鸣枪示警”，而像是中场的哨声，提醒我们人生的上半场快结束了，短暂的休整之后，就该提起精神开始下半场了。 所以恐惧感不应是一种束缚，而是一种警醒。 无惧感：舍生假如你在一份工作中，对丢掉工作本身产生了恐惧，那你做工作的形式很可能会走向谨小慎微。 这时工作让你产生了恐惧感，你就将会被工作绊住，只想兢兢业业、如履薄冰地做好份内工作，以保护好自己的位置。但为了保护位置所做的所有努力都会是徒劳的，因为恐惧感绊住了你，这样的工作状态，自己也是缺乏信心的，而一个对自己信心不足人，也很难让别人对你产生信心。最终，几乎没有任何办法阻止别人占有你当前的位置。 而偏偏是要对工作的无惧感才能真正释放你的潜力，发挥你的能力，让你能够留在原地甚或更进一步。 作为程序员，我们只有一个位置：专业阵地。这是一个专业性要求比较高的职业，我们被雇佣并要求成为一名专业人士，所以应该像一个专业人士一样行事。普通劳动者和专业人士的区别在于，普通劳动者主要被动接受指令去执行任务，而专业人士则在其领域内自己生成指令，同时在领域外还会向同事或上级提供来自该领域的输出：专业建议。 普通劳动者是一种劳动力资源，他们保证执行，而专业人士则是保证选择的执行方向是有意义的，执行路径是优化的。作为专业人士，我们需要去坚持和持续地打磨专业力，守住这块阵地。 有时我在想，是专业让人拥有无惧感呢，还是无惧了才能走向更专业？也许，“谋生的恐惧”害怕失去的不过是工作岗位，“舍生的无惧”才能塑造专业的职业生涯吧。 安全感：重生安全感，是渴望稳定、安全的心理需求，是应对事情和环境表现出的确定感与可控感。 本来丢掉工作并不可怕，如果我们很容易找到下一份工作，并能很快适应变化的话。但现实是，如果是因为经济大环境变化导致的失业或技术性淘汰，找下一份工作并不容易，适应这种变化也不轻松。 二十年前，上一辈的中年人，他们从自认为的铁饭碗（国企大厂）中批量下岗了，这是一种社会经济与技术变革引发的批量淘汰。近一点的，如美国 2008 年金融危机，一夜之间失业的也不在少数，而且之后很长一段时间都找不到工作，这并非专业能力过时的技术性淘汰，而是环境剧变导致的萧条。 而离程序员更近的案例，来自 TOMsInsight 的深度调查采访，也就是 2015 年的事。 Tony 37 岁，清华本硕，毕业后加入全球知名的 A 记公司中国研发中心工作 11 年，年薪 80 万。在北京东三环，置业豪宅，老婆全职太太，两个孩子。但 2014 年 5 月，A 记公司中国研发中心裁员，Tony 就成为了其中之一。 Tony 作为专业技术人士的价值依然存在，更以百万年薪身价加入著名的互联网巨头 B 厂。但后来，Tony 却无法适应互联网的节奏，感觉工作上周边环境各种 “浮躁”，管理也不 “专业”，只好再度离职。 辞职后 Tony 很难找到合适的工作：不能很好地适应互联网公司，外企整体不景气招聘冻结，进入体制内早已过了年龄，创业没有机会和资源，当然也没勇气。而维持家庭高品质生活还需要不小的开支。Tony 在 37 岁这年，学会了抽烟、喝酒，仿佛人生的不顺利，来得稍微晚了一些。 最可怕的失业就来自变革引发的技能性淘汰（如：国企下岗），其次是环境引发的萧条（如：金融危机），再次是技能虽然还有普适价值，但自身却适应不了环境变化带来的改变与调整（如：Tony 的危机）。 Tony 面对的危机还是比较少见，属于个人问题。而金融危机也不多见，面对萧条 “血”（储蓄）够厚也可以撑得过去。只有第一种，技能性淘汰，积重难返。四十而不惑，不过四十岁程序员的悲哀在于，他们拥有十五年以上的经历与经验，有时却在和只有五年经验的年轻程序员竞争同样的岗位。 中年人和年轻人本应在不同的战场上。年轻时，拼的是体力、学习力和适应能力，是做解答题的效率与能力；中年了，拼的是脑力、心力和决策能力，是做对选择题的概率。 年轻时，是用体力和时间积累经历，换取成长与机会。就拿我来说，从年轻到中年我的体力状态变化是：20 岁以前可以通宵游戏后再接着上一天课；30 岁以前连续一个月加班通宵颠倒，睡一觉后就又精神满满；35 岁以前，还能上线到凌晨两、三点，睡上几小时后，早上 9 点又正常上班；35 岁以后，就要尽可能保持规律作息，否则可能第二天就精神不振了。 所以，中年了体力下降是自然生理规律，但和脑力有关的学习能力并不会有明显改变。记得以前看过一篇万维钢的文章讲了一本书《成年大脑的秘密生活：令人惊讶的中年大脑天赋》，其中提到： 跟年轻的大脑相比，中年大脑在两个方面的性能是下降的：计算速度和注意力。其他方面，比如模式识别、空间想象能力、逻辑推理能力等等，性能不但没有下降，而且还提高了。 计算速度和注意力下降应该是对学习力有一些影响的，但丰富的经历和经验应该可以缩短学习路径，更有效地学习。回顾过往，年轻时学习的路径试错曲线要长得多，所以这一点在学习效率上得到了弥补。而从其他方面看，模式识别、空间想象和逻辑推理意味着中年人的大脑擅长更多高级的工作技能，所以完全没必要担心 “老了” 会导致学习能力下降。 缺乏安全感，正是源自变化，变化带来的不确定性。 环境和人都处在长期持续的变化中，变化总是不确定的，我们没法消除变化，只能把变化纳入考虑，承认变化是永恒的，不确定是长期的。面对这一点很难，难在反人性，我们真正需要做的是战胜自己人性里的另一面 —— 适应变化，无论世界怎样变化，内心依然波澜不惊，就像大海深处，无论海面如何波浪滔天，深处依然静谧悠然。 简言之，人到中年，转换了战场，重新定位自己的优势，转变核心竞争力，浴火重生，开启人生的下半场。 年轻时，我们打的是突击站，左冲右突；中年了，我们打的是阵地战，稳步推进；如今，我们进入了人生的中场战事。这场战事从谋生的恐惧感开始，给予我们警示；到舍生的无惧感，让我们摆脱束缚，整装待发；最后经过重生的安全感，推动我们再次上升。 关于中年之惑，你有哪些看法呢？ 47 该不该去创业公司？大约是 2015 年时，那是一个大众创新、万众创业的 “双创” 年代。当时，创业公司如雨后春笋般出现，又如昙花一现般凋零。也是在那年，招聘时碰到过一个人，一年换了三个公司，我就问：“为什么这么频繁跳槽呢？”而他的答案也让我吃了一惊，他说因为他加入的每家公司，没几个月就都倒闭关门了。 那时候，我和我身边的同事都收到过来自创业公司的邀约，有的同事就此去创业了，而我最终选择了拒绝。后来，我复盘了当时的场景，面临这样的选择，会同时有感性和理性的因素。感性的因素也许每个人都不尽相同，但理性的方面，更有普适性，从中我慢慢提炼和完善成了一组选择决策框架。 一、期望为什么要加入创业公司，你的期望是什么？也许有下面几种原因： 自由成长 变身土豪 追求梦想 1. 自由成长创业公司相对成熟的大公司，会有更大的自由度，能接触的东西更多，但需要处理的问题也更多、更杂，会让人更容易自由成长为一种解决各类问题的多面手。这对于程序员而言，很可能就是综合能力更强，但在特定的专业领域又不够精深。 但有些人就会觉得在大公司过于拘束，缺乏自由度，干的事情专业分工很精细，并不适合自己相对广泛的兴趣路线。那么这类人在初创公司也许就会有更多的尝试机会，更大的发挥空间。 2. 变身土豪业界坊间一直流传着创业公司上市 IPO 一夜变身土豪的故事，但我们不妨理性地来分析一下。 最早期的创业公司，大概处在天使轮阶段。作为技术人，如果你的经验和背景足以让你以技术合伙人的身份加入，那么你可以大概拿到公司占比 5% 左右的期权。假如公司最后成功 IPO 上市了，市值 100 亿，那么你的股票兑现就值大约 5 亿了（这里忽略行权和各类税务成本），成功变身土豪。但关键点在于，从天使轮到上市途中，统计数据上显示会倒下 99% 的创业公司。 如果创业公司进展到了 A 轮，你再加入，成为合伙人的概率就低了，更可能成为一名高管。这时能分到的期权会少一个量级，大约 0.5%。最终公司上市，还是 100 亿市值，勉强还能成为一个“瘦”点的土豪。 进一步到了 B 轮，再加入时，想成为高管的能力和背景要求都更高了，这时能拿到的期权比例会进一步下降一个量级，大约 0.05%。100 亿的市值，按这个比例就不太能成为土豪了。 到了 C 轮，公司上市的可能性大大增强，前景可期。但这时加入，能拿到的比例进一步下降一个量级到 0.005%，如果这时公司的上市预期市值就 100 亿，估计也吸引不到什么人了。 变身土豪，其实需要的是增值 100 倍的机会，而最低的下注金额是一年的收入。加入创业公司就是用你的时间下注，能否撞上 100 倍的机会，很多时候就是靠时运。因上努力，果上随缘，尽人事，听天命。 3. 追求梦想也许创业做的事情正是你梦想的、喜欢做的事情，人生有时不就是挣钱来买一些 “喜欢” 么？那么你愿为 “喜欢” 支付多大的成本与代价？ 在成熟的大公司工作，无论工资还是配股的收益都有很高的确定性。而创业公司即使给你开出同等的工资加上对应的期权，相比大公司的稳定性和持续性，也依然处于劣势。更可能的情况是，创业公司给你的工资加上按目前融资轮次估值的期权价值一起，才勉强和你在大公司每年的确定收益相持平。 站在创业公司的角度，公司通常也不希望招一个只要高工资，不要公司期权的人吧。公司当然会觉得期权价值的不菲，而且每进入下一轮融资期权价值一般都会增幅巨大，拥有很大的增值潜力。而站在你的角度，给期权的正确估值应该是 0，因为期权的兑现日期你无法预期，也许是五年，也可能是十年后，再考虑创业的高失败率，所以一开始就不要寄予太多期望的好。 将期权更多的看作彩票，如果期权让你发了财，这非常好，但是你应当确保自己的工资报酬至少可以接受，也就是说即使你的合同中没有期权，你也仍然会选择加入这家创业公司。这中间相对你在大公司的确定性收益的差距便是追求梦想的直接经济成本，也可以理解为你选择创业的风险投入资本。 最理想情况下，通过一次创业的成功，上述三者期望都一次性实现了。但，现实却往往没那么理想。 二、条件搞清楚了自身的期望与需要付出的成本和代价，再来理性地看看其他方面的因素。 1、创始人创业的目的是什么？期望是什么？创业毕竟是一段长期的旅程，大家的目的、价值观、期望差距太大，必然走不长远，身边就目睹过这样的例子。 2、创始人以前的口碑和信用如何？有信用污点的人并不值得合作与跟随，而且前面说的创业公司期权，最终能否兑现？就国内的创业环境而言，这一点也很是关键。 3、公司的核心团队成员如何？看看之前都有些什么样的人，你对这个团队的感觉契合么？价值观对味么？这个团队是合作融洽，还是各怀鬼胎？有些小公司，人虽不多，办公室政治比大公司还厉害。 4、对你的定位是什么？创业公司在发展初期容易遇到技术瓶颈，会以招 CTO 的名义，来找一个能解决当前技术瓶颈的专业人才。也许你会被名头（Title）吸引，解决完问题，渡过了这个瓶颈，但这之后老板会觉得你的价值还足够大么？有句话是这么说的：“技术总是短期被高估，长期被低估”。而你自身还能跟得上公司的发展需要么？ 5、公司是否有明确的业务方向？业务的天花板多高？有哪些对手？相对竞争的核心优势是什么？很多做技术的同学都不太关心业务的商业模式，也许这在大公司可以，毕竟船大，一般也就感觉不到风浪。但在创业公司则不然，业务的天花板有多高？也就是能做到多大？如果公司业务没有明确的方向和优势，你憧憬着踏上了火箭，结果却是小舢板，起风时感觉还走得挺快，风一停，就只好随波荡漾了。 也许还有很多其他方面你关注的条件和因素，在选择前都可以先列出来比较。只是最后我比较确定的一件事是，不会有任何一家公司满足你所有心仪的条件，这时就需要你做决策了。 三、决策决策之前，期望是内省，条件是外因；决策就是将客观的外因与主观的内省进行匹配判断选择的过程。 决策很难，让人经常很矛盾，很沮丧。往回看，我们总能找到适合自己的最优决策路径，但当初却并没有选到这条路，所以沮丧。往前看，其实有无数的路径分支，我们怎么可能选中最优路径，有这样的方法吗？没有。 这样的决策就像古时先哲讲过的一个故事，大意是：你有一个机会经过一条路，这条路两边都是大大小小的宝石，但你只能走过这条路“一次”，捡起其中“一块”宝石，中间不能更换。这里捡到最大的宝石就是最优策略，但你怎么实现这个最优策略呢？其实没有方法能保证。 而先哲的建议是，前 1/3 的路径，你只观察周围的宝石，最大的有多大，平均大小大概在什么水平，但不出手捡。经过这前 1/3 的路程，你应该有一个预期的大小标准，这个标准可能略比平均大小大一些，但不应该以之前看见的最大的宝石为标准。再走剩下的 2/3 路程时，你只要看见第一个符合这个标准的宝石，就可以出手捡起，之后快速走完全程。 这个方法虽不能保证你捡到最大的宝石，但可以很大概率保证你捡到符合自己预期标准大小的宝石，而这个预期标准，就是你的 “满意标准”。这个捡宝石的决策就是 “满意决策”，满意决策是一种折衷决策，只是在当时情况下可选的最佳行动方案。 人生中会有很多类似 “捡宝石” 这样的决策场景：找工作、找伴侣、选房子、买股票，甚至是买任何东西，只不过因为其中大部分东西的购买支付代价低，所以你不会有太大的决策压力。前 1/3 的路程就是让你在决策前充分观察、调研、确定你的满意标准，之后面对第一个满意对象就能够直接决策，然后继续快速前行。 满意决策的方案就是让你做完决策不纠结，即使后来回头看离最优还有差距，也不遗憾。因为，人一生要面对的决策很多，“满意决策” 的办法让你省下了 2/3 纠结的路程，继续快速前行。 最后，当你面临加入创业公司的选择时，问问你的期望，评估现实的条件，再做出满意的选择；决策过后，可能有遗憾，但没不甘。 如今在创业公司的你，当初是如何选择的呢？或者你是怎么看待这件事的呢？ 48 该不该接外包？以前我曾接到过一些关于程序外包站点的营销邮件，也看到过身边有些人选择去接一些外包，赚点外快。当然也有人找到过我做外包项目，这时我就必须做出一个评估和选择，面对外包赚钱的诱惑，到底该如何进行更好的选择呢？ 赚钱与诱惑外包的直接诱惑，就是能立刻增加工资之外的收入，赚点外快。 但反过来，我们需要问自己的是：需要为赚点外快去接外包吗？为此，我先去调研考察了一番现在的程序员外包市场。好几年前，我留意了一个程序员外包平台，已有好几万签约开发者了，如今再去看时，已有近二十万程序员了。这不免让我思考：什么样的程序员会去这样的平台上接外包项目呢？ 我把该平台上的程序员页面列表挨着翻了十来页，发现了一个规律。我看过的这些签约程序员多数工作经验在三到五年之间，还看到一个创业公司的创始人，可能是目前创业维艰，接点外包项目来维持团队生存吧。 但总的来说，来这里接单的很大一部分程序员应该都是想要赚点工资之外的钱吧。赚钱本无错，只是程序员除了接兼职外包项目还有什么其他赚钱方式吗？我想了想，程序员赚钱的方式大概有下面这些。 咨询 / 培训。一般被外部企业邀请去做咨询或培训的程序员，根据个体差异可能报酬从几千到几万不等吧，但能够提供此类服务的程序员，对其本身的素质要求较高，而且来源不稳定，所以不具有普适性。 演讲 / 分享。程序员圈子经常会有一些技术分享大会，有些组织者会对提供分享的讲师支付一点报酬，具体数额可能因“会”而异吧，但一般不会比咨询和培训类更多。 投稿 / 翻译。一些写作和英语能力都不错的程序员可以向技术媒体去投稿或翻译稿件。原创千字标准一百五左右，而翻译会更低些，看译者的水平从千字几十到一百左右。 写书。也有不少程序员写书出版的，但基本都是技术类图书。对于图书版税，一个非著名作者不太可能超过 10%，而能卖到一万册的国内技术书籍其实并不多，假如一本书销售均价 50 元，那你可以自己算下大概写一本书能挣多少。畅销和长销的技术类图书，基本都成了教材，而现实中要写一本优秀的教材保持十数年长盛不衰，是件极困难的事。 写博客 / 公众号。十年前大家写博客，现在很多人都写公众号。博客是免费阅读，靠广告流量分成赚钱，但其实几乎就没几个有流量的独立博客，都是聚合性的博客站赚走了这部分钱。 而公众号开创了阅读打赏模式，有些人看见一些超级大 V 随便写篇文章就有几千人赞赏，觉得肯定赚钱。但其实写公众号的人真没有靠赞赏赚钱的，赞赏顶多算个正向鼓励罢了。一个拥有十万读者的公众号，实际平均每篇的打赏人数可能不到 50 人，而平均打赏单价可能不到 5 元。这么一算，假如一篇文章 2000 字，还不如投稿的稿费多。所以持续的博客或公众号写作基本靠兴趣，而能积累起十万读者的程序员几乎属于万中无一吧。 课程 / 专栏。这是今年才兴起的形式，一些有技术积累和总结表达（包括：写和讲）能力的程序员有机会抓住这个形式的一些红利，去把自己掌握的知识和经验梳理成作品出售。但能通过这个形式赚到钱的程序员，恐怕也是百里挑一的，普适性和写书差不多。 兼职 / 外包。这就是前面说的外包平台模式，平台发布项目，程序员注册为签约开发者，按人天标价，自己给自己的人天时间估值。我看平台上的跨度是一天从 300 到 2000 不等。 各种赚钱方式，分析了一圈下来，发现其实对于大部分程序员而言，最具普适性的还是兼职外包方式。因为其他方式都需要编程之外的一些其他技能，而且显然兼职外包方式相比较而言属于赚钱效率和收入最高的一种方式，无怪乎会有那么多程序员去外包平台注册为签约开发者。 只是，这种方式的赚钱性价比真的高吗？短期的直接收入回报诱惑很大，但长期的代价和成本呢？ 成本与比较接外包的短期成本是你的时间，那长期的成本和代价呢？ 桥水基金创始人雷·达里奥（Ray Dalio），也是近年畅销书《原则》的作者，制作过一个视频叫《三十分钟看清经济机器如何运转》，他在视频的末尾提出了三条建议： 不要让债务的增长速度超过收入。 不要让收入的增长速度超过生产率。 尽一切努力提高生产率。 这三条建议虽然是针对宏观经济的，但我理解转化一下用在个人身上也是无比正确啊。特别是第二条，现下多接外包提高了当下的收入，但长期可能会抑制你的生产率，让你失去竞争力。为什么呢？举个例子，我们经常在电影里能看到这样一些熟悉的画面，白天晚上打着几份工的人为生活疲于奔命，那他（她）还有时间来做第三条吗？疲于奔命导致个人生产率增长的停滞，未来竞争力的下降。 生产率是一个宏观经济术语，用到程序员个人身上可不能直白地理解为产出代码的效率，正确的理解我认为是个人价值的产出率，即如下等式： 个人生产率 = 个人价值的产出率 基于以上理解，面临当初的外包项目我的选择是：拒绝。因为，它带来的收入是一次性的，不具备积累效应，而且相比我的全职工作收入还有差距，短期也许能增加点收入，但也没有其他任何意义了。如果老是去接这样的事情，长期的代价必然是个人生产率的降低，得不偿失。 但我确实还做一些不赚钱的事，比如过去多年经常写作，偶尔翻译，我所做的这些事情的直接目的都和提高现阶段的收入（立刻多赚钱）没关系，只是想尽可能地在提高个人价值的同时提升价值产出率，也就是说在做达里奥所说的第三条建议。 不过，个人价值的提升可能不会立刻反映到当下的收入上，就像公司的内在价值提升了可能股价还没涨一样。但长期来看，价格总是要回归价值的，这是经济规律，宏观如国家，微观如个人。 值钱与选择该不该接外包的选择本质是：选择做赚钱的事，还是值钱的事？ 梁宁有篇文章就叫《赚钱的事和值钱的事》，文中总结了这两点的差别： 赚钱的事，核心是当下的利差，现金现货，将本求利。 值钱的事，核心是结构性价值，兑现时间，在某个未来。 从赚钱的角度看，前面分析的所有赚钱方式的赚钱性价比都很低，完全不值得做。你可能会反驳说，外包项目的收入可能也不低，甚至比你的全职工资还高，怎么会认为赚钱性价比很低呢？一方面，全职工作提供的收入是稳定的；另一方面，兼职外包的收入多是临时的，一次性而不稳定的。若你能持续稳定地获得高于全职工资的外包收入来源，那么仅从赚钱角度看，更好的选择可能应该是去全职做外包了。 从值钱的角度看，前面分析的所有赚钱方式，在以个人价值增值为出发点的前提下，是值得尝试的。正因为兼职外包接单对很多程序员具有普适性，所以针对这件事情的出发点应该是看是否以个人价值及其增长为归依，而非是为了当下能多赚点钱。过于专注短期的收入提升，可能会“一叶障目”，忽视了长期的价值增值。 为了多赚点外快牺牲当下所有的业余时间，这值得吗？这种兼职外包项目对于自身的价值增值有多大的帮助？这是你需要反问和思考的问题。我估计很多兼职项目都是低水平的重复劳动，其实不止是兼职，甚至很多全职工作亦是如此。 说个例子，刚毕业时，我被分配维护一些历史遗留 Java Web 项目，可能因为毕业时我已有了些 Java Web 相关的课程设计经验；而和我一起加入公司的另一个校友则完全没有这方面的基础，所以被安排维护另外一个历史遗留基于 IBM Lotus Notes 的系统。 估计 Lotus 这套东西现在几乎绝迹了，在当时也是非技术主流，只不过因为历史原因还需要维护。既然公司出钱招聘了我们，为了生存和生活，刚毕业的我们其实没有多少挑选工作内容的机会。因此他在维护 Lotus 项目之余，还在不断地学习 Java 相关的内容，找一些业余项目来做并练习，为下一次的工作转型做准备。我认为像他这样以此为出发点的兼职或业余项目都是没问题的。 为什么外包平台上（我观察下来）三到五年的签约程序员最多？我揣摩可能与他们所处的阶段有关，正是处在结婚安家的阶段，收入敏感度较高。但牺牲未来潜在的生产率增长来换取当下收入临时且不高的增幅，是不值得的。 在价值积累到一定阶段之前，收入增长得并不明显，这阶段人和人之间的收入差距其实很小。想想同一家公司、同一个岗位、同样工作三到五年的程序员，收入能有多大差距呢。这阶段你即使花费所有的业余时间来赚钱，与你的同龄人拉开的收入差距也不会大。 而我观察多数真正拉开差距的阶段是在工作的十年到二十年之间，根据个人的价值积累大小，价值结构变现的机遇，拉开的差距是数量级的差别，会让你生出“当时看起来我们差不多，但如今他干一天能抵我干上一个月甚至一年了”的感慨，所以前十年不妨把关注的焦点放在个人价值的增值上。 最后，再总结下到底“该不该接外包”这个问题。我认为值得接的外包，它包括下面一些特性： 如果外包项目对你的技术积累有好处，那么收点钱去实践提升下正好一举两得；其实参与开源项目，本质上不就是不收钱的外包项目？它的收益就是让你更值钱。 外包项目的成果具有可复制、可重用性，这样就可以通过大量复制和重用来降低一次性开发成本；而成本和比较优势才是外包模式的核心竞争力所在啊。 外包项目不是临时一次性的，而是需要长期维护的，而这种维护的边际成本可以依靠技术工具手段不断降低，那这样的外包项目就是一个长期赚钱的 “机器” 了。 所有以上特性都反映了一个本质：去做值钱的事，打造值钱的结构，从知识结构、技能结构到作品结构与产品结构，然后等待某个未来的兑现时间。 末了，也谈谈你对外包项目的看法吧，欢迎留言。 49 技术干货那么多，如何选？在我刚进入行业的早些年，也是互联网的早期，其实网上的信息都不算特别多，而技术干货类信息更是少，所以就养成了一个习惯，遇到好的技术干货类文章就会收藏下来。这个习惯延续了多年，后来某天我突然发现仅仅是微信收藏夹内保存的技术干货型文章就已经累积了半年之多，都没时间去阅读和筛选。 收藏了如此多的干货，半年没读似乎也没缺了啥，那么还有必要读吗？2011 年时，我刚进入互联网行业，那已是互联网时代的成熟期，移动互联网的孕育期，也肯定是信息爆炸的时代，但依然是技术干货寥寥的时期。如今，却已是连技术干货也进入了爆炸期，那我们该如何挑选与应对？ 循证与决策路径为什么我们会去挑选和阅读技术干货文章？我想，循证大概是一个原始诉求，通过分析别人走过的路径，来拨开自己技术道路探索上的迷雾。 循证方法，也是我早年刚接触 J2EE 开发时遇到的技术决策指导思想，记得J2EE Development without EJB一书的译序中有一段话，很好地阐释了 “循证” 方法： 任何一个从事 J2EE 应用开发的程序员或多或少都曾有过这样的感觉：这个世界充斥着形形色色的概念和 “大词”，如同一个幽深广袤的魔法森林般令人晕头转向，不知道该追随这位导师还是该信奉那个门派。 这时，Rod Johnson 发出振聋发聩的一呼：尔等不必向泥胎偶像顶礼膜拜，圣灵正在尔等自身 —— 这就是他在书中一直倡导的 “循证架构”。选择一种架构和种技术的依据是什么？Rod Johnson 认为，应该是基于实践的证据、来自历史项目或亲自试验的经验…… 所以，我们去阅读技术干货文章，想从别人的分享中获得对自己技术方案的一个印证。这就是一种行业的实践证据，毕竟想通过听取分享去印证的，通常都是走过了一条与自己类似的道路。技术道路的旅途中充满着迷雾与不确定性，我们不过是想在别人已走过的类似道路中获得指引和启发，并得到迈出坚实下一步的信心。 这就是循证方式的技术决策路径。 多年前，我们刚开始做咚咚这个 IM 系统时，就是沿着这条路径一路过来的。 刚启动是 2012 年，一开始其实是完全不知道怎么迈步，专门花了三个月时间来研究业界的 IM 软件系统都是怎么做的。当时行业 IM 第一的当属 QQ，但那时腾讯公司的技术保持神秘而低调，在互联网上几乎找不到任何公开的技术分享资料。 退而求其次，我们只好研究起开源的 IM 软件，也就是基于 XMPP 开放协议实现的一类开源 IM 服务端和客户端，并以此为基础去设计我们自己的 IM 架构，然后实现了一个最初的原型。 再后来，腾讯终于有一位即时通讯的 T4 专家出来分享了一篇关于 QQ 的后台技术架构演进之路，记得是叫《1.4 亿在线背后的故事 —— QQ IM 后台架构的演化与启示》。我仔细听了一遍，又把分享材料翻过好多遍，思考并体会其中的架构演化道路。 数年后，微信在移动互联网时代崛起，并且在 IM 领域甚至还超越了 QQ，微信团队也分享了其后端架构演进之路。此时，我们自身的架构也基本成型并运行一些年了。而我也注意到，关于 IM 类消息应用最核心的一个技术决策是：消息模型。微信的方式和我们并不一样。 微信的方式是基于消息版本的同步加存储转发机制，而我们则是基于用户终端状态的推送加缓存机制。微信的机制从交互结构上更简洁和优雅一些，在端层面的实现复杂度要求更低，符合其重后端、轻前端的设计思路和原则。 然而，循证的方式就是：即便你看到了一个更好的技术与架构方式，但也要结合自身的实际情况去思考实践的路径。消息模型，作为一个核心的底层架构模型，也许刚起步未上线时，变更优化它只需要一两个程序员一两周的时间；但经过了数年的演进，再去完全改变时，就需要各端好几个团队配合，并忙上一两个季度了。 循证，不一定能立刻给你的当下带来改变，但可以给你的演进路径方向带来调整，未来将发生改变。 切磋与思考方式技术干货多了以后，在类同的领域都能找到不同公司或行业的实践分享，这时不仅可以循证，还能够达到切磋和多元化思考的目的。 处在 IM 这个领域，我就会经常去看关于 IM 相关技术领域的干货文章，所以我知道了微信的消息模型采用了推拉结合，还有基于版本的同步机制。但我不会再纠结于为什么我们不同，而是去看到它的好处与代价。 一个更具体的切磋案例：大家都熟悉且特别常用的功能 —— 群消息。关于群消息模型，微信采用的是写扩散模型，也就是说发到群里的一条消息会给群里的每个人都存一份消息索引。这个模型的最大缺点就是要把消息索引重复很多份，通过牺牲空间来换取了每个人拉取群消息的效率。 好多年前我们刚开始做群时，也是采用了的写扩散模型，但后来因为存储压力太大，一度又改成了读扩散模型。在读扩散模型下，群消息只存一份，只需记录每个群成员读取群消息的偏移量，偏移量的记录相比消息索引量要小几个量级，所以减轻了存储压力。 而之所以存储压力大在于当时公司还没有一个统一的存储服务组件，我们直接采用 Redis 的内存存储，当时原生的 Redis 在横向和纵向上的扩展性都比较受限。这在当时属于两害相权取其轻，选择了一个对我们研发团队来说成本更低的方案。 再后来公司有了扩展性和性能都比较好的统一存储组件，实际再换回写扩散模型则更好。毕竟读扩散模型逻辑比较复杂，考虑自己不知道加了多少个群了，每次打开应用都要检查每个群是否有消息，性能开销是呈线性递增的。 同一个技术方案在不同的时期，面临不同的环境，就会带来不同的成本，并做出不同的选择与取舍。虽然看起来是在走类似的路，但不同的人，不同的时代，不同的技术背景，这些都导致了终究是在走不同的路。路虽不同，但可能会殊途同归吧。 切磋带来的思考是：你不能看见别人的功夫套路好，破解难题手到擒来，就轻易决定改练别人的功夫。表面的招式相同，内功可能完全不同，就像金庸小说里的鸠摩智非要用小无相功催动少林七十二绝技，最后弄得自废武功的结局。 切磋，主要是带给你不同的思维方式，用自己的功夫寻求破解之道。 连结与知识体系干货多了，时间有限，自然就存在一个优先级的选择阅读问题。 就我个人来说，我的出发点很简单，有两点：基于功利性和兴趣。说起功利性也别觉得不好，毕竟整个商业社会都是基于功利性为基础的，所以基于此的选择其实是相当稳定的。考虑下所在组织和团队的功利性需求来做出技术的选择，有时甚至是必须的，而不能完全由着兴趣来驱动。 我在前文[《领域：知识与体系》]中已经有过说明，我会把过去自己所掌握的所有技术总结编织成一张“网”，若一个技术干货分享的东西离我的“网”还太远，我就会放弃去了解。因为如果不能连结到这张“网”中，形成一个节点，我可以肯定它就很难发挥任何作用，很可能是我看过之后没多久就遗忘了。 如今技术发展百花齐放、遍地开花，但人生有限，所以你必须得有一种方式去做出选择，最差的可能就是所谓的随性选择。我觉得很多情况下是需要一个选择指导框架的，而对于如何选择阅读技术干货的问题，前面比喻的那张“网”就是一个我自己的指导框架。 即便是针对同一个问题或场景，我们也可以将已知的部分连结上新的知识和实践，形成更密、更牢固的技术体系之网。 刚做 IM 时，曾经有个疑惑，就是 IM 的长连接接入系统，到底单机接入多少长连接算合适的？很早时运维对于长连接有个报警指标是单机 1 万，但当时我用 Java NIO 开 2G 最大堆内存，在可接受的 GC 停顿下，一台 4 核物理机上测试极限支撑 10 万长连接是可用的。那么平时保守点，使用测试容量的一半 5 万应该是可以的。 之后一次机会去拜访了当时阿里旺旺的后端负责人，我们也讨论到了这个长连接的数量问题。当时淘宝有 600 万卖家同时在线，另外大概还有 600 万买家实时在线，所以同时大概有 1200 万用户在线，而当时他们后端的接入服务器有 400 台，也就是每台保持 3 万连接。他说，这不是一个技术限制，而是业务限制。因为单机故障率高，一旦机器挂了，上面的所有用户会短暂掉线并重连。若一次性掉线用户数太多，恢复时间会加长，这会对淘宝的订单交易成交产生明显的影响。 他还说了一次事故，整个机房故障，导致单机房 600 万用户同时掉线。整个故障和自动切换恢复时间持续了数十分钟，在此期间淘宝交易额也同比下降了约 40% 左右。因为这种旺旺在线和交易的高度相关性，所以才限制了单机长连接的数量，而当时已经有百万级的单机长连接实验证明是可行的。 在一篇关于微信红包的的技术干货文章《100 亿次的挑战：如何实现一个“有把握”的春晚摇一摇系统》里提到： 在上海跟深圳两地建立了十八个接入集群，每个城市有三网的接入，总共部署了 638 台接入服务器，可以支持同时 14.6 亿的在线。 简单算一下，大概就是 228.8 万单机长连接的接入能力，14.6 亿怕是以当时全国人口作为预估上限了。实际当然没有那么多，但估计单机百万长连接左右应该是有的。这是一个相当不错的数量了，而采用 Java 技术栈要实现这个单机数量，恐怕也需要多进程，不然大内存堆的 GC 停顿就是一个不可接受和需要单独调优的工作了。 以上就是从干货中提取知识和经验总结的案例，形成对已有知识的连结。这就是不断加固并扩大自己的技术知识体系之网。 总结来说：面对众多的技术干货，从循证出发，找到参考，做出技术决策，决定后续演进路线；在演进路上，不断切磋，升级思考方式，调整路径，走出合适的道路；在路上，把遇到的独立的知识点，不断吸收连结进入自己的技术知识体系之网。 回答了标题的问题，这篇文章也该结束了。面对技术这片大海，我们都是一个渔民，三天打鱼，两天结网。愿你的“网”越结越大，捞的“鱼”也越来越多，也欢迎留言分享下你的“打鱼”和“结网”经历。 50 技术分歧，如何决策？作为一名程序员或技术人，总会碰到这样的场景：在一些技术评审会上，和其他程序员就技术方案产生分歧与争论。如果你是一名架构师或技术 Leader，站在技术决策者的立场和角度，该如何去解决分歧，做出决策呢？ 这背后，有什么通用的方法和原则吗？ 绝对曾几何时，我以为技术是客观的，有绝对正确与否的标准判断。 在学校我刚开始学习编程技术时，捧着一本数据库教材，它在述说着经典的关系数据库表设计原则：第一、第二、第三范式。后来，我参加工作，那时的企业应用软件系统几乎都是以数据库为核心构建的，严格遵守范式定义的表结构。所以，当时觉得所有不符合范式设计的应用肯定都是错的，直到后来进入大规模的分布式领域，碰到了反范式设计。 也还是在学校做课程设计时，一起学习的同学总跟我讨论设计模式。一边写代码，一边研究这个代码到底符不符合某种模式，似乎没有套进某种模式中的代码就像没有拿到准生证的婴儿，带有某种天生的错误。直到后来，我碰到了反模式设计。 刚工作不久，同事和我讨论当用户删除自己的数据时，我们到底应不应该删掉它？我那时觉得理所应当写个 Delete 的 SQL 语句把它删掉。因为当时是这么想的：既然用户都不要他的数据了，我们还把它保留下来做什么呢？不是浪费资源嘛，而且服务器存储资源还算挺贵的。 但今天的互联网大数据时代，用户主动或非主动提交的任何数据，你都别想再将它真正地删除了。这个时代，受益于摩尔定律，存储设备容量不断增加，而价格不断降低，所有关于用户的数据总是可能有用的，都先存下来再说。 做技术这么些年下来，关于技术方案的判断，曾经以为的绝对标准，今天再看都是相对的。 相对的确是的，适合的技术决策总是在相对的条件下做出的。 曾经，读到一篇英文文章，其标题翻译过来就是《简化：把代码移到数据库函数中》。我一看到这个标题就觉得这是一个错误的技术决策思路，为什么呢？因为曾经我花了好长时间做了一个项目，就是把埋在数据库存储过程中的代码迁移到 Java 应用里；而且，现在不依赖数据库的代码逻辑不正大行其道吗？ 作者是在正话反说，还是在哗众取宠？我很是好奇。所以，我就把这篇文章仔细读了一遍，读完以后我发现作者说得似乎有些道理，他的说法我大概概括为如下。 作者说，如今绝大部分的 Web 应用包括两部分： 一个核心数据库，负责存储数据； 以及围绕数据库的负责所有业务智能与逻辑的代码，体现为具体编程语言的类或函数。 现在几乎所有的 Web 系统都是如此设计的，所以这像是真理，业界最佳实践，事实工业标准，对吧？但作者描述了他自己的经历，是下面这样的。 他从 1997 年开始做了一个电子商务网站，用了 PostgreSQL 作为数据库，第一版网站用 Perl 写的。1998 年换成了 PHP，2004 年又用 Rails 重写了一遍。但到 2009 年又换回了 PHP，2012 年把客户端逻辑拆出去用 JavaScript 重写，实现了前后端分离。 这么些年下来，代码重构过很多次，但数据库一直是 PostgreSQL。可是大量和数据存取有关的逻辑也随着代码语言的变迁而反复重写了很多遍。因而，作者感叹如果把这些与数据存取有关的逻辑放在数据库里，那么相关的代码将不复存在，他也不需要反复重写了。 这里有个疑问，作者没事老换语言，到底是在折腾啥？他虽然没有在文中明说，但作为程序员的我还是能设身处地感受到其中的缘由。作者本身是学音乐出身，目标是建网站卖音乐唱片，自学编程只是手段。作为一个过来人，我相信他早期的代码写得肯定不咋地，又在各种流行 Web 技术趋势的引诱下，充满好奇心地尝试各种当时时髦的技术，不断重构改进自己的代码。 在这个过程中发现，有一些和业务关系不太大的数据存取逻辑，被反复重写了很多遍，所以才产生出了这样的思路：假如把这部分代码移到数据库中。其实对这个思路的挑战，也是显而易见的： 如何进行调试、回滚？ 如何做单元测试？ 如何进行水平扩展？ 上述“挑战”在一般情况下都成立，但对于作者来说却不是很重要。因为作者思路成立的前提是：第一，他维护的是一个小网站，数据库没有成为瓶颈；第二，这个网站的开发维护人员只有作者一个人，而不是一个团队。 是的，围绕这个网站，作者创办了一家公司，雇佣了 85 名员工，并成为了公司的 CEO 也是唯一的程序员。因此，这就是一个在作者所处特定环境下的技术决策，虽看上去明显不太对，但在作者的相对限定条件下，这个决策实际省了他个人的负担（虽然扩展有明显的极限，网站也不会发展太大）。 仔细看作者这个案例，可以发现其技术决策方案也是符合 “康威定律” 的。“康威定律”是这么说的： 任何组织在设计一套系统时，所交付的设计方案在结构上都与该组织的沟通结构保持一致。 换句话说，就是系统设计的通信结构和设计系统的团队组织的沟通结构是一致的。案例中，作者的系统只有他一个人负责设计与实现，只需要和不同阶段的自己产生沟通，在他的系统和场景下，变化最小、稳定度最高的是数据存储和结构，所以他选择把尽可能多的代码逻辑绑定在系统中更稳定的部分，从而降低变化带来的代价。 而康威定律告诉我们系统架构的设计符合组织沟通结构时取得的收益最大。这是一个经过时间检验和验证过的规律与方法，体现的就是一个相对的选择标准，那在这背后，有没有隐藏着关于技术决策更通用的判断原则呢？ 原则康威定律，是和组织的团队、分工、能力与定位有关的，其本质是最大化团队的核心能力，最小化沟通成本。 在足够大的组织中，沟通成本已经是一个足够大的成本，有时可能远超采用了某类不够优化的技术方案的成本。每一次人事组织架构变动的背后，都意味着需要相应的技术架构调整去适应和匹配这种变化，才能将沟通成本降下来。而技术方案决策的核心，围绕的正是关于方案的实施成本与效率。 曾经很多次的项目技术评审会上，后端的同学和前端的同学经常就一些技术方案产生争论。而争论的问题无所谓谁对谁错，因为同样的问题既可以后端解决，也可以前端解决，无论哪条路都可以走到目的地。那么还争论什么呢？无非是各自基于局部利益的出发点，让自己这方更省事罢了。 这些问题的解决方案处在技术分工的临界地带就容易产生这样的争论，而技术的临界区，有时就是一些无法用技术本身的优劣对错来做判断的区域。这时，最佳的选择只能是将前后端整体全盘考虑，以成本和效率为核心来度量，应该由哪方来负责这个临界区。 而成本与效率背后的考量又包括如下因素： 团队：这是人的因素，关于团队的水平，掌握的技术能力和积累的经验； 环境：能利用的环境支持，公司内部的平台服务或外部的开源软件与社区； 技术：技术本身的因素，该项技术当前的成熟度，潜在的发展趋势； 约束：其他非技术约束，比如管理权限的干涉、限定死的产品发布日期等。 不同的人，同样的技术方案，成本效率不同；不同的环境，同样的技术方案，成本效率也不同；不同的技术，同样的环境和人，成本效率也不同；不同的约束，同样的团队和环境，会得到不同的技术方案，成本效率自然不同。 在技术的理想世界中，技术决策的纯粹部分，其决策原则都和成本效率有关；而其他非纯粹的部分，其实都是 “政治” 决策，没有所谓通用的原则，只和博弈与利益有关。 最后，简单总结下：技术没有绝对的标准，适合的技术决策，总是在受限的约束条件下，围绕成本与效率做出的选择权衡。对于一些纯粹的技术理想主义者，追求技术的完美与合理性，初心本不错，但也许现实需要更多的行动柔性。 关于技术方案分歧，你是否遇到过类似的争论呢？又是采用的是怎样的决策方式？欢迎留言分享和大家一起讨论。 51 技术债务，有意或无意的选择？在编程的路上，我们总会碰到历史系统，接手遗留代码，然后就会忍不住抱怨，那我们是在抱怨什么呢？是债务，技术债务。以前说过，代码既是资产也是债务，而历史系统的遗留代码往往是大量技术债务的爆发地。 然而，技术债务到底是如何产生的？它是我们有意还是无意的选择？这里就先从技术债务的认知开始谈起吧。 认知技术债务，最早源自沃德·坎宁安（Ward Cunningham） 1992 年在一次报告上创造的源自金融债务的比喻，它指的是在程序设计与开发过程中，有意或无意做出的错误或不理想的技术决策，由此带来的后果，逐步累积，就像债务一样。 当作为程序员的我们采用了一个非最优或不理想的技术方案时，就已经引入了技术债务。而这个决定，可能是有意的，也可能是无意的。有意产生的债务，一般是根据实际项目情况，如资源与期限，做出的妥协。 而无意产生的债务，要么是因为程序员经验的缺乏引入的，要么是程序员所处的环境并没有鼓励其去关注技术债务，只是不断地生产完成需求的代码。但只要程序员在不断地生产代码，那他们就是在同时创造资产与债务。债务如果持续上升，软件在技术上的风险就不断增加，最后慢慢走向技术破产。 以前看过另一位程序员写的一篇文章，名字就叫《老码农看到的技术债务》，印象还是比较深刻的。文中把技术债务分成了好几类，我记得的大概有如下： 战略债务 战术债务 疏忽债务 战略债务，是为了战略利益故意为之，并长期存在。我理解就是在公司或业务高速发展的阶段，主动放弃了一些技术上的完备与完美性，而保持快速的迭代与试错性。在这个阶段，公司的战略利益是业务的抢占，所以此阶段的公司都有一些类似的口号，比如：先完成，再完美；优雅的接口，糟糕的实现。 这类债务的特点是，负债时间长，但利息不算高且稳定，只要保持长期 “付息”，不还本金也能维持下去。 战术债务，一般是为了应对短期紧急情况采取的折衷办法。这种债务的特点就是高息，其实说高利贷也不为过。 这类债务，一直以来经常碰到。比如，曾经做电信项目时，系统处理工单，主流程上有缺陷，对某一类工单处理会卡住。这时又不太方便停机更新程序，于是就基于系统的动态脚本能力去写了个脚本临时处理这类工单，可以应对当时业务经营的连续性，但缺陷是资源开销大，当超过一定量时 CPU 就会跑满了。这样的技术方案就属于战术债务的应用。为避免“夜长梦多”，当天半夜的业务低谷，我就重新修复上线了新程序，归还了这笔短期临时债务。 疏忽债务，这类债务一般都是无意识的。从某种意义上来说，这就是程序员的成长性债务，随着知识、技能与经验的积累，这类债务会逐步减少。另一方面，如果我们主动创造一个关注技术债务的环境，这类债务就会被有意识地还掉。 从上面的分类可以看出，战略和战术债务都是我们有意识的选择，而疏忽债务正如其名，是无意识的。但不论技术债务是有意的还是无意的，我们都需要有意识地管理它们。 管理对于技术债务，开发团队中的不同角色关注的债务分类与形态也不太一样。 比如架构师关注的更多是战略债务，保持系统能够健康长期演进的债务平衡。作为架构师，就像 CFO，需要长期持续地关注系统的资产负债表。战略债务可能更多体现为架构、设计与交互方面的形态。而具体某个功能实现层面的代码债务，则更多落在相关开发工程师的关注范围内。测试工程师，会关注质量方面的债务，而一到交接时，各种文档债务就冒出来了。 那对于一个软件系统，我们如何知道技术债务已经积累到了需要去警示并着手计划进行还债的阶段了呢？一般来说，我们直觉都是知道的。 举个例子来说明下，好几年前团队接手继续开发并维护一个系统，系统的业务一开始发展很快，不停地添加功能，每周都要上好几次线。一年后，还是每周都要上好几次线，但每次上线的时间越来越长，回归测试的工作量越来越大。再后来，系统迎来了更多的新业务，我们不得不复制了整个系统的代码，修改，再重新部署，以免影响现有线上系统的正常运行… 到了这样的状况，每个人都知道，债务在报警了，债主找上门了。一次重大的还债行动计划开始了，由于还债的名声不太好听，所以我们喜欢叫：架构升级。架构升级除了还债，还是为未来铺路。当然，前提是要有未来。如果未来还能迎来更大的业务爆发增长，架构升级就是为了在那时能消化更多的长短期债务。 管理债务的目标就是识别出债务，并明了不同类型的债务应该在何时归还，不要让债务持续累积并导致技术破产。一般来说，只要感觉到团队生产力下降，很可能就是因为有技术债的影响。这时，我们就需要识别出隐藏的债务，评估其 “利率” 并判断是否需要还上这笔债，以及何时还。 有时，我们会为债务感到焦虑，期望通过一次大规模重构或架构升级还掉所有的债务，从此无债一身轻。其实，这是理想状态，长期负债才是现实状态。 清偿在产品突进，四处攻城略地时，还需要配合周期性地还债，保持债务平衡，才能保证系统整体健康稳步地发展。 首先，我们认识并理解了技术债务，识别出了系统中的各种债务，并搞清楚了每种债务的类型和利率，这时就需要确定合理的清偿还债方式了。 对于战略债务，长期来说都是持续付利。就像现实中一些大企业从银行借钱经营发展，每年按期付息，但基本不还本金；等公司快速发展到了一定阶段，基本进入成熟期后，市场大局已定，再主动降低负债风险和经营成本。 创业公司从小到大的发展过程中，业务在高速增长，系统服务的实现即使没那么优化，但只要能通过加机器扩展，就暂时没必要去归还实现层面的负债。无非是早期多浪费点机器资源，等业务到了一定规模、进入平稳期后，再一次性清偿掉这笔实现负债，降低运营成本。 这就是技术上的战略债务，业务高速发展期保持付息，稳定期后一次性归还。 战术债务，因为利息很高，所以一般都是快借快还。而疏忽债务，需要坚持成长性归还策略，一旦发现过去的自己写下了愚蠢的代码，就需要主动积极地确认并及时优化，清偿这笔代码实现债务。 其次，还债时，我们主要考虑债务的大小和还债的时机，在不同的时间还债，也许研发成本相差不大，但机会成本相差很大，这一点前面分析战略债务时已有提及。而按不同债务的大小，又可以分为大债务和小债务。一般，我把需要以周或月为单位计算的债务算作大债务，而只需一个程序员两三天时间内归还的债务算作小债务，所以这不是一个精确的定义。 小债务的归还，基本都属于日常的重构活动，局限在局部区域，如：模块、子服务的实现层面。而大债务的归还，比如：架构升级，就需要仔细地考虑和分析机会成本与潜在收益，所以大债务归还要分三步走： 规划：代表愿景，分析哪些债务需要在什么时间还，机会成本的损失与预期收益是多少。 计划：代表路径，细致的债务分期偿还迭代计划。 跟踪：代表过程，真正上路了，确认债务的偿还质量与到位情况。 如今微服务架构的流行，基本把小债务锁定在了一个或几个微服务体内。即使债务累积导致一两个微服务技术破产，这时的还债方式无非就是完全重写一个，在微服务拆分合理的情况下，一个服务的重写成本是完全可预期和可控的。 除了技术债务的管理与清偿，我们还需关注技术债务与作为程序员的我们之间的信用关系，因为毕竟债务也是我们生产出来的。 信用生产并拥有技术债务的程序员，并不代表其信用就差。 现实生活中，债务依附于借债的主体方，比如金融债务依附于个体或组织，但如果个体死亡或组织破产了，债务就失去了依附体，自然也就消失了。而技术债务的依附体，并不是程序员，而是程序构造的产品或系统，所以当产品或系统的生命周期结束时，相应的技术债务也会消失。 因而，此种情况下，程序员是有充足的理由不还技术债的，这是技术决策的一种，并不会降低程序员的信用。 任何一个程序系统或其一部分都会与某一个程序员建立关联，如果这个程序员此时就负责这部分系统，那么他在此基础上继续创造代码时，既增加了资产也可能引入了新的债务。这时他的一个重要职责就是，维持好资产与债务的平衡关系。如果在此期间，系统的债务失衡导致技术破产，需要被迫大规模重构或重写时，那么这个程序员的信用必将受到关联伤害。 所以，程序员的信用，更多体现在面对技术债务的态度和能力——有意识地引入债务，并有计划地归还债务；无意识地引入债务，发现之后，有意识地归还。 再有代码洁癖的人也没法写出无债务的代码，而无债务的系统也不存在。面对负债高的系统，我们不必过于焦虑，高负债的系统往往活力还比较强。作为程序员的我们，应把技术债务当作一门工具，而不是一种负担，那么可能就又获得了新的技能，得到了成长。 总之，面对债务，做一个有信用的程序员；将其当作工具，做一个有魄力的技术决策者。 最后，你也可以聊聊你对技术债务的态度和看法，欢迎留言一起讨论。 52 选择从众，还是唯一？想要取得成就，就会面临竞争，几乎所有的成就，都是直接或间接通过与他人的比较来评价的。理解了这样的评价与竞争关系，想要取得成就，出类拔萃，就意味着你要做出选择：选择从众、随大流，还是选择一条只属于自己的路？ 不同的选择，意味着面临的竞争水平不同，付出的努力自不相等。 众争有时，我们会下意识不自觉地选择从众，随大流；这样的选择往往给人更安全的感觉，但这样的选择也意味着更激烈的竞争。 随大流，属于众争之路，感觉是安全的，看上去也是热闹的，但竞争是激烈的，而且竞争所处的水平并不高，属于中等平均水平。比如：作为一名职业的普通程序员，你的任何一次求职、晋升或加薪，都面临类似水平的竞争，这样的竞争规模局限于一个局部市场，比如公司或部门内，规模不大，但人数不少。 在这样水平的竞争层面，其实最顶尖的那部分程序员已被排除在外了，因为这类人在市场上其实供不应求，而且没有大规模的生产方法。处在这样的众争之地，如果你永远都在看周围的人在做什么，和他们保持类似，那么你就很可能处在这群人中的一个平均水平区间。 其实，在这样的竞争水平下，你只需要稍微付出一些努力，就能超越平均水平；即使想要脱颖而出，也只需要持续地多付出一些努力。有一句流行的话是这么说的：“以大多数人的努力程度之低，根本轮不到拼天赋”，这就是众争层面竞争关系的本质。 先努力拉开差距，再去找到少有人走的适合自己的路。 稀少2% 的人创造内容，而 98% 的人消费内容；写作，就是这么一件少有人走的路。 写作的竞争，其实就比职场的竞争高了一个层次。因为职场求职、晋升的竞争都是局部区域性质的，而写作不受地域的限制，最厉害和成功的写作者可以直接与你竞争。然而，写作也可以通过专业化和差异化来划分领域，从而缩小你的竞争范围。但即使是这样，你仅仅是成为你所在的小集体组织（如：部门或班级）中写作水平最高的人，也不足以赢得竞争，而是需要成为该领域最优秀的写作者之一。 正因为写作所处竞争维度的残酷性，所以才会只有这么少的人在长期写作。我的写作之路，一开始本是因为有兴趣，偶尔有了感触或灵感就写写，属于灵感事件触发的兴趣写作。但这种没有约束感的兴趣写作导致的结果就是一年下来也没写出多少东西来，灵感这么飘忽的东西，似乎总也不来。后来，觉得需要增加点限制，保底平均每月至少写一篇，就像有人每月要去健一次身、跑一次步一样。 就这样带着个限制，持续写了五年，从灵感触发的兴趣写作，到主动选择的规律写作，也算是写出了点东西。再后来，我把这个约束提高到了每周一篇，虽说这会带来更大的消耗，但我逐渐想清楚了它的意义：这就是一个 2% 的选择，少有人走的路。 持续写作并不是为了写而写，它是为了满足自身。一开始即使写完一篇文章没人读，也是完成了最基本的价值，于我，即是每周一次的思维训练。就像每周健身一次，肯定比每月去一次效果更好。而一个写作者只需要持续去写对自己有意义和价值的东西就好，从一、两篇到一百、两百篇，也许其中某篇就和更多的人产生了共鸣，让写作和文字有了更大的意义。 曾在和菜头的公众号看到有人留言：“菜头叔，我可以写，但是没人看，就非常难受……都大半年了，看的人还是二十几个……心累啊！”和菜头的回复是：“我写了十年的时候，也只有 400 人看，半年时间很长么？” 当你写完一篇文字，把它推向这个世界的文字海洋，然后扑咚一声，便安静了下去，没有掀起一朵浪花。没必要纠结于此，继续写，继续改进，直到终于能掀起一丝涟漪，那么浪花也就不远了。 当然，也并非一定要选择写作，本杰明·富兰克林是这么说的： 要么写点值得读的东西，要么做点值得写的事情。 写作本身就是一个关于选择的活动，而值得写的东西，本来也是稀少的。选择少有人走的路，通常也意味着你要大量地尝试，考虑自己的长处加上刻意的练习，虽不能保证成功，但却在创造可能性。 稀缺稀少的事情，你可以有计划地去持续做；但真正稀缺的东西，比如：机会，却不会随时有。 在前面 “计划” 系列的文章中，分享了我会采用计划清单来安排时间，每天其实早就做好了计划。计划得满满当当的，一件接一件地划去待办事项列表（TO-DO List）上的条目，成就感满满的。但执行了一段时间后就发现了问题，虽然有计划，但总是有变化，计划得太满，变化来了就总会让计划落空；计划得不到执行，就会产生懊恼与愧疚感。 一开始我以为是计划得太满，缺乏弹性，所以无法应对变化。如果在计划里留出弹性空间，那么这些空间就是空白的，但如果一天下来没有太多变化发生，那这些留出的空白空间我又该做什么呢？这么一想，我突然就明白了，原来所有的日常计划都应该是备用的 B 计划（ Plan B），而真正的 A 计划（Plan A）就是变化，那种让你产生 “哇～噢～” 的惊叹感觉的变化。 我们大多数人，对太多的东西做出了过度承诺。这些东西通常就是一些日常计划，都是些小而平庸的事情，它们填满了我们的生活。但问题是，偶尔遭遇到“哇～噢～，我的天！”这样的变化，一些事情发生了，却没有给予足够的时间和精力去注意它们，因为满脑子都在想着那些还没完成的日常计划。 当一件事情来到你面前，决定是否需要去做时，如果你觉得不能让你产生 “哇～噢～” 的感觉，那么就可以坚决地说 “不”。这为你的生活留下了空间，然后当真正稀缺的 “哇～噢～” 时刻来临时，才可能有机会注意到并全身心地投入进去。“哇～噢～” 的稀缺时刻不会经常出现，所以才需要备用计划，既然是备用的，也是可以随时抛弃的。 平时，计划做一些少有人做的事，然后等待稀缺的 “哇～噢～” 时刻与机会出现，这样的时刻或机会是没法规划或计划出来的，否则它就不是稀缺的。而能否让你碰到 “哇～噢～” 的稀缺选择机会，这好像有点运气。如果没碰到也就算了，但如果碰到了当时却没注意到，好几年后回过头来才发觉，那留下的将是 “哦～哎…”了。 独一独一无二的路，要么是没有竞争的，要么是别人没法竞争的。 瓦叔就曾走过独一无二的路，那瓦叔是谁？你多半熟悉，就是阿诺德·施瓦辛格，跟他有关的标签有：健美先生、终结者、美国加州州长。看过他的一个采访后，才明白：这看起来傻傻的大块头真有大智慧。 他在自己发展的路上，问了自己一个问题： How can I carve myself out a niche that only I have? 这句话怎么理解？Niche 这个词的原意是 “壁龛”，如果你参观过像千佛洞这样的地方，应该对山壁上放佛像的凹洞有印象，那就是 “壁龛”。而 Carve out 的原意是“雕刻”，所以比较形象的理解就是：如何在崖壁上雕刻出一个凹洞，把我这尊佛放进去。后来 Niche 引申为“职业生涯中合适的位置”，所以这句话就可以理解为：我如何为自己谋得一个独一无二的位置？ 这是他从健美先生转型进军好莱坞时问自己的问题。所以，在好莱坞他从不去试镜：“我才不会去尝试走这些常规路径，因为你知道我看起来长得就不像是一个常规的家伙。”因此，他没有急着去试镜一个角色，然后赚租金养家糊口。 作为之前的全美乃至全球健美先生，已有一定的经济基础去支撑他等待一个合适的稀缺选择机会，然后他等到了一个独一无二的角色：终结者。导演詹姆斯·卡梅隆说：“要是没有施瓦辛格，我可能不会拍《终结者》这部电影，因为只有他像个机器人。” 独一，可遇不可求；遇，也先得有遇的基础，它包括：异常的努力，不错的运气，非凡的能力，也许还有特别的天赋。 可惜，我们很多时候都选择了随大流。 最后，总结提炼下今天的内容： 走众争之路，拼的是努力，只能成为平均的普通人； 走少有人走的路，拼的是选择、勇气和毅力，可以让你遇见独特的风景，为稀缺的机会创造可能性； 走独一无二的路，真的是要拼天赋了。 那么，现在你正走在哪条路上？ 53 选择工作，还是生活？从大学到职场，会经历一次失衡。 在学校的时候，虽有时间课程表，但大部分时间还是属于我们自己自由安排的。毕业后，一进入职场，就会发现工作开始占据了主导，而后随着工作日久，越发陷入一种关于工作与生活平衡的选择困惑。 处境工作与生活的平衡，到底是怎样一种状态？ 曾经我以为的平衡是这样的，我想很多人也这样以为过，工作与生活是完全隔离的。 工作逼迫我们在寒冷的冬天早晨从热乎乎的被窝里不情愿地钻出，去日复一日地完成一些枯燥、乏味甚至令人心生畏惧的事情，但却又不得不安慰自己，工作让我们所做的这一切都是为了生活啊，再忍忍吧。 而下班之后才是我们真正热切期待的生活，迫不及待地去玩热爱的游戏（对，那时我还热爱玩魔兽），周末就和朋友去游山玩水，感觉这才是生活。但似乎永远缺乏足够的时间去过这样的生活，假期总是太短，而工作的时间却总是在不断地变长。工作的第一年，我发现越来越少有时间玩游戏，总是在加班，总是坐最后一班公交车回到租住的小屋，冲个凉后，再一看时间，已经过了凌晨。 而工作之后的第二、三、四年，长期地出差，似乎连周末都剥夺了，感觉总是在工作。我期待的平衡，完全地失衡了。不仅是我感觉如此，也有好些同事因此选择离开了广州，回到二、三线城市的家乡，比如：西安、长沙。那时我也在想，“我是不是也可以回成都，听说成都是一个休闲的城市呢，回去后，工作与生活是不是就会更平衡些呢？” 是的，后来我就这么回来了，但却没有找到期待的平衡，工作反而变得丧失了充实与成就感，生活也变得更焦虑了。如今回首想来，当时我并没有认清和想明白自己的处境与状态，并去定义好属于那个阶段的平衡点。 每个阶段会有每个阶段的生活目标。刚毕业时，对我来说合适的目标应该是：自力更生，好好生存下来并获得成长。再之后几年，生活目标会进化到：恋爱成家。再往后，目标也随之发展为：事业有成，家庭幸福。而我当时的症结在于，错把平衡当作了目标，而实际平衡更多是一种感受。有句话是这么说的： 人若没有目标，就只好盯着感受，没有平衡，只有妥协。 认清自己当前阶段的目标，定义清楚这个阶段的平衡点。一个阶段内，就不用太在意每一天生活与工作的平衡关系，应放到整个阶段中一个更长的周期来看，达到阶段的平衡即可。通过短期的逃避带来的平衡，只会让你在更长期的范围内失衡。 作为个人，你需要承担起定义并掌握自己生活轨迹的重任，如果你不去规划和定义自己的生活，那么别人就会为你规划，而别人对平衡的处理你往往并不认同。 结合当下的处境与状态，没有静态的平衡，只有动态的调整。 关系工作与生活的关系，短期的每一天总在此消彼长地波动，但长期，应该是可以动态平衡的；当从长期的视角来看待工作与生活时，会发现二者之间并没有那么明显的分界线。 长期的视角决定了，无论工作还是生活追求的都不应该是最后的目标或目的 —— 一种終点状态。你必须得关注过程，这个过程才是你的生活。所以，生活包括了工作，有时候甚至是非常艰辛的工作，就像我刚开始工作的那几年。那时，工作填满了我绝大部分生活，让我错觉工作剥夺了我的生活。 只是因为当时我并没有想清楚自己到底想要一种什么样的生活，什么对我是重要的？我只是感觉从学校毕业进入工作，然后工作就逼迫着我放弃了曾经热爱的游戏。工作似乎在剥夺着我曾经生活中的很多东西，于是工作与生活就这样对立起来了。 然而工作不该是受罪，我们应当从中找到乐趣，王小波是这么说的： 人从工作中可以得到乐趣，这是一种巨大的好处，相比之下，从金钱、权利、生育子女方面可以得到的快乐，总要受到制约。人在工作时，不单要用到手、腿和腰，还要用脑子和自己的心胸。我总觉得国人对这后一方面不够重视，这样就会把工作看成是受罪，失掉了快乐最主要的源泉，对生活的态度也会因之变得灰暗… 当想清楚了这点后，工作就不过是生活的一部分，何必需要去平衡。与其去平衡两者，不如从整体长期的角度去选择一种平衡的生活。一段时间，也许你的生活中充满了工作；一段时间，你决定减少一些工作，去交交朋友，谈个恋爱。再一段时间后，有了孩子，你决定把曾经生活里的一部分，比如玩游戏，换成陪孩子玩游戏。也许你没法每一天都能做到这样自如地选择，但从一个长期的角度（五到十年）你总是可以选择的。 紧要的是，去过你想要的生活，而非不得不过的生活。 而这里所指的“工作”已不再仅仅是“上班、打工”这样的狭义含义，而是更广义上的“工作”。比如，现在我正在写这篇文字，写到这里，时间已过了凌晨，窗外有点淅沥声，下起了小雨。我喜欢成都夜晚的小雨，突然想起了杜甫《春夜喜雨》中的某几句： 随风潜入夜，润物细无声。 晓看红湿处，花重锦官城。 写作，于我就是另一种广义上的 “工作”。而且我喜欢上了这样凌晨夜里的写作，有一点点的辛苦，也有一点点的美好，是吧？这也是当下我选择的生活。 比例既然要主动选择，从一定的长周期看，就需要确定到底怎么样的比例合适。 选择工作在生活中的比例问题，是一个关于优先级和价值观的问题。从操作上来说，它其实是一个交易问题，关乎自己的所得和所失的交易。选择二者间的交换比例，意味着我们要进行权衡取舍，并为之承担相应的结果。 工作与生活的平衡比例选择，既然从操作上是交易问题，那么我们也就可以借用一下投资交易中的一种颇有启发的策略：年轻时，要更多投资于风险更高、波动更大、但潜在收益也更大的股权类权益；随着年纪见长，就要慢慢增大更稳定和确定的债券类投资比例，降低股权比例。 而且，这个策略还有非常具体的量化指标。就是用 100 或 120 减去你的年龄来得到你应该投资股权的比例。至于到底是用 100 还是 120，取决于你心理的风险承受能力和偏好。 把这个思路用在平衡工作与生活上的话，大概是这样，假如对于一个非常有事业心和野望的人（可以理解为风险偏好大的人），大学毕业平均是 22 岁，那么就应该是 120 - 22 = 98，也就是 98% 的精力花在工作上，当然这里是广义上的 “工作”。而对于那些刚毕业但没有那么大野心的年轻人，也应该投入大约 80%（这是用 100 来减） 的精力在 “工作” 上。 对于这个策略，我的理解是早期的高投入，是为了将来需要更多平衡时，能获得这种平衡的能力。在我有限的见识和理解能力之内，我是认同这个比例的。一开始就想获得安稳与平衡，人过中年之后是否还能获得这样的安稳与平衡，感觉就比较靠运气。掌控自己能把握的，剩下的再交给时代和运气。 人生，就是在风险中沉浮，平衡的交易策略就是用来应对风险与波动的。 工作是我们度过很长一段生命的方式，还有句话是这么说的：“我不喜欢工作，但我喜欢存在于工作里的东西 —— 发现自己的机会”，工作才会让我们找到属于自己的真正生活。 而我们应该追求过好这一生，而非追求平衡，如何才算 “好”，每个人都会有自己的答案。我的答案是：不是通过努力工作来过上想要的生活，而是先设定了想要的生活，自然而然工作就会成为生活中合适的一部分。 末了，我总结下今天的内容： 缺乏真正的目标时，就只好盯着感受，把平衡当作了目标，由此带来了平衡选择的困扰； 不同的处境与状态，会有不同的平衡点，需要做出规划与选择； 短期只有此消彼长，长期才能动态平衡； 早期年轻时的高投入，换取将来平衡的能力与选择权。 那么关于工作与生活的平衡选择，你有怎样的看法呢？ 54 侠客行：一技压身，天下行走从今天开始，我们进入了专栏的第 5 部分 —— 寻路：路在何方？这是一条关于方向、角色和自我定位的探索，那就让我们开始一起走走这条程序江湖路吧。 大约三年前吧，读到一篇文章《为何我工作十年，内心仍无比恐慌》，来自一位腾讯产品总监的演讲分享。文中分析了一个让其感到恐慌与焦虑的深层次原因：好像不会什么技能，技能门槛低。 这种恐慌和焦虑感在这个行业中普遍存在，不止于产品经理，程序员也一样。一些传统行业的生命已经远超过一个人的寿命，而 IT 互联网行业还不满三十岁，也许正是因为其还很年轻，生命力旺盛，远超传统行业的发展速度和新陈代谢规律，让其中的从业者深感疲惫，同时对未来又充满了不确定性，而未来的不确定性通常正是让我们感到焦虑的一个主要原因。 门槛技能的门槛高低，决定了让我们产生恐慌和焦虑的水位线。 在前面提到的《恐慌》一文中说，产品的从业门槛足够低，作者十年的从业经历中见过从事产品的人来自各种专业，还有各种改行做产品的。而从业门槛主要来自于技能门槛，特别是硬技能，硬技能属于行业的专有技能，需要足够的时间积累，通常这个积累时间就是你可能熟悉的理论值：一万小时。 产品看起来是一个缺乏硬技能门槛的职业，因而感觉门槛低。而程序员职业其实是有一定硬技能门槛的，但这种门槛随着技术和工具的进步正在变得越来越低。如今 IT 互联网行业当然是繁荣的，繁荣的行业带来利差，自会吸引大量其他行业的从业者进入，而这些进入者自然会选择门槛低的职业工种来跨越边界。 在其他行业干了些年头的人，有些可以在这个 “互联网 +” 的时代通过垂直行业专家来进入互联网行业，但要进入程序员这个职业就得赶早了，毕竟硬技能需要的积累时间是很难省却得了的。大部分人都是在大学期间或刚毕业不久就完成了转行到程序员职业的切换，如我的一个高中同学，她本是文科专业中文系的，大二就毅然开始辅修计算机的第二学位了。 还有个行业一直繁荣，需求永续存在而且供不应求，但却从没见过任何其他行业的人进入。我说的就是“医生”这个职业，它的硬技能门槛之高不免让人联想起《冰与火之歌》里的绝境长城，让人完全兴不起翻越的欲望。我听说过小说写得好的前妇产科医生，却没听说过手术做得好的前小说家。 医学院的学生本科都要比其他专业多读一年，但本科毕业可能都找不到什么好工作，至少要读到硕士，想有点发展还得读博，十年一晃而过。而本科毕业的程序员，一进入 IT 互联网行业可能拿的工资比医学博士生刚进入医院还高，这就是行业繁荣的好处。但坏处是，这个行业变化太快，有时你没什么错，只是因为老了。很多互联网公司喜欢年轻人，标榜年轻，员工平均年龄二十多，所以才能最懂年轻人。 而医生呢？这么说吧，你是喜欢年轻有激情的医生，还是经验老道的中年 “老” 医生？ 程序员看似是很有技术含量的硬技能门槛，实际远不如医生这个千年来的 “古老” 职业，行业的最低技能门槛要求挡不住很多人热情地涌入，而技能成长的天花板也感觉并不高，如何能不恐慌与焦虑？ 模型有时可能我们会有一个职业理想，叫 “一技压身，天下行走”，就像一名侠客一样，学好了功夫，从此闯荡江湖，好不逍遥自在。 之前看过一本武侠玄幻小说，里面有一些角色就叫 “天下行走”，他们都有自己厉害的独门绝技，不厉害怎能天下行走。其中，剑客的剑快，野人的身体坚硬如铁，和尚从不说话修的闭口蝉，一开口就人人色变，这些就是他们独特的技能模型。 技能模型才是区分不同专业人才特点和价值的核心关键点。 而技能模型的形成是一系列选择的结果。以前玩过一个游戏叫《暗黑破坏神》，正常不作弊地玩，一个角色是很难点亮所有技能的，游戏是故意这样设计的。所以你可以反复玩来尝试点亮不同的技能组合方式，这样游戏才具备反复的可玩性。而与游戏不同的是，人生只有一次，你无法点亮所有技能，只有唯一的一种点亮路径选择塑造独一无二的你。 而这种选择，可能一开始是无意的，比如我成为一名 Java 程序员是偶然的，而你成为一名 C++ 程序员也可能是偶然的，早期的技能点亮策略有很多的偶然性。但到了后期，我们逐渐成长，有了更多的经验和选择权，这时就需要主动选择去建立自己的技能模型。 记得有一篇关于工程师思维的文章是这么说的： 工程师思维的大道，就是先创造一个好模型，然后想办法实现这个模型，工程师关心的是能不能用这个模型创造出东西来。 而技能模型其实正是工程师创造的第一个元模型，这个模型决定了后续作为工程师的你还能基于此创造怎样的模型，从而完成产品的实现。 当只拥有一些零散的技能点，而且这些技能点还会随着时间流逝而过时，我们当然会感到恐慌与焦虑；但如果能够将这些技能点组合成我们独有的技能模型，提供独特的价值，从此独步江湖，甚至开宗立派，想必也就没那么恐慌与焦虑了。 以前文章写过关于 “知识体系”的内容，那它和技能模型有什么区别？知识体系本质也是一种知识模型，但技能模型更深一个层次，因为技能是对知识的应用。知识模型构筑了理论边界，技能模型是实践的路径。 路径那么，关于技能模型这条实践路径该如何去选择和构建呢？ 程序员作为工程师的一种，必须得有一项核心硬技能，这是需要长时间积累和磨练的技能，要花大力气的，而这个大力气和长时间，也正是这门技能的门槛。关于技能的习得有一个流行的看法是：花 20% 的时间快速获得某个领域 80% 的知识和技能。这看起来像是一种学习的捷径，但一个硬技能领域最核心的竞争力往往都是最后那 20% —— 也就是你用那 80% 的功夫反复磨练出来的最后 20% 的技艺。 古龙小说中有个角色叫荆无命，他腰带右边插着一柄剑，剑柄向左，是个左撇子，江湖中都知道他左手剑快，但其实他右手剑更快。荆无命要是个程序员的话，那可能就同时具备了两个核心硬技能，属于那种 Java 很强，但 C++ 更牛的人。但我从业这些年还没碰到过同时点亮两者的，无论 Java 还是 C++，因为各自都有足够大的生态和体系，已经需要很长的时间来积累和打磨了。 我们大部分普通人，拥有的是有限的时间与才华，面对的是无限的兴趣和技能，同时修炼多个核心硬技能是不明智，甚至是不可行的。记得以前读万维钢有篇文章介绍了一本书叫《达芬奇诅咒》，文艺复兴时期的达芬奇是一位多才多艺的人，但一个人如果像达芬奇一样对什么东西都感兴趣，但又没有和达芬奇匹敌的才华，很可能尝试了很多，最终却一事无成，这就中了 “达芬奇诅咒”。 所以，构建核心技能模型其实是关于才华和技能的战略。《达芬奇诅咒》一书作者就选择技能领域推荐了三个标准： 你确实喜欢 你在这个领域有天赋 这个领域能挣到钱 我仔细回味了下这三个标准，真是很接地气，实在可行。你喜欢的领域，至少在启动进入时也容易一些，长时间的坚持时也更有毅力一些；而你有天赋的领域，信心也足一些，并且拥有相对竞争优势；能挣到钱的领域，最好还比别得领域更挣钱，那么外在的经济激励会更强，而同等努力相对收益也更大。无怪乎，一个技术热潮起来后，大家都看到了第三点，急匆匆跳进去，但往往忽视了前两点。 另一方面，多个核心硬技能之间是一种加和关系，若非迫不得已，再下同样的大功夫去修炼另一项核心硬技能显得就不是那么明智了。所以应先深度修炼“一门”核心硬技能，建立门槛，但需要深到何种程度才能天下行走？如果刚开始起步算 0， 1 算是行业平均水准，那至少先要专注在核心硬技能上，并修行到 1 以上，能进入前 20% 就更好了。 然后，就可以围绕核心硬技能适度练习和发展一些辅助技能，这些辅助技能大多属于软技能，也有部分硬技能，只是没有核心技能那么硬，通常起到放大和加强核心技能的作用，可以发挥指数效应。这也是为什么核心硬技能要先修行到 1 以上，因为指数关系只有在大于 1 时才有意义。 有些辅助软技能可以通过刻意练习来掌握，而有些则很难，属于埋藏在天生的基因和后天的成长性格中。在漫画《火影》的忍术体系中对这种天生的技能有个术语叫 “血继限界”，其中最厉害的当属 “写轮眼”。想想在职业发展的技能体系中，有什么是可媲美 “写轮眼” 的辅助软技能的？如果你幸运拥有这种 “血继限界”，可别浪费了天赋。 程序员怕什么？就怕技术潮流的颠覆直接废了全身武功。我读大学时就经历过一次，当时主流的企业应用开发是 C/S 架构的 Delphi 和 VB，如今已是明日黄花。而武功体系由内力加招式组成，技术的演进容易废了招式，却不容易废了内力。 张无忌学会九阳神功，一身内力惊人，招式现学现卖也打的少林龙爪手高僧叫屈，所以在点亮技能模型树的过程中，你得分清九阳神功和龙爪手的区别。类比于技能模型树，内力是根茎，招式如花叶，时间流逝，落花残叶，冬去春来，复又发新。 到这里，关于技能的焦虑和建立技能模型的方法，我们就探讨完了，最后总结提炼下： 程序员这行的技术门槛没想的那么高，所以就此易引发恐慌和焦虑； 建立你自己的技能模型，才能提升门槛和核心竞争力； 避开 “达芬奇诅咒”，围绕核心硬技能，发展“一主多辅”的技能模型树。 从此，种下技能模型之树，让其茁壮生长，方能一技压身，天下行走。 在程序这个江湖上，你又是靠什么在行走天下呢？欢迎你留言分享。 55 江湖路：刀剑相接，战场升级回首自己的成长之路，通常每五年就会感觉碰到一个成长的瓶颈点。在传统 IT 行业的第一个五年后，我就感觉明显进入技术成长的瓶颈期；之后也算有点运气，通过转换到互联网行业升级到了新的技术维度。 又过了五年，站在十年后的一端，回望过去，刀剑相接，如梦似幻，我渐渐感知到突破这次瓶颈的道路，就意味着走向一个升级后的新战场。 刀剑相接：杀人术天下风云出我辈，一入江湖岁月催。 你狠狠地敲下键盘的回车键，终于看见程序按预期输出了正确结果。长长吐了一口气，点上一支烟，环顾四周，独自一人，又是一个夜深人静的晚上。在一种搞定 Bug 的满足与空旷寂寥的忧伤中，你不禁迷惘。 记不清这是你修复的第多少个 Bug 了，甚至记不清这是你参与开发和维护的第几个系统了。就像一个剑客在这个江湖上行走多年，已记不清死在自己剑下的人有多少，拔剑，收剑，有人倒下，你继续行走，如今 “杀人术” 已成。 对一个程序员而言何谓 “杀人术”？你选择了一门语言开始学习编程，就像一个刚入江湖的人选了学剑或刀。再弄几本江湖宝典，假想了一个项目开始练习，熟悉基本的使用套路。然后走入江湖，拜入门派，腥风血雨，数年后剑鸣空灵，刀啸云天，飞刀无影，“杀人术” 终成。 这就是一个程序员的成长之路，你选了门武器，学了基本招式，然后进入江湖不停地在厮杀中成长。终于你能搞定各种各样的系统问题，了解不同系统的设计模式。每过数月或一年半载，你总会发现过去的代码写得不好，再重构上一遍，改进你的招式，数年后，终成江湖高手。 一个程序员修成 “杀人术” 大概需要多久？按照一万小时理论，如果你在某一领域每天持续学习和实践练习十小时，最快也要三年。但这三年是没算各种可能的中断的，比如：生病、偷懒、假期休闲娱乐等等，所以大部分人的平均时间可能需要五年。 五年成术已算理想，实际上我自身用了更长的时间，走了更多弯路。从 Basic 程序入门，后来 VB 再到 Delphi ，然后 C 最后 Java，Java 也经历了几代变迁，但还算一脉相承。技术的发展，时代的变迁会让 “杀人术” 也在不停地演化。而今剑术已成，然拔剑四顾，却发现已进入枪炮时代，不免心下茫然。 经历了一万小时的杀人术训练与实战后，技能增长曲线已经进入了对数增长的平缓期，过于单一的技术维度成为了我们的瓶颈和焦虑的源头，该如何去突破这样的瓶颈点？ 认知升维：化形爱因斯坦说过：“我们不能用制造问题时同一水平的思维来解决问题。” 技能维度的瓶颈问题，经常会让作为程序员的我们陷入一种常见的平面思维方式。比如，一个程序员做了十多年桌面客户端开发，后来移动崛起，桌面式微，就颇感焦虑，这就是他所面临的技能维度的瓶颈。而他想尝试突破的方法，可能却是转到服务器的后端开发，因为感觉这个领域还一直比较长青。 然而这只是从一个领域的核心硬技能转换到了另一个领域，但这两个领域基本是独立的，关联性很弱，而且交叉的区域也很薄，也就意味着很多经验和能力要重新积累。这就是从问题本身的维度去寻找到的解决方案，而爱因斯坦说了，我们需要到更高的维度去寻找答案。而更高的维度就是认知的维度，所以首先需要的是升维我们的认知结构。 在我修行成术的过程中出现了好多新技术，当时我总想忙完这阵就抽空去学习了解下。但一过几年也一直没能抽出空去看，如今再去看时发现好些当年的新技术已不需再看了。五年成术是立足于一点，成立身之本；而下一阶段不该是寻找更多的点，而是由点及线、由线成网、由网化形。围绕一个点去划线，由一组线结成网，最后由网化成形，“化形” 表达了一种更高级的知识和技能运用形态，比一堆离散的知识技能点有价值得多。 而对于认知升维，由点及线、由线成网、由网化形，其实走的是一种 “升维学习” 之道。这个过程几乎没有终点，是一个持续学习、不断完善的过程，最终结多大的网，成什么样的形，全看个人修为。一条线至少要两个点才能画出，那么第二个点的选择就要看能不能和第一个点连起来了，而这比在一个维度上去预测和乱踩点要有效得多。 其实这套道理在金庸设计的武学体系中也很是明显。这里就以大家最熟悉的《射雕》三部曲为例来看下。郭靖一开始师从江南七怪，后来又跟全真七子中的几位学过功夫。这在功夫里就是两个点，但没看出这两个点有何联系，最后郭靖江湖成名，终成一代高手靠的是什么？降龙十八掌。为什么有十八掌这么多，从小说里的描述表达了一个体系的意思，一个体系结网成形，最后的形态命名为降龙十八掌。 其实郭靖还学了另一个更有体系、形态更牛的武功秘籍——《九阴真经》。除了郭靖，《九阴真经》还有很多人看过、学过，有高手如：黄药师、王重阳等，也有一般人如：梅超风。高手们本身有自己的武功体系和形态，所以看了《九阴真经》也仅仅是从中领悟，融入自己的体系中甚至因此创造出新的武功形态。而梅超风之流则仅仅是学点其中的招式，如：九阴白骨爪，和之前自身所学其实没有太多关联，武功境界终究有限。 所以，升维化形，化的正是技能模型，而这套模型基本决定了你的功力高低。 再回到前面那位桌面端程序员的瓶颈问题，升一点维度看更泛的终端，桌面端不过是这棵技能模型树上的一个分枝。树并没有死，甚至更壮大了，只是自己这棵枝干瘪了些，所以可以去嫁接其他分枝获取营养，而非想要跳到另一棵树上去，重新发芽开枝。 战场升级：十面埋伏结网化形，走上升维之道，因而战场也变大了，但你的时间并没有增多，这就存在一个理论学习和战场实战的矛盾。 到底是应该更宽泛地看书学习建立理论边界，还是在实战中领悟提升？关于这点，你需要选择建立适当的平衡，走两边的极端都不合适。在学校的学习更多是在建立理论体系，而在工作前五年的成术过程则更多是偏实战。 再之后的阶段又可能需要回归偏理论，提升抽象高度，从具体的问题中跳出来，尝试去解决更高层次、更长远也更本质的问题。而从更现实的角度来看，你的环境也会制约你能参与实战的经历，导致有些东西靠实战可能永远接触不到，不去抽象地思考是无法获得和领悟的。 历史上关于理论和实战有很多争论，还留下了一些著名的成语。理论派的负面历史代表人物有：赵括。还有一个关于他的成语：纸上谈兵。他谈起军事理论来一套一套的，一上战场真打起来就葬送了数十万将士的性命，所以大家都会以赵括为例来批评没有实战经验支撑的理论靠不住。 但其实还有另一个更著名的历史人物，也是理论派出身，在真正拜将之前也没什么实战经验。并且也有关于他的成语，如：背水一战，这是他抽象地思考过很久的战法，但也是第一次上战场使用，一战而青史留名。 他就是韩信，历史上说他率军出陈仓、定三秦、擒魏、破代、灭赵、降燕、伐齐，直至垓下全歼楚军，无一败绩，天下莫敢与之相争。王侯将相韩信一人全任，一时国士无双，属于中国古代从理论到实战的谋战派代表人物。 韩信的对手项羽在历史上就是一个实战派代表人物，个人的 “杀人术” 相比韩信高出怕不止一个等级。但其实他和韩信根本不在一个维度上，韩信在最后面对项羽前，已通过众多大大小小的战斗去不断实证和完善了他的谋战理论。垓下之战项羽中十面埋伏，致其乌江自刎，更像是一场高维打低维的降维攻击。 所以，关于理论和实战的关系，从这个历史故事可以有所体会。而 “十面埋伏” 这样的技能维度显然比 “霸王举鼎” 要高出不少，而升维后的技能，也需要升级后的战场才发挥得出来。 技能的成长速度总会进入平缓阶段，并慢慢陷入瓶颈点，然后也许你就会感到焦虑；而焦虑只是一种预警，此时你还未真正陷入困境，但若忽视这样的预警，不能及时进行认知和技能升维，将有可能陷入越来越勤奋，却越来越焦虑的状态，结果走入 “三穷之地”（包括如下三种“穷”）： 结果穷：技能增长的边际收益递减； 方法穷：黔驴技穷，维度过于单一； 时间穷：年龄增长后你能用来成长的时间会变少，分心的事务更多，而且专注力会下降。 认知和技能升维带来新的成长收益，同时防止了单一维度的死胡同，而年长的优势正在于经验带来的理解力和思考力的提升。 最后，总结下今天的分享内容，在程序江湖上，从刀剑相接到战场升级走的是这样一条升维路： 刀剑相接的战场，我们靠 “杀人术” 也即硬技能求生存，但时间久了就会有瓶颈； 技能升维，需要认知结构先升维，“我们不能用制造问题时同一水平的思维来解决问题”； 升维后的技能，也需要一个升级后的新战场，走上理论结合实践的 “谋战” 之路。 在我的寻路过程中，我找到的就是这样一条技能升维之道，那你呢？ 56 御剑流：一击必杀，万剑归心在前文《江湖路》中我找到的路是一条 “战场升级，技能升维” 之路，技能与战场的升维演化是一个相辅相成的过程。进入了升级后的战场，也需要升维后的技能模型，那我们该如何从旧有的技能模型进行升维演化呢？ 我想还是用一些形象点的武功招式来类比说明。 拔刀斩拔，提手旁，喻义需要亲自拔刀动手。 而拔刀术源自日本古武道，其核心思想便是一击必杀，利用瞬间高速的拔刀攻击对敌人造成出其不意的打击。其讲究的是快，也即速度和锋利度。 武士不断修行拔刀术，力求一击杀敌，而程序员学习和练习编程的过程也是类似的。最终，你的编程技能到达了一个什么样的程度，就是看它的锋利度，即面临一个个程序问题能否一刀见血，一击必杀。 刚入门的程序员上线发布碰到了一个问题，抓耳挠腮，冥思苦想，加班加点终不得解。于是跑来向你这个高级程序员请教，此时时钟指向了凌晨一点。你放下手中刚泡好正准备吃的方便面，一支燃烧着的半截烟头挂在你的指尖。你犹豫了一下：是猛抽两口还是灭掉烟头去处理这个紧急问题？ 最终，你终究不舍地把半截烟头小心地放在方便面盒边沿，再用塑料的方便面叉把面盖和烟头一起固定住。然后，你挽起了袖子走到这个年轻程序员的电脑前，迅速扫了几眼报错的错误日志，再调出你心爱的 vi 编辑器，噼里啪啦地改动了几行代码，保存，关闭，再重新构建，发布。电脑黑底白字的界面不停地滚动着，你已站起身向散发着两种味道的方便面走去，并回头轻轻对年轻程序员说了声：可以了。 这就是你向年轻程序员展示你的拔刀术，问题一斩而绝。好吧，这是一种诡异的优雅，似乎任何问题对于电影里的程序员而言，在电脑前噼里啪啦敲上几行代码都能解决。但现实中大部分时候都比看上去要更困难一些，真实世界的拔刀术和动漫《浪客剑心》里剑心的 “天翔龙闪” 相比，终归显得笨拙了许多。 而拔刀术正是我们第一阶段的技能模型，在我们追求 “天翔龙闪” 的境界时，看上去并不遥远，但越走到后面，却越来越慢了，似乎永远也到不了，这就是已经进入了第一阶技能的瓶颈区间了。 在瓶颈区中，进境缓慢近乎停滞，就可以尝试下技能升维 —— 从 “拔刀” 到 “御剑” —— 看能否在新的战场找到突破点。 御剑术御，双人旁，喻义贴身教授与把控。 御剑术，这个招数的类比来自好多年前（我那会还读初中吧）玩过的一个电脑游戏——《仙剑奇侠传》，我记得这也是游戏里主角在第二阶段学会的技能。如果过去面临问题你需要拔刀解决，那这里的 “刀” 就是你的知识、技能和经验。那御剑术里的 “剑” 又是什么？ 记得以前读过一篇关于高级程序员的文章，其中提出了一个组合三角的观点，先看下面这张图： img 程序员成长阶段要求的帮助和提供的指导变化趋势示意图 图中蓝色三角区域表明，随着你从入门初级成长到高级程序员的过程中，需要得到的帮助和指导越来越少；而红色三角区域表明，你能提供的帮助和指导应该越来越多。所在，在前面那个想象的 “泡面拔刀” 的场景中，作为高级程序员的你，更理想的做法应该是去指导年轻程序员如何解决问题的思路，而不是自己拔刀，唰唰两下搞定。 对，很多高级程序员都会以 “等把他教会，我自己早都搞定了” 为由，忍不住自己拔刀。理解、掌握并应用好一种知识和技巧是你的 “拔刀术”，但分享传递并教授指导这种知识和技巧才是 “御剑术”，而 “剑” 就是你面前更年轻、更初级的程序员。 曾经多少次面对年轻初级程序员交付的结果，我都有一种懊恼的心情，怀疑当初是不是该自己拔刀？那时就突然理解了驾校老司机为何总是满腔怒火地吼着：“让你松点离合，只松一点儿就好…”，而当初的我刚学开车时，一开始不是松少了，就是熄火了。 从 “拔刀术” 到 “御剑术”，其技能模型的招式和对象变化了，但本质框架却是类同的，这里的关键点是：如何剥离自我，通过他人来完成设计和实现，并达成解决问题的目标。 万剑诀诀，言字旁，喻义以言引导，影响多于控制。 所有的程序员都是从修行 “拔刀术” 开始，但只有极少数人最终走到了剑心 “天翔龙闪” 的境界，所有未能突破的我们都进入了瓶颈停滞区。我们不断学习和练习，终于练到拔刀由心，收发自如，终成习惯，但要将这个技能升维，跨越战场，却正是需要打破这个习惯。 其中，从 “拔刀术” 到 “御剑术” 是习惯的打破；从 “御剑术” 到 “万剑诀” 则是量级的变化。因而，“御剑术” 是修行 “万剑诀” 的必经之路。嗯，游戏里也是这么设定的。 “万剑诀” 正如其名，御万剑而破敌。回到现实中，这是一项高杠杆率的技能。而高杠杆率的活动包括： 一个人可以同时影响很多人。 一个人可以对别人产生长远的影响。 一个人所提供的知识和技能，会对一群人的工作造成影响。 这就是 “万剑诀” 的核心要诀。应用到程序员修行之路上：如果走上同时影响多人的路线，这就是一条团队管理和领导者之路；如果走上影响长远的路线，你可能乐于分享、传授，这可能是一条布道师的路线；如果你通过提供知识和技能来影响其他一群人的工作，那么这可能是一条架构师的路线。 “万剑诀” 和 “御剑术” 的共通之处在于都以人为剑，观察、揣摩每把剑的特性，先养剑再御剑最后以诀引之。若 “拔刀术” 是自己实现的能力，那 “御剑术” 和 “万剑诀” 都是借助他人使之实现的自信和能力，只是后者相比而言规模更大，杠杆率更高。“万剑诀” 的重心在追求问题解决的覆盖面，而面临每个具体问题时就需要依赖每把剑的锋利度了。 另外，“御”之一字更着重了一层控制的含义，而 “诀” 之一字在于影响多于操控，这里面的关键点就是：剑本身的成熟度。不够成熟的剑只能 “御” 之，足够成熟的剑方能 “诀” 之。 走上 “万剑诀” 之路后，还能再领悟 “天翔龙闪” 的奥义么？也许这是时代演进让我们不得不做出的选择，今天的程序江湖掌握了 “天翔龙闪” 奥义的 “神” 级程序员已经越来越成为一个传说，数十年前，那个英雄辈出的年代已不复再现。 拔刀术，是亲自动手斩杀问题，难处在于维度单一，后期进境陷入瓶颈停滞；御剑术，是指导他人解决问题，难处在于打破习惯，剥离自我；万剑诀，是借助他人使之实现，难处在于剑的养成。 它们的共通之处，都是基于长期的编程和工程训练，建立的系统化思维能力，创造模型来解决问题，而变化在于模型的适用对象不同，导致需要不停地调试合适的 “模型参数” 来适配问题，并且不论是技术框架还是人的 “模型参数” 都是在变化之中的。 最后，在你的技术升维演进转型路线上，你对这类变化的感受和认知是怎样的？欢迎留言分享。 57 三维度：专业、展现与连接曾经在和朋友探讨个人发展的问题时，讨论出一个 PPC 理论，该理论粗略地把涉及个人发展的方向分成了三个维度，包括： 专业 Profession 展现 Presentation 连接 Connection 而像程序员这样的专业技术人员，都倾向于在专业维度不断发展提升，却往往忽略了另外两个维度。如果三个维度综合发展的话，可能会得到 1 + 1 + 1 &gt;&gt; 3 的效果，即三个维度相加远远大于 3 的效果。 一、专业 Profession什么才算是 “专业”？其实没有一个标准定义，我尝试将其进一步分解为三个子维度。 专业能力专业能力，包含了知识和技能。以程序员为例，具备专业能力的软件工程师应该拥有系统的知识体系和相应技能。 那么程序员的系统知识体系和技能又包括哪些？曾经在知乎看到过一个抽象的类比，它用我们在学校学习的各种学科体系来类比程序员的专业知识体系和技能，我结合自己的理解也做了一些延伸，包括下面这些方面： 数学：这个不算类比，因为数学就是计算机科学的基础； 物理：程序世界中的基本定律，如 CAP、NP、算法与数据结构； 化学：程序世界中的 “元素” 和属性，如编程语言平台、各类框架和系统特性。 在程序世界里，学好 “数理化” 基本也算走遍天下都不怕了，到哪都能找个工作，但这还不够。“数理化” 属于硬知识与技能，实际工作中还需要软知识与技能。而软知识与技能又包括如下内容： 语文：除了能写代码，还得能写好文档，起得好名字，表达好逻辑，让代码更可读、可懂； 英语：高级编程语言几乎都是英语的子集，第一手的技术材料多来自英语世界； 生物：不同的技术都发展出了不同的生态体系，今天的系统几乎都在某种生态之中； 历史：任何一门新技术，都有其历史渊源，它从哪里来，将会到哪里去； 艺术：编程是一门艺术，一种逻辑与审美的表达； 经济：成本、收益、效率，有关技术决策的核心； 建筑：有关架构的一切，钢筋、水泥、脚手架、灾备、抗压、防单点以及相关的权衡。 当把这些学科的知识和技能都掌握得七七八八了，那么才算具备了专业能力。 专业行为专业行为，包括规范化的工作流程和作风，严格的职业纪律与操守。 这些专业的行为，最终会内化成一个人的习惯，敏捷专家肯特·贝克（Kent Beck）说过一句话：“我不是个优秀的程序员，我只是一个有着优秀习惯的普通程序员。” 所谓 “优秀习惯”，就是专业行为的一个重要体现。 专业能力加上专业行为，会让你从周围的合作者那里得到一个做事很专业的评价。 专业产出专业产出，指最终产出的结果是稳定的，可预测的，处在一定品质标准差范围内的。 这一点可以用小说家类比。比如，金庸写了 15 本武侠小说，从第一本到最后一本的产出质量都在一定的水平之上，他的最低标准也高于绝大多数人，品质标准稳定可靠。而同时代的古龙，就不是这样的，早期古龙的小说良莠不齐，品质标准的波动范围很大；其中的分水岭是《绝代双骄》，之后的小说才开始逐渐稳定在一个很高的品质标准之上了。 所以，一个专业的程序员，交付的程序应该像金庸和后期的古龙那样，在一个可预测且稳定的品质标准之上波动。 所有技能维度的成长都是一条对数增长曲线，迟早会进入上升的平缓区，在这个区间 “投入增长比” 不高，这时就可以适当发展下后面两个维度，将会是不错的选择。 二、展现 Presentation展现建立于专业的基础之上，所以展现也对应着专业的三个子维度。 展现专业能力：包括代码、架构、认知、决策； 展现专业行为：包括沟通、交流、表达、协作； 展现专业产出：包括作品、方案、洞察、演示。 对应这些展现的需求，有不同的展现形式，无外乎下面这些。 代码：Github 等开源站提供了最直接的围绕专业能力中编程能力的所有展现形式、证据和历史； 交流：在日常的即时通讯、邮件、会议、交谈与协作中，展现了关于专业行为的一切； 演讲：有关专业产出的重要形式，如汇报（业绩产出）、分享（作品与影响力产出）； 写作：文字作品，一种长尾影响力的产出形式。 在大部分情况下，你的专业价值评估都是由你的展现水平来决定的。 三、连接 Connection我把社交连接分成了 5 个圈层，一般每个人都会具备前两个圈层，而只有在展现的基础之上，才有扩大连接到后面三个圈层的可能性。 10人生的每一个阶段，都会有一些最要好的朋友，也就是好朋友，这是我们社交关系中最强的连接了。 一般这个数字都低于 10，而我自己的经历是，每一个阶段其实都没有超过 5 个。从小学、中学、大学、工作，包括从一个城市到另一个城市的不同阶段，各个阶段都有一些关系很好的朋友，但每经历过了一个阶段，这些好朋友就会发生变化。 很少有人，小学时候的好朋友，到了如今还是好朋友的，人生的变化实在太难预测。而这种好朋友的亲密关系，在每个阶段对你都是最有意义和价值的，会让你感到生活的快乐与幸福。 因而，50% 以上的社交时间都值得花在每个阶段最好的这 5 个朋友身上。 100有一个神奇的数字叫 “邓巴数”，它来自神经科学领域，研究认为： 人的大脑新皮层大小有限，提供的认知能力只能使一个人维持与大约 150 人的稳定人际关系，这一数字是人们拥有的，与自己有私人关系的朋友数量。也就是说，人们可能拥有 150 名好友，甚至更多社交网站的 “好友”，但只能维持与现实生活中大约 150 个人的 “内部圈子”。而 “内部圈子” 好友在此理论中指一年至少联系一次的人。 按这个定义，我自己的感受是很难维持这么多联系，因为社交负担太大了。当然如果把上文中的 “联系” 理解成朋友圈点个赞也算的话，勉强也能达到吧。实际上，好多曾经阶段属于好朋友的人，过了那一个阶段，比如考上大学，大学毕业后各奔东西，慢慢也就进入了这个圈层。一开始还常联系，慢慢联系会越来越少，最后只在重要节假日（如春节）发个短信或红包了。 曾经熟悉的同学、同事们，大部分都在这个圈层中，除此，也会有一些当下新认识的熟人。总之，这个圈层中都是一些你们彼此还算认识，并且在一定程度上也彼此认同对方一部分价值的人。 以上就是几乎所有人都有的社交连接圈层。再往后的三个圈层，就只有极少数人拥有了。 10002008 年，著名科技作家凯文·凯利写了一篇文章《一千个铁杆粉丝》（1000 true fans），这里的 1000 连接圈层就是这么来的。不过这有个前提，就是你必须是一个创作者，而凯文·凯利的观点是： 任何从事创作或艺术工作的人，例如：艺术家、音乐家、摄影师、工匠、演员、动画师、设计师或作者等，只要能获得一千位忠实粉丝就能维持生活。 他大概是这么计算的，通过出售创作作品每年从每个铁杆粉丝上获取 100 美元的收入，那么每年大概有 10 万美元的收入，就足够生活了。今天，获得 1000 个粉丝不算太难，但在前面加上铁杆，就太难了。所谓铁杆，就是不论你创作的是什么，他们都愿意支付买单。 而我理解 1000 个铁杆也不必是固定的同一批人，可能是流水变化的 1000 人，他们只是每年为你不同的作品支付买单而已，但前提就是你得有持续的创作能力。 10000这个层次是拥有一万个关注者（如：微博）或订阅者（如：微信公众号）。 这个量级才算是拥有了培育自己观点和内容种子的一块自留地，在这块土地上你可以播下你的观点，可能有人支持，也有人反对，更多人是不置可否，但至少你可以开始拥有了反馈。但若没有这块自留地，你的声音或观点几乎不会在互联网上收到什么反馈，也无法形成有效的讨论和互动。 100000+自从有了微信公众号，100000+ 现在也是一个神奇的数字了；100000+ 的存在，体现了一个信息、观点与影响力的传递网络。 五种连接圈层，第一层次 “10” 的连接是强连接；其他的都是弱连接，弱连接的价值在于获取、传递与交换信息。强连接交流情感，弱连接共享信息。 而建立连接的关键在于：给予。也许并不需要物质上的给予，仅仅是心理上或是虚拟的给予。所以说为什么展现是扩大连接的基础，展现即创作表达，创作即给予。另外，建立连接得先提供价值，而且还得源源不断。 关于 PPC 个人发展理论的分享就到这里了，我们总结一下： 专业，建立价值内核； 展现，提供价值输出； 连接，完成价值交换。 专业是价值，展现是支点，连接是杠杆。 最后，补充说明下：虽然本文指出了三个维度，但实际这三个维度并不是均衡发展的，每个人都需要根据自己的具体特点和主观意愿去做选择平衡。其实，任何一个维度发展到极致，都会有巨大的价值，但极致，何其难矣。 关于这三个维度的发展，你有怎样的观点呢？欢迎留言分享。 58 三人行：前辈、平辈与后辈成长的路上，有时会陷入停顿，感到迷茫，就像前行的一辆车陷在了泥地里，不管你怎么加油踩油门，它只是在原地打转而无法继续前行。这时，你就需要有人来帮助，或推或拉或扶。而从广义的角度看，总会有三类人在身边，你未必是独行。 孔子说：“三人行，必有我师”。原意中的“三”是虚数，泛指多人，意思是身边的任何人都可以成为你的老师，拥有值得你学习的地方。成长的路，本是一条越走人越少的路，但若有伙伴同行，你会走得更远，走得更久。 这就是成长路上的三人行，此时的“三”不再是虚数，而是指代身边的三类人，它们是： 前辈 同辈 后辈 这三类人代表了不同的成长路径和成长阶段。你应该有一个动态的列表，在成长的不同阶段将这三类人中的典型代表放在这个列表中仔细观察。 如果放在职场上，前辈可能就是你的上级，是比你更资深和有经验的人，是走在你前面的人；同辈自是你的同事，你们在不同的领域各有所长，甚至在同一领域做得比你还好，但不管怎样肯定是让你尊敬的人；而后辈可能是你的下属，他们也许正在走你曾经走过的路，可能正在做你一年、两年或三年前做过的事，而且可能做得比当时的你更好。 如果你在身边都找到了这三类人的典型代表，你观察他们，便是以他们为尺来度量自己；你学习他们，便是以他们为模来塑造自己；你加入他们，便是从后辈的重复中去反思过去，从同辈的领域中去扩展当下，从前辈的脚印中去引领未来。 前辈前辈，是那些走在你前面的人，他们不止一个，且每个人都会有不同的路径。观察他们的路径，哪个更适合自己，哪个人的哪些方面让你更想要去模仿。在职场上，这些人似乎都有差不多的等级，但实际上每个人都有不同的特点和路径。 在不同的阶段，会有不同的前辈。而最适合作为前辈代表的人，应该在你前方不远处，因为这样的观察、模仿和借鉴才更有意义。毕竟走在你前方太远的人，他们的行为方式和路径你都很难看得清晰，而且很可能你们的工作活动已经处在不同的维度了，这阶段的你还理解不了。比如，刚入门的新手，适合观察和借鉴的前辈应该是比较熟练的中级工程师，而不是架构师。 程序员有时爱自比农民，自称 “码农”，因为程序员每天写代码的工作，就像农民种地。一个初出茅庐的程序员，不断地通过提升技能、吸收经验和改进工具来提升产量。从一开始的手工作业，到利用耕牛（新的技能和工具），再到现代化的机器工程作业（进一步改进的技能和工具），所负责的田地亩产量越来越高，每天能耕耘的土地面积也越来越大。直到有一天，技能提高和工具改进接近了极限，耕种的土地面积和单位产量增长都渐渐停滞。 之前的这个改进过程都是一个自然连续的成长过程，而当你进入极限区增长停滞后，再给你更大的土地，要求更高的产量时，这个连续的增长过程就被打断了，你会看到虽有前辈在前方，但中间的路却断了。 在这个断点之前，前辈的价值在于：他们走过的路，你不用再去摸索，只需快速顺着走下去。这个过程中你只需要刻意地玩命练习去解决自然连续的快速成长问题，而在断点之后，前辈在没路的地方留下的 “脚印” 也解决了非连续性的跨越问题。 十多年前，我以为程序员的成长终点是架构师，后来我知道了，程序员的自然连续成长终点是资深程序员，也许还有 “神” 级程序员。但架构师却是从某个点开始断裂分叉的另一条路，从程序员到架构师，就需要跨越非连续性断点，而转型到技术管理者也会面临同样的非连续性断点。 跨越非连续性的断点转变意味着什么？有一部电影叫《爆裂鼓手》，电影中有两个角色，一个鼓手，一个指挥。鼓手类似程序员，指挥则像架构师。成为顶级鼓手的路是玩命练习打鼓，成为指挥的路则是放下鼓槌，拿起指挥棒，协调各种乐器的演奏。 放下了乐器，未必是放弃了音乐，电影中的指挥，任何时候乐队中的任何一个乐器吹（拉、弹、打）错了一个音，他都能立刻分辨出来。这就是另外一条路的另一套技能，是为了得到更大规模的生产力和更震撼的演奏效果（品质）。 除此之外，前辈的另一个价值在于塑造环境，而环境决定了整体的平均水平线，在这个环境中的个体很少有能大幅偏离的。 就以我的中学环境为例，当年我进入这所少数民族中学时，那一届高考最好的学生是考上了中央民族大学。六年后，到我参加高考时，学校师生都在为实现清华北大的零突破努力，虽然依然没能实现，但这届学生的最高水平已经可以考上除清华北大之外的任何大学了。 在我所在中学的这个环境中，每一届高考学生都是下一届的前辈；每一年这些 “前辈” 们都在把学校的高考水平线抬高一点点，在前进道路的尽头继续探索走出长一点点的路来，而到我的下一届终于实现了零突破。 所以说在一个既定环境中，有强悍的前辈是我们的好运气。 同辈同辈，本是那些与你并行前进的人。 同辈，特别是临近的同辈间普遍存在竞争，这也是所谓的 “同辈压力” 的来源。而很多时候我们的进步就是被这种压力逼出来的，这样压力转化为动力，同辈就成为了动力源。 还是以中学这个环境为例，同届的同学之间就是一种同辈关系，而且有相当的竞争压力，都在竞争大学的录取名额。在参与考试竞争这件事上，我可以做到期末或模拟考试班级第一或者年级第一，但高考的竞争其实是在全省范围的同届学生之间展开的，每次模拟考试下来发现离最高分还差很远，我就产生了一个困惑：为什么会觉得无论如何我也不可能达到那个最高分？ 如今我自然明白了，我当时做不到是因为在学习和考试这个领域，我没有一个参考视角获知最高分的同学是如何学习的，而且这样的同学所在的学校环境，其整体水平线要远高于我所在的学校。因而，我想如果当时能有一个环境，让我和这样的同学产生交流和共同学习，那么必然我也可以得到提高。 中学是一个相对单一维度的领域，同辈同学间都是在忙于学习和考试；而到了职业和工作领域后，维度就丰富了很多，每一个同辈都可以拥有自己独特的领域，他们之间得以互相观察，并能相互沟通、交流与合作。 那什么是领域？这听起来有点像是一个玄幻小说的术语，在一些玄幻小说中，拥有领域的人物都是超厉害的，在他们的领域中，都是近乎无敌的存在。领域，是一个你自己的世界，在这个世界中，你不断地提出问题并找到有趣或有效的解决方案。进入这个世界的人，碰到的任何问题，你都解决过或有解决方案，慢慢地人们就会认识到你在这个世界拥有某种领域，并识别出你的领域。然而，计算机专业毕业的程序员们，人人都拥有专业，但工作十年后，不是人人都能拥有领域。 所以，在你前行的路上，碰到一个拥有领域的同行者，是一种幸运。所谓术业有专攻，每一个拥有领域的人，都有值得敬佩的地方，因为这都需要付出艰辛的努力。 每个人都能拥有一个自己的领域，在自己的领域内去耕耘、创造、提升，纵向提升这个领域的深度，横向扩张领域的维度，当和其他人的领域发生交集时，取长补短，也许还会产生意外的收获。 同辈，除了竞争，也有碰撞与交流，它会成为你的催化剂。 后辈后辈，他们正沿着你走过的路直面而来。 好些年前，工作没几年，带了两个刚毕业的学生。我把我的自留地分了一点让他们种，每隔两天我就去看看他们种的怎么样？每次看完，我都忍不住想去自己再犁一遍。后来我还是没忍住，最后又自己种了一遍。如今回想起来，虽然保障了当时的产能，却牺牲了人的成长速度。 人，似乎不犯一些错，就成长不了，也许这就是成长的成本。 如今，我再回头看这样的路径和例子，就会以成长思维去考虑，而不仅仅是产能视角。为了获得长期的产能效率，有时不得不承担一些短期的成本压力。而后辈们，既可能重复犯下曾经的错误，也可能走出更好的路径。通过观察他们的来路，我反省到了过去的错误，也看到了更好的路径。 回望后辈直面而来，假如再来一遍，我能做得更好吗？我们无法改变过去的事实，但可以从思想上修正过去，以更好地作用于现在和未来。 成长路上三人行，有前辈、同辈和后辈。前辈塑造环境，开辟道路，留下脚印；同辈之间有竞争，也有交流与合作，既带来压力，也激发动力，催化能力；后辈带来反思，也提供支持。 前辈探路开拓，同辈携手并行，后辈参考借鉴。 在成长的路上，你需要找到当前阶段的三类人，也许就会感觉这条路走起来也就没那么迷茫和孤单了，你觉得呢？ 59 三角色：程序员、技术主管与架构师还记得[开篇词]中我画了一个程序员的成长路径图，其中在图的左侧部分展示了程序员成长路径上一些主要阶段的定义，在我们从初级走向资深的过程中，会面临一条支路，在这条路上不仅普遍称呼的名称不同了，工作内容可能也发生了变化，角色的转换会带来不少的困惑。 这条路就是从 “程序员” 到 “技术主管” 再到 “架构师” 的路径，下面我们就来看看这条路径上的三个角色有何不同？ 程序员与寻路当我刚进入软件行业成为一名程序员时，我的理想就是成为一名架构师。 “架构师”这个词的英文叫 Architect，原意是建筑师，因为软件行业参照借鉴了很多建筑行业的概念，所以就借用这个词。我是在学校读书时知道“架构师”这个名词的，当时很多软件方面的书都是翻译过来的，也不知道是谁最早把 Architect 翻译成了“架构师”的。总之从那时起，“架构师”这个名词对于我这个刚准备走出校门的学生来说就特别高大遥远，自然当成了最初的一个职业目标。 但遗憾的是在我从业前几年的好几家公司，都没有架构师这个职位，直到后来进入了互联网公司。到了京东后，不仅有架构师职位，还有架构师团队；在这里，不仅有了方向，还可以放心地作为一名程序员发力狂奔：不停地写程序，优化代码，追求更优、更简洁的代码，重构了一遍又一遍，解决了一个又一个问题。 在前面的文章中，我将程序员具体和代码相关的工作比作剑术，修炼代码技能类似练剑的过程。很多程序员梦想着有一天能成为一代高手，面对敌人，抽刀拔剑，刹那间交击，归剑入鞘，敌人倒下。就像线上系统突然出现大问题，你打开电脑，看了几眼日志，敲下几行代码，系统分分钟恢复。 一个好的程序员当然要能写得一手好代码。在工作前十年中，我每天的主要工作内容就是编程写新代码，重构旧代码，直到有一天发现这样不断继续下去，我的“剑术”已精进迟滞，进境有限。而当时所在的系统开始向大规模分布式化方向发展，更大的价值已不再是代码实现层面上的局部优化。 那时我开始在团队承担起整体的系统设计工作，此时若再专注于局部代码优化其实是在驱动细节而非本质了。作为资深程序员出身的架构师，单兵作战能力都是极强的，就像《进击的巨人》中的利威尔兵长，具备单挑巨人的能力。可当面对成群结队的巨人来袭时，个人单挑能力的作用始终有限。 这时，从程序员到架构师不仅仅是一个名称的变化，它也意味着技能和视角的转变。在地上飞奔了七八年的程序员，在面对成群的巨人袭来时，深深地感觉到，杀光巨人不应是目的，真正的目的应是到达彼岸。所以，选择合适的路径，坚定地前行，清除或绕过挡道的巨人，到达目的地。 是的，我是到了资深程序员阶段直接转向了架构师。而在路径图上还有另一条路，会经历另一个角色：技术主管，这是一个从程序员到架构师阶段的过渡角色。 技术主管与过渡技术主管，有些公司可能又叫 “技术经理”，英文一般是“Tech Leader”或简称“TL”。 技术主管是开发团队中的某位程序员需要对整个开发团队负责时所承担的角色。既要对最终交付的软件系统负责，另外也会像一个程序员一样去开发实现系统。一般一个技术主管约 70% 的时间可能花在了开发任务分解分配、开发实践、代码审核和风险识别上，而余下 30% 的时间则花在为了保障系统按时交付所需要的各种计划、协作、沟通和管理上。 在拉姆·查兰 (Ram Charan) 写的《领导梯队》一书中提到：一个人的工作角色中至少有百分之五十以上的时间是花费在管理事务上，那么他的角色才算是一个经理（Manager）。所以技术主管（经理）更多还是偏重于技术工作，有点类似产品经理属于以经理命名却非真正的经理角色。 例如：在一个开发团队中经常会碰到技术方案和实现细节方面的分歧，如果程序员无法自主友好地完成对不同技术意见的统一，这时候技术主管就需要介入去了解两种不同意见所造成的冲突，对事不对人地去把问题搞清楚，分析各自方案的利弊，必要的时候甚至能够提出第三种更好的技术方案，以帮助开发团队达成共识。 另一方面，技术主管即使在日常的开发实现中，重点的内容一般也不是放在某个具体的功能实现上。在完成了具体的开发任务评估、分解并分配后，技术主管应该负责设计整体代码的结构和规范，必要时引入能提高整个团队生产力的新工具，推广代码模板，总结最佳实践。并且技术主管需要经常性地关注整个团队完成一项研发任务的水平和实际要求的水平之间的差距问题，让团队不仅满足及时的软件系统交付，同时又得到成长。 现实中，一个开发团队中最优秀的程序员容易被指定承担技术主管的角色，但优秀的程序员又很容易陷入到实现功能的细节中，满足于完美的实现，优雅简洁的代码。但实际上，这样优秀的程序员转入技术主管这个角色后，就很容易尝试控制设计和代码的实现，他们很难接受代码不按照他们希望的方式去编写，这个是他们作为优秀程序员一直以来的工作习惯，长此以往他们自身很容易变成整个开发团队的瓶颈，而团队里的其他成员也未能得到足够的锻炼和成长。 所以技术主管实际相比团队里的其他程序员对系统的视角更开阔，以更有策略和长远的方式来考虑问题。他们即使拥有比团队里所有其他程序员更高超的开发实现技能，对所有开发任务拥有最强大的实现自信，也需要转变为另一种 “借助他人使之实现” 的能力和自信，因为技术主管是一个承担更广泛责任的角色，必然导致能够专注有效编码的时间会相比以前减少很多，而这一点正是优秀程序员转变为技术主管所面临的最大挑战之一。 最适合技术主管角色人，不一定是团队中编程能力最好的人，但必然是团队中编程、沟通和协作能力最综合平衡的人。而技术主管之所以是一个过渡，就在于继续往前走，如果偏向 “主管” 就会成为真正的管理者（经理），如果偏向 “技术” 就会走向架构师。 架构师与取舍架构师是一个在业界拥有知名的称谓，但在绝大部分公司却不属于一个职位序列，许多公司都很纠结于如何定义架构师的角色，以及架构师所做的工作。 以前听阿里的同学说 P7 属于架构师职位，不过最近在看另一个阿里同学写的文章提及：前几年是有专职的“架构师”职位的，现在已经回归到 “工程师”“技术专家”“研究员” 这样的纯技术职位。可见在一线互联网公司关于架构师的定义也是很模糊的。 [前面]我曾引用过一篇文章《在首席架构师眼里，架构的本质是…》中提到的架构师能力模型图，我结合自己的经验和理解，稍微扩展解释了一下，如下： img 架构师能力模型 正因为业界和公司对架构师这个角色的职责定义很模糊，所以很多经验积累到一定程度的优秀程序员，并且在公司内被提升到一定高度的技术级别后，都会冠以 “架构师” 之名。但实际情况是大部分刚刚冠以“架构师”之名的优秀程序员，其能力模型大部分还停留在上图中的蓝色区域，而对其他区域并未有过系统性的认知和训练。 看过了架构师的能力模型，我们再来试着分析下其对应的职责。技术主管的角色与架构师这一角色会产生一些职责上的重叠，事实上我认为在团队规模比较小的时候（十来人的规模），架构师和技术主管的职责几乎完全重叠，甚至技术主管还会代理一些团队主管的角色。 随着软件系统复杂度和规模的提升，团队也相应变大，那么一个架构师此时所处的职责位置就开始和技术主管区别开来。如果把技术主管想成是站在楼顶看整个系统，那么架构师此时就是需要飞到天上去看整个系统了。 开发功能，解决 Bug，优化代码，这是一个高级或资深程序员的拿手技能，也是地面作战的基本技能。而一个架构师还需要掌握空中的技能，也许就像《进击的巨人》中的立体机动装置，让其能在需要时飞在空中看清全局，也能落地发起凌厉一击。 那多了一个空中的维度，过去在地面练到精熟的剑术，飞在空中还有效么？这就需要时间去学习，适应新维度的技巧。这不是一个容易掌握的技能，这也正是前面我写过的从一个点到另一个点连成线的技能升级，需要一个升维的学习过程。 架构师站在更高的空中维度去做关于软件系统的抽象和封装。如果技术主管的抽象和封装层次更多考虑的是语言函数、设计模式、代码结构等这一类的事务，那么架构师是站在整体软件系统高度，考虑不同子系统之间的交互关系、技术的合理性、需求的完整性、未来的演进性，以及技术体系发展与组织、产品商业诉求的匹配度。 这是相对技术主管更高维度的全局视角，另一方面依然有很多技术主管可能感觉没把握的技术决策和技术争端需要架构师的介入协调。之所以要找架构师来对一些技术争端和方案进行决策判断，很多情况在于程序员对架构师在技术领域内专业力和影响力的信任，而建立这种专业力和影响力是实际构建架构师非权威领导力的来源。 何谓 “非权威领导力”？非权威自是相对权威而言，管理者的权威领导力来自于公司正式任命的职位和职权，而架构师在大部分公司基本连职位职责都没定义清楚，更没有职权一说，所以实际上就不会有任何权威领导力。所以，架构师要发挥更大的作用和价值就需要去构建自己的非权威领导力，而这需要长期的专业力和影响力积累。 除此之外，架构师还承担着在技术团队和非技术团队（例如：产品设计等团队）之间的接口作用，明确产品的边界，勾勒技术蓝图，协调不同技能的技术团队协作，完成最终的软件系统交付。这时架构师的角色就像服务化架构中的 API，定义了协作规范、交互协议和方式，但并不会聚焦在具体的实现上。 在更大规模的系统上，架构师似乎还要去涉猎更多的跨领域知识，否则很可能无法做出最适合的技术决策。但人终究是有局限的，你不可能学完所有的领域，所以特定的领域又会涌现一些垂直领域的架构师。比如：数据架构师、网络架构师、业务架构师、安全架构师。因而某一个领域背景出身的架构师，对其他领域也只能做个初步了解，当需要做出关于涉及其他领域的架构决策时，就需要和其他领域的垂直架构师做深度的沟通交流，以辅助决策判断。 一旦选择走入架构师这条路，基本你就从一名出色的程序员这个领域走出，需要尽快去补充上面能力模型中指出的其他能力。这一点会让刚刚走上这条路的程序员很不适应，因为承担了更多其他职责，就必然会减少在编码实现的时间，慢慢就会怀疑自己的编码能力会退化，也跟不上一线最新的技术栈、各种酷酷的新工具。 舍得，舍得，没有舍就没有得。成为架构师会拥有一个更立体的知识、技能矩阵，这是你的得，获得了一个面，在某些点上必然面临被超越的结局。工作在一个面上，一个有经验的架构师应该能够很好地表达某些技术指导原则，借助他人使之实现，并且了解和把握什么时候该插手，什么时候该放手。 这就是架构师从技术 “实现力” 到 “掌控力” 再到 “决策力” 的能力变迁。 从程序员，到技术主管，再到架构师，名称变化了，角色的困惑我们也分析了，最后总结下这三种角色的工作内容和职责，如下表： img 程序员、技术主管和架构师的职责表 每种角色有不同的技术和组织职责，只是在每种职责分配的时间比例不太一样。看完上表的职责范围，是不是感觉有时安安静静地做个程序员，要心净多了。 如今的你，正走在哪条路上呢？ 60 三视角：定位、自省与多维记得以前阅读时碰到过一个观点，是关于 “视角” 的，其中说道：“视角的选择，对解题的难易，关系重大”。而关于成长，放到程序模型中来类比，就是一道图论题，我们求解的是适合自己的最优路径。 面对这道成长路径的难题，我们可以从哪些视角来求解？我自己找到了下面三个视角。 定位定位，是一个时间视角，回顾初心，定位未来。 还记得当初为什么选择程序员这个职业么？如今程序员所在的行业处于发展上升期，薪酬待遇整体高于传统行业，所以各类程序员培训机构如雨后春笋涌现，流水线般地为各类只差程序员的公司批量供应，这样的批量生产似乎有点把程序员当成了工厂的工人。 而程序员的工作实际更贴近于工匠，既有创造性的工艺性工作，也有模式化的工程性工作。想清楚自己成为程序员的初衷是什么？如果只是为了进入一个相对高薪的行业，得到一份工资高于平均水准的工作，终究是走不了太远的。 很多入门的新手程序员都是刚从学校毕业的，曾记得在吴多益的一篇工程师成长分享的材料上，如是说： 从小到大的教育，你习惯性被安排：“课后作业是 X1、X2，后天必须交”“本学期的必修课有 XX、YY，必选的选修课有 ZZ、WW”。 十几年来你都是这样度过的，但现在你已经不在学校了，你要安排你的未来。 刚入职场的程序员依然保持这个习惯，等着主管来安排。但如果你每天的工作就只是完成被安排好的任务，那么你自己的成长就会非常缓慢，因为主管安排任务时并没有那么多的精力来考虑任务是否适合个人的成长发展。这些任务是组织发展的需要，而不一定适合个人的成长发展，但组织是付了薪酬来让你完成任务的，所以这是工作的必需部分。 自己才是职业生涯的管理者，要想清楚自己的发展路径：远期的理想是什么？近期的规划是什么？而今日的任务和功课又是什么？今日之任务或功课哪些有助于近期之规划的实现，而近期之规划是否有利于远期之理想？ 为什么今日除了任务外还要有功课？功课是学校里的概念，职场里没有，所以离开学校进入职场的功课都是自己给自己安排的。任务来自主管的安排，功课来自自己的安排。很多时候你只去完成任务却从未给自己安排功课，而等着被安排和主动安排之间，在未来将产生巨大的差别。 一开始你可能只有模糊的远期理想，也没那么清晰的近期规划，但一定要有足够清晰明确的今日任务和功课，即使在你的主管因为各种原因没给你安排的情况下。虽说方向不太可能一朝就定好，但也不要不管不顾地埋头走路，你需要抬头看路，定期检视，因为如今环境和大势的变化也很快。在边走边看的过程中逐步就清晰了近期的规划，甚至远期的理想。 另外，主管在你职业发展的路上，除了大部分时候给你安排任务，偶尔也可能给你创造机会，而机会出现时你能否抓住，全在今日之功课上。 定位的视角，是关于一条成长的时间路径，它关乎：昨日初心，今日功课，明日机会。 自省自省，自我的视角，关乎自身，是一个观察自己成长路上行为的角度。 乔治·海尔迈耶（George Heilmeier），是一位美国工程师和技术管理者，他也是液晶显示技术的主要发明者之一。他在科研领域最著名的事情就是他提出的 “海尔迈耶系列问题”： 你要做什么？不要用术语，清晰地表述你的目标。 这件事现在是怎么做的？现在的做法有什么局限？ 谁在关心？你的方法有哪些创新？你为什么觉得你的方法能够成功？ 如果你的方法能够成功，它能带来怎样的变化？ 你的方法需要花多少钱？需要花费多少资源？要怎样在过程中和结束时进行评估？ 我觉得这个系列问题，用在程序员个人成长上也有异曲同工之妙，因为现在的技术方向和路线太多，即使选定了路线依然会有很多茫然和困惑。如果你想要学习一门新技术或在项目中引入一项技术，就可以试试套用 “海尔迈耶系列问题” 来自省一番。 你学习这项技术的目标是什么？清晰地表述出来。 这项技术现在是怎么做的？有什么局限吗？ 这项技术有什么创新之处？为什么它能够取得成功？要是在项目中引入这项技术，谁会关心？ 如果这项技术能成功，会带来怎样的变化？ 采用这项技术的成本、风险和收益比如何？你需要花费多少资源（时间、金钱）？如何去评估它的效果？ 程序员有时粗浅地学习并了解了一点新技术，就想着如何应用到真实的项目中。这时用上面的问题来问问自己，如果有回答不上来的，说明你对这项技术掌握并不充分，那就还不足以应用到实际项目里。 除了技术领域，你成长路上的许多行动，都可以此为参考坐标来反思：“这项行动的目标清晰吗？行动的方法有可参考的吗，局限在哪？我能有何创新之处？完成这项行动，会给我带来怎样的变化？我要付出多少时间、金钱和精力？行动过程中我该如何评估？行动结束的标准是什么？” 这就是自省，从埋头做事，到旁观者视角的自我反思。 多维多维，是一个空间视角，关乎如何选择不同维度的成长路径。 有些时候，程序员写了几年代码，觉得太枯燥乏味，就想着是不是可以转管理，比如转技术主管之类的。从技术到管理似乎就是一条多维度的发展路径，是这样吗？不是的，这不叫多维扩展，而仅仅是想从一个维度逃离，转换到另一个维度。 打造多维度竞争力的前提是，要先在一个维度上做得足够好，让其成为你赖以生存的维度，这个维度就是你的核心基础维度，而它是其他维度得以发展的根基。其中，“足够好”的程度，可能就是指我们常说的 “精通”。 关于“精通”的概念，每个人的理解可能会有所不同，但我认为“精通”肯定不是无所不知，而是可以拆解成两个层面：第一，如学校时期学过的卖油翁所说的“无他， 惟手熟尔”；第二，在一个领域形成自己的体系和方法论。 第一个层面，表达了在当前维度的不断精进，在精进这个方向上，有一本书和咱们专栏主题类似，但更微观一些，偏向于 “术” 的层面，但又有点从 “术” 悟 “道” 的意思。这本书叫《程序员修炼之道：从小工到专家》，书里覆盖了一名程序员真正面临的一些问题，比如： 与软件腐烂作斗争 避开重复知识的陷阱 编写灵活、动态、可适应的代码 使你的代码 “防弹” 捕捉真正的需求 无情而有效的测试 无处不在的自动化 这些具体问题的解法，就是第一层面。然后逐步上升到了第二层面，它的方法体系，一篇书评中将其称为本书的 “哲学”： 本书的哲学将渗入你的意识，并与你自己的哲学交融在一起。它不鼓吹，它只是讲述什么可行，但在讲述中却又有更多的东西到临，我们有时称之为 “无名的品质（Quality without a name）”。 当这些问题倒下而你还在程序员的阵地上时，想必你就会让人感受到那种 “无名的品质”，此时你也就在当前维度走到了 “精通” 的门前。在第一层面上你达成了品质和效率，然后在第二个层面上，抽象出了当前维度的 “解”，那么就可以通过 “启发式” 方法应用到其他维度，具备了向其他维度扩展的基础，从一个细分领域到另一个关联领域的 “精通” 能力。 所谓 “启发式” 方法，就是 “在某个视角里，使用这个规则能够得到一个解，那么你受此启发，也许可以把这个规则用在别的问题上，得到别的解”，而规则就是你在一个维度里抽象出来的方法论体系。 当你感觉在技术维度进境迟滞时，可以尝试扩展到英语维度去，接触一手的技术论文或资料，说不定就能获得启发，找到新的技术维度进境之路。作为多年的程序员，已经形成了用工程师思维分析和求解问题。抽象出来看，程序员都是对问题领域进行建模，然后再用代码实现求得一个 “概率解”。 编程实现得到的难道不是一个确定的系统或服务吗？为什么是 “概率解”？系统或服务是确定的，但解决的问题，如：需求满足率、服务可靠性，却是概率的。每完成一个系统版本的发布，到底多大程度地满足了用户需求，其实是一个概率，这个概率可以通过用户反馈得到一个大概的感知，但你几乎不会知道一个确定的值。而可靠性，相对来说会更可量化，比如在 99.9% ～ 99.99% 之间波动，但也不会是确定的百分百。 工程师的这个求解模型，可以转移应用到其他很多与你息息相关的工作生活领域，比如投资理财，把钱存银行定期赚钱的概率解无限接近百分百；但买基金、买股票的概率解对大部分人来说就完全靠赌和猜了，因为缺乏一个合适的模型去求解，而对领域建模应该是程序员的强项，也是可迁移扩展到其他维度的能力。 即使是学习成长本身，也可以用工程模型来求解。这时你的学习维度就需要扩展一下，不仅仅局限于你当前的专业领域，还可以了解点神经科学，认知心理学之类的，并配合自己的现实情况、作息习惯，去建立你的学习模型，获得最佳学习效果。而学习效果，也是一个 “概率解”。虽然你不能知道确切的值，但我想你肯定能感觉出不同模型求解的效果好坏。 简言之，多维的路径，其实是从一个核心基础维度去扩散开的。 最后，我们总结下，在求解成长的最优路径时，视角的不同，对求解的难度差别巨大。我分享了我的三个视角：定位，时间视角；自省，自我视角；多维，空间视角。通过三个不同的视角，探讨了关于 “我” 与所在现实的时空关系，从中尝试提炼出一种方法，用于探索最适合自己的成长路径。 成长最优路径，求的依然是一个概率解，只是我感觉通过这三个视角去求解，也许概率会更高。 你不妨将这个三维度，套在自己身上，感受一下呢。 61 工作之余，专业之外程序员的主流成长发展路线，是一个明显的“T”形线路。在纵深方向上，工作到一个阶段后，可能我们就会感到深入不下去了，而且越走会越有沉滞的感觉；在横向上，是广度方面，包括技术专业之外的领域，也会感觉了解甚少，短板明显。 有时候，要想产生真正的成长转变与发展突破，就不应自我局限于当下的工作内容和技术专业。 一、工作之余工作，是技术发展纵深线中很重要的一个实践部分，但因为工作的内容和环境的限制，会把你困在一定的阶段，此时工作之余的内容将发挥很关键的作用。 工作之余，你都在做什么？我猜有人会说，工作已经够忙碌了，业余时间就该好好休息和娱乐了。的确，有很多人是这样选择的，但也有不少人不是的。即使再忙，有些人就喜欢在业余时间做点事情，这可能是一种性格特质，拥有这种性格和热情的人，总是能在忙碌的工作之余安排点其他内容，比如： 看看程序设计相关的书、文章和博客； 参加一些技术主题论坛或会议； 写写技术博客； 创建自己的业余项目（Side Project）。 以上前两条是接收和学习知识，第 3 条是总结和提炼知识，最后第 4 条则是实践所学，获得新的技能或加强旧的技能经验。 特别是第 4 条“创建自己的业余项目”，我感觉这是每一个程序员都应该做的事，为什么呢？在现实中切换一次工作环境是有比较高的成本的，开启自己的业余项目能帮助你打破工作内容和环境的限制，让你去做一些你喜欢做，但在工作中还没机会做的事。另一方面，业余项目也是你练习新技术和新技能的最佳试验场，相比你直接用真实的项目去实验，承担的风险和压力都要小很多，这样你也就有了机会去接触你想要学会的新技术。 记得几年前，我还参与过一个关于程序员业余项目的活动，那个活动的口号是下面这样的： 世界在被代码改变着，而我们在创造着代码。 仅仅是因为好玩，他开发了一款操作系统，连想都没想过，这会让自己有一天成为开源世界的领袖级人物。 只是想创造一个很酷的东西，所以他动手，坚持，因而有了让这个世界上的每一个人都可以免费地获取人类所有知识的百科全书。 成功者和其他人最大的区别就是，他们真正动手去做了，并且做了下去。 这也说明了业余项目的积极价值，而且这个世界上也有不少著名的产品来自业余项目的转正，比如：Gmail、Instagram、Slack，甚至包括 Facebook 本身。确实这些闪耀的例子激励着我们去尝试着各种各样的业余项目，但真正能做到像上述例子中那样光彩夺目，只怕这概率也和中头彩差不多了。 即使没有辉煌的成功，那么你做业余项目对自身还有什么积极的意义和价值吗？我想应该有的，你之所以要用自己的业余时间来开启一个业余项目，想必它是让你感兴趣的。全职工作的内容是你的职责，它支付你的账单；业余项目的内容则是你的兴趣，它满足你的好奇和探索之心。 在我学习写程序的前七八年里，业余时间也做了一些练习性质的项目。在 Github 之前的时代，Google 还能访问，我就在 Google Code 上维护了应该不止十万行的业余代码之作。后来 Github 兴起后迁移过来，不断练习重构优化和维护自己的专属工具库，删减了很多冗余代码，又新增了不少，剩下几万行代码。这个过程大约持续了七年，基本每年重构优化一次。每一次重构，都是对以前自己的否定，而每一次否定又都是一次成长。 在做业余项目中最大的收获是：完整地经历一次创造。这样的经历，对于程序员来说可能在很多年的工作中都不会有太多机会。写程序，实现系统，发布交付，仅仅是创造的一个中间部分。而完整创造的第一步应是确定你要创造什么，明确它，规划它，找出创造它的方向和路径，做出决策，然后才是下定决心去实现它。 一方面，业余项目只能在业余时间做，而业余时间又是那么有限，这样的时间制约决定了你只能走极简路线，要么保持足够简单，要么就可能陷入膨胀的泥潭，从而失控导致失败。另一方面，正因为业余项目不会给你带来直接的金钱收益，所以你选择增加的每一个特性，要么让你感觉有意思，要么能磨练提升你的手艺，打磨你的深度。 然而，大部分的业余项目最终都失败了，但这没什么关系，你已经从中收获了趣味与成长。 二、专业之外专业是你的核心领域，而专业之外则是你的辅助领域；核心属于硬技能领域，辅助属于软技能领域，这也是“T”线中的横向延伸部分。 那么该怎样选择辅助的软技能领域呢？如果你的工作之余是在做一件业余项目，那么我想下面一些领域就是你在做业余项目之时更感缺乏的技能。 1. 创造与洞察工程师，是一个创造者，创造模型来解决问题，但又不应该止步于此。 你的业余项目是你的作品，作品是创造出来的，按作品原始的需求是满足了作者创造的愿望，但业余项目要能取得成功就需要得到真正的用户，而获取用户就需要洞察，洞察用户的需要。 我记得以前读过一篇博文，来自著名 JavaScript 程序员尼古拉斯·泽卡斯（Nicholas C.Zakas，《JavaScript 高级程序设计》一书作者），他写了几条职业建议，其中第一条就是： 不要成为做快餐的 “厨师”。 也就是说，不要像外卖接单一样，别人点什么，你就做什么。应该搞清楚你正在做的事情的价值和出发点，你不仅仅是实现代码，还要想想为什么要实现它。当你多想了后一步，在实现的过程中就会有更多的洞察。 开启过自己业余项目的程序员，已经走出了 “创造” 这一步，但多数还是失败在 “洞察” 这一点上。 2. 表达与展现安安静静地写代码固然是不错的，但代码很多时候没法很直接方便地展现出你的真实能力和水平。 你可能会用 Linus 的“Talk is cheap, show me the code.”来反驳我。是的，也许在开源的世界，每个个人贡献者都隐藏在网络的另一端，他们只能通过代码来直接交流。但其他更多的现实是，当别人要来判断你的能力和水平时，通常都不是通过你写的代码，而是其他的表达与展现方式。 如果你的代码能给你作证，只有一个可能场景，那就是找到了大量直接使用你代码的用户，这就是成功开源作品的方式。否则，大部分时候你只能说你用代码完成了什么事情，做出了什么作品。 如果，你有好作品，就值得好好地展现，甚至还要不遗余力地推销它。 3. 沟通与决策一个人的能力再强，也是有限的。当你想做更多、更大的事情时，就不可避免地要借助他人的力量，这时所面临的就将是大量的沟通了。 沟通一般有两个目的：一是获取或同步信息；二是达成共识，得到承诺。前者需要的是清晰的表达和传递，后者就需要更深的技巧了。这些技巧说起来也很简单，核心就是换位思考、同理心，外加对自身情绪的控制，但知易行难在沟通这件事上体现得尤其明显。 关于决策，如果都是在好或更好之间的话，那就真没什么纠结的问题了。而决策，是在优劣相当的情况下做出选择，更多的决策难点发生在取舍之间。程序员能碰到的大部分决策场景都是关于技术的，技术相对来说还有一些相对客观的标准来掂量，比如通过测试数据来验证技术决策的结果。 而其他方面的更多决策会让人陷入困境和纠结。如果要问我在这点上获得过怎样的教训，那就是：即使是一个坏的决策也比始终不做决策要好，因为在行动的过程中比“陷”在原地有可能产生好的改变。 决策和沟通有时是紧密联系的，大量的沟通之后可能产生决策，而决策之后也需要大量沟通来落地实施。 最后总结下：工作之余你可以有多种选择，但若被工作环境所困，导致专业力进境阻碍，可以开启业余项目来突破这种限制；而业余项目带来的诸多益处，从此也为你走向专业之外打开了一个新的视角与空间。 工作之余，专业之外，就是一条“T”线纵横交错发展的路线，当两条线都画得足够长了，在面临成长路上的断层时，才有机会与可能实现跨越。 那么，你的工作之余和专业之外都在忙些什么呢？ 62 跨越断层，突破边界在前文中定义过程序员的职场阶梯，而阶梯不过就是很多人已经走过的路，我们只需要沿着这条路去持续成长就能爬上还算不低的楼层。只是到了一定楼层后我们会发现上面似乎还有几层，但却看不见下一层的楼梯了。因为再往上走的人就不多了，也就没能成了路，自然也就看不见，这可能就是所谓成长阶梯的断层。 在程序员的成长阶梯上，到了一定阶段，我们可能会面临方向的选择，不同的方向选择意味着不同的路径，会碰到不同的断层，而跨越断层也需要不同的方法。 那我们会面临怎样的方向选择呢？ 方向在我的技术成长路上，我看到了三个方向，正好可以用三个字来表达：“高”“精”“尖”。 “高” 指的是 “高级（High-grade）”，“精” 代表 “精确（Precision）”，而 “尖” 则是 “尖端（Advanced）”。这是我所看到的技术人前进的三个主要方向，而这三个方向的走向往往还是互斥的。 高级，说的不是更高级的技术，因为技术之间的横向比较没有高低级之分，比如操作系统、数据库、网络编程、机器学习等技术，没法比出个高下。这里的“高级”，如其英文是更高等级的意思，是职位和人的级别。而往高等级走的技术人，离 “精” 自然只能越来越远，毕竟站的高就只能看得广，但很难看得精确了。 精确，就是把一门技术做到真正的精通。现在技术的分工越来越细，通常能精通一两个细分领域已实属不易。而要做到精，其实越往后付出越多，但感觉提升却变得越来越慢。都到 95 分了，再往后每提升 1 分都需要付出艰辛的努力。走到细微深处，也很难再看得远、看得广了。 尖端，似乎听起来像 “精” 的极致，其实不然，这完全是另一条路。“高” 与 “精”，是工业界的实践之路，而 “尖” 是理论界的突破之路。只有能推进人类科技进步的技术才称得上尖端，就如 IT 界历史上著名的贝尔实验室里的科学家们做的工作。 “高”“精”“尖”三个字，三个方向，三条路，各有各的机遇与风险。在三条路的岔路口，工作多年的你若止步不做选择，也许就止于一名普通的程序员或资深的技术人。若继续选择一个方向走下去，越往高处走，高处不胜寒，一旦落下，你知道再也回不去了；而走向精深之处，沿着技术的河流，溯根回源，密林幽幽，林声鸟不惊，一旦技术的潮流改了道，你知道你可能会迷失；而尖端之路，或者有朝一日一鸣惊人，青史留名，或者一生碌碌。人工智能的发展史上，曾有一段时间找错了路，让学界止步不前，而这一段时间就是走尖端之路的学者们二十年的岁月。 “高” 是往宏观走，“精” 是往微观走，“尖” 是去突破边界。 这三条路，“高” 和 “精” 的方向在业界更常见，而 “尖” 不是工业界常规的路，毕竟业界拥有类似贝尔实验室这样机构的公司太罕见，所以 “尖” 的路线更多在学术界。因而后面我们主要探讨 “高” 和 “精” 两个方向的路径断层与跨越方法。 高高的两条典型路线如下： 程序员—架构师—技术领导者 程序员—技术主管—管理者 往高处走，每一次角色的转变，都是断层。有时候，公司里到了一定级别的程序员就会被冠以架构师的称呼，但工作的实质内容依然是资深程序员平时做的事，如：一些关键系统的设计和实现，解决一些困难的技术问题。 这些工作中的确有一部分也算是架构师的内容，但如果不能认识到架构师工作内容的实质，再往高处走也就很难实现断层的跨越了。而架构工作的实质是创造一个模型，来连接、匹配关于业务、技术和团队之间的关系。 其中的 “业务” 属于架构师工作内容中的领域建模；“技术” 是匹配领域模型的技术实现模型；“团队” 是关于个体之间如何组合的结构，需要满足个体技术能力与技术实现模型的匹配。由这三个元素连接和匹配构成的模型中，“业务” 是变化最频繁的，其次是 “团队”，而变化频次最低的反倒是 “技术”。 每一项元素发生变化，都意味着架构模型需要去适应这种变化，适应不了变化的模型就需要升级。而常见的组织架构调整，也就意味着 “团队” 的沟通路径变化了，因为康威定律（系统设计的通信结构和设计系统的团队组织的沟通结构是一致的）的缘故，必然带来架构模型的适应性变化调整。 透过具体的实质再往高处抽象到本质，你会发现架构工作的本质是在通过模型调优生产关系，从而提高生产效率和生产力。这是一条杠杆之路，通过找到其中的关键支点去放大输出，扩大价值。 在架构模型三元素中，技术本身就是一种杠杆，而团队和业务是价值支点。 曾经，技术的草莽时期，是一个英雄辈出的年代。两个人可以创造 Unix、C 语言，一个人也可以发明 Linux，也可以写出 Foxmail。掌握了技术，就可能创造历史，那时技术的杠杆很高。 如今，是技术的成熟时期，个体英雄少了，更多是一种团队和集团军作战的方式。如果你是技术的绝世高手（精的极致），那你也需要找到一支契合你技能的场景与队伍，加入进去。此时个人的技术杠杆也许不像曾经那么高，但也许你们这个队伍还是有机会能创造历史的。 前几年，Facebook 曾收购了一家叫 WhatsApp 的公司，花了 190 亿美元。这家公司当时仅 50 人，而其中一半是技术人员，这应该是近年用技术杠杆撬动价值之最了吧。 在 WhatsApp 这个例子中的价值支点是什么？是产品（业务），连接用户、形成网络。技术本身的价值通过这个产品业务形态支点，在每个活跃用户身上得到了放大。 而另一个价值支点，是借助团队，但这只适合高级别的技术人员，比如：技术管理者或架构师。但团队也需要能创造真正的价值，才能实现利用杠杆放大价值的效果。在商业环境下，任何一种产品业务形态，其最终能实现价值，都会存在一个价值网络。这个网络中覆盖了各种角色，技术只是其一，若要找到最好的价值支点，那么通常会在离价值来源比较近的地方。 技术像是一根棍子，能发挥多大价值，取决于棍子本身的品质和运用的方式。而往高处走的技术人，要跨越这条路径的断层，就是要认识清楚这个价值网络，并找到最适合技术发挥的价值点。 精精的路线是一条 “专家” 之路。 曾经在[前文《定义：阶梯与级别》]中定义过 “专家”，我说：专家可能就是某个领域中你绕不过去的人吧。这个定义中包含两个点，一个是领域，另一个是绕不过去。第一点表达了某个范围，第二个则模糊地表达了这个范围的大小，绕不过去其实是一个很大的范围了。 比如，若你处在物理学领域，牛顿就是你绕不过去的人，之后是爱因斯坦。而在计算机领域，图灵定义了计算机的边界，也是这个领域绕不过去的人。但这样的天才人物，百年来才出一个，如果都要达到这个水平才算是专家，可能就太难了，从而失去了指导意义。 如今反思，其实用这两点来定义专家也是可以的，只是需要更清晰地明确领域和量化范围。大至国家、社会、行业，小到公司、团队、小组，都有自己关于专家的定义。 曾经，好些年前，我最早在公司的几个同事组成的小组内研究引入 Java NIO 的技术来编写网络程序，读了一些相关的书和开源框架代码（Mina、Netty），周围的几个同事就戏称我为 Java NIO 的专家。这就是用领域（Java NIO 是一个很细分的技术领域）加范围（局限于周围组内几个同事，他们要解决 NIO 的网络编程问题都绕不过我）定义专家的方式。 因而，像前面说的爱因斯坦、牛顿、图灵，他们既是行业（学科维度）范围内的，也是世界（地理维度）范围内的专家。而公司内的专家职级定义，其范围无非就是与公司经营相关的某个领域，其大小无非就是公司组织架构的某一层级之内。 走向专家之路，就是精确地找到、建立你的领域，并不断推高壁垒和扩大边界的过程。 那么如何建立属于自己的、更大范围内且具备足够识别性的领域？这就是 “精” 的路径中的非连续性断层问题。曾经读过一篇吴军的文章，谈到了工程师成长中的类似问题，他用了一个公式来描述解法： 成就 ＝ 成功率 x 事情的量级 x 做事的速度 在连续的成长阶段，我们的成长主要体现在不断提升做事的熟练度，也就是上述公式中的速度和成功率，但这两个指标到了一定的熟练度阶段后就会碰到物理极限。实际情况是，一个资深的工程师的速度甚至不会比一个初级工程师快两倍，但可能成功率会高几倍，甚至十倍，这就是传说中的一个顶十个的程序员，但离极限也就差不远了。 而要成为传说中以一敌百的程序员，只有一个可能，他们做的事情和其他人不在一个量级上。现实案例中，就有如 Linus 这样的人。所以，一直做同样的事，都是写代码，也可以跨越断层，但关键是，你写的代码体现在什么量级的事情上。 之前在工程思维中总结过：问题的量级变了，逻辑就不一样了。作为程序员，我们会有直观的感受，用户量级越过了一定的门槛后，我们编写、维护和部署程序系统的方式都会发生本质的变化。而提升量级最难的就在于我们要放下曾经熟悉的方式和习惯，站在更高的维度去看更大量级的事情，并且找到适合这个量级事情的合适解决方案。 面临成长路上的非连续断层，以及角色之间的无形壁障，该如何跨越断层，突破边界？我们着重从成长路线的两个方向：“高” 和 “精”， 提供了分析和解法。 高的路线，需要借助技术的杠杆，认清所处的价值网络，找到合适的价值点，撬动更大的价值； 精的路线，在做事情的成功率和速度接近自己的极限后，只能去提升事情的量级，才能发挥出专家的价值。 明晰了不同路线的价值方向，但每个人脚下的路都是具体的、不同的，我们跨越的方式也不会一样。在成长的路上，你碰到了断层没？是如何跨越的？欢迎留言和大家一起分享探讨。 63 成长蓝图，进化跃迁回顾过去，我们会清晰地看见走过来的路线，但面向未来我们又该如何走下去？但凡过往，皆为序章，过去不可变，未来才是希望，而如何去规划并管理好未来的成长进化之路，才是我们当下要面临的主要任务。 我们先从一个高度抽象的维度，来看看这条成长之路。 一、成长路线结合我自己的经历、思考与总结，我对走过的路和未来的路概括成如下这张图： img 图中描述了好几个阶段，从一个阶段到下一个阶段，都会经历一次转折。 1. 开发代码（Develop Code）从刚走出学校到进入职场成为一名新手程序员，在最初的一两年内，你可能都处在这个阶段。不停地大量写代码，为各类系统的“大厦”添砖加瓦，像块海绵一样，把自己吸得满满的，朝 9 晚 24 地工作与学习，并不时自嘲为 “码农”。 这个阶段，你为生存所需（迫），会强烈地渴望成长。 2. 开发系统（Develop System）三、五年后，你可能从初级、中级成长到了高级，此时你不再仅仅是写代码搬砖，而是开始负责起或大或小的整个系统。这时，你最关心的是如何用最好的技术方案，去开发、优化和完善系统。 3. 开发产品（Develop Product）从高级走向资深、专家或架构师，你会发现你的技术执行技能已经优化到了相当的程度，这时往前多走一步，关注你所实现的系统所属的产品，会让你打开新的空间，找到更有效率和效果的实现路径，减少做无用功。 而且在技术的世界里，有很多面向开发者的技术型产品，这个领域中最适合承担起产品经理角色的就应该是各类资深的技术专家和架构师了。 4. 开发团队（Develop Team）当你选择走上技术主管并转变为一名管理者，那么人和团队将成为你的主要开发对象，而不再是代码了，这是成为管理者的必经之路。 5. 开发梦想（Develop Dream）梦想这个东西也会随着岁月与你相伴成长，梦想实际永远在前方，它只是不断引领着你往前走。梦想相对而言是一个感觉上很 “虚” 的概念，它可能需要产品作为载体，也需要团队来一起开发创造。如此，梦想的引力就会引发你向一名创新者或领导者的方向进化跃迁。比如说，十多年前，刚毕业时，我的梦想是成为一名架构师，如今已然实现。 以上这张图只是帮你看清从过去到未来的一条路，但如何走好这条路，就需要另一个视角维度的蓝图了。 二、战略蓝图战略这个词，通常会和组织、公司关联在一起；那假想下，如果个人是一家公司，那么这家 “公司” 的战略该如何确定？ 在分析战略之前，我们需要先分析下公司的业务。为了更好地分析清楚公司的主要业务，这里借鉴下咨询公司爱用的商业分析模型：波士顿矩阵。实际有很多不同的分析模型，我只是觉得这个最简单，比较适合像个人这样的小小微 “公司”。 波士顿矩阵模型，把公司业务分成下面四类： 现金牛业务 明星业务 问题业务 瘦狗业务 现金牛业务，比较形象地表达了就是产生现金的业务。比如谷歌的搜索业务、微软的 Windows 操作系统，都是它们的现金牛业务，有很高的市场占有率，但成长率相对就比较低了。 就个人来说，现金牛业务自然是一份稳定的工作，产生现金，维持个人生活的基本面，当然稳定之外越高薪越好。程序员这个职业就是很好的现金牛业务，行业繁荣，工作也比较稳定，专注于这个业务，不断提升薪资水平，这就是：活在当下。 明星业务，比较形象地表达了很有前景的新兴业务，已经走上了快速发展的轨道。比如：亚马逊的云计算（AWS）就是它的未来之星。而个人呢？如果你的现金牛业务（级别和薪资）已经进入行业正态分布的前 20%，那么再继续提升的难度就比较大了。 个人的明星业务是为未来 5 到 10 年准备的，就是现在还并不能带来稳定的现金流但感觉上了轨道的事。于我而言，是投资理财。人到中年，除了劳动性收入，资产性收益将作为很重要的补充收入来源，而当资本金足够大时，很可能就是未来的主要收入来源。当你开始在考虑未来的明星业务时，这就是：活在未来。 问题业务，比较形象地表达了还有比较多问题的业务领域，面临很多不确定性，也就是还没走上正轨。将来到底是死掉，还是成为新的明星业务，现在还看不清楚。比如谷歌的无人驾驶、机器人等业务领域都属于此类。 就个人而言，可能是一些自身的兴趣探索领域。于我来说，目前就是写作和英语，即使写作已经开了专栏，但并不算是稳定可靠的收入来源，主要还是以兴趣驱动，投入时间，不断探索，开拓新的维度，这就是：活在多维。 瘦狗业务，比较形象地表达了一些食之无味、弃之可惜的业务。瘦狗业务要么无法产生现金流，要么产生的现金流不断萎缩。今日之瘦狗，也许是昨日的明星或现金牛，比如像诺基亚的功能机。 就个人而言，行业在发展，技术也在进化，曾经你赖以为生的 “现金牛” 技能，可能过几年后就会落后，逐渐变成了 “瘦狗”，无法果断地放弃旧技能、开发新技能，可能就如诺基亚一般在新的时代被淘汰。固守瘦狗业务，那就是：活在过去。 业务模型构成了你的蓝图，而对你的各种业务进行与时俱进地布局与取舍，这就是战略。 三、进化跃迁明晰了路线，掌握了蓝图，该如何完成你的成长进化跃迁呢？ 跃迁是量子力学里的概念，指电子吸收能量后，突然跳到更高的能量级，这种不连续、跳跃的突变，我们称之为 “跃迁”。我借用了这个概念来类比成长，从如上定义中有几个关键点： 吸收能量 更高能量级 非连续跳跃 个人成长的跃迁也需要能量，在这里能量就是知识、技能和能力。完成 “能量” 的积累就需要持续地学习和实践行动，而持续行动又靠什么来驱动？内心的自驱力，这是稳定有效的驱动力来源，若没有自我驱动的力量是不太可能带来持续行动的。 学习行动计划、养成行动习惯都是为了提升行动的效率，行动积累了足够的 “能量” 后，就向更高能量级跳跃。这里更高的能量级是对知识和能力的更高维度抽象的比喻，比如：知识模型和技能体系，就比孤立的知识点和技能拥有更高的能量级。 而第三个关键点：非连续跳跃，说明这样的进化有突变的特征。而个人知识的积累与能力的提升，其实都是比较缓慢而连续的，非连续的跳跃其实体现在机会和运气上。合适的机会若没能降临，你就没法完成跃迁。 连续的成长积累是你能掌控的部分，而跃迁的机会、运气则属于概率成分，你的努力可能一定程度上提高了概率，但它并不能导致必然的跃迁结果发生。即使机会没能到临，努力过后也许有无奈，也该当无悔了。 最后，我们总结下： 从开发代码到开发梦想，你可以画出一张你的成长路线图，从而走上进化跃迁的道路；上了路后，接着你可以利用工程师的思维模式和商业工具模型，建立一个你的成长战略蓝图去指导你如何走这条路。剩下的，就让你的努力、选择和运气来帮助你完成不断的跃迁变化吧。 专栏至此，已近尾声，而如今的你，正在向哪个阶段跃迁呢？ 尾声 始于知，终于行专栏历时半年，终于到了尾声。 在写这个专栏之前，我已经写了好些年博客，写过很多关于技术的，也写过更多围绕程序员或者说当时的我自己成长的一些感悟。在回顾曾经写过的一些主题时，发现很多技术的内容可能都随着时间变迁过时了，但关于成长的认知却依旧历久弥新，因此选了这个关于成长的主题。 而成长的本质，就是两个字：知行——始于知，终于行。 知知，起于阅读；当你决定学习一样东西时，自然就会从阅读开始。从阅读中学习，要么是直接获得知识，要么就是从别人的学习经历或经验中找到值得自身借鉴的参考与启发。 我硕士毕业于广州中山大学，一直让我铭记的是当年学校的校训，那是孙中山先生于 1924 年 11 月 11 日在广东大学（原校名，后为纪念孙中山先生改名）举行成立典礼时亲笔提写的十字训词： 博学 审问 慎思 明辨 笃行 这十字训词原文出自儒家经典《礼记·中庸》：“博学之，审问之，慎思之，明辨之，笃行之”，但孙中山先生赋予了它新时代的涵义。 “博学” 好理解，在校训牌旁边不远处就是陈寅恪的故居，陈寅恪是中国现代历史学家、古典文学研究家、语言学家、中央研究院院士、中华民国清华大学国学院四大导师之一（其余三人为梁启超、王国维、赵元任），通晓二十余种语言，堪称博学之人。 相比九十多年前孙中山先生的时代，今天是信息爆炸与过载的时代，知识与学问也淹没在这些爆炸的信息中，谁还能轻易堪称博学，我们只能说在信息的洪流中，保持永无止境地学习。如果能坚持学下去，那么今天的自己就比昨天的自己稍微博学一点，今年的自己也比去年的自己要博学一些。 正因为信息过载，我们通过各式各样的大量阅读来接收信息，因此对这些信息进行 “审问、慎思、明辨” 就显得十分重要和关键了。“问、思、辨” 是对信息进行筛选、分析与处理，去其糟粕取其精华。经过降噪、筛选、分析处理后的信息再与我们自身已有的知识和经验结合形成属于自己的独立思考与观点，而这些独立的思考和观点才能用来指导我们的行动，也即 “笃行”。 先有 “知”，方有 “行”。知，只是行的方法；行，才是知的目的。 行在中大学习的年间，我每天早上去实验室，晚上又回来，多少次要从校训牌前来回经过。十多年后再回想当初在学校习得的那点知识和技能，要么已经过时，要么也遗忘殆尽了。最终留在心里的反倒是校训牌上那无比清晰的十字训词，并一直指导着我未来的学习与成长之路。 十字训词，前 8 字 4 词占了 80% 的文字内容，但我觉着用在上面的时间和精力应该正好反过来：花 20% 时间和精力研究如何更好地 “知”，而 80% 的时间和精力放在持续地 “行” 上。搞错了比例，很可能最终也就无所成就，收获寥寥。 但 “笃行” 往往是最消耗时间的阶段，一旦方向搞错了，可能大量的努力就浪费了。因此，“行” 之前的 “学、问、思、辨” 就很关键了，它们是行之前甚至行程中不断修正方向的指南针。 我的专栏能提供给你的也不过是我的一些经历、经验与思考，供你行路参考。你的阅读会让你更 “博学” 一点，但这只是第一步的信息传递与接收阶段，如果没有后面的 “问、思、辨、行”， 于你又有多大的意义呢？所以，后面的部分只能靠你自己来完成了。 纸上得来终觉浅，绝知此事要躬行。 在 “行” 的路上，也许一开始都是参照走前人走过的路，虽然我们经常想走自己的路，其实绝大部分人终其一生都是在走前人的路。写到这，想起一个前几年关于我自己的真实 “行路” 的感悟。 几年前，我考了驾照买了车，然后就跑去自驾。从成都出发，经过了红军长征走过的草原，绕过了青海湖边，经古代丝绸之路的路线一路开到了敦煌。丝绸之路从敦煌出去，分出两条，北上经玉门关，南下出阳关，走到那里突然有种诗和远方的感觉。 但无论自驾如何自由，我们也不过是在走前人的路。在敦煌的洞窟里看到了张大千临摹的笔迹，才了解到战争年代大师也曾在这里临摹古人的壁画，走着前人的路。 开着车走在路上，两边是沙漠，偶尔看见前面有车，超过，再前行，两边的沙漠变成戈壁，路看不到头，一望之下再也看不到其他的人和车，走在路上感觉有些心慌然，仅仅是走在前人的路上已有些慌然，那走出这条路的前人又该是怎样的心境？ 回程中，入蜀后国道一来一去两条车道，车多起来了后都只能跟着走，大车在路上慢悠悠地挡着道，小车都会借道超车。借道本身是有一定危险的，超大车还好，如果前面是小车，本身开得不慢，跟着走是不是更能在安全和速度之间取得平衡？我试过跟着小车走，不超车，结果跟不了多久就跟丢了。 当你决定跟车时就放弃了超越的心，安稳是安稳些了，但节奏掌握在前车手里，最终只会被远远甩下。开车行路如此尚可，但人生之路终究是无法去跟住别人的，有一颗超越的心，按自己的节奏一直走下去，你终究会慢慢走出一条属于自己的路。 这条路，难不难走？难，感觉走不下去时，不妨读读李白的诗吧。 行路难！行路难！多歧路，今安在？ 长风破浪会有时，直挂云帆济沧海。 所以，近年啊，我总不时读读唐诗。 感谢你一路同行读到这里，希望这个专栏是你又一次 “知” 的起点，后面该看你的 “行” 了。最后，祝你：前路无碍，挂帆破浪。 末了，专栏虽然结束了，但我的“行”——写作之旅并未停止，在未来，我还会继续在我的公众号（瞬息之间）思考与写作下去，期待你也行动起来，我们一路同行 ^_^。 上一页 下一页","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"分布式锁的阐述以及实现","slug":"分布式/distributed-lock-manager","date":"2021-09-22T08:10:46.000Z","updated":"2021-09-22T14:46:23.802Z","comments":true,"path":"distributed-lock-manager/","link":"","permalink":"https://winniekun.github.io/distributed-lock-manager/","excerpt":"","text":"分布式锁阐述在搞明白分布式锁之前，先明白其由来。 谈到分布式锁自然也就能联想到分布式应用。 在将应用拆分为分布式应用之前，是单机系统，在单机系统中的并发场景为单进程多线程模式 采用加锁或者非阻塞同步或者无锁同步可以简单的实现同步操作 将应用拆分为分布式应用之后，并发场景变成了多进程+多线程的模式 业界常用的解决方案通常是借助于一个第三方组件并==利用它自身的排他性来达到多进程的互斥==。如： 基于DB的唯一索引 基于ZK的临时节点 基于Redis的NX EX参数 EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。 PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。 NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。 XX ：只在键已经存在时，才对键进行设置操作。 一个良好的分布式锁，要解决如下的几个核心的问题： 可用问题： 无论何时都要保证锁服务的可用性（这是系统正常执行锁操作的基础）。 死锁问题： 客户端一定可以获取锁，即使其他客户端获取锁之后，在释放锁之前宕机了。 脑裂问题： 集群同步时产生的数据不一致或者故障转移时，导致新的进程有可能拿到锁，但之前的进程以为自己还有锁，那么就出现两个进程拿到了同一个锁的问题。 可重入： 一个节点获取了锁之后，还可以再次获取整个锁资源。 MySQL实现分布式锁基于MySQL的方案，一般分为3类：基于表记录、乐观锁和悲观锁 基于表记录最直观的形式就是创建一张表，然后在表里面执行操作，获取锁时在记录中新增一条记录，释放锁的时候再把该记录删除即可。 DDL： CREATE TABLE `database_lock` ( `id` BIGINT NOT NULL AUTO_INCREMENT, `resource` int NOT NULL COMMENT '锁定的资源', `description` varchar(1024) NOT NULL DEFAULT \"\" COMMENT '描述', PRIMARY KEY (`id`), UNIQUE KEY `uiq_idx_resource` (`resource`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='数据库分布式锁表'; 因为添加了唯一索引，所以能够保证排他性，同一时间只有一个客户端获取到共享资源（报错：ERROR 1062 (23000): Duplicate entry ‘1’ for key ‘uiq_idx_resource’）。 获取锁： INSERT INTO database_lock(resource, description) VALUES (1, 'lock'); 释放锁： DELETE FROM database_lock WHERE resource = 1; 注意事项： 没有时效时间，如果客户端获取锁之后，宕机之后，或者其他释放锁操作失败，就会导致其他客户端无法获取锁 可以做一个定时任务去定时清理。 这种锁的可靠性依赖于数据库。建议设置备库，避免单点，进一步提高可靠性 这种锁是非阻塞的，因为插入数据失败之后会直接报错，想要获得锁就需要再次操作。如果需要阻塞式的，可以弄个for循环、while循环之类的，直至INSERT成功再返回 这种锁也是非可重入的，因为同一个线程在没有释放锁之前无法再次获得锁，因为数据库中已经存在同一份记录了。想要实现可重入锁，可以在数据库中添加一些字段，比如获得锁的主机信息、线程信息等，那么在再次获得锁的时候可以先查询数据，如果当前的主机信息和线程信息等能被查到的话，可以直接把锁分配给它。 基于乐观锁DDL： CREATE TABLE `optimistic_lock` ( `id` BIGINT NOT NULL AUTO_INCREMENT, `resource` int NOT NULL COMMENT '锁定的资源', `version` int NOT NULL COMMENT '版本信息', `created_at` datetime COMMENT '创建时间', `updated_at` datetime COMMENT '更新时间', `deleted_at` datetime COMMENT '删除时间', PRIMARY KEY (`id`), UNIQUE KEY `uiq_idx_resource` (`resource`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='数据库分布式锁表'; 在使用乐观锁之前要确保表中有相应的数据，比如： INSERT INTO optimistic_lock(resource, version, created_at, updated_at) VALUES(20, 1, CURTIME(), CURTIME()); 在单线程的情况中，流程如下： 获取资源： select resource from optimistic_lock where id = 1; 执行业务逻辑 更新资源：update optimistic_lock set resource = resource - 1 where id = 1 不过在多线程的情况下，可能会出现超减的问题。所以我们可以通过一个version或者时间戳来进行控制，类似CAS 获取资源：SELECT resource, version FROM optimistic_lock WHERE id = 1 执行业务逻辑 更新资源：UPDATE optimistic_lock SET resource = resource -1, version = version + 1 WHERE id = 1 AND version = oldVersion 虽然本身并没有利用到数据库自身的锁机制，不影响请求性能，但是，并发量大的时候，会导致大量的请求失败。同时因为都是作用在同一条记录上，在一些特殊场景，如大促、秒杀等活动开展的时候，大量的请求同时请求同一条记录的行锁，会对数据库产生很大的写压力。所以综合数据库乐观锁的优缺点，乐观锁比较适合并发量不高，并且写操作不频繁的场景 基于悲观锁除了可以通过增删操作数据库表中的记录以外，我们还可以借助数据库中自带的锁来实现分布式锁。在查询语句后面增加FOR UPDATE，数据库会在查询过程中给数据库表增加悲观锁，也称排他锁。当某条记录被加上悲观锁之后，其它线程也就无法再改行上增加悲观锁。 步骤如下： 获取资源 SELECT * FROM database_lock WHERE id = 1 FOR UPDATE 执行业务逻辑 释放锁 COMMIT 注意事项： 避免锁升级到表锁。所以需要明确能够走到索引。 在悲观锁中，每一次行数据的访问都是独占的，只有当正在访问该行数据的请求事务提交以后，其他请求才能依次访问该数据，否则将阻塞等待锁的获取。悲观锁可以严格保证数据访问的安全。但是缺点也明显，即每次请求都会额外产生加锁的开销且未获取到锁的请求将会阻塞等待锁的获取，在高并发环境下，容易造成大量请求阻塞，影响系统可用性。另外，悲观锁使用不当还可能产生死锁的情况。 Redis实现分布式锁单机Redis实现分布式锁获取锁： SET resource_name my_random_value NX PX 30000 上面的命令如果执行成功，则客户端成功获取到了锁，接下来就可以访问共享资源了；而如果上面的命令执行失败，则说明获取锁失败。 SET命令阐述： resource_name 可以视为一个共享资源 my_random_value 通过客户端自己生成一个随机符号，作为唯一标志符，避免错误解锁问题 NX 若当前key已经存在，则不执行任何操作，若当前key不存在，执行命令，也就是set操作。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁（很好的排他性）。 PX 3000 表示这个锁有一个30秒的自动过期时间。当然，这里30秒只是一个例子，客户端可以选择合适的过期时间。 释放锁： if redis.call(\"get\",KEYS[1]) == ARGV[1] then return redis.call(\"del\",KEYS[1]) else return 0 end LUA命令阐述： 前面的my_random_value作为ARGV[1]传入，然后把resource_name作为KEY[1]传进来 单机Redis实例实现分布式锁的一些核心点： 锁必须要设置一个过期时间（锁的有效时间），避免客户端获取锁之后崩溃或者出现网络分割等问题导致的其无法和Redis实例继续通信，最后导致其他客户端都无法获取锁 获取锁操作要保证原子性 上述获取锁的语义分为两步骤： set 、设置过期时间 SETNX resource_name my_random_value EXPIRE resource_name 30 但分为两个命令的话，无法保证原子性操作（set之后，客户端宕机了，则会一直持有锁），上述的获取锁操作就是一个命令，也就具有原子性了。 my_random_value是必须的 通过my_random_value作为每个客户端的唯一标识符，可以有效的解决错误解锁的问题 客户端A获取锁，然后执行操作 客户端A在某个操作上阻塞了很久，锁的有效时间超过了，自动释放锁 客户端B成功获取锁，执行自己的业务 客户端A从阻塞中恢复，然后释放了客户端B的锁 释放锁要保证原子性 对于释放锁来说，共有三个步骤：查询、判断、删除，和获取锁同理，也要保证原子性。为了实现原子性操作，可以通过LUA脚本来做 if redis.call(\"get\", KEY[1]) == ARGV[1] then return redis.call(\"del\", KEY[1]) else return 0; end 如果无法保证原子性的话，会出现如下的情况 客户端A成功获取到了锁 客户端A对共享资源进行操作 客户端A执行结束，开始释放锁，先执行GET操作获取锁，然后进行比较客户端自身的随机值比较，符合预期 客户端A因为某些原因，发生了阻塞 超过了锁的使用时间，客户端B在锁被超时释放后，成功获取锁 客户端A从阻塞中恢复过来，执行最后一步，也就是DEL操作，结果错误释放了客户端B获取的锁。 分布式锁RedLock以上问题，在实现分布式锁时，稍加注意就能够很好的的解决，但是有一种情况很难解决，其是由failover问题导致的，具体如下： failover引起的问题 客户端1从Master中获取锁 Master宕机了，并且Master的数据还同步到Slave上 Slave升级为Master 客户端2从新的Master中获取到了对应同一个资源的锁 这样就导致了客户端A和客户端B同时获取了同一个资源的锁，这样就违背了分布式锁的语义了，锁的安全性被打破了。针对这个问题，antirez设计了Redlock算法。 获取锁步骤： 获取系统当前的时间（毫秒级别） 按照顺序依次向N个Redis实例执行获取锁操作 整体流程和基于单个Redis实例获取锁相同，包含有random_value和过期时间（PX 3000 也称为有效时间） 同时为了保证某个Redis实例宕机时，RedLock能够正常工作，对于每次获取锁操作，还要有一个超时时间，并且要远小于整个锁的有效时间。客户端在当前Redis实例获取锁失败（可能是宕机、可能时网络超时）的话，需要立即尝试在后续的Redis的实例上获取锁。 计算客户端获取锁的过程中，共消耗了多少时间。计算方式为：访问N个Redis实例之后的时间 - 第一步开始时的时间。同时保证 成功获取了 $N/2 + 1$个Redis实例上获取到了锁。那么认为获取锁成功， 否则视为失败。 获取锁成功，对应的锁的有效时间要重新计算。它等于最开始设置的有效时间减去获取锁消耗的时间。 获取锁失败，要求客户端要对所有的Redis实例进行释放锁操作（Lua脚本保证原子性）。 释放锁的步骤 客户端要对所有的Redis实例进行释放锁操作（Lua脚本保证原子性），不管这些节点当时在获取锁的时候成功与否。 ZooKeeper实现分布式锁 客户端创建一个znode节点，比如/lock，那么就意味着客户端获取锁成功了。其他客户端获取锁失败（znode已经存在） 持有锁的客户端业务逻辑执行完成之后，会删除znode，这样其他的客户端就接下来就能获取锁了 znode应该被创建成ephemeral（临时的）的。这是znode的一个特性，它保证如果创建znode的那个客户端崩溃了，那么相应的znode会被自动删除。这保证了锁一定会被释放。 那么问题来了，ZooKeeper是如何检测到客户端是否崩溃呢？实际上每个客户端和ZooKeeper的某个服务器都维护一个 Session，这个Session通过心跳检测来维持，如果ZooKeeper长时间获取不到客户端的心跳（Session的过期时间），那么就认为Session过期了，同时会该Session对应的ephemeral的znode都会自动删除。 设想如下的执行序列： 客户端1创建了znode节点/lock，获得了锁。 客户端1进入了长时间的GC pause。 客户端1连接到ZooKeeper的Session过期了。znode节点/lock被自动删除。 客户端2创建了znode节点/lock，从而获得了锁。 客户端1从GC pause中恢复过来，它仍然认为自己持有锁。 最后，客户端1和客户端2都认为自己持有了锁，冲突了。这与Martin在文章中描述的由于GC pause导致的分布式锁失效的情况类似。 看起来，用ZooKeeper实现的分布式锁也不一定就是安全的，该有的问题它还是有。但是，ZooKeeper作为一个专门为分布式应用提供方案的框架，它提供了一些非常好的特性，是Redis之类的方案所没有的。像前面提到的ephemeral类型的znode自动删除的功能就是一个例子。 还有一个很有用的特性是ZooKeeper的watch机制。这个机制可以这样来使用，比如当客户端试图创建/lock的时候，发现它已经存在了，这时候创建失败，但客户端不一定就此对外宣告获取锁失败。客户端可以进入一种等待状态，等待当/lock节点被删除的时候，ZooKeeper通过watch机制通知它，这样它就可以继续完成创建操作（获取锁）。这可以让分布式锁在客户端用起来就像一个本地的锁一样：加锁失败就阻塞住，直到获取到锁为止。这样的特性Redlock就无法实现。 基于ZooKeeper的锁和基于Redis的锁相比在实现特性上有两个不同： 在正常情况下，客户端可以持有锁任意长的时间，这可以确保它做完所有需要的资源访问操作之后再释放锁。这避免了基于Redis的锁对于有效时间(lock validity time)到底设置多长的两难问题。实际上，基于ZooKeeper的锁是依靠Session（心跳）来维持锁的持有状态的，而Redis不支持Sesion。 基于ZooKeeper的锁支持在获取锁失败之后等待锁重新释放的事件。这让客户端对锁的使用更加灵活。 总结摘自张铁蕾的博客 按照锁的两种用途，如果仅是为了效率(efficiency)，那么你可以自己选择你喜欢的一种分布式锁的实现。当然，你需要清楚地知道它在安全性上有哪些不足，以及它会带来什么后果。而如果你是为了正确性(correctness)，那么请慎之又慎。我们在分布式锁的正确性上走得最远的地方，要数对于ZooKeeper分布式锁、单调递增的epoch number以及对分布式资源进行标记的分析了。请仔细审查相关的论证。 References 基于数据库实现的分布式锁 基于Redis的分布式锁到底安全吗 分布式系统中，如何回答锁的实现原理","categories":[{"name":"分布式","slug":"分布式","permalink":"https://winniekun.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"锁","slug":"锁","permalink":"https://winniekun.github.io/tags/%E9%94%81/"}]},{"title":"零拷贝技术的理解","slug":"操作系统/zero-copy","date":"2021-09-14T07:41:13.000Z","updated":"2021-09-14T11:32:28.465Z","comments":true,"path":"zero-copy/","link":"","permalink":"https://winniekun.github.io/zero-copy/","excerpt":"","text":"零拷贝的好处 减少或避免不必要的CPU数据拷贝，从而释放CPU去执行其他任务 零拷贝机制能减少用户空间和操作系统内核空间的上下文切换 减少内存的占用 DMA技术 DMA 在没有DMA技术之前，I/O的过程如上图所示： CPU 发出对应的指令给磁盘控制器，然后返回； 磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个中断； CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。 可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。 为了解决这一问题，中间层的思路就又出来了。后期引入DMA技术，在进行I/O处理的时候（设备和内存进行数据传输的时候），数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。 DMA 具体过程： 用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态； 操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务； DMA 进一步将 I/O 请求发送给磁盘； 磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满； DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务； 当 DMA 读取了足够多的数据，就会发送中断信号给 CPU； CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回； 传统的文件传输 文件传输 首先，期间共发生了 4 次用户态与内核态的上下文切换，因为发生了两次系统调用，一次是 read() ，一次是 write()，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。 上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。 其次，还发生了 4 次数据拷贝，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程： 第一次拷贝，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。 第二次拷贝，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。 第三次拷贝，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。 第四次拷贝，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。 优化思路减少上下文的切换首先， 对于I/O的处理，用户态是无权限的，只能切换到内核态进行处理，所以减少上下文的切换的一个思路就是：减少系统调用 减少拷贝的次数通过对上述的分析，我们知道传统的文件传输，涉及到了四次的copy过程。在一些场景中，我们知道其实数据是完全不必copy到用户空间的，因为应用程序一般不会对数据进行加工。 零拷贝mmap + write在前面我们知道，read() 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 mmap() 替换 read() 系统调用函数。 mmap + write 示意图 流程： 应用进程通过mmap后，DMA将磁盘文件放入内核缓冲区，然后用户程序和内核共享该缓冲区 然后用户程序调用write，将数据写入socket缓冲区，（内部而言，是cpu内核缓冲区的内容copy到socket缓冲区） 然后DMA将socket缓冲区放入到网卡缓冲区中 拷贝次数 从 4 -&gt; 3 上下文切换还是发生了4次 sendfile 通过减少系统调用，实现零copy技术 sendfile sendfile可以替代read和write两个系统调用，这样就可以减少一次系统调用，避免两次上下文切换。其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如上图所示。 但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（The Scatter-Gather Direct Memory Access）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程（只进行了 2 次数据拷贝）。 网卡DMA 第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里； 第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝； 这就是所谓的零拷贝（*Zero-copy*）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的 零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。 所以，总体来看，零拷贝技术可以把文件传输的性能提高至少一倍以上。 总结 使用mmap + write （4次上下文切换，上次文件拷贝） 减少一次文件copy 使用sendfile（2吃上下文切换，三次文件拷贝） 减少了2次上下文切换 减少一次文件copy 网卡支持SG-DMA（2次上下文切换， 两次文件拷贝（不需要CPU进行操作）） 减少了2次上下文切换 减少了2次文件拷贝 使用零拷贝技术的项目kafka使用零拷贝技术，消费者（consumer）从Kafka消费数据，Kafka从磁盘读数据然后发送到网络上去，数据一共发生了四次传输的过程。其中两次是 DMA 的传输，另外两次，则是通过 CPU 控制的传输。通过零拷贝技术，避免了文件的多余的copy次数，以及CPU的参与，进而能够更好的提升整体的性能，优化CPU的使用。 Java transferTopublic static void copyFileByChannel(File source, File dest) throws IOException { try (FileChannel sourceChannel = new FileInputStream(source) .getChannel(); FileChannel targetChannel = new FileOutputStream(dest).getChannel()) { for (long count = sourceChannel.size(); count &gt; 0; ) { long transferred = sourceChannel.transferTo( sourceChannel.position(), count, targetChannel); sourceChannel.position(sourceChannel.position() + transferred); count -= transferred; } } } references 原来 8 张图，就可以搞懂「零拷贝」了","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://winniekun.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://winniekun.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Dubbo和Spring、SpringBoot的结合简单Demo","slug":"rpc/dubbo-demo","date":"2021-09-05T11:45:28.000Z","updated":"2021-09-07T16:50:20.349Z","comments":true,"path":"dubbo-demo/","link":"","permalink":"https://winniekun.github.io/dubbo-demo/","excerpt":"","text":"序dubbo和Spring、SpringBoot的集合 环境 Spring （说白了就是两个进程的通信，然后将dubbo交由spring来管理，我们需要做的就是进行配置，然后按照文档硬编码） &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring.version&gt;5.3.4&lt;/spring.version&gt; &lt;dubbo.version&gt;2.7.8&lt;/dubbo.version&gt; &lt;curator.version&gt;4.2.0&lt;/curator.version&gt; &lt;zk.version&gt;3.5.8&lt;/zk.version&gt; &lt;/properties&gt; SpringBoot &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.wkk.dubbo&lt;/groupId&gt; &lt;artifactId&gt;provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;provider&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.wkk.dubbo&lt;/groupId&gt; &lt;artifactId&gt;api&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 和Spring的结合(未配置ZK) dubbo和spring的结合 pom.xml: &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.wkk&lt;/groupId&gt; &lt;artifactId&gt;spring-dubbo-demo&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;dubbo-provider&lt;/module&gt; &lt;module&gt;dubbo-consumer&lt;/module&gt; &lt;module&gt;dubbo-api&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring.version&gt;5.3.4&lt;/spring.version&gt; &lt;dubbo.version&gt;2.7.8&lt;/dubbo.version&gt; &lt;curator.version&gt;4.2.0&lt;/curator.version&gt; &lt;zk.version&gt;3.5.8&lt;/zk.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;${dubbo.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;${zk.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;${curator.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;${curator.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; API 公共接口，然后provider提供对该接口的实现，consumer对其发起调用 image-20210905233104405 package com.wkk.api; /** * @author weikunkun * @since 2021/9/5 */ public interface HelloApi { String hello(String name); } PROVIDER 负责对api的实现 dubbo-provider 配置&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. --&gt; &lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt; &lt;dubbo:application name=\"demo-provider\"/&gt; &lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt; &lt;!-- 声明对外暴露的接口 --&gt; &lt;dubbo:service registry=\"N/A\" interface=\"com.wkk.api.HelloApi\" ref=\"quickStartServiceApi\"/&gt; &lt;!--配置bean实例--&gt; &lt;bean id=\"quickStartServiceApi\" class=\"com.wkk.provider.api.HelloApiImpl\"/&gt; &lt;/beans&gt; 依赖&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;spring-dubbo-demo&lt;/artifactId&gt; &lt;groupId&gt;com.wkk&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;dubbo-provider&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.wkk&lt;/groupId&gt; &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 相关实现：API实现： package com.wkk.provider.api; import com.wkk.api.HelloApi; /** * @author weikunkun * @since 2021/9/5 */ public class HelloApiImpl implements HelloApi { public String hello(String name) { return \"this is dubbot quick starter, name = \" + name; } } 启动类： package com.wkk.provider; import org.springframework.context.support.ClassPathXmlApplicationContext; import java.io.IOException; /** * @author weikunkun * @since 2021/9/5 */ public class ProviderClient { public static void main(String[] args) throws IOException { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"dubbo-provider.xml\"); context.start(); System.in.read(); } } CONSUMER 负责调用对应的接口，为了方便起见，具体的调用直接在consumer中的启动类进行操作 dubbo-consumer 配置&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. --&gt; &lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt; &lt;dubbo:application name=\"consumer-of-helloworld-app\" /&gt; &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt; &lt;dubbo:reference id=\"demoService\" interface=\"com.wkk.api.HelloApi\" url=\"dubbo://xxxx:20880\"/&gt; &lt;/beans&gt; 依赖&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;spring-dubbo-demo&lt;/artifactId&gt; &lt;groupId&gt;com.wkk&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;dubbo-consumer&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.wkk&lt;/groupId&gt; &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 相关实现启动类 package com.wkk.consumer; import com.wkk.api.HelloApi; import org.springframework.context.support.ClassPathXmlApplicationContext; import java.util.Scanner; /** * @author weikunkun * @since 2021/9/5 */ public class ConsumerClient { public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"dubbo-consumer.xml\"); HelloApi demoService = (HelloApi) context.getBean(\"demoService\"); while (true) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); System.out.println(demoService.hello(str)); } } } 最终结果 成果展示 和SpringBoot的结合(未配置ZK) 整体和Spring结合一致 API 公共接口，然后provider提供对该接口的实现，consumer对其发起调用 api 接口的设计 package com.wkk.dubbo.api; /** * @author weikunkun * @since 2021/9/6 */ public interface HelloApi { String hello(String name); } PROVIDER配置dubbo: application: name: demo-provider registry: address: N/A protocol: name: dubbo port: 20880 依赖&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.wkk.dubbo&lt;/groupId&gt; &lt;artifactId&gt;provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;provider&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.wkk.dubbo&lt;/groupId&gt; &lt;artifactId&gt;api&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 相关实现package com.wkk.dubbo.provider.impl; import com.wkk.dubbo.api.HelloApi; import org.apache.dubbo.config.annotation.DubboService; import org.apache.dubbo.rpc.RpcContext; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; /** * @author weikunkun * @since 2021/9/6 */ @Component @DubboService(version = \"1.0.0\") public class HelloApiImpl implements HelloApi { private static final Logger logger = LoggerFactory.getLogger(HelloApiImpl.class); @Override public String hello(String name) { try { Thread.sleep(200); // logger.info(\"Hello \" + name + \", request from consumer: \" + RpcContext.getServerContext().getRemoteAddress()); return \"Hello \" + name + \", response from provider: \" + RpcContext.getServerContext().getLocalAddress(); } catch (InterruptedException e) { e.printStackTrace(); } return null; } } CONSUMER配置spring: application: name: dubbo-consumer 依赖&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.wkk.consumer&lt;/groupId&gt; &lt;artifactId&gt;consumer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;consumer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.wkk.dubbo&lt;/groupId&gt; &lt;artifactId&gt;api&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 相关实现DemoServiceComponent： 用于调用provider中对应的实现方法 package com.wkk.consumer.consumer.comp; import com.wkk.dubbo.api.HelloApi; import org.apache.dubbo.config.annotation.DubboReference; import org.springframework.stereotype.Component; /** * @author weikunkun * @since 2021/9/7 */ @Component public class DemoServiceComponent implements HelloApi { @DubboReference(version = \"1.0.0\", url = \"dubbo://xxxx:20880\") private HelloApi helloApi; @Override public String hello(String name) { return helloApi.hello(name); } } ConsumerApplication： 启动类，通过Scanner做了交互 package com.wkk.consumer.consumer; import com.wkk.dubbo.api.HelloApi; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ConfigurableApplicationContext; import java.util.Scanner; @SpringBootApplication public class ConsumerApplication { public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(ConsumerApplication.class, args); HelloApi demoService = (HelloApi) context.getBean(\"demoServiceComponent\"); Scanner sc = new Scanner(System.in); while (true) { String s = sc.nextLine(); System.out.println(demoService.hello(s)); } } } 最终结果 成果展示 源码链接源码","categories":[{"name":"dubbo","slug":"dubbo","permalink":"https://winniekun.github.io/categories/dubbo/"}],"tags":[{"name":"rpc","slug":"rpc","permalink":"https://winniekun.github.io/tags/rpc/"}]},{"title":"Kafka在Linux上的配置","slug":"配置/kafka-config","date":"2021-08-22T13:24:40.000Z","updated":"2021-08-22T14:35:22.469Z","comments":true,"path":"kafka-config/","link":"","permalink":"https://winniekun.github.io/kafka-config/","excerpt":"","text":"序Kafka简介Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个“按照分布式事务日志架构的大规模发布/订阅消息队列”，[3]这使它作为企业级基础设施来处理流式数据非常有价值。此外，Kafka可以通过Kafka Connect连接到外部系统（用于数据输入/输出），并提供了Kafka Streams——一个Java流式处理库)。 Kafka架构Kafka存储的消息来自任意多被称为“生产者”（Producer）的进程。数据从而可以被分配到不同的“分区”（Partition）、不同的“Topic”下。在一个分区内，这些消息被索引并连同时间戳存储在一起。其它被称为“消费者”（Consumer）的进程可以从分区查询消息。Kafka运行在一个由一台或多台服务器组成的集群上，并且分区可以跨集群结点分布。 Kafka高效地处理实时流式数据，可以实现与Storm、HBase和Spark的集成。作为聚类部署到多台服务器上，Kafka处理它所有的发布和订阅消息系统使用了四个API，即生产者API、消费者API、Stream API和Connector API。它能够传递大规模流式消息，自带容错功能，已经取代了一些传统消息系统，如JMS、AMQP等。 Kafka架构的主要术语包括Topic、Record和Broker。Topic由Record组成，Record持有不同的信息，而Broker则负责复制消息。Kafka有四个主要API： 生产者API：支持应用程序发布Record流。 消费者API：支持应用程序订阅Topic和处理Record流。 Stream API：将输入流转换为输出流，并产生结果。 Connector API：执行可重用的生产者和消费者API，可将Topic链接到现有应用程序。 环境依赖 JDK11 kafka_2.13-2.8.0.tgz 基础使用假设Kafka环境和Zookeeper环境都没有 1. 下载并解压&gt; tar -xzf kafka_2.13-2.8.0.tgz &gt; mv kafka_2.13-2.8.0.tgz /usr/local/kafka &gt; cd /usr/local/kafka 2. 启动服务 kafka的启动依赖于Java环境，所以在使用Kakfa之前，记得配置Java8+的环境 &gt; bin/zookeeper-server-start.sh config/zookeeper.properties 打开另一个命令终端启动kafka服务： ## 用于后台启动 &gt; bin/kafka-server-start.sh config/server.properties &amp; 一旦所有服务成功启动，那Kafka已经可以使用了。 3. 创建一个主题创建一个名为“test”的Topic，只有一个分区和一个备份： &gt; bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test 创建好之后，可以通过运行以下命令，查看已创建的topic信息： &gt; bin/kafka-topics.sh --describe --topic test --bootstrap-server localhost:9092 Topic:quickstart-events PartitionCount:1 ReplicationFactor:1 Configs: Topic: quickstart-events Partition: 0 Leader: 0 Replicas: 0 Isr: 0 4. 发送消息Kafka提供了一个命令行的工具，可以从输入文件或者命令行中读取消息并发送给Kafka集群。每一行是一条消息。 运行 producer（生产者）,然后在控制台输入几条消息到服务器。 &gt; bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test hello world what's your name 5. 消费消息Kafka也提供了一个消费消息的命令行工具，将存储的信息输出出来，新打开一个命令控制台，输入： &gt; bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning hello world what's your name 注意，若是在服务器开启kafka服务，然后本地消费生产的消息，需要在kafka中的 config/service.properties 中修改配置（注意开启服务器对应的端口） advertised.listeners=PLAINTEXT://your ip : your port 6. 使用 Kafka Connect 来 导入/导出 数据可能现有的系统中拥有大量的数据，如关系型数据库或传统的消息传递系统，以及许多已经使用这些系统的应用程序。Kafka Connect允许你不断地从外部系统提取数据到Kafka，反之亦然。用Kafka整合现有的系统是非常容易的。为了使这个过程更加容易，有数百个这样的连接器现成可用。 7. 使用Kafka Stream来处理数据一旦我们的数据存储在Kafka中，就可以用Kafka Streams客户端库来处理这些数据，该库适用于Java/Scala。它允许你实现自己的实时应用程序和微服务，其中输入和/或输出数据存储在Kafka主题中。Kafka Streams将在客户端编写和部署标准Java和Scala应用程序的简单性与Kafka服务器端集群技术的优势相结合，使这些应用程序具有可扩展性、弹性、容错性和分布式。该库支持精确的一次性处理、有状态操作和聚合、窗口化、连接、基于事件时间的处理等等。 一个初步的体验，实现一个流行的WordCount算法的： KStream&lt;String, String&gt; textLines = builder.stream(\"quickstart-events\"); KTable&lt;String, Long&gt; wordCounts = textLines .flatMapValues(line -&gt; Arrays.asList(line.toLowerCase().split(\" \"))) .groupBy((keyIgnored, word) -&gt; word) .count(); wordCounts.toStream().to(\"output-topic\", Produced.with(Serdes.String(), Serdes.Long())); 以系统服务方式启动kafka创建 /usr/lib/systemd/system/zookeeper.service 并写入 [Unit] Requires=network.target After=network.target [Service] Type=simple Environment=\"PATH=/opt/jdk-11.0.12/bin:/opt/jdk-11.0.12/jre/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\" LimitNOFILE=1048576 ExecStart=/usr/local/kafka/bin/zookeeper-server-start.sh /usr/local/kafka/config/zookeeper.properties ExecStop=/usr/local/kafka/bin/zookeeper-server-stop.sh Restart=Always [Install] WantedBy=multi-user.target 创建 /usr/lib/systemd/system/kafka.service 并写入 [Unit] Requires=zookeeper.service After=zookeeper.service [Service] Type=simple Environment=\"PATH=/opt/jdk-11.0.12/bin:/opt/jdk-11.0.12/jre/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\" LimitNOFILE=1048576 ExecStart=/usr/local/kafka/bin/kafka-server-start.sh /usr/local/kafka/config/server.properties ExecStop=/usr/local/kafka/bin/kafka-server-stop.sh Restart=Always [Install] WantedBy=multi-user.target 注意：示例的kafka安装地址在 /usr/local/kafka 因为系统服务不会直接读取我们配置在/etc/profile或者bash_profile中的环境变量，所以Environment一定要记得配置。 ## 查看当前环境变量 export $PATH 启动服务重载系统服务并启动 systemctl daemon-reload systemctl enable zookeeper &amp;&amp; systemctl enable kafka systemctl start zookeeper &amp;&amp; systemctl start kafka systemctl status zookeeper &amp;&amp; systemctl status kafka zookeeper kafka references 维基百科—-kafka Kafka教程","categories":[{"name":"kafka","slug":"kafka","permalink":"https://winniekun.github.io/categories/kafka/"}],"tags":[{"name":"配置","slug":"配置","permalink":"https://winniekun.github.io/tags/%E9%85%8D%E7%BD%AE/"}]},{"title":"虚拟内存概览","slug":"操作系统/virtual-memory","date":"2021-07-27T06:57:30.000Z","updated":"2021-08-09T10:11:43.891Z","comments":true,"path":"virtual-memory/","link":"","permalink":"https://winniekun.github.io/virtual-memory/","excerpt":"","text":"序 “Any problem in computer science can be solved by another layer of indirection. ——程序员的自我修养 物理寻址早期，CPU在处理某个进程的时候，处理的流程如下。 对于物理寻址而言，我们需要直接将程序全部装入到物理内存中，接下来运行期间，CPU在处理时，直接进行物理寻址。然后执行相关的读写命令。 对于物理内存而言，是不做任何访问限制的，所以直接操作进行物理寻址会导致一个问题是： 读写内存的安全性问题 不同的进程被分配到不同的物理内存中，运行期间导致进程A错误修改了进程B占用的物理内存，导致进程B出现问题 危害操作系统自身的安全。恶意的进程直接修改操作系统所占用的物理空间，导致系统崩溃 内存的利用率不高 一个系统中，不同的进程是共享CPU和物理内存资源的，如果有很多的进程需要很大的内存，那么就会导致这些进程所需的内存大小 &gt; 实际的物理内存，这样就会导致有些有些进程无法被执行。 所以，为了更加有效的管理内存并且少出错，现代的操作系统提供了一种对主存的抽象概念—-虚拟内存。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘和内核软件的完美交互 虚拟内存概念 虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。现代所有用于一般应用的操作系统都对普通的应用程序使用虚拟内存技术，老一些的操作系统，如DOS和1980年代的Windows，或者那些1960年代的大型机，一般都没有虚拟内存的功能——维基百科 引入序中所引用的话Any problem in computer science can be solved by another layer of indirection. 同理虚拟内存为进程&lt;---&gt;物理内存的中间层，它为进程隐藏了物理内存的概念，同时为其提供了更加简洁易用的接口，供其调用。同时还提供了一些更加复杂的功能。 能力一：高速缓存我们可以将虚拟内存看作是磁盘上的一片空间，当这片空间中的一部分访问比较频繁时，该部分数据会以页为单位被缓存到主存中以加速 CPU 访问数据的性能，虚拟内存利用空间较大的磁盘存储作为『内存』并使用主存储缓存进行加速，让进程认为操作系统的内存很大而且很快，然而区域很大的磁盘并不快，而很快的内存也并不大。 虚拟内存作为缓存 在虚拟内存中的虚拟页共分为三种类型： 未分配 没有被进程申请使用的，也就是空闲的虚拟内存， 不占用虚拟内存磁盘的任何空间 未缓存 仅仅加载到磁盘中的页 已缓存 已经加载到内存中的内存页（页框） 能力二：内存管理 简化链接和加载 简化内存共享 将不同的进程中的页表中某些页表项映射到相同的物理地址，即可实现内存的共享。 简化内存分配 独立的虚拟内存空间也会简化内存的分配过程，当用户程序向操作系统申请堆内存时，操作系统可以分配几个连续的虚拟页，但是这些虚拟页可以对应到物理内存中不连续的页中。 能力三：内存保护现代操作系统中，用户进程不应该被允许修改它的只读代码段，而且也不应该允许它读取或修改任何内核中的代码和数据结构，并且也不允许其读取或者修改其他进程的私有内存，以及修改和其他进程共享的虚拟页面。如果不对进程的内存访问进行限制，攻击者就能够访问和修改其他进程的私有内存，进而导致整个系统崩溃。 通过虚拟内存，我们为进程提供了独立的地址空间，同时这也让我们能够快速的区分不同进程的私有内存。同时我们通过虚拟内存到实际的物理内存的转化需要使用地址翻译机制，整体流程如下所示： 虚拟寻址方式 通过MMU，每次都会读取页表中的一个页表条目(PTE)，通过在这些页表条目(PTE)中添加一些标志位，就能够实现对一个虚拟页的访问控制权限。譬如： 带标志位的页表 应用程序如何如何使用和管理虚拟内存 [ ] TODO 总结虚拟内存的思想，整体来看就是：通过结合磁盘和内存各自的优势，利用中间层对资源进行更合理地调度，充分提高资源的利用率。并提供和谐以及统一的抽象。个人目前接触到的最直观的体现就是 JDK中集合类的设计与实现。其也可以算是数据和数据结构之间的中间层，结合其他的技术譬如泛型，为上层的数据提供了接口的同时，隐藏了内部数据结构的实现以及维护。 最后再总结下为什么需要虚拟内存： 虚拟内存可以结合磁盘和物理内存的优势为进程提供看起来速度足够快并且容量足够大的存储； 虚拟内存可以为进程提供独立的内存空间并引入多层的页表结构将虚拟内存翻译成物理内存，进程之间可以共享物理内存减少开销，也能简化程序的链接、装载以及内存分配过程； 虚拟内存可以控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性； references csapp 第九章 操作系统导论 内存虚拟化部分 为什么Linux需要虚拟内存 如何理解虚拟内存","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://winniekun.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"内存管理","slug":"内存管理","permalink":"https://winniekun.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"ConcurrentHashMap源码分析","slug":"源码/JDK/map/concurrenthashmap-analysis","date":"2021-07-19T10:40:55.000Z","updated":"2021-07-19T13:56:53.865Z","comments":true,"path":"concurrenthashmap-analysis/","link":"","permalink":"https://winniekun.github.io/concurrenthashmap-analysis/","excerpt":"","text":"序ConcurrentHashMap，可以理解成是HashMap的线程安全版本，同样的，内部使用也是（数组 + 链表 + 红黑树）的结构来存储元素。同时相比于同样提供线程安全的HashTable，效率等各方面都有所提升 概述 ConcurrentHashMap 阅读套路按照正常的逻辑， 首先基础的数据构造, 然后了解其构造方法， 之后了解常用的API(CRUD)操作即可。 [x] 增 [x] 删 [x] 改 [x] 查 类的属性// 和hashmap类似 transient volatile Node&lt;K,V&gt;[] table; // 用于并发情况下的扩容控制 private transient volatile Node&lt;K,V&gt;[] nextTable; // 并发安全控制 private transient volatile long baseCount; private transient volatile int sizeCtl; private transient volatile int transferIndex; private transient volatile int cellsBusy; private transient volatile CounterCell[] counterCells; // views private transient KeySetView&lt;K,V&gt; keySet; private transient ValuesView&lt;K,V&gt; values; private transient EntrySetView&lt;K,V&gt; entrySet; private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * The default initial table capacity. Must be a power of 2 * (i.e., at least 1) and at most MAXIMUM_CAPACITY. */ private static final int DEFAULT_CAPACITY = 16; /** * The largest possible (non-power of two) array size. * Needed by toArray and related methods. */ static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * The default concurrency level for this table. Unused but * defined for compatibility with previous versions of this class. */ private static final int DEFAULT_CONCURRENCY_LEVEL = 16; /** * The load factor for this table. Overrides of this value in * constructors affect only the initial table capacity. The * actual floating point value isn't normally used -- it is * simpler to use expressions such as {@code n - (n &gt;&gt;&gt; 2)} for * the associated resizing threshold. */ private static final float LOAD_FACTOR = 0.75f; /** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2, and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */ static final int TREEIFY_THRESHOLD = 8; /** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */ static final int UNTREEIFY_THRESHOLD = 6; /** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * The value should be at least 4 * TREEIFY_THRESHOLD to avoid * conflicts between resizing and treeification thresholds. */ static final int MIN_TREEIFY_CAPACITY = 64; /** * Minimum number of rebinnings per transfer step. Ranges are * subdivided to allow multiple resizer threads. This value * serves as a lower bound to avoid resizers encountering * excessive memory contention. The value should be at least * DEFAULT_CAPACITY. */ private static final int MIN_TRANSFER_STRIDE = 16; /** * The number of bits used for generation stamp in sizeCtl. * Must be at least 6 for 32bit arrays. */ private static int RESIZE_STAMP_BITS = 16; /** * The maximum number of threads that can help resize. * Must fit in 32 - RESIZE_STAMP_BITS bits. */ private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1; /** * The bit shift for recording size stamp in sizeCtl. */ private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS; /* * Encodings for Node hash fields. See above for explanation. */ static final int MOVED = -1; // hash for forwarding nodes static final int TREEBIN = -2; // hash for roots of trees static final int RESERVED = -3; // hash for transient reservations static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash /** Number of CPUS, to place bounds on some sizings */ static final int NCPU = Runtime.getRuntime().availableProcessors(); 构造方法public ConcurrentHashMap() { } public ConcurrentHashMap(int initialCapacity) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(); int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); this.sizeCtl = cap; } public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) { this.sizeCtl = DEFAULT_CAPACITY; putAll(m); } public ConcurrentHashMap(int initialCapacity, float loadFactor) { this(initialCapacity, loadFactor, 1); } public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (initialCapacity &lt; concurrencyLevel) // Use at least as many bins initialCapacity = concurrencyLevel; // as estimated threads long size = (long)(1.0 + (long)initialCapacity / loadFactor); int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)size); this.sizeCtl = cap; } 构造方法与HashMap对比可以发现，没有了HashMap中的threshold和loadFactor，而是改用了sizeCtl来控制，而且只存储了容量在里面，那么它是怎么用的呢？官方给出的解释如下： Table initialization and resizing control. When negative, the table is being initialized or resized: -1 for initialization, else -(1 + the number of active resizing threads). Otherwise, when table is null, holds the initial table size to use upon creation, or 0 for default. After initialization, holds the next element count value upon which to resize the table. -1 有线程正在初始化 -(1 + n) 有n个线程正在一起扩容 0 默认值， 后续在真正初始化的时候使用默认容量 &gt;0 初始化或扩容完成后下一次的扩容门槛 增public V put(K key, V value) { return putVal(key, value, false); } /** Implementation for put and putIfAbsent */ final V putVal(K key, V value, boolean onlyIfAbsent) { // key和value都不能为null if (key == null || value == null) throw new NullPointerException(); // 计算hash值 int hash = spread(key.hashCode()); // 要插入的元素所在桶的元素个数 int binCount = 0; // 死循环，结合CAS使用（如果CAS失败，则会重新取整个桶进行下面的流程） for (Node&lt;K,V&gt;[] tab = table;;) { Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) // 如果桶未初始化或者桶个数为0，则初始化桶 tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) { // 如果要插入的元素所在的桶还没有元素，则把这个元素插入到这个桶中 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) // 如果使用CAS插入元素时，发现已经有元素了，则进入下一次循环，重新操作 // 如果使用CAS插入元素成功，则break跳出循环，流程结束 break; // no lock when adding to empty bin } else if ((fh = f.hash) == MOVED) // 如果要插入的元素所在的桶的第一个元素的hash是MOVED，则当前线程帮忙一起迁移元素 tab = helpTransfer(tab, f); else { // 如果这个桶不为空且不在迁移元素，则锁住这个桶（分段锁） // 并查找要插入的元素是否在这个桶中 // 存在，则替换值（onlyIfAbsent=false） // 不存在，则插入到链表结尾或插入树中 V oldVal = null; synchronized (f) { // 再次检测第一个元素是否有变化，如果有变化则进入下一次循环，从头来过 if (tabAt(tab, i) == f) { // 如果第一个元素的hash值大于等于0（说明不是在迁移，也不是树） // 那就是桶中的元素使用的是链表方式存储 if (fh &gt;= 0) { // 桶中元素个数赋值为1 binCount = 1; // 遍历整个桶，每次结束binCount + 1 for (Node&lt;K,V&gt; e = f;; ++binCount) { K ek; // 在链表中找到了改元素，覆盖 并退出 if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } // 如果没有找到 则 直接在尾部插入改元素 Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) { pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; } } } // 树上找点 else if (f instanceof TreeBin) { Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } // 如果binCount不为0，说明成功插入了元素或者寻找到了元素 if (binCount != 0) { // 如果链表元素个数达到了8，则尝试树化 // 因为上面把元素插入到树中时，binCount只赋值了2，并没有计算整个树中元素的个数 // 所以不会重复树化 if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } // 成功插入元素，元素个数加1（是否要扩容在这个里面） addCount(1L, binCount); return null; } 流程和hashmap类似： 如果hash桶未初始化，则先初始化 如果当前位置无元素，则通过cas的方式放入元素 如果当前位置存在元素 是转移节点（正在扩容），则将当前线程一起加入到扩容中 不是转移节点，锁这个桶 如果为链表节点，进行在链表上查找该元素，找到？覆盖：执行插入操作 如果为树节点，在红黑树中查找该元素，找到？覆盖：执行插入操作 存在该元素时，返回旧value 不存在，整个map的元素+ 1，并检查是否需要扩容 因为是线程安全的操作，所以仔细看下在整个put阶段，采用了哪些手段保证线程安全。这个才是我们看CHM源码的关键 数组初始化时的线程安全措施private final Node&lt;K,V&gt;[] initTable() { Node&lt;K,V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) { // 小于 0 代表有线程正在初始化，释放当前 CPU 的调度权，重新发起锁的竞争 if ((sc = sizeCtl) &lt; 0) Thread.yield(); // lost initialization race; just spin // CAS 赋值保证当前只有一个线程在初始化， // -1 代表当前只有一个线程能初始化 // 保证了数组的初始化的安全性 else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { try { // 很有可能执行到这里的时候，table 已经不为空了，这里是双重 check // 如果把sizeCtl原子更新为-1成功，则当前线程进入初始化 // 如果原子更新失败则说明有其它线程先一步进入初始化了，则进入下一次循环 // 如果下一次循环时还没初始化完毕，则sizeCtl&lt;0进入上面if的逻辑让出CPU // 如果下一次循环更新完毕了，则table.length!=0，退出循环 if ((tab = table) == null || tab.length == 0) { // 进行初始化 int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(\"unchecked\") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = tab = nt; sc = n - (n &gt;&gt;&gt; 2); } } finally { sizeCtl = sc; } break; } } return tab; } 小总结 数组初始化时： 使用CAS锁控制只有一个线程初始化桶数组并且一定能初始化成功； 然后通过 CAS 设置 sizeCtl 变量的值，来保证同一时刻只能有一个线程对数组进行初始化，CAS 成功之后，还会再次判断当前数组 是否已经初始化完成，如果已经初始化完成，就不会继续再执行初始化 扩容门槛写死的是桶数组大小的0.75倍，桶数组大小即map的容量，也就是最多存储多少个元素。 通过自旋 + cas + double check 保障了数组初始化时的线程安全。 Java线程中的一些方法的区别（sleep、yield、wait、join）只有runnable到running时才会占用cpu时间片，其他都会出让cpu时间片。线程的资源有不少，整体来看可分为如下两类 CPU资源 锁资源 分析以上四个方法时，查看这两个共享资源是否释放，区分更加明显 sleep：Thread类的方法，必须带一个时间参数。会让当前线程休眠进入阻塞状态并释放CPU（阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段），提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁 可通过调用interrupt()方法来唤醒休眠线程。 yield：让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 ，并且yield()方法只能让同优先级的线程有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。 wait：Object类的方法(notify()、notifyAll() 也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁 join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。 在桶位置放入元素时的线程安全措施（4个措施）else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) { if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin } static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) { return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v); } 通过自旋死循环保证一定可以新增成功 1⃣️ 在新增之前，通过==for (Node[] tab = table;;)==这样的死循环来保证新增一定可以成功，一旦新增成功，就可以退出当前死循环，新增失败的话，会重复新增的步骤，直到新增成功为止。 当前hash桶是否有元素： 无元素 cas 新增 2⃣️ Java 这里的写法非常严谨，没有在判断槽点为空的情况下直接赋值，因为在判断槽点为空和赋 值的瞬间，很有可能槽点已经被其他线程赋值了，所以我们采用 CAS 算法，能够保证槽点为空 的情况下赋值成功，如果恰好槽点已经被其他线程赋值，当前 CAS 操作失败，会再次执行 for 自旋，再走槽点有值的 put 流程，这里就是自旋 + CAS 的结合。 有元素 锁住当前点 （synchronized）3⃣️ put 时，如果当前槽点有值，就是 key 的 hash 冲突的情况，此时槽点上可能是链表或红黑树， 我们通过锁住槽点，来保证同一时刻只会有一个线程能对槽点进行修改 红黑树旋转时， 锁住红黑树的根节点，保证同一时刻，当前红黑树只能被一个线程旋转 4⃣️ 扩容时的线程安全措施ConcurrentHashMap 的扩容时机和 HashMap 相同，都是在 put 方法的最后一步检查是否需要扩 容，如果需要则进行扩容，但两者扩容的过程完全不同，ConcurrentHashMap 扩容的方法叫做 transfer，从 put 方法的 addCount 方法进去，就能找到 transfer 方法 private final void addCount(long x, int check) { CounterCell[] as; long b, s; // 这里使用的思想跟LongAdder类是一模一样的（后面会讲） // 把数组的大小存储根据不同的线程存储到不同的段上（也是分段锁的思想） // 并且有一个baseCount，优先更新baseCount，如果失败了再更新不同线程对应的段 // 这样可以保证尽量小的减少冲突 // 先尝试把数量加到baseCount上，如果失败再加到分段的CounterCell上 if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) { CounterCell a; long v; int m; boolean uncontended = true; if (as == null || (m = as.length - 1) &lt; 0 || (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) { fullAddCount(x, uncontended); return; } if (check &lt;= 1) return; s = sumCount(); } if (check &gt;= 0) { Node&lt;K,V&gt;[] tab, nt; int n, sc; while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) { int rs = resizeStamp(n); if (sc &lt; 0) { if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); } else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); s = sumCount(); } } } // 真正触发扩容的方式 // 扩容主要分 2 步， // 1. 第一新建新的空数组， // 2. 第二移动拷贝每个元素到新数组中去 // tab:原数组，nextTab:新数组 private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) { // 老数组的长度 int n = tab.length, stride; if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range // 如果新数组为空，初始化，大小为原数组的两倍，n &lt;&lt; 1 if (nextTab == null) { // initiating try { @SuppressWarnings(\"unchecked\") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; nextTab = nt; } catch (Throwable ex) { // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; } nextTable = nextTab; transferIndex = n; } // 新的table长度 int nextn = nextTab.length; // 代表转移节点，如果原数组上是转移节点，说明该节点正在被扩容 (node的hash值为-1) ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); boolean advance = true; boolean finishing = false; // to ensure sweep before committing nextTab // 无限自旋，i 的值会从原数组的最大值开始，慢慢递减到 0 for (int i = 0, bound = 0;;) { Node&lt;K,V&gt; f; int fh; while (advance) { int nextIndex, nextBound; // 结束循环的标志 if (--i &gt;= bound || finishing) advance = false; // 已经拷贝完成 else if ((nextIndex = transferIndex) &lt;= 0) { i = -1; advance = false; } // 每次减少 i 的值 else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) { bound = nextBound; i = nextIndex - 1; advance = false; } } // if 任意条件满足说明拷贝结束了 if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) { int sc; // 拷贝结束，直接赋值，因为每次拷贝完一个节点，都在原数组上放转移节点，所以拷 贝完成的节点的数据一定不会再发生变化。 // 原数组发现是转移节点，是不会操作的，会一直等待转移节点消失之后在进行操作。 // 也就是说数组节点一旦被标记为转移节点，是不会再发生任何变动的，所以不会有任 何线程安全的问题 // 所以此处直接赋值，没有任何问题。 if (finishing) { nextTable = null; table = nextTab; sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); return; } if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) { if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) return; finishing = advance = true; i = n; // recheck before commit } } else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd); else if ((fh = f.hash) == MOVED) advance = true; // already processed else { // 进行节点的拷贝 synchronized (f) { if (tabAt(tab, i) == f) { Node&lt;K,V&gt; ln, hn; if (fh &gt;= 0) { int runBit = fh &amp; n; Node&lt;K,V&gt; lastRun = f; for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) { int b = p.hash &amp; n; if (b != runBit) { runBit = b; lastRun = p; } } if (runBit == 0) { ln = lastRun; hn = null; } else { hn = lastRun; ln = null; } // 桶内只有的单个数据， 直接拷贝，为链表，循环多次形成链表拷贝 for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) { int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); else hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); } // 在新数组位置上放置拷贝的值 setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); // 在老数组位置上放上 ForwardingNode 节点 // put 时，发现是 ForwardingNode 节点，就不会再动这个节点的数 setTabAt(tab, i, fwd); advance = true; } // 红黑树的拷贝 else if (f instanceof TreeBin) { TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null; TreeNode&lt;K,V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) { int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt; (h, e.key, e.val, null, null); if ((h &amp; n) == 0) { if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; } else { if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; } } ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; } } } } } } 小结transfer方法的主要思路： 首先需要把老数组的值全部拷贝到扩容之后的新数组上，先从数组的队尾开始拷贝 拷贝数组的槽点时，先把原数组槽点锁住，保证原数组槽点不能操作，成功拷贝到新数组时， 把原数组槽点赋值为转移节点 这时如果有新数据正好需要 put 到此槽点时，发现槽点为转移节点，就会一直等待，所以在 扩容完成之前，该槽点对应的数据是不会发生变化的 从数组的尾部拷贝到头部，每拷贝成功一次，就把原数组中的节点设置成转移节点; 直到所有数组数据都拷贝到新数组时，直接把新数组整个赋值给数组容器，拷贝完成。 通过在原数组上设置转移节点，put 时碰到转移节点时会等待扩容成 功之后才能 put 的策略，来保证了整个扩容过程中肯定是线程安全的，因为数组的槽点一旦被设 置成转移节点，在没有扩容完成之前，是无法进行操作的。 （1）新桶数组大小是旧桶数组的两倍； （2）迁移元素先从靠后的桶开始； （3）迁移完成的桶在里面放置一ForwardingNode类型的元素，标记该桶迁移完成； （4）迁移时根据hash&amp;n是否等于0把桶中元素分化成两个链表或树； （5）低位链表（树）存储在原来的位置； （6）高们链表（树）存储在原来的位置加n的位置； （7）迁移元素时会锁住当前桶，也是分段锁的思想； 改查删总结（1）ConcurrentHashMap是HashMap的线程安全版本； （2）ConcurrentHashMap采用（数组 + 链表 + 红黑树）的结构存储元素； （3）ConcurrentHashMap相比于同样线程安全的HashTable，效率要高很多； （4）ConcurrentHashMap采用的锁有 synchronized，CAS，自旋锁，分段锁，volatile等； （5）ConcurrentHashMap中没有threshold和loadFactor这两个字段，而是采用sizeCtl来控制； （6）sizeCtl = -1，表示正在进行初始化； （7）sizeCtl = 0，默认值，表示后续在真正初始化的时候使用默认容量； （8）sizeCtl &gt; 0，在初始化之前存储的是传入的容量，在初始化或扩容后存储的是下一次的扩容门槛； （9）sizeCtl = (resizeStamp &lt;&lt; 16) + (1 + nThreads)，表示正在进行扩容，高位存储扩容邮戳，低位存储扩容线程数加1； （10）更新操作时如果正在进行扩容，当前线程协助扩容； （11）更新操作会采用synchronized锁住当前桶的第一个元素，这是分段锁的思想； （12）整个扩容过程都是通过CAS控制sizeCtl这个字段来进行的，这很关键； （13）迁移完元素的桶会放置一个ForwardingNode节点，以标识该桶迁移完毕； （14）元素个数的存储也是采用的分段思想，类似于LongAdder的实现； （15）元素个数的更新会把不同的线程hash到不同的段上，减少资源争用； （16）元素个数的更新如果还是出现多个线程同时更新一个段，则会扩容段（CounterCell）； （17）获取元素个数是把所有的段（包括baseCount和CounterCell）相加起来得到的； （18）查询操作是不会加锁的，所以ConcurrentHashMap不是强一致性的； （19）ConcurrentHashMap中不能存储key或value为null的元素； 一些思想 cas + 自选 乐观锁的思想，减少线程上下文切换的时间 分段锁思想，减少同一时间 竞争锁带来的低效问题 CounterCell，分段存储元素，减少多线程同时更新一个字段带来的低效 多线程协同进行扩容","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"jdk","slug":"jdk","permalink":"https://winniekun.github.io/tags/jdk/"}]},{"title":"kafka-consumer-note","slug":"中间件/kafka-consumer-note","date":"2021-07-02T08:32:01.000Z","updated":"2021-08-28T05:45:49.455Z","comments":true,"path":"kafka-consumer-note/","link":"","permalink":"https://winniekun.github.io/kafka-consumer-note/","excerpt":"","text":"Mathjax$m_i = a ^ {21}$","categories":[{"name":"中间件","slug":"中间件","permalink":"https://winniekun.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://winniekun.github.io/tags/kafka/"}]},{"title":"ThreadLocal源码解读","slug":"源码/JDK/lang/threadlocal-analysis","date":"2021-05-27T13:21:59.000Z","updated":"2021-09-08T13:19:53.637Z","comments":true,"path":"threadlocal-analysis/","link":"","permalink":"https://winniekun.github.io/threadlocal-analysis/","excerpt":"","text":"序多线程共享可变数据时，涉及到线程见同步的问题，并不是所有的时候，都要用到共享数据，所以就需要线程封闭出场了。数据都被封闭在各自的线程之中，就不需要进行同步，这种通过将数据封闭在线程内而避免使用同步的技术称之为线程封闭。 适用场景 线程间数据隔离，各线程的 ThreadLocal 互不影响 方便同一个线程使用某一对象，避免不必要的参数传递 全链路追踪中的 traceId 或者流程引擎中上下文的传递一般采用 ThreadLocal Spring 事务管理器采用了 ThreadLocal Spring MVC 的 RequestContextHolder 的实现使用了 ThreadLocal Demopublic class ThreadLocalDemo { public static final ThreadLocal&lt;String&gt; THREAD_LOCAL = new ThreadLocal&lt;&gt;(); public static final ThreadLocal&lt;String&gt; THREAD_LOCAL_NEXT = new ThreadLocal&lt;&gt;(); @Test public void demo() { new ThreadLocalDemo().threadLocalTest(); } public void threadLocalTest() { THREAD_LOCAL.set(\"wkk\"); THREAD_LOCAL_NEXT.set(\"cjsq\"); String v = THREAD_LOCAL.get(); String v2 = THREAD_LOCAL_NEXT.get(); System.out.println(\"子线程 执行前， \" + Thread.currentThread().getName() + \"线程取到的值：\" + v + \" \" + v2); Thread child = new Thread(new Runnable() { @Override public void run() { String v = THREAD_LOCAL.get(); String v2 = THREAD_LOCAL_NEXT.get(); System.out.println(Thread.currentThread().getName() + \"线程取到的值：\" + v + v2); // 设置 threadLocal THREAD_LOCAL.set(\"hhh\"); THREAD_LOCAL_NEXT.set(\"cjpl\"); v = THREAD_LOCAL.get(); v2 = THREAD_LOCAL_NEXT.get(); System.out.println(\"重新设置之后，\" + Thread.currentThread().getName() + \"线程取到的值为：\" + v + \" \" + v2); System.out.println(Thread.currentThread().getName() + \"线程执行结束\"); } }, \"子线程\"); child.start(); try { child.join(); } catch (InterruptedException e) { e.printStackTrace(); } v = THREAD_LOCAL.get(); v2 = THREAD_LOCAL_NEXT.get(); System.out.println(\"子线程线程执行之后，\" + Thread.currentThread().getName() + \"线程取到的值：\" + v + \" \" + v2); } } 输出 子线程 执行前， main线程取到的值：wkk cjsq 子线程线程取到的值：nullnull 重新设置之后，子线程线程取到的值为：hhh cjpl 子线程线程执行结束 子线程线程执行之后，main线程取到的值：wkk cjsq 源码解读重要属性// Thread类 ThreadLocal.ThreadLocalMap threadLocals = null; // 当前threadlocal的hashcode // 用于用于计算该ThreadLocal在线程的threadlocals（map）中的索引位置 private final int threadLocalHashCode = nextHashCode(); // hash表的阈值，黄金分割比 private static final int HASH_INCREMENT = 0x61c88647; // 保证了在一台机器中每个 ThreadLocal 的 threadLocalHashCode 是唯一的 private static AtomicInteger nextHashCode = new AtomicInteger(); // 用于当前threadlocal的hashcode private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } // 初始话的操作 protected T initialValue() { return null; } // lambda的初始化实现 public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) { return new SuppliedThreadLocal&lt;&gt;(supplier); } HashCode散列成果验证可以通过和String的hashcode做个对比，然后验证其使用这种方式的hash结果如何 private static AtomicInteger nextHashCode = new AtomicInteger(); private static final int HASH_INCREMENT = 0x61c88647; private static final int SIZE = 32; private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } @Test public void test_idx() { int hashCode = 0; Set&lt;Integer&gt; setThreadLocal = new HashSet&lt;&gt;(); Set&lt;Integer&gt; setNormal = new HashSet&lt;&gt;(); for (int i = 0; i &lt; SIZE; i++) { hashCode = nextHashCode(); int threadLocalHashCode = hashCode &amp; (SIZE - 1); int normalHashCode = String.valueOf(i).hashCode() &amp; (SIZE - 1); setThreadLocal.add(threadLocalHashCode); setNormal.add(normalHashCode); System.out.println(i + \" ThreadLocal的散列：\" + threadLocalHashCode + \" 普通散列：\" + normalHashCode); } double threadLocalRate = setThreadLocal.size() / (double)SIZE * 100; double normalRate = setNormal.size() / (double)SIZE * 100; System.out.println(\"ThreadLocal的散列：\" + threadLocalRate + \"% \" + \" 普通散列：\" + normalRate + \"% \"); } // ThreadLocal的散列：100.0% 普通散列：68.75% 形象理解 ThreadLocal形象理解 如果类比为HashMap的话，我们可以将threadlocal类比为key，然后被封闭的数据类比为value。不过稍微不同的是，hashmap中将key和value做映射的操作是map.put(key, value)，而threadlocals中，将threadlocal和被封闭的数据做映射的操作是threadlocal.set(xxx)。 思路转换emmmm怎么说呢，就是我们使用普通map的时候，操作的是一个map，获取key的value时，直接通过map.get()即可。 但是我们使用threadlocal时，其本身是一个key，怎么获取对应的value呢？ 先获取map（每个线程独有的map，所以根据当前线程获取map） 然后通过map.get(key)获取value 返回value ThreadLocalMapstatic class ThreadLocalMap { /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as \"stale entries\" in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) { super(k); value = v; } } // 下面的成员变量和hashmap同理 // 初始化容量 private static final int INITIAL_CAPACITY = 16; // 存储ThreadLocal的键值对，长度为2的幂次 private Entry[] table; /** * The number of entries in the table. */ private int size = 0; /** * The next size value at which to resize. */ private int threshold; // Default to 0 } ThreadLocalMap就是一个map，和hashmap类似，不过有些机制不同。 hash冲突解决方式 ThreadLocalMap处理hash冲突的方式为线型探测 HashMap使用的是拉链法 ThreadLocal内存泄漏根据注释和代码，了解到了ThreadLocalMap内部的每个entry中，key设置为弱引用的原因，不过value还是正常的引用。这也就导致了如果ThreadLocal没有外部的强引用时，只要发生GC，就会被回收。这样ThreadMap中的key就变成了null，但是value被Entry引用，Entry被ThreadLocalMap引用，ThreadLocalMap被Thread引用，这也就说明了只要，线程不终止，value的值一直无法被回收，所以可能会出现内存泄漏的现象 为了避免这种情况，在需要使用threadlocal之后，需要我们手动remove掉。防止 ThreadLocalMap 中 Entry 一直保持对 value 的强引用，导致 value 不能被回收 removepublic void remove() { ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); } // 根据当前线程获取其map ThreadLocalMap getMap(Thread t) { return t.threadLocals; } // 因为使用的线型探测法 // 所以要采用线型探测法找到对应的位置 private void remove(ThreadLocal&lt;?&gt; key) { Entry[] tab = table; int len = tab.length; // 根据threadlocal获取其hashcode值 int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { if (e.get() == key) { e.clear(); expungeStaleEntry(i); return; } } } private static int nextIndex(int i, int len) { return ((i + 1 &lt; len) ? i + 1 : 0); } private int expungeStaleEntry(int staleSlot) { Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal&lt;?&gt; k = e.get(); if (k == null) { e.value = null; tab[i] = null; size--; } else { int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) { tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; } } } return i; } 通过当前线程获取该线程的map 然后调用map.remove方法 后续的代码分析不动了。。。 set/** * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the {@link #initialValue} * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */ public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } ThreadLocalMap getMap(Thread t) { return t.threadLocals; } set方法的作用是把我们想要存储的value给保存方法，只要流程是： 先获取当亲的线程 根据当前线程获取该线程的map 判断map是否为空 为空 创建map 不为空 在map中放入元素 set(ThreadLcoal&lt;?&gt; key, Object value)// 在map中存储键值对&lt;key, value&gt; private void set(ThreadLocal&lt;?&gt; key, Object value) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); // 遍历一段连续的元素，以查找匹配的 ThreadLocal 对象 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { // / 获取该哈希值处的ThreadLocal对象 ThreadLocal&lt;?&gt; k = e.get(); // 键值ThreadLocal匹配，直接更改map中的value if (k == key) { e.value = value; return; } // 若 key 是 null，说明 ThreadLocal 被清理了，直接替换掉 if (k == null) { replaceStaleEntry(key, value, i); return; } } // 直到遇见了空槽也没找到匹配的ThreadLocal对象，那么在此空槽处安排ThreadLocal对象和缓存的value tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); } 通过这两种set方式，就更加证明了思路的转换，我们在set时，都需要先获取当前线程获取map，然后再对整个map遍历然后放入value、或者直接放入key、value getpublic T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } return setInitialValue(); } // 根据threadlocal获取entry private Entry getEntry(ThreadLocal&lt;?&gt; key) { // 计算hashcode，然后获取对应的索引位置 int i = key.threadLocalHashCode &amp; (table.length - 1); // 根据索引位置获取对应的entry Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e); } private T setInitialValue() { T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; } 先获取当前线程 获取当前线程的map map != null 通过key直接获取对应entry 返回entry.value map == null 初始化map 总结threadlocal本质属于某种map的一个key值，只不过该值通过泛型实现，支持各种类型。和基础的map不同的是，可以直接通过key.set(value)实现key-value的映射。而这种特殊的map是属于Thread级别的成员变量，多个线程之间该变量互不影响，所以这也就是我们所说的线程本地存储地方。不过需要注意的是，该key是虚引用，需要注意内存泄露的问题，所以在使用过threadlocal之后，记得及时remove。内部的threadlocalmap和hashmap的实现机制类似，不过区别就是对于hash冲突的解决方式为线型探测 内存泄露问题什么是内存泄漏内存泄漏指的是，当某一个对象不再有用的时候，占用的内存却不能被回收，这就叫作内存泄漏。 因为通常情况下，如果一个对象不再有用，那么我们的垃圾回收器 GC，就应该把这部分内存给清理掉。这样的话，就可以让这部分内存后续重新分配到其他的地方去使用；否则，如果对象没有用，但一直不能被回收，这样的垃圾对象如果积累的越来越多，则会导致我们可用的内存越来越少，最后发生内存不够用的 OOM 错误。 下面我们来分析一下，在 ThreadLocal 中这样的内存泄漏是如何发生的。 Key 的泄漏分析了 ThreadLocal 的内部结构之后，知道了每一个 Thread 都有一个 ThreadLocal.ThreadLocalMap 这样的类型变量，该变量的名字叫作 threadLocals。线程在访问了 ThreadLocal 之后，都会在它的 ThreadLocalMap 里面的 Entry 中去维护该 ThreadLocal 变量与具体实例的映射。 我们可能会在业务代码中执行了 ThreadLocal instance = null 操作，想清理掉这个 ThreadLocal 实例，但是假设我们在 ThreadLocalMap 的 Entry 中强引用了 ThreadLocal 实例，那么，虽然在业务代码中把 ThreadLocal 实例置为了 null，但是在 Thread 类中依然有这个引用链的存在。 GC 在垃圾回收的时候会进行可达性分析，它会发现这个 ThreadLocal 对象依然是可达的，所以对于这个 ThreadLocal 对象不会进行垃圾回收，这样的话就造成了内存泄漏的情况。 references Java并发编程 面试官系统精讲Java源码及大厂真题 Java并发编程78讲 【细谈Java并发】谈谈ThreadLocal 一文搞懂 ThreadLocal 原理 为何每次用完 ThreadLocal 都要调用 remove()？——内存泄漏","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"lang","slug":"lang","permalink":"https://winniekun.github.io/tags/lang/"}]},{"title":"死磕双指针","slug":"LeetCode/stick-to-two-pointer","date":"2021-05-27T09:10:30.000Z","updated":"2021-05-27T09:10:30.816Z","comments":true,"path":"stick-to-two-pointer/","link":"","permalink":"https://winniekun.github.io/stick-to-two-pointer/","excerpt":"","text":"序双指针，一个看了脑子里就有画面的算法技巧，主要方式有： 快慢指针 譬如链表环系列问题 获取链表的第K个节点 应该也属于快慢指针吧 只不过是一个指针先移动一定步长，然后另一个两个指针再以同样的速度移动 头尾指针 适用于数组和字符串 根据使用场景，用于优化遍历的时间复杂度 滑动窗口 普通指针26. 删除有序数组中的重复项class Solution { public int removeDuplicates(int[] nums) { int i = 0; int N = nums.length; for (int j = 1; j &lt; N; j++) { if (nums[i] != nums[j]) { nums[++i] = nums[j]; } } return i + 1; } } // 通法 class Solution { public int removeDuplicates(int[] nums) { return process(nums, 1); } int process(int[] nums, int k) { int idx = 0; for (int x : nums) { if (idx &lt; k || nums[idx - k] != x) nums[idx++] = x; } return idx; } } 80. 删除有序数组中的重复项 IIpublic int removeDuplicates(int[] nums) { return process(nums, 2); } private int process(int[] nums, int k) { int idx = 0; for (int x : nums) { if (idx &lt; k || nums[idx - k] != x) { nums[idx++] = x; } } return idx; } 283. 移动零88. 合并两个有序数组归并排序的中的一个步骤 快慢指针环系列 141. 环形链表public boolean hasCycle(ListNode head) { if (head == null) { return false; } ListNode fast = head; ListNode slow = head; while (fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { return true; } } return false; } 142. 环形链表 II头尾指针可以理解为对整个数组的暴力搜索的优化，正常情况下，是得到所有的区间k的子数组，然后一次计算结果。双指针之后，可以在遍历的过程就的出结果，避免的重复的遍历，并且优化的了遍历的时间复杂度 11. 盛最多水的容器public int maxArea(int[] height) { // 双指针(头尾指针) int N = height.length; int left = 0; int right = N - 1; int area = 0; while (left &lt; right) { int hight = Math.min(height[left], height[right]); int innerArea = hight * (right - left); area = Math.max(area, innerArea); if (height[left] &lt; height[right]) { left++; } else { right--; } } return area; } 15. 三数之和public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { // 思路 // 核心思路：双指针 头尾指针 Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); int N = nums.length; for (int i = 0; i &lt; N - 2; i++) { int rst = -nums[i]; int left = i + 1; int right = N - 1; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } while (left &lt; right) { int cur = nums[left] + nums[right]; if (cur == rst) { res.add(new ArrayList&lt;&gt;(Arrays.asList(nums[i], nums[left], nums[right]))); // 处理后序重复的元素 while (left &lt; right &amp;&amp; nums[left + 1] == nums[left]) { left++; } while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) { right--; } left++; right--; } else if (cur &gt; rst) { right--; } else { left++; } } } return res; } 16. 最接近的三数之和和上述类似，不过不用考虑元素重复问题，但是需要考虑最近，所以使用一个变量，用于检测当前结果是否比之前更好。 public int threeSumClosest(int[] nums, int target) { int N = nums.length; Arrays.sort(nums); // 如何判断最近？ // min(closest, curDistance) int closest = Integer.MAX_VALUE; int res = nums[0] + nums[nums.length - 1] + nums[1]; for (int i = 0; i &lt; N - 2; i++) { int low = i + 1; int height = N - 1; while (low &lt; height) { int innerCur = nums[i] + nums[low] + nums[height]; if (innerCur &lt; target) { low++; } else if (innerCur &gt; target) { height--; } else { return target; } if (Math.abs(innerCur - target) &lt; closest) { closest = Math.abs(innerCur - target); res = innerCur; } } } return res; } 18. 四数之和同样的思路，不过可以做一些细节处理，提前退出循环。 public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) { List&lt;List&lt;Integer&gt;&gt; quadruplets = new ArrayList&lt;&gt;(); if (nums == null || nums.length &lt; 4) { return quadruplets; } Arrays.sort(nums); int length = nums.length; for (int i = 0; i &lt; length - 3; i++) { // 重复 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } // 不符合条件 if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) { break; } // 结果小 if (nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] &lt; target) { continue; } for (int j = i + 1; j &lt; length - 2; j++) { // 重复 if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) { continue; } // 不符合条件 if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) { break; } // 太小 if (nums[i] + nums[j] + nums[length - 2] + nums[length - 1] &lt; target) { continue; } int left = j + 1, right = length - 1; while (left &lt; right) { int sum = nums[i] + nums[j] + nums[left] + nums[right]; if (sum == target) { quadruplets.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) { left++; } left++; while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) { right--; } right--; } else if (sum &lt; target) { left++; } else { right--; } } } } return quadruplets; } 259. 较小的三数之和public int threeSumSmaller(int[] nums, int target) { Arrays.sort(nums); int N = nums.length; int count = 0; for (int i = 0; i &lt; N - 2; i++) { int left = i + 1; int right = N - 1; while (left &lt; right) { int innerCur = nums[i] + nums[left] + nums[right]; if (innerCur &lt; target) { int innerCount = right - left; count += innerCount; left++; } else { right--; } } } return count; } 30. 串联所有单词的子串滑动窗口209. 长度最小的子数组public int minSubArrayLen(int target, int[] nums) { int N = nums.length; int left = 0; int right = 0; int ans = Integer.MAX_VALUE; int sum = 0; while (right &lt; N) { sum += nums[right]; while (left &lt;= right &amp;&amp; sum &gt;= target) { ans = Math.min(ans, right - left + 1); sum -= nums[left]; left++; } right++; } return ans == Integer.MAX_VALUE ? 0 : ans; } 713. 乘积小于K的子数组双指针（滑动窗口）：left 和 right指针开始时均指向 nums数组的开头。 right指针遍历 nums数组，每遍历一个元素就更新一次乘积，即 product = product * nums[right]： 若当前更新后的 product &lt; k，则直接统计当前窗口中的元素个数（这恰好就是当前子数组中符合条件的全部子集个数） 我们每次都统计以nums[right]为结尾符合条件的子数组个数 若更新后的 product &gt;= k，则此时需要缩小窗口的大小，即令当前 product 除以当前 left 指针指向的元素值，然后令 left指针右移一位，直到当前的 produc &lt; k 为止，然后统计当前窗口中的元素个数，即为此时符合条件的子数组的个数，继续令 right 指针右移。 如此反复，直到 right 指针指向 nums 数组的末尾为止。 public int numSubarrayProductLessThanK(int[] nums, int k) { // 滑动窗口 int N = nums.length; int left = 0; int sum = 1; int count = 0; for (int right = 0; right &lt; N; right++) { sum *= nums[right]; while (left &lt;= right &amp;&amp; sum &gt;= k) { sum /= nums[left]; left++; } count += right - left + 1; } return count; }","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://winniekun.github.io/categories/leetcode/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://winniekun.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"PriorityQueue源码解读","slug":"源码/JDK/queue/PriorityQueue-analysis","date":"2021-05-22T12:00:56.000Z","updated":"2021-05-23T12:10:46.393Z","comments":true,"path":"PriorityQueue-analysis/","link":"","permalink":"https://winniekun.github.io/PriorityQueue-analysis/","excerpt":"PriorityQueue源码解读","text":"PriorityQueue源码解读 优先队列, 顾名思义就是按照元素的优先级进行弹出等操作, 那么在JDK中使用何种数据结构来实现优先队列嘞, Let’s Go 依赖 PriorityQueue emmm, 感觉从依赖上来看, 和其他的集合类一样, 实现其对应的接口(Marker Interface的作用?) 基础在阅读基础的时候，我们需要先理解一下什么是堆，其数据结构是啥，有哪些存储方式。 堆的底层数据结构为完全二叉树 存储方式（既然是二叉树，那么其存储方式主要分为如下两种） 顺序存储结构 根节点下标为0 若节点p的下标为$i$，则左孩子$2\\cdot i$ 右孩子为$2 \\cdot i + 1$ 若节点p的下标为$i$，则父节点的下标为$\\lfloor i/2\\rfloor$ 链式存储结构 树的存储结构 由上述的顺序存储结构可知，堆是用物理上的线性表示逻辑上的非线性的数据结构 具体的关于堆的操作，如刚开始的建堆，以及插入元素，删除堆顶元素，迭代等操作，可自行百度。 属性// 默认初始化容量 private static final int DEFAULT_INITIAL_CAPACITY = 11; // 底层使用Object[]数组实现, 和ArrayList这些一样 transient Object[] queue; // non-private to simplify nested class access // 标记元素个数 private int size = 0; // 比较器, 说明其实例均是可比较的 private final Comparator&lt;? super E&gt; comparator; // 说明具有fast fail 机制 transient int modCount = 0; // non-private to simplify nested class access 因为底层使用的是数组，同时其本身是支持动态插入和删除的，所以同理，和ArrayList同理，扩容应该是其核心的地方。同时也要关注其是否生成新的数组对象。 像ArrayList、HashMap中都有一个属性叫 modCount，每次对集合的修改这个值都会加1，在遍历前记录这个值到 expectedModCount中，遍历中检查两者是否一致，如果出现不一致就说明有修改，则抛出ConcurrentModificationException异常。 构造函数PriorityQueue()public PriorityQueue() { this(DEFAULT_INITIAL_CAPACITY, null); } PriorityQueue(int initialCapacity)public PriorityQueue(int initialCapacity) { this(initialCapacity, null); } PriorityQueue(Comparator&lt;? super E&gt; comparator)public PriorityQueue(Comparator&lt;? super E&gt; comparator) { this(DEFAULT_INITIAL_CAPACITY, comparator); } PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator)public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) { // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator; } 还有几个构造函数主要是用于将原各种类型的数据放入PriorityQueue中 增(入队)在阅读这些方法的时候, 想起来自己手撕算法的时候, 经常会记混List, Stack, Queue, Map这些的添加删除操作的API… 下面罗列的是个人觉得不错的代表数据结构特性的添加/删除操作的API 数据结构 添加 删除 List/Set add() remove() Stack push() pop() Queue offer() poll() Map put() remove() 用于入队的操作有add和offer。 public boolean add(E e) { return offer(e); } public boolean offer(E e) { // 不支持null元素 if (e == null) throw new NullPointerException(); modCount++; int i = size; // 元素数量超过数组数量，引发扩容机制 if (i &gt;= queue.length) // 扩容机制先按下不表 grow(i + 1); // 元素数量+1 size = i + 1; // 如果还没有元素 // 直接插入到数组第一个位置 if (i == 0) queue[0] = e; else // 否则 插入到堆的最后一个元素 // 然后再调整堆 siftUp(i, e); return true; } 宏观上来看, offer()方法会先检测是否需要扩容, 之后再插入元素, 最后进行调整, 最后调用siftUp进行调整。 siftUp假设在数组queue的k位置插入元素key（小根堆） 不断的比较key和k的父节点e （$queue\\lfloor(k-1/2\\rfloor)$）的关系 若$key &lt; e$ ，则queue[k] = e, 同时k到达e的位置（parent） 若$key \\geq e$ 或者 $k$已经到达跟节点，则结束循环 $queue[k]==e$ private void siftUp(int k, E x) { // 判断比较策略 // 1. X自身实现了Comparable接口，则通过comparable进行比较 // 2. X自身未实现Comparable接口，通过自定义的外部比较器compartor比较 if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x); } @SuppressWarnings(\"unchecked\") private void siftUpComparable(int k, E x) { Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x; while (k &gt; 0) { int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (key.compareTo((E) e) &gt;= 0) break; queue[k] = e; k = parent; } queue[k] = key; } @SuppressWarnings(\"unchecked\") private void siftUpUsingComparator(int k, E x) { while (k &gt; 0) { int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (comparator.compare(x, (E) e) &gt;= 0) break; queue[k] = e; k = parent; } queue[k] = x; } 结论 不允许null元素 插入元素前，先检测数组长度是否够用，不够进行扩容（扩容机制后续详细阐述） 在尾部插入元素，之后不断调整 通过调整的过程，可以知道PrioriryQueue默认是小根堆 删(出队)出队有两个方法，poll()和remove()，实际上remove调用的还是poll。remove不存在的元素时会报错。 public E remove() { E x = poll(); if (x != null) return x; else throw new NoSuchElementException(); } public E poll() { if (size == 0) return null; int s = --size; modCount++; E result = (E) queue[0]; // 获取当前最后一个元素 // 并将最后一个位置置空 E x = (E) queue[s]; queue[s] = null; // 如果弹出元素后还有元素 if (s != 0) //将队列末元素移到队列首 // 再做自上而下的堆化 siftDown(0, x); return result; } siftDown自顶向下，选择小的节点，不断的比较、交换，直到： 下标越界 节点的值同时小于等于左孩子和右孩子 假设数组queue最后一个元素的值为key（小根堆），下标k从0开始，当k存在左孩子时，执行以下循环： 若k有右孩子，则比较左右孩子的值，然后选出小的孩子child 比较key和c=queue[child]的大小 若$key \\leq c$ 结束循环 若$key &gt; c$, 则$queue[k] = c, k = child$， 继续循环 $queue[k] = key$ private void siftDown(int k, E x) { // 和 siftUp一样的思路 if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x); } @SuppressWarnings(\"unchecked\") private void siftDownComparable(int k, E x) { // 因为删除是从堆顶开始删除，所以和siftUp相反 Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x; int half = size &gt;&gt;&gt; 1; // loop while a non-leaf while (k &lt; half) { int child = (k &lt;&lt; 1) + 1; // assume left child is least Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0) c = queue[child = right]; if (key.compareTo((E) c) &lt;= 0) break; queue[k] = c; k = child; } queue[k] = key; } @SuppressWarnings(\"unchecked\") private void siftDownUsingComparator(int k, E x) { int half = size &gt;&gt;&gt; 1; while (k &lt; half) { int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c; k = child; } queue[k] = x; } 将队列首元素弹出 将队列末元素移到队列首 自上而下堆化，一直往下与最小的子节点比较 如果比最小的子节点大，就交换位置，再继续与最小的子节点比较 如果比最小的子节点小，就不用交换位置了，堆化结束 获取队头元素public E peek() { return (size == 0) ? null : (E) queue[0]; } 获取第一个元素的值。 扩容策略private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) { int oldCapacity = queue.length; // Double size if small; else grow by 50% int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ? (oldCapacity + 2) : (oldCapacity &gt;&gt; 1)); // overflow-conscious code // 检查是否溢出 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); queue = Arrays.copyOf(queue, newCapacity); } private static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 原数组空间大小&lt;64时，默认扩容为原先的两倍再加2个。。。 原数组空间大小&gt;64时，扩容为原先的1.5倍 最大容量空间为Integer.MAX_VALUE 总结 PriorityQueue内部的数据结构是堆，堆使用的数据结构是完全二叉树，然后使用的是顺序存储结构（数组） PriorityQueue默认是小根堆 堆保证堆顶元素为当前的最值，然后严格遵守字节点的值大于（小于）父节点的值 堆的删除操作从堆顶进行删除，然后会将最后的一个元素移至堆顶，此时堆的结构被破坏，所以需要执行siftDown 堆的插入操作从堆尾进行插入，此时堆的结构被破坏，所以需要执行siftUp","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"Queue","slug":"Queue","permalink":"https://winniekun.github.io/tags/Queue/"}]},{"title":"https总结","slug":"网络/https-conclution","date":"2021-05-21T14:32:09.000Z","updated":"2021-10-14T13:18:07.101Z","comments":true,"path":"https-conclution/","link":"","permalink":"https://winniekun.github.io/https-conclution/","excerpt":"","text":"序引入一个新的概念的时候，必然先阐述其相关方面已有的实现有哪些缺点，新的概念解决了哪些缺点。所以～让我们看看HTTP有哪些却缺点 缺点： 明文传输，传输信息容易被窃听 —- 窃听风险 不验证通信方的身份，因此可能会遭遇伪装 —- 冒充风险 无法验证报问的完整性，所以通信的信息可能已遭篡改 —- 篡改风险 譬如强行植入的广告信息 而HTTPS的出现就正好解决了上述的三个问题。对于窃听风险使用加密措施解决，对于冒充风险使用证书认证解决，对于篡改风险使用完整性保护解决（信息摘要算法） HTTPS概述 https HTTPS其实就是http secure的意思。HTTP是应用层协议，位于HTTP协议之下是传输协议TCP。TCP负责传输，HTTP则定义了数据如何进行包装。所以HTTP传输给TCP什么样的数据包，其都会原样的发送个通讯方（仅仅将数据包分为了多个报报问段）。 HTTP —&gt; TCP （明文传输） 而HTTPS相对于HTTP有哪些不同呢？其实就是在HTTP和TCP中间加多了一层加密层TLS/SSL。 通俗的讲，TLS、SSL其实是类似的东西，SSL是个加密套件，负责对HTTP的数据进行加密。TLS是SSL的升级版。现在提到HTTPS，加密套件基本指的是TLS。 原先是应用层将数据直接给到TCP进行传输，现在改成应用层将数据给到TLS/SSL，将数据加密后，再给到TCP进行传输。如下图所示 https和http传输过程 所以HTTPS本身并不是应用层的一个新的协议，只是HTTP在和TCP进行交接的中间，又新增了一层SSL/TLS协议。所以HTTPS可以理解为披着SSL/TLS协议外壳的HTTP而已。 HTTPS的加密—-混合加密首先需要了解对称加密、非对称加密的区别。我们知道实际对通信加密的是SSL/TLS层。SSL/TLS采用是混合加密的机制，也就是对称加密和非对称加密的混合。使用非对称加密传输安全传输对称加密的密钥，之后使用对称加密的密钥进行通信从而提高整体的通讯效率。 接下来结合WireShark抓包详细阐述TLS的加密流程，TLS 是建立在 TCP 基础上的，因此必定需要先三次 TCP 握手建立 TCP 连接，然后再是建立 TLS。 Client Hello Client Hello 报文：客户端对加密算法的支持度不同，因此需要向服务端发送客户端支持的 加密套件（Cipher Suite） ，同时还要生成一个 随机数 同时保存在客户端和发送给服务 Server Hello ServerCertificate 报文：服务端收到 Client Hello 之后，向客户端发送 CA 认证的数字证书，用来鉴别服务端身份信息，同时还要生成一个 随机数 同时保存在服务端和发送给客户端 Server Hello Done 报文：表示服务端宣告第一阶段的客户端服务端握手协商结束 可选：Certificate Request 报文：必要情况下，要求客户端发送证书验证身份 可选：Server Key Exchange 报文：如果 CA 认证的数字证书提供的信息不够，服务端还可发送提供补充信息 Client Finish Client Key Exchange 报文：客户端收到 CA 数字证书并通过验证，然后通过 CA 公钥解密获取到 服务端公钥。Client Key Exchange 报文包括有一个随机数，这个随机数被称为 Pre-master key/secret；一个表示随后的信息使用双方协商好的加密方法和密钥发送的 通知 ；还有一个通过协商好的 HASH 算法对前面所有信息内容的 HASH 计算值，用来提供服务端校验。这些信息都通过服务端公钥加密传送给服务端 ExchangeCipherSpec 报文：该报文通知服务端，此后的通信都将使用协商好的加密算法计算对称密钥进行加密通信（也就是使用两个随机数以及第三个 Pre-master key/secret 随机数一起算出一个对称密钥 session key/secret） Finished 报文：该报文包括连接至此的所有报文的校验值，使用已经生成的对称加密密钥加密 可选：ClientCertificate 报文：如果服务端请求，客户端需要发送 CA 数字证书 可选：CertificateVerify 报文：服务端如果要求 CA 数字证书，那么需要通过 HASH 算法计算一个服务端发送来的信息摘要 Server Finish 服务端先私钥得出Pre-master key， 同样使用这三个随机数得出对称加密密钥。服务端最后对客户端发送过来的 Finished 报文使用服务端对称密钥进行解密校验。 ClientCipherSpec 报文：报文通知服务端，此后的通信都将使用协商好的加密算法计算对称密钥 session key/secret 进行加密通信 Finished 报文：标志 TLS 连接建立成功 TLS 握手成功此后通过对称密钥 session key/secret 加密通信 握手：证书下发，密钥协商（这个阶段都是明文的） 数据传输：这个阶段才是加密的，用的就是握手阶段协商出来的对称密钥 进行整理，如下图所示 粗略的流程图 使用wireshark实战证明本地地址和LeetCode-CN的交互 wireshark抓包显示 具体的流程如TLS 1.2 的官方文档，RFC-5246，其中的section-7.3所示 整体流程 接下来，根据wireshark进行实际的验证 ClientHello阶段 客户端想服务端发送https请求链接，同时将自身支持的TLS版本，一个随机串Random，密码套件（非对称加密算法、对称加密算法、摘要算法）发送给服务端，同时返回的内容还有一些其他的信息，如compression_methods（压缩的算法）、extensions（扩展字段） ServerHello阶段 服务端根据客户端获发送的数据，选择一套密码套件，以及自身的证书发送给客户端 选择的密码套件阐述： TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 ECDHE_RSA： 密钥交换时采用的RSA非对称加密算法 AES_128_GCM：握手通讯后使用AES对称算法，密钥长度为128 SHA256：摘要算法使用的是SHA256 Server Certificate阶段 服务端发完上面的 ServerHello 后立即发这个包 整个证书内容展开来看如下： 其中subject展开整理如下： CountryName: CN printableString: Shanghai printableString: IT uTF8String: 领扣网络（上海）有限公司 printableString: leetcode-cn.com 还有一个很重要的内容 subjectPublicKeyInfo（证书的公钥信息）： 整体来看，证书共分为如下的内容： 执行了客户端 + 服务端的两个hello阶段，然后在发送一个Certificate包，用于传递证书，待客户端校验 Server Hello Done 阶段 标识着 serverHello 这个握手过程结束了 Client ClientKeyExchange 阶段 紧接着 ServerHelloDone 发送，用于协商出 premaster_secret，同之前的 ServerKeyExchange 配合使用的。 生成最终通信的对称加密秘钥master_secret 这一步不是抓包的信息，而是客户端和服务端此时都在自己端内所做的事情，非常关键。 就是计算出最终对称加密用的秘钥 master_secret，这也是整个花里胡哨的过程，最终且唯一的一个目的，并且两端算出来的结果肯定是一样的。 HTTPS 的目的，不就是双方协商出一个共同的对称加密秘钥么，怕被中间人拦截到，所以做的证书呀，非对称加密算法呀，秘钥协商算法等复杂的规定。 那 master_secret 是怎么计算出来的呢？ 还记不记得之前我们得到了三个随机数： 随机数 1（客户端随机数）：在 ClientHello 消息里，由客户端生成的随机数，是： f52870c0be8c82f46f6ae0c5ad1be08a550bda92416bafebe54b9923b0795150 随机数 2（服务端随机数）：在 ServerHello 消息里，由服务端生成的随机数，是： d763c799e2dea5f59fb9dc12a476598d9fc486e0f43d57148bd15f137793f77a 随机数 3（pre_master)：通过秘钥交换算法 ECDHE 计算出的，我们叫它 pre_master。 最终的对称加密秘钥 master_secret，就是根据这三个随机数共同计算出来的。 一旦双方协商出来了这个相同的对称秘钥，那就可以开始愉快地安全通信了，TLS 层的工作也就圆满完成。 所以可想而知，接下来的工作，就都是收尾工作了，因为秘钥已经协商好了。就可以开心的用协商的密钥进行加密通讯了，啦啦啦 Client ChangeCipherSpec阶段 秘钥改变通知，此时客户端已经生成了 master_secret，之后的消息将都通过 master secret 来加密 Encrypted Handshake Message 阶段 用于数据验证 Server ChangeCipherSpec阶段 也是秘钥改变通知，此时服务端也已经生成了 master_secret 了，后面的通信都用此值加密。 Server Finish阶段 同 Client Finish，服务器端发送握手结束通知，同时会带上前面所发内容的签名到客户端，保证前面通信数据的正确性。 HTTPS的认证—-数字证书了解了HTTPS加密通信的流程后，对于数据裸奔的疑虑应该基本打消了。然而，还有一个问题：如何确保证书时可信的？ 证书不可信可能有两种情况： 证书是伪造的：压根不是CA颁发的 证书被篡改过：比如将XX网站的公钥给替换了 数字证书是由权威的CA（Certificate Authority）机构给服务端进行颁发，CA机构通过服务端提供的相关信息生成证书，证书内容包含了持有人的相关信息，服务器的公钥，签署者签名信息（数字签名）等，最重要的是公钥在数字证书中。 数字签名和摘要算法的关系 明文 —&gt; hash运算 —&gt; 摘要 —&gt; 私钥加密 —&gt; 数字签名 数字证书是如何保证公钥来自请求的服务器？ 数字证书上由持有人的相关信息，通过这点可以确定其不是一个中间人 证书包含的内容： 一个证书中含有三个部分:证书内容，散列算法，加密密文，证书内容会被散列算法hash计算出摘要，然后使用CA机构提供的私钥进行RSA加密得到数组签名（加密密文）。 Support/typora-user-images/image-20210521221149447.png 证书伪造浏览器内置的CA的根证书包含了CA的公钥 证书颁发的机构是伪造的：浏览器不认识，直接认为是危险证书 证书颁发的机构是确实存在的，于是根据CA名，找到对应内置的CA根证书、CA的公钥。 用CA的公钥，对伪造的证书的摘要进行解密，发现解不了。认为是危险证书 证书篡改 根据证书的加密密文（数字签名）使用CA的公钥得到证书摘要A 根据证书内容使用摘要算法得到证书摘要B 对比摘要A和摘要B是否相同 HTTPS的完整性保护—-摘要算法 [ ] TODO 总结references 图解HTTP 趣谈协议—-极客时间 Why does the SSL/TLS handshake have a client and server random","categories":[{"name":"网络","slug":"网络","permalink":"https://winniekun.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"应用层","slug":"应用层","permalink":"https://winniekun.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"}]},{"title":"Spring IoC解读","slug":"spring/spring-ioc-analysis","date":"2021-05-21T01:24:20.000Z","updated":"2021-07-24T07:46:15.133Z","comments":true,"path":"spring-ioc-analysis/","link":"","permalink":"https://winniekun.github.io/spring-ioc-analysis/","excerpt":"","text":"序IoCIoC控制反转，意思就是将创建对象的控制权从我们自己硬编码来new一个对象反转到了第三方身上。IoC的主要实现方式是依赖注入，Spring中的依赖注入方式有：构造方法注入、settter注入、接口注入。 控制反转是一种思想 依赖注入是一种设计模式 IoC是一种可以帮助我们解耦各业务对象间依赖关系的对象绑定方式 IoC Service Provider虽然业务对象可以通过IoC方式声明相应的依赖，但是最终仍然需要通过某个角色或者服务将这些依赖的对象绑定到一起。而IoC Service Provider就对应IoC场景中的这一角色。IoC Service Provider在这里是一个抽象出来的概念，它可以指代任何将IoC场景中的业务对象绑定到一起的实现方式。它可以是一段代码，也可以是一组相关的类，甚至可以是比较通用的IoC框架或 者IoC容器实现。 职责 业务对象的构建管理 IoC中，业务对象无需关心所依赖注入的对象如何构建如何取得，但是这部分的工作还是需要有人来做的。所以IoC Service Provider需要将对象的构建逻辑从客户端对象那里抽离出来，一面这部分逻辑污染业务对象的实现。 客户端：代使用某个对象或者某种服务的对象。如果对象A需要引用对象B，那么A就是B的客户端对象，而不管A 处于Service层还是数据访问层。 业务对象之间的依赖绑定 最艰巨也是最重要的，这 是它的最终使命之所在。如果不能完成这个职责，那么，无论业务对象如何的“呼喊”，也不 会得到依赖对象的任何响应(最常见的倒是会收到一个NullPointerException)。IoC Service Provider通过结合之前构建和管理的所有业务对象，以及各个业务对象间可以识别的依赖关系，将这些对象所依赖的对象注入绑定，从而保证每个业务对象在使用的时候，可以处于就绪状 态。 Spring IoC容器 image-20210520140010820 Spring的IoC容器就是一个IoC Provider，但是其相比于IoC Provider的功能更加的丰富，除了业务对象的构建、依赖关系的绑定这种IoC Provider的基本功能，还新增了业务对象声明周期的管理，AOP支持等。同时Spring提供了两种容器类型:BeanFactory和ApplicationContext。 BeanFactory 基础类型IoC容器，提供完整的IoC服务支持。如果没有特殊指定，==默认采用延迟初始化策略(lazy-load)==。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的 IoC容器选择。 ApplicationContext 在BeanFactory的基础上构建，是相对比较高 级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。ApplicationContext所管理 的对象，在该类型容器启动之后，==默认全部初始化并绑定完成==。所以，相对于BeanFactory来 说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中， ApplicationContext类型的容器是比较合适的选择。 简单的式例Spring IoC容器的一些特性简介autowire自动注入，通过autowire，我们可以略去很多人工显示的配置bean的操作，被依赖的发现和注入都交给了Spring，同时其有几个类型可选择，比如byName、byType等。 FactoryBeanBeanFactory和FactoryBean傻傻分不清？虽然两者类似，但是功能不同。FactoryBean是一种工厂Bean，和普通的Bean不一样，FactoryBean是可以生产Bean的Bean。 depends-on当一个 bean 直接依赖另一个 bean，可以使用 &lt;ref/&gt; 标签进行配置。不过如某个 bean 并不直接依赖于其他 bean，但又需要其他 bean 先实例化好，这个时候就需要使用 depends-on 特性了。depends-on 特性比较简单，就不演示了。仅贴一下配置文件的内容，如下： 这里有两个简单的类，其中 Hello 需要 World 在其之前完成实例化。相关配置如下： &lt;bean id=\"hello\" class=\"xyz.coolblog.depnedson.Hello\" depends-on=\"world\"/&gt; &lt;bean id=\"world\" class=\"xyz.coolblog.depnedson.World\" /&gt; BeanPostProcessorBeanPostProcessor 是 bean 实例化时的后置处理器，包含两个方法，其源码如下： public interface BeanPostProcessor { // bean 初始化前的回调方法 Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; // bean 初始化后的回调方法 Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException; } BeanPostProcessor是Spring框架的一个扩展点，可以通过BeanPostProcessor接口，我们能够插手Bean的实例化过程，比如AOP就是在bean实例将切面逻辑织入bean实例中，AOP也是正是通过BeanPostProcessor和IoC容器建立了联系 示例@Slf4j public class LoggerBeanPostProcessor implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) { log.info(\"Before \" + beanName + \" Initialization\"); return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) { log.info(\"After \" + beanName + \" Initialization\"); return bean; } } 配置如下&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean class=\"com.titizz.simulation.toyspring.learninng.LoggerBeanPostProcessor\"/&gt; &lt;bean id=\"car\" class=\"com.titizz.simulation.toyspring.Car\"&gt; &lt;/bean&gt; &lt;/beans&gt; 测试如下@Test public void testBeanPostProcessor() { String xmlPath = \"test-spring.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); } image-20210502181644978 核心接口Resource以 Resource 接口为核心发散出的几个类，都是用于解决 IoC 容器中的内容从哪里来的问题，也就是 配置文件从哪里读取、配置文件如何读取 的问题。 类名 说明 Resource 接口，标识一个外部资源。通过 getInputStream() 方法 获取资源的输入流 。 UrlResource 实现 Resource 接口的资源类，通过 URL 获取资源。 ResourceLoader 资源加载类。通过 getResource(String) 方法获取一个 Resouce 对象，是 获取 Resouce 的主要途径 。 BeanDefinition功能：用于解决Bean的定义问题，包括Bean的名字，类型以及它的属性赋予了什么值或者引用。说白了也就是解决了在IoC容器中定义一个Bean，使得IoC容器可以根据这个定义来生成实例。 类名 说明 BeanDefinition 该类保存了 Bean 定义。包括 Bean 的 名字 String beanClassName、类型 Class beanClass、属性 PropertyValues propertyValues。根据其 类型 可以生成一个类实例，然后可以把 属性 注入进去。propertyValues 里面包含了一个个 PropertyValue 条目，每个条目都是键值对 String - Object，分别对应要生成实例的属性的名字与类型。在 Spring 的 XML 中的 property 中，键是 key ，值是 value 或者 ref。对于 value 只要直接注入属性就行了，但是 ref 要先进行解析。Object 如果是 BeanReference 类型，则说明其是一个引用，其中保存了引用的名字，需要用先进行解析，转化为对应的实际 Object。 BeanDefinitionReader 解析 BeanDefinition 的接口。通过 loadBeanDefinitions(String) 来从一个地址加载类定义。 AbstractBeanDefinitionReader 实现 BeanDefinitionReader 接口的抽象类（未具体实现 loadBeanDefinitions，而是规范了 BeanDefinitionReader 的基本结构）。内置一个 HashMap rigistry，用于保存 String - beanDefinition 的键值对。内置一个 ResourceLoader resourceLoader，用于保存类加载器。用意在于，使用时，只需要向其 loadBeanDefinitions() 传入一个资源地址，就可以自动调用其类加载器，并把解析到的 BeanDefinition 保存到 registry 中去。 XmlBeanDefinitionReader 具体实现了 loadBeanDefinitions() 方法，从 XML 文件中读取类定义。 BeanFactory ❓以 BeanFactory 接口为核心发散出的几个类，都是用于解决 IoC 容器在 已经获取 Bean 的定义的情况下，如何装配、获取 Bean 实例 的问题。 类名 说明 BeanFactory 接口，标识一个 IoC 容器。通过 getBean(String) 方法来 获取一个对象 AbstractBeanFactory BeanFactory 的一种抽象类实现，规范了 IoC 容器的基本结构，但是把生成 Bean 的具体实现方式留给子类实现。IoC 容器的结构：AbstractBeanFactory 维护一个 beanDefinitionMap 哈希表用于保存类的定义信息（BeanDefinition）。获取 Bean 时，如果 Bean 已经存在于容器中，则返回之，否则则调用 doCreateBean 方法装配一个 Bean。（所谓存在于容器中，是指容器可以通过 beanDefinitionMap 获取 BeanDefinition 进而通过其 getBean() 方法获取 Bean。） AutowireCapableBeanFactory 可以实现自动装配的 BeanFactory。在这个工厂中，实现了 doCreateBean 方法，该方法分三步：1，通过 BeanDefinition 中保存的类信息实例化一个对象；2，把对象保存在 BeanDefinition 中，以备下次获取；3，为其装配属性。装配属性时，通过 BeanDefinition 中维护的 PropertyValues 集合类，把 String - Value 键值对注入到 Bean 的属性中去。如果 Value 的类型是 BeanReference 则说明其是一个引用（对应于 XML 中的 ref），通过 getBean 对其进行获取，然后注入到属性中。 ApplicationContext以 ApplicationContext 接口为核心发散出的几个类，主要是对前面 Resouce 、 BeanFactory、BeanDefinition 进行了功能的封装，解决 根据地址获取 IoC 容器并使用 的问题。 类名 说明 ApplicationContext 标记接口，继承了 BeanFactory。通常，要实现一个 IoC 容器时，需要先通过 ResourceLoader 获取一个 Resource，其中包括了容器的配置、Bean 的定义信息。接着，使用 BeanDefinitionReader 读取该 Resource 中的 BeanDefinition 信息。最后，把 BeanDefinition 保存在 BeanFactory 中，容器配置完毕可以使用。注意到 BeanFactory 只实现了 Bean 的 装配、获取，并未说明 Bean 的 来源 也就是 BeanDefinition 是如何 加载 的。该接口把 BeanFactory 和 BeanDefinitionReader 结合在了一起。 AbstractApplicationContext ApplicationContext 的抽象实现，内部包含一个 BeanFactory 类。主要方法有 getBean() 和 refresh() 方法。getBean() 直接调用了内置 BeanFactory 的 getBean() 方法，refresh() 则用于实现 BeanFactory 的刷新，也就是告诉 BeanFactory 该使用哪个资源（Resource）加载类定义（BeanDefinition）信息，该方法留给子类实现，用以实现 从不同来源的不同类型的资源加载类定义 的效果。 ClassPathXmlApplicationContext 从类路径加载资源的具体实现类。内部通过 XmlBeanDefinitionReader 解析 UrlResourceLoader 读取到的 Resource，获取 BeanDefinition 信息，然后将其保存到内置的 BeanFactory 中。 对 ApplicatinoContext 的分层更为细致。AbstractApplicationContext 中为了实现 不同来源 的 不同类型 的资源加载类定义，把这两步分层实现。以“从类路径读取 XML 定义”为例，首先使用 AbstractXmlApplicationContext 来实现 不同类型 的资源解析，接着，通过 ClassPathXmlApplicationContext 来实现 不同来源 的资源解析。 战略观望 容器启动阶段使用Resource相关接口标识我们配置文件从哪里获取，然后使用BeanDefinitionReader对标识的文件进行解析，将分析后的信息编组为相应的BeanDefinition。最后将保存了每个Bean定义信息的BeanDefinition，注册到相应的BeanDefinitionRegistry，这样容器的启动就完成了。 启动阶段任务 Bean实例化阶段通过容器的启动阶段，现在所有的Bean定义的信息，都通过BeanDefiniton的方式注册到了BeanDefinitionRegistry中，当某个请求方通过容器的getBean方法明确的调用某个对象的时候，或者因为依赖关系容器需要隐式的调用getBean方法，就会出发第二阶段的活动。 bean的实例化过程 Spring容器将对其所管理的对象全部给予统一的生命周期管理，这些被管理的对象完全摆脱了原 来那种“new完后被使用，脱离作用域后即被回收”的命运 详细阐述最简单的IoC容器public class BeanFactory { // 说白了就是一个map private Map&lt;String, Object&gt; beanMap = new HashMap&lt;&gt;(); public void registerBean(String name, Object bean) { beanMap.put(name, bean); } public Object getBean(String name) { return beanMap.get(name); } } public class SimpleBeanContainerTest { @Test public void testGetBean() throws Exception { // 需要我们去手动new依赖对象，然后放入 BeanFactory beanFactory = new BeanFactory(); beanFactory.registerBean(\"helloService\", new HelloService()); HelloService helloService = (HelloService) beanFactory.getBean(\"helloService\"); assertThat(helloService).isNotNull(); assertThat(helloService.sayHello()).isEqualTo(\"hello\"); } class HelloService { public String sayHello() { System.out.println(\"hello\"); return \"hello\"; } } } BeanFactoryPostProcess和BeanPostProcessorBeanFactoryPostProcess和BeanPostProcessor是spring框架中具有重量级地位的两个接口，理解了这两个接口的作用，基本就理解spring的核心原理了 BeanFactoryPostProcessor是spring提供的容器拓展机制，允许我们在bean实例化之前修改bean的定义信息（BeanDedinition），其重要的实现类PropertyPlaceholderConfigurer和CustomEditorConfigurer PropertyPlaceholderConfigurer的作用是用properties文件的配置值替换xml文件中的占位符 CustomEditorConfigurer的作用是实现类型转换。 BeanPostProcessor也是spring提供的容器拓展机制，不同于BeanFactoryPostProcessor，BeanPostProcesssor在Bean实例化之后修改Bean或替换Bean。也是实现AOP的关键。 等等等。。。 整体流程图 整体流程图 BeanDefinitionReader读取Bean的相关配置信息，并将读取到的信息使用BeanDefinition表示，同时注册到BeanDefinitionRegistry中。 通过实现了BeanFactoryPostProcessor的类，自定义修改BeanDefinition中的信息 Bean的实例化 采用策略模式，策略化Bean的实例，共包含两种方式：cglib、反射 获取Bean的实例之后，根据BeanDefinition中的信息，填充Bean的属性、依赖 检测各种检测各种Aware接口，并放入Bean中 调用BeanPostProcessor接口的前置处理方法，处理符合要求的Bean实例 如果实现了InitializingBean接口，则处理对应的afterPropertiesSet()方法 如果定义init-method方法，处理对应的初始化方法 调用BeanPostProcessor接口的后置处理方法，处理符合要求的Bean实例 使用 判断Bean的Scope，如果是prototype，不再管理 如果是单例，如果实现了DisposableBean接口，则执行对应的destroy方法 如果定义了destory-method，则执行自定义的销毁方法 结束整理的还是很乱，虽然看的时候是都看了。。。 后面慢慢优化吧（涉及到以后==永远不会）😑 references spring揭秘 tiny-spring mini-spring tiny-spring分析 Spring IoC容器分析 Spring IOC 容器源码分析系列","categories":[{"name":"spring","slug":"spring","permalink":"https://winniekun.github.io/categories/spring/"}],"tags":[{"name":"ioc","slug":"ioc","permalink":"https://winniekun.github.io/tags/ioc/"}]},{"title":"归并排序","slug":"算法/排序/归并排序","date":"2021-04-30T13:35:01.000Z","updated":"2021-06-17T04:51:19.309Z","comments":true,"path":"归并排序/","link":"","permalink":"https://winniekun.github.io/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","excerpt":"","text":"归并排序步骤 先选择分界点 先递归排序 归并 合二为一 Support/typora-user-images/image-20210419120203122.png private static void mergeSort(int[] array, int l, int r) { if (l &gt;= r) { return; } int mid = (l + r) / 2; mergeSort(array, l, mid); mergeSort(array, mid+1, r); // 整合 int[] tmp = new int[r - l + 1]; // 临时数组, 用于临时存储 [l,r]区间内排好序的数据 int i = l, j = mid + 1, k = 0; // 两个指针 // 进行归并 while (i &lt;= mid &amp;&amp; j &lt;= r) { if (array[i] &lt;= array[j]) tmp[k++] = array[i++]; else tmp[k++] = array[j++]; } while (i &lt;= mid) tmp[k++] = array[i++]; while (j &lt;= r) tmp[k++] = array[j++]; // 进行赋值 for (i = l, j = 0; i &lt;= r; i++, j++) array[i] = tmp[j]; }","categories":[{"name":"排序","slug":"排序","permalink":"https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"归并排序","slug":"归并排序","permalink":"https://winniekun.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"}]},{"title":"死磕数学基础","slug":"LeetCode/stick-to-math","date":"2021-04-20T11:56:11.000Z","updated":"2021-05-16T16:42:07.999Z","comments":true,"path":"stick-to-math/","link":"","permalink":"https://winniekun.github.io/stick-to-math/","excerpt":"前言LeetCode死磕系列十二： 数学基础 说实话，其实都是刷题都是数学的实现，不过感觉有些题目更加偏向数学应用，譬如蓄水池，等概率抽样…。","text":"前言LeetCode死磕系列十二： 数学基础 说实话，其实都是刷题都是数学的实现，不过感觉有些题目更加偏向数学应用，譬如蓄水池，等概率抽样…。 题目470 用rand7()实现Rand10()从最基础的讲起如何做到均匀的生成随机数 从上述的文章可以得出： 已知: $randN()$可以==等概率==生成$[1, N]$范围的数字那么: $(randN()-1) \\times Y + randY()$可以==等概率==生成$[1, Y \\times N]$ 范围的数字 即：实现了$randNY()$ 以$[(rand9() - 1) \\times 7 + rand7()]$为例子 rand9()-1\\rand7 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 1 8 9 10 11 12 13 14 2 15 16 17 18 19 20 21 3 22 23 24 25 26 27 28 4 29 30 31 32 33 34 35 5 36 37 38 39 40 41 42 6 43 44 45 46 47 48 49 7 50 51 52 53 54 55 56 8 57 58 59 60 61 62 63 是不是很神奇，数学证明不会 那么想到通过rand4()来实现rand2()呢？这个就很简单了，已知rand4()会均匀产生[1,4]的随机数，通过取余，再加1就可以了。如下所示，结果也是等概率的。 rand4() % 2 + 1 = ? 1 % 2 + 1 = 2 2 % 2 + 1 = 1 3 % 2 + 1 = 2 4 % 2 + 1 = 1 事实上，只要rand_N()中N是2的倍数，就都可以用来实现rand2()，反之，若N不是2的倍数，则产生的结果不是等概率的。比如： rand6() % 2 + 1 = ? 1 % 2 + 1 = 2 2 % 2 + 1 = 1 3 % 2 + 1 = 2 4 % 2 + 1 = 1 5 % 2 + 1 = 2 6 % 2 + 1 = 1 rand5() % 2 + 1 = ? 1 % 2 + 1 = 2 2 % 2 + 1 = 1 3 % 2 + 1 = 2 4 % 2 + 1 = 1 5 % 2 + 1 = 2 通用一些的 如果需要实现$randX()$ 先实现$randN()$ $N$为$X$的倍数（$N&gt;X$） 再通过 $randN() \\% X + 1$即可 public int rand10() { // rand 49 while (true) { int num = (rand7() - 1) * 7 + rand7(); // rand49 if (num &lt;= 40) { // 使用拒绝采样，得到rand40 return num % 10 + 1; // rand10 } } } 优化 class Solution extends SolBase { // 上述拒绝了9个数字， // 优化之后，减少丢弃值，提高命中率 public int rand10() { while(true) { int a = rand7(); int b = rand7(); int num = (a-1)*7 + b; // rand 49 if(num &lt;= 40) return num % 10 + 1; // 拒绝采样 a = num - 40; // rand 9 b = rand7(); num = (a-1)*7 + b; // rand 63 if(num &lt;= 60) return num % 10 + 1; a = num - 60; // rand 3 b = rand7(); num = (a-1)*7 + b; // rand 21 if(num &lt;= 20) return num % 10 + 1; } } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"数学基础","slug":"数学基础","permalink":"https://winniekun.github.io/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"}]},{"title":"死磕SQL","slug":"LeetCode/stick-to-sql","date":"2021-04-20T11:56:11.000Z","updated":"2021-05-16T16:39:43.618Z","comments":true,"path":"stick-to-sql/","link":"","permalink":"https://winniekun.github.io/stick-to-sql/","excerpt":"前言LeetCode死磕系列十： SQL","text":"前言LeetCode死磕系列十： SQL 作为一个后端开发程序员，SQL功底还是很重要的！！！ 所以还是要练习。 还记得去年被字节面试的时候，连SQL都写不出来。。。 LeetCode SQL题目整理刷了LC上的top70之后，感觉考察最多的还是多表的联合查找，毕竟实际中也不会仅仅是单表的查询。 主要题型： TOP N 问题 排名问题 滑动窗口 自链接问题 题解TOP N问题176. 第二高的薪水思路： 使用limit 注意判空、去重 select ifnull ((select distinct Salary from Employee order by Salary desc limit 1, 1) , null) as SecondHighestSalary; 先使用max查询最高的薪水 max，之后再通过自查询，查询小于max的max 184. 部门工资最高的员工-- 思路： 寻找最大薪资的数据 -- join -- 1. 直接join group by 选取最大的即可 但是 无法保证最大的薪资不重复 失败 -- 2. 先通过员工信息 寻找最大的薪资+id 的数据A，然后再join 两张表，将A中对应的数据返回 -- 1. select d.Name as Department, e.Name as Employee, e.Salary as Salary from Employee e inner join Department d on e.DepartmentId = d.Id where (e.DepartmentId, e.Salary) in (select DepartmentId, max(Salary) from Employee group by DepartmentId); 177. 第N高的薪水LIMIT PAGE, OFFSET 跳过 PAGE * OFFSET条数据，接下来的offset条数据， 因为题目中未说明薪资是否不重复，所以还需要使用distinct去重 CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN set N:= N-1; RETURN ( # Write your MySQL query statement below. select distinct Salary from Employee order by Salary desc limit N,1 ); END 185. 部门工资前三高的所有员工select d.Name as Department, e2.Name as Employee, e2.Salary from Department d inner join ( select e.*, dense_rank() over(partition by DepartmentID Order by Salary DESC) as 'rank' from Employee e ) e2 on d.Id= e2.DepartmentID where e2.rank&lt;=3 order by Department AND Salary 排名问题178.分数排名select Score, dense_rank() over(order by Score desc) as `Rank` from Scores; 自链接问题603. 连续空余座位-- 几个朋友来到电影院的售票处，准备预约连续空余座位。 -- 你能利用表 cinema ，帮他们写一个查询语句，获取所有空余座位，并将它们按照 seat_id 排序后返回吗？ select distinct a.seat_id from cinema a join cinema b on abs(a.seat_id - b.seat_id) = 1 and a.free = true and b.free = true order by a.seat_id","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"SQL","slug":"SQL","permalink":"https://winniekun.github.io/tags/SQL/"}]},{"title":"死磕多线程","slug":"LeetCode/stick-to-multi-thread","date":"2021-04-14T11:56:11.000Z","updated":"2021-06-06T07:56:37.628Z","comments":true,"path":"stick-to-multi-thread/","link":"","permalink":"https://winniekun.github.io/stick-to-multi-thread/","excerpt":"前言LeetCode死磕系列十一： 多线程","text":"前言LeetCode死磕系列十一： 多线程 看那么多的面经，发现已经开始询问多线程的编程了。个人感觉多线程编程主要是理解，思想。是有固定的套路的，譬如：交替输出，有序的输出哇。深挖下去就是考察对线程通讯的使用，以及一些高阶用法。和哲学家就餐问题、生产者消费者问题、读写者问题差不多。 所以～～～ 我来开始熟悉并发操作了，毕竟光看不练假把式 LeetCode 多线程题目整理1114. 按序打印","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"多线程","slug":"多线程","permalink":"https://winniekun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"一行一行源码分析清楚AbstractQueuedSynchronizer","slug":"Java进阶/并发/一行一行源码分析清楚AbstractQueuedSynchronizer","date":"2021-03-30T12:14:20.000Z","updated":"2021-04-05T12:19:21.814Z","comments":true,"path":"一行一行源码分析清楚AbstractQueuedSynchronizer/","link":"","permalink":"https://winniekun.github.io/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9AAbstractQueuedSynchronizer/","excerpt":"在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础。 Google 一下 AbstractQueuedSynchronizer，我们可以找到很多关于 AQS 的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。 本文将从 ReentrantLock 的公平锁源码出发，分析下 AbstractQueuedSynchronizer 这个类是怎么工作的，希望能给大家提供一些简单的帮助。","text":"在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础。 Google 一下 AbstractQueuedSynchronizer，我们可以找到很多关于 AQS 的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。 本文将从 ReentrantLock 的公平锁源码出发，分析下 AbstractQueuedSynchronizer 这个类是怎么工作的，希望能给大家提供一些简单的帮助。 申明以下几点： 本文有点长，但还是挺简单，主要面向读者对象为并发编程的初学者，或者想要阅读 Java 并发包源码的开发者。对于新手来说，可能需要花好几个小时才能完全看懂，但是这时间肯定是值得的。 源码环境 JDK1.7（1.8没啥变化），看到不懂或有疑惑的部分，最好能自己打开源码看看。Doug Lea 大神的代码写得真心不错。 本文不分析共享模式，这样可以给读者减少很多负担，第三篇文章对共享模式进行了分析。而且也不分析 condition 部分，所以应该说很容易就可以看懂了。 本文大量使用我们平时用得最多的 ReentrantLock 的概念，本质上来说是不正确的，读者应该清楚，AQS 不仅仅用来实现可重入锁，只是希望读者可以用锁来联想 AQS 的使用场景，降低阅读压力。 ReentrantLock 的公平锁和非公平锁只有一点点区别，第二篇文章做了介绍。 评论区有读者反馈本文直接用代码说不友好，应该多配点流程图，这篇文章确实有这个问题。但是作为过来人，我想告诉大家，对于 AQS 来说，形式真的不重要，重要的是把细节说清楚。 AQS 结构先来看看 AQS 有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了，毕竟可以猜嘛！ // 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的 private transient volatile Node head; // 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表 private transient volatile Node tail; // 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁 // 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1 private volatile int state; // 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入 // reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁 // if (currentThread == getExclusiveOwnerThread()) {state++} private transient Thread exclusiveOwnerThread; //继承自AbstractOwnableSynchronizer 怎么样，看样子应该是很简单的吧，毕竟也就四个属性啊。 AbstractQueuedSynchronizer 的等待队列示意如下所示，注意了，之后分析过程中所说的 queue，也就是阻塞队列不包含 head，不包含 head，不包含 head。 aqs-0 等待队列中每个线程被包装成一个 Node 实例，数据结构是链表，一起看看源码吧： static final class Node { // 标识节点当前在共享模式下 static final Node SHARED = new Node(); // 标识节点当前在独占模式下 static final Node EXCLUSIVE = null; // ======== 下面的几个int常量是给waitStatus用的 =========== /** waitStatus value to indicate thread has cancelled */ // 代码此线程取消了争抢这个锁 static final int CANCELLED = 1; /** waitStatus value to indicate successor's thread needs unparking */ // 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒 static final int SIGNAL = -1; /** waitStatus value to indicate thread is waiting on condition */ // 本文不分析condition，所以略过吧，下一篇文章会介绍这个 static final int CONDITION = -2; /** * waitStatus value to indicate the next acquireShared should * unconditionally propagate */ // 同样的不分析，略过吧 static final int PROPAGATE = -3; // ===================================================== // 取值为上面的1、-1、-2、-3，或者0(以后会讲到) // 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待， // ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。 volatile int waitStatus; // 前驱节点的引用 volatile Node prev; // 后继节点的引用 volatile Node next; // 这个就是线程本尊 volatile Thread thread; } Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。 上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说 ReentrantLock 的公平锁。再次强调，我说的阻塞队列不包含 head 节点。 aqs-0 首先，我们先看下 ReentrantLock 的使用方式。 // 我用个web开发中的service概念吧 public class OrderService { // 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个 private static ReentrantLock reentrantLock = new ReentrantLock(true); public void createOrder() { // 比如我们同一时间，只允许一个线程创建订单 reentrantLock.lock(); // 通常，lock 之后紧跟着 try 语句 try { // 这块代码同一时间只能有一个线程进来(获取到锁的线程)， // 其他的线程在lock()方法上阻塞，等待获取到锁，再进来 // 执行代码... // 执行代码... // 执行代码... } finally { // 释放锁 reentrantLock.unlock(); } } } ReentrantLock 在内部用了内部类 Sync 来管理锁，所以真正的获取锁和释放锁是由 Sync 的实现类来控制的。 abstract static class Sync extends AbstractQueuedSynchronizer { } Sync 有两个实现，分别为 NonfairSync（非公平锁）和 FairSync（公平锁），我们看 FairSync 部分。 public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } 线程抢锁很多人肯定开始嫌弃上面废话太多了，下面跟着代码走，我就不废话了。 static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; // 争锁 final void lock() { acquire(1); } // 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力 // 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。 // 否则，acquireQueued方法会将线程压到队列中 public final void acquire(int arg) { // 此时 arg == 1 // 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试 // 因为有可能直接就成功了呢，也就不需要进队列排了， // 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的) if (!tryAcquire(arg) &amp;&amp; // tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) { selfInterrupt(); } } /** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. */ // 尝试直接获取锁，返回值是boolean，代表是否获取到锁 // 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取 protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); // state == 0 此时此刻没有线程持有锁 if (c == 0) { // 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到， // 看看有没有别人在队列中等了半天了 if (!hasQueuedPredecessors() &amp;&amp; // 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了， // 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_= // 因为刚刚还没人的，我判断过了 compareAndSetState(0, acquires)) { // 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁 setExclusiveOwnerThread(current); return true; } } // 会进入这个else if分支，说明是重入了，需要操作：state=state+1 // 这里不存在并发问题 else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc &lt; 0) throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; } // 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁 // 回到上面一个外层调用方法继续看: // if (!tryAcquire(arg) // &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // selfInterrupt(); return false; } // 假设tryAcquire(arg) 返回false，那么代码将执行： // acquireQueued(addWaiter(Node.EXCLUSIVE), arg)， // 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE) /** * Creates and enqueues node for current thread and given mode. * * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared * @return the new node */ // 此方法的作用是把线程包装成node，同时进入到队列中 // 参数mode此时是Node.EXCLUSIVE，代表独占模式 private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure // 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后 Node pred = tail; // tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧) if (pred != null) { // 将当前的队尾节点，设置为自己的前驱 node.prev = pred; // 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴 if (compareAndSetTail(pred, node)) { // 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连， // 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了 pred.next = node; // 线程入队了，可以返回了 return node; } } // 仔细看看上面的代码，如果会到这里， // 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队) // 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的 enq(node); return node; } /** * Inserts node into queue, initializing if necessary. See picture above. * @param node the node to insert * @return node's predecessor */ // 采用自旋的方式入队 // 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队， // 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的 private Node enq(final Node node) { for (;;) { Node t = tail; // 之前说过，队列为空也会进来这里 if (t == null) { // Must initialize // 初始化head节点 // 细心的读者会知道原来 head 和 tail 初始化的时候都是 null 的 // 还是一步CAS，你懂的，现在可能是很多线程同时进来呢 if (compareAndSetHead(new Node())) // 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了 // 这个时候有了head，但是tail还是null，设置一下， // 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了 // 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return // 所以，设置完了以后，继续for循环，下次就到下面的else分支了 tail = head; } else { // 下面几行，和上一个方法 addWaiter 是一样的， // 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排 node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } // 现在，又回到这段代码了 // if (!tryAcquire(arg) // &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // selfInterrupt(); // 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列 // 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话， // 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false // 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了 final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); // p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head // 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列 // 所以当前节点可以去试抢一下锁 // 这里我们说一下，为什么可以去试试： // 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node， // enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程 // 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试， // tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state if (p == head &amp;&amp; tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return interrupted; } // 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头， // 要么就是tryAcquire(arg)没有抢赢别人，继续往下看 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; } } finally { // 什么时候 failed 会为 true??? // tryAcquire() 方法抛异常的情况 if (failed) cancelAcquire(node); } } /** * Checks and updates status for a node that failed to acquire. * Returns true if thread should block. This is the main signal * control in all acquire loops. Requires that pred == node.prev * * @param pred node's predecessor holding status * @param node the node * @return {@code true} if thread should block */ // 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：\"当前线程没有抢到锁，是否需要挂起当前线程？\" // 第一个参数是前驱节点，第二个参数才是代表当前线程的节点 private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { int ws = pred.waitStatus; // 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true if (ws == Node.SIGNAL) /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; // 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。 // 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。 // 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点， // 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队， // 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的 if (ws &gt; 0) { /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do { node.prev = pred = pred.prev; } while (pred.waitStatus &gt; 0); pred.next = node; } else { /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ // 仔细想想，如果进入到这个分支意味着什么 // 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3 // 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0 // 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0 // 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1) compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } // 这个方法返回 false，那么会再走一次 for 循序， // 然后再次进来此方法，此时会从第一个分支返回 true return false; } // private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) // 这个方法结束根据返回值我们简单分析下： // 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒 // 我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了 // 如果返回false, 说明当前不需要被挂起，为什么呢？往后看 // 跳回到前面是这个方法 // if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; // parkAndCheckInterrupt()) // interrupted = true; // 1. 如果shouldParkAfterFailedAcquire(p, node)返回true， // 那么需要执行parkAndCheckInterrupt(): // 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的 // 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒======= private final boolean parkAndCheckInterrupt() { LockSupport.park(this); return Thread.interrupted(); } // 2. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况 // 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。 // 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程： // =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。 } 说到这里，也就明白了，多看几遍 final boolean acquireQueued(final Node node, int arg) 这个方法吧。自己推演下各个分支怎么走，哪种情况下会发生什么，走到哪里。 解锁操作最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被 LockSupport.park(this); 挂起停止，等待被唤醒。 // 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了 public void unlock() { sync.release(1); } public final boolean release(int arg) { // 往后看吧 if (tryRelease(arg)) { Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } // 回到ReentrantLock看tryRelease方法 protected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); // 是否完全释放锁 boolean free = false; // 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉 if (c == 0) { free = true; setExclusiveOwnerThread(null); } setState(c); return free; } /** * Wakes up node's successor, if one exists. * * @param node the node */ // 唤醒后继节点 // 从上面调用处知道，参数node是head头结点 private void unparkSuccessor(Node node) { /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; // 如果head节点当前waitStatus&lt;0, 将其修改为0 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ // 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1） // 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的 Node s = node.next; if (s == null || s.waitStatus &gt; 0) { s = null; // 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; } if (s != null) // 唤醒线程 LockSupport.unpark(s.thread); } 唤醒线程以后，被唤醒的线程将从以下代码中继续往前走： private final boolean parkAndCheckInterrupt() { LockSupport.park(this); // 刚刚线程被挂起在这里了 return Thread.interrupted(); } // 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了 好了，后面就不分析源码了，剩下的还有问题自己去仔细看看代码吧。 总结总结一下吧。 在并发环境下，加锁和解锁需要以下三个部件的协调： 锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。 线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。 阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现，感兴趣的读者可以参考这篇文章关于CLH的介绍，写得简单明了。 示例图解析下面属于回顾环节，用简单的示例来说一遍，如果上面的有些东西没看懂，这里还有一次帮助你理解的机会。 首先，第一个线程调用 reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回 true 了，结束。只是设置了 state=1，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，那世界就太太太平了，完全没有交集嘛，那我还要 AQS 干嘛。 如果线程 1 没有调用 unlock() 之前，线程 2 调用了 lock(), 想想会发生什么？ 线程 2 会初始化 head【new Node()】，同时线程 2 也会插入到阻塞队列并挂起 (注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环) private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // Must initialize if (compareAndSetHead(new Node())) tail = head; } else { node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } 首先，是线程 2 初始化 head 节点，此时 head==tail, waitStatus==0 aqs-1 然后线程 2 入队： aqs-2 同时我们也要看此时节点的 waitStatus，我们知道 head 节点是线程 2 初始化的，此时的 waitStatus 没有设置， java 默认会设置为 0，但是到 shouldParkAfterFailedAcquire 这个方法的时候，线程 2 会把前驱节点，也就是 head 的waitStatus设置为 -1。 那线程 2 节点此时的 waitStatus 是多少呢，由于没有设置，所以是 0； 如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 shouldParkAfterFailedAcquire 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。 aqs-3 这里可以简单说下 waitStatus 中 SIGNAL(-1) 状态的意思，Doug Lea 注释的是：代表后继节点需要被唤醒。也就是说这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着 “waitStatus代表后继节点的状态” 这种思路去看一遍源码。 （全文完）","categories":[{"name":"concurrency","slug":"concurrency","permalink":"https://winniekun.github.io/categories/concurrency/"}],"tags":[]},{"title":"2020年总结","slug":"碎碎念/2020年总结","date":"2021-01-02T16:11:11.000Z","updated":"2021-01-02T16:40:50.580Z","comments":true,"path":"2020年总结/","link":"","permalink":"https://winniekun.github.io/2020%E5%B9%B4%E6%80%BB%E7%BB%93/","excerpt":"啊","text":"啊 2020年到底还是结束了，感觉现在的自己也不喜欢做各种阶段性总结了，总感觉把自己的经历写出来是一种特别矫情的事情。相反，更想把这些经历仅供自己慢慢回味和感触。但是，时间久了，有些东西记得就不够客观了（虽然现在记忆的也不够观。。。） 所以，以后的每一年都还是做一次年终小结吧。 上半年因为疫情，上半年一直在家里呆着，每天的生活差不多如下 时间 干啥 上午 网课（挂机，干自己的事情） 下午 网课（挂机，干自己的事情） 晚上 和韩老师还有沈总打游戏 在上网课的3个月里，自己虽然课没好好上过，不过还是做了一些事情的： 剑指offer刷了3遍 LeetCode300大关完成 深入理解JVM虚拟机终于是看懂了 JDK源码（collection、juc）嗑了一遍 HashMap的设计是真的精妙 红黑树真的不是正常人写的来的 操作系统过了一遍 为啥要做这些事情嘞，主要还是想找实习，感觉在学校里面呆腻了，想出来看看（什么**想法）… 终于，在我的艰苦复习和准备之下，我心仪的字节还是把我拒绝了（今年只面了字节一家大厂），被打击到了之后，也就没再继续投递其他大厂。后面通过牛客上的内推，来到了蔚来汽车实习。 下半年从9月中旬起，开始我的实习生活，从刚开始的不适应，到后面的一脸懵逼，再到现在的勉强适应。让我认识到了自己技术上的不足，以及交流上的问题。所以基本每天回来都会主动去看每个节点的所负责的业务逻辑，涉及哪些技术栈，这些技术栈是怎么使用的，和我之前自己写着玩儿的有什么区别。自己也学会了在做任务的时候，先去看需求背景，再去看实现方案，然后脑子构建实现方式，最后再看是撸代码。遇到了自己解决不了的，有疑惑的地方，也渐渐的学会主动去请教同事了。最后，在距离实习结束还有两个月不到的时间里，希望能够拓宽自己的技术栈，精进自己的技术深度。主动去和同事交流，学习经验。","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"2021年书单【年汇总】","slug":"碎碎念/2021年书单【年终汇总】","date":"2021-01-01T07:01:10.000Z","updated":"2022-07-16T02:00:36.816Z","comments":true,"path":"2021年书单【年终汇总】/","link":"","permalink":"https://winniekun.github.io/2021%E5%B9%B4%E4%B9%A6%E5%8D%95%E3%80%90%E5%B9%B4%E7%BB%88%E6%B1%87%E6%80%BB%E3%80%91/","excerpt":"我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 摘自鶸道场 趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。","text":"我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 摘自鶸道场 趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。 书籍相关 程序员代码面试指南- IT名企算法与数据结构题目最优解 计划的是去年年底开始刷，然后计划赶不上变化 公司安排的1230的任务挺复杂的，还挺多，就没有开始搞 不过终于在31号，下定决心先把书买了，然后1号正式开刷 Linux/Unix系统编程手册 Redis的设计与实现 C++ Primer 转C++和Go了要 Go 程序涉及语言 设计模式的艺术 感觉代码写的怪怪的，不符合正常编码习惯 操作系统导论 我这渣渣英语能力 深入理解Java虚拟机：JVM高级特性与最佳实践 看来是成长了，研一上看的时候，完全看不懂 现在也是常看常新 CSAPP YYDS 深入理解Kafka：核心设计与实践原理 基础 + 经验总结类型，挺好 UNIX网络编程卷1 Spring揭秘 写的真的好 不愧是国内技术书里面少有的上9⭐的图书 MySQL技术内幕(InnoDB存储引擎) 精进MySQL必备 Java 编程的逻辑 很有条理，但是有些知识点自己有些先入为主的坏习惯，所以有些地方不太能赞同 TCP&amp;IP网络编程 我的第二本C入门书籍~ 电影、电视剧、综艺、纪录片 一点就通 合伙人2 ？？？ 温暖的抱抱 拆弹专家2 送你一朵小红花 赘婿 上头看的 哪吒重生 够朋克 你好李焕英 好看的 因为是男高所以很幸福 憨批一家人哇 罗小黑战绩 更新了，泪目 灵笼 剧情很有趣，批量生产刀子ing 荣耀乒乓 你是我的城池营垒 白敬亭真的是逗 然后B站上还关注了他的账号","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"书单","slug":"书单","permalink":"https://winniekun.github.io/tags/%E4%B9%A6%E5%8D%95/"}]},{"title":"if-else代码优化的几种方案","slug":"代码规范/if-else-code-optimization","date":"2020-11-02T11:46:42.000Z","updated":"2020-11-02T12:46:17.949Z","comments":true,"path":"if-else-code-optimization/","link":"","permalink":"https://winniekun.github.io/if-else-code-optimization/","excerpt":"前言代码中涉及到较为复杂的逻辑是，一般情况下会出现大量的if-else，虽然实现了整个功能，但是阅读起来比较耗时，并且维护的时候也十分的困难，同时只要有一个地方没有考虑清楚，修改起来就难免出现bug。最近在做公司某个节点的性能优化，就遇到了这个问题，然后在review的时候，同事和我讲了一些优化方案，以及默认的规范之后。自己重新修改之后，感觉很舒服，后续自己重新整理一下，所以就写了这篇博客。","text":"前言代码中涉及到较为复杂的逻辑是，一般情况下会出现大量的if-else，虽然实现了整个功能，但是阅读起来比较耗时，并且维护的时候也十分的困难，同时只要有一个地方没有考虑清楚，修改起来就难免出现bug。最近在做公司某个节点的性能优化，就遇到了这个问题，然后在review的时候，同事和我讲了一些优化方案，以及默认的规范之后。自己重新修改之后，感觉很舒服，后续自己重新整理一下，所以就写了这篇博客。 优化方案优化一：提前return，去除不必要的else如果if-else代码块包含return语句，可以考虑通过提前return，把多余else干掉，使代码更加优雅。 优化前if(condition){ // do something } else { // do other thing return; } 优化后if(!condition) { return; } // do something 优化二：使用三元运算优化前int price; if(condition){ price = 10; } else { price = 20; } 优化后int price = condition ? 10 : 20; 优化三：使用枚举优化前int orderStatus = getXXX(xxx); String OrderStatusDes; if(orderStatus == 0) { OrderStatusDes = \"订单未支付\"; }else if(OrderStatus == 1) { OrderStatusDes = \"订单已支付\"; }else if(OrderStatus == 2) { OrderStatusDes = \"已发货\"; } 优化后先定义一个枚举类型 public enum OrderStatusEnum { UN_PAID(0,\"订单未支付\"),PAIDED(1,\"订单已支付\"),SENDED(2,\"已发货\"),; private int index; private String desc; public int getIndex() { return index; } public String getDesc() { return desc; } OrderStatusEnum(int index, String desc){ this.index = index; this.desc =desc; } OrderStatusEnum ofCode(int orderStatus) { for (OrderStatusEnum temp : OrderStatusEnum.values()) { if (temp.getIndex() == orderStatus) { return temp; } } return null; } } 有了枚举之后，以上if-else逻辑分支，可以优化为一行代码 String OrderStatusDes = OrderStatusEnum.ofCode(orderStatus).getDesc(); 优化四：合并条件表达式如果有一系列条件返回一样的结果，可以将它们合并为一个条件表达式，让逻辑更加清晰。 优化前double getVipDiscount() { if(age&lt;18){ return 0.8; } if(\"深圳\".equals(city)){ return 0.8; } if(isStudent){ return 0.8; } //do somethig } 优化后double getVipDiscount(){ if(age&lt;18|| \"深圳\".equals(city)||isStudent){ return 0.8; } //doSomthing } 如果返回统一结果的条件过多，可以再编写一个方法，封装起来😄 优化五：使用Optional有时候if-else比较多，是因为非空判断导致的，这时候你可以使用Java9的Optional进行优化。 优化前String str = \"wkk\"; if (str != null) { System.out.println(str); } else { System.out.println(\"Null\"); } 优化后Optional&lt;String&gt; strOptional = Optional.ofNullable(\"wkk\"); strOptional.ifPresentOrElse(System.out::println, () -&gt; System.out.println(\"Null\")); Java8的Optional虽然没有这个方法，但是我们可以用Optional来优化非空的赋值操作 示例： 电池平台服役状态赋值：如果为null，赋值为0，否则为原来的值 batteryBasicInfoCollectDto.setFlowControlState(Optional.ofNullable(batteryInfo.getFlowControlState()).orElse(0)); 优化六：表驱动法优化前表驱动法，又称之为表驱动、表驱动方法。表驱动方法是一种使你可以在表中查找信息，而不必用很多的逻辑语句（if或Case）来把它们找出来的方法。以下的demo，把map抽象成表，在map中查找信息，而省去不必要的逻辑语句。 if (param.equals(value1)) { doAction1(someParams); } else if (param.equals(value2)) { doAction2(someParams); } else if (param.equals(value3)) { doAction3(someParams); } 优化后// 这里泛型是为方便演示，实际可替换为你需要的类型 Map&lt;?, Function&lt;?&gt; action&gt; actionMappings = new HashMap&lt;&gt;(); // 初始化 actionMappings.put(value1, (someParams) -&gt; { doAction1(someParams)}); actionMappings.put(value2, (someParams) -&gt; { doAction2(someParams)}); actionMappings.put(value3, (someParams) -&gt; { doAction3(someParams)}); // 省略多余逻辑语句 actionMappings.get(param).apply(someParams); 优化七：优化逻辑结构，让正常流程走主干优化前public double getAdjustedCapital(){ if(_capital &lt;= 0.0 ){ return 0.0; } if(_intRate &gt; 0 &amp;&amp; _duration &gt;0){ return (_income / _duration) *ADJ_FACTOR; } return 0.0; } 优化后 public double getAdjustedCapital(){ if(_capital &lt;= 0.0 ){ return 0.0; } if(_intRate &lt;= 0 || _duration &lt;= 0){ return 0.0; } return (_income / _duration) *ADJ_FACTOR; } 将条件反转使异常情况先退出，让正常流程维持在主干流程，可以让代码结构更加清晰。 优化八：策略模式+工厂方法消除if-else策略类定义：一个策略接口和一组实现这个接口的策略类。 特点：客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。 假设需求：根据不同勋章类型，处理相对应的勋章服务 优化前 String medalType = \"guest\"; if (\"guest\".equals(medalType)) { System.out.println(\"嘉宾勋章\"); } else if (\"vip\".equals(medalType)) { System.out.println(\"会员勋章\"); } else if (\"guard\".equals(medalType)) { System.out.println(\"展示守护勋章\"); } 优化后首先，我们把每个条件逻辑代码块，抽象成一个公共的接口，可以得出以下代码： //勋章接口 public interface IMedalService { void showMedal(); } 我们根据每个逻辑条件，定义相对应的策略实现类，可得以下代码： //守护勋章策略实现类 public class GuardMedalServiceImpl implements IMedalService { @Override public void showMedal() { System.out.println(\"展示守护勋章\"); } } //嘉宾勋章策略实现类 public class GuestMedalServiceImpl implements IMedalService { @Override public void showMedal() { System.out.println(\"嘉宾勋章\"); } } //VIP勋章策略实现类 public class VipMedalServiceImpl implements IMedalService { @Override public void showMedal() { System.out.println(\"会员勋章\"); } } 接下来，我们再定义策略工厂类，用来管理这些勋章实现策略类，如下： //勋章服务工产类 public class MedalServicesFactory { private static final Map&lt;String, IMedalService&gt; map = new HashMap&lt;&gt;(); static { map.put(\"guard\", new GuardMedalServiceImpl()); map.put(\"vip\", new VipMedalServiceImpl()); map.put(\"guest\", new GuestMedalServiceImpl()); } public static IMedalService getMedalService(String medalType) { return map.get(medalType); } } 使用了策略+工厂模式之后，代码变得简洁多了，如下： public class Test { public static void main(String[] args) { String medalType = \"guest\"; IMedalService medalService = MedalServicesFactory.getMedalService(medalType); medalService.showMedal(); } }","categories":[{"name":"代码质量","slug":"代码质量","permalink":"https://winniekun.github.io/categories/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"}],"tags":[{"name":"if-else优化","slug":"if-else优化","permalink":"https://winniekun.github.io/tags/if-else%E4%BC%98%E5%8C%96/"}]},{"title":"lombok介绍","slug":"工具/lombok-introduce","date":"2020-10-02T12:08:21.000Z","updated":"2020-10-04T14:34:01.269Z","comments":true,"path":"lombok-introduce/","link":"","permalink":"https://winniekun.github.io/lombok-introduce/","excerpt":"Lombok使用 Lombok是一款好用顺手的工具，值得去好好去熟练使用和深究。Lombok是一种Java™实用工具，可用来帮助开发人员消除Java的冗长代码，尤其是对于简单的Java对象（POJO）。它通过注释实现这一目的。通过在开发环境中实现Lombok，开发人员可以节省构建诸如hashCode()和equals()这样的方法以及以往用来分类各种accessor和mutator的大量时间。","text":"Lombok使用 Lombok是一款好用顺手的工具，值得去好好去熟练使用和深究。Lombok是一种Java™实用工具，可用来帮助开发人员消除Java的冗长代码，尤其是对于简单的Java对象（POJO）。它通过注释实现这一目的。通过在开发环境中实现Lombok，开发人员可以节省构建诸如hashCode()和equals()这样的方法以及以往用来分类各种accessor和mutator的大量时间。 使用步骤 导入Maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;${lomok.version}&lt;/version&gt; &lt;/dependency&gt; 在IDE中安装对应的插件（lombok plugin） 常用注解详解简化代码，增加可读性@Getter&amp;@Setter@Getter @Setter public class Person { private Integer id; private String name; private String age; } 通过@Getter和@Setter之后，其就类似于如下的代码： public class Persons { private Integer id; private String name; private String age; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } } @Data其等同于如下的几个注解，使用的频率最高 @Getter/@Setter @ToString @EqualsAndHashCode @RequiredArgsConstructor @Buider自动生成流式set写法，能够快速的设定Object值。但是需要注意的是，虽然该方法很好，但是因为大多数的框架都使用到了set方法进进行注入，所以在开发的时候，我们一般是将@Builder和@Data一起使用。 // 方便查看输出对象 @ToString @Builder public class Person { private Integer id; private String name; private String age; public static void main(String[] args) { Person person = Person.builder().age(\"11\").id(1).name(\"wkk\").build(); System.out.println(person); } } //Builder的使用等同于如下 public static class PersonBuilder { private Integer id; private String name; private String age; PersonBuilder() { } public Person.PersonBuilder id(Integer id) { this.id = id; return this; } public Person.PersonBuilder name(String name) { this.name = name; return this; } public Person.PersonBuilder age(String age) { this.age = age; return this; } public Person build() { return new Person(this.id, this.name, this.age); } public String toString() { return \"Person.PersonBuilder(id=\" + this.id + \", name=\" + this.name + \", age=\" + this.age + \")\"; } } 日志使用一般情况下，我们做日志处理，都会先生成一个Logger的静态常量，使用@Slf4j之后，我们就可以完全不用new一个该常量了。 public class Person{ private static final Logger logger = LoggerFactory.getLogger(Person.class); private Integer id; private String name; private String age; public static void main(String[] args){ logger.info(\"logger: {}\", \"aaaa\"); } } // Lombok实现 @Slf4j public class Person { private Integer id; private String name; private String age; public static void main(String[] args) { System.out.println(\"fsda\"); log.info(\"Person: {}\", \"fdsa\"); } } 流式对象的关闭","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://winniekun.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"2020实习前的总结","slug":"碎碎念/before-internship","date":"2020-09-06T11:11:50.000Z","updated":"2020-10-01T15:12:36.296Z","comments":true,"path":"before-internship/","link":"","permalink":"https://winniekun.github.io/before-internship/","excerpt":"前言2020年2月底，在自己确定要找实习的时候，开始和女朋友哭诉所害怕自己找不到实习，没有公司要我，我太菜了等等等。经过耗时半年的时间，终于确定下来的了实习地点和实习公司，感觉整个过程还挺好玩儿的，所以就记录下来吧。","text":"前言2020年2月底，在自己确定要找实习的时候，开始和女朋友哭诉所害怕自己找不到实习，没有公司要我，我太菜了等等等。经过耗时半年的时间，终于确定下来的了实习地点和实习公司，感觉整个过程还挺好玩儿的，所以就记录下来吧。 现在挺尴尬的，本来想着再实习之前把文章写好，但是后面有别的事情就没有来得及写，最后想写的时候，发现hexo出问题了。所以就一直拖到了国庆假期，抽了点时间改改，终于又能重新写blog了。 目前已经在NIO实习两周了，第一周还好，就是看看公司文档，然后按照需求完善了一个接口，后面老师安排我看几个节点的代码，然后修复sonarQube上检测出的Bug。第二周就开始忙碌了，刚好排期，分配了我还挺多的任务，希望能做的又好又棒。 放张我所在楼的前台，感觉还挺好看的（假期前一天走的晚，刚好没有多少人，顺手拍的😄）。 NIO 国庆假期人是真的多，虹桥车站爆满。不知道为什么，脑子里竟然是釜山行的画面… 虹桥火车站 总结面试真的并不可怕，大不了就是给面试官感觉你不行，在面试官面前尬聊一个小时，其他的真的没什么。面多了就感觉还挺好玩儿的（就是每次面试前还是会紧张好长时间）。面试期间，感觉有一些问题并没有标准的答案，所以可以使用和面试官讨论的形式阐述自己的观点。最后就是记得面试后做好复盘，这样不仅可以帮助自己查缺补漏，还能让自己能够更好的梳理知识点。","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"死磕图","slug":"LeetCode/stick-to-graph","date":"2020-08-20T00:59:56.000Z","updated":"2020-08-30T04:50:22.250Z","comments":true,"path":"stick-to-graph/","link":"","permalink":"https://winniekun.github.io/stick-to-graph/","excerpt":"前言LeetCode死磕系列九： 图 说实话图目前遇到的题目类型不多, 再加上今年图论课程上的一些算法, 只能说算是覆盖了图相关的一丢丢的内容😄 最近LeetCode每日一题, 遇到了较多的图遍历(深度遍历, 广度遍历)问题, 感觉是有迹可循的, 所以做一下整理吧.","text":"前言LeetCode死磕系列九： 图 说实话图目前遇到的题目类型不多, 再加上今年图论课程上的一些算法, 只能说算是覆盖了图相关的一丢丢的内容😄 最近LeetCode每日一题, 遇到了较多的图遍历(深度遍历, 广度遍历)问题, 感觉是有迹可循的, 所以做一下整理吧. 题目 130. 被围绕的区域 133. 克隆图 733. 图像渲染 529. 扫雷游戏 题解","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"dfs","slug":"dfs","permalink":"https://winniekun.github.io/tags/dfs/"},{"name":"bfs","slug":"bfs","permalink":"https://winniekun.github.io/tags/bfs/"}]},{"title":"ArrayDeque-analysis","slug":"源码/JDK/queue/ArrayDeque-analysis","date":"2020-07-08T07:27:56.000Z","updated":"2020-08-30T04:50:22.257Z","comments":true,"path":"ArrayDeque-analysis/","link":"","permalink":"https://winniekun.github.io/ArrayDeque-analysis/","excerpt":"依赖","text":"依赖 ArrayDeque依赖 实现了Deque接口, Serializable接口, Cloneable接口, 继承了AbstractCollection类, 同时可以看到的是Deque接口继承自Queue接口, 它是对Queue的一种增强. Deque 接口的实现类可以被当作 FIFO（队列）使用，也可以当作 LIFO（栈）来使用 Queue和DequeDeque是对Queue的增强, 我们可以先看下Queue的具体设计: public interface Queue&lt;E&gt; extends Collection&lt;E&gt; { // 添加 boolean add(E e); // 添加 不同的实现使用的添加方式不同 // list使用add // queue使用offer boolean offer(E e); // 删除 E remove(); // 弹出 E poll(); E element(); // 获取头部数据 E peek(); } Deque的设计 public interface Deque&lt;E&gt; extends Queue&lt;E&gt; { void addFirst(E e); void addLast(E e); boolean offerFirst(E e); boolean offerLast(E e); E removeFirst(); E removeLast(); E pollFirst(); E pollLast(); E getFirst(); E getLast(); E peekFirst(); E peekLast(); boolean removeFirstOccurrence(Object o); boolean removeLastOccurrence(Object o); boolean add(E e); boolean offer(E e); E remove(); E poll(); E element(); E peek(); // *** 栈 ***// void push(E e); E pop(); // *** Collection中的方法 *** boolean remove(Object o); boolean contains(Object o); public int size(); Iterator&lt;E&gt; iterator(); Iterator&lt;E&gt; descendingIterator(); } Deque中新增了以下几类方法： *First，表示从队列头操作元素； *Last，表示从队列尾操作元素； *push(e)，pop()，以栈的方式操作元素的方法； 其抽象的样子 字段&amp;属性// 底层使用数组存储元素 transient Object[] elements; // non-private to simplify nested class access // 队列头位置 transient int head; // 队列尾位置 transient int tail; // 最小初始容量 private static final int MIN_INITIAL_CAPACITY = 8; 使用数组存储元素, 默认的最小初始化容量为8, 同时有头尾两个标记位 构造函数// 默认构造函数数组容量为16 public ArrayDeque() { elements = new Object[16]; } // 指定初始容量构造函数 public ArrayDeque(int numElements) { allocateElements(numElements); } // 将集合c中的元素初始化到数组中 public ArrayDeque(Collection&lt;? extends E&gt; c) { allocateElements(c.size()); addAll(c); } // 初始化数组 private void allocateElements(int numElements) { elements = new Object[calculateSize(numElements)]; } // 和HashMap的类似, 求大于且最接近numelemnets的2的幂次且不小于8 private static int calculateSize(int numElements) { int initialCapacity = MIN_INITIAL_CAPACITY; if (numElements &gt;= initialCapacity) { initialCapacity = numElements; initialCapacity |= (initialCapacity &gt;&gt;&gt; 1); initialCapacity |= (initialCapacity &gt;&gt;&gt; 2); initialCapacity |= (initialCapacity &gt;&gt;&gt; 4); initialCapacity |= (initialCapacity &gt;&gt;&gt; 8); initialCapacity |= (initialCapacity &gt;&gt;&gt; 16); initialCapacity++; if (initialCapacity &lt; 0) // Too many elements, must back off initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements } return initialCapacity; } 通过构造方法，我们知道默认初始容量是16，最小容量是8。 入队头部入队public void addFirst(E e) { if (e == null) throw new NullPointerException(); // 将head指针减1并与数组长度减1取模 // 这是为了防止数组到头了边界溢出 // 如果到头了就从尾再向前 // 相当于循环利用数组 elements[head = (head - 1) &amp; (elements.length - 1)] = e; // 如果头尾挨在一起了，就扩容 // 扩容规则也很简单，直接两倍 if (head == tail) doubleCapacity(); } 扩容// 扩容为两倍 private void doubleCapacity() { assert head == tail; int p = head; int n = elements.length; int r = n - p; // number of elements to the right of p int newCapacity = n &lt;&lt; 1; if (newCapacity &lt; 0) throw new IllegalStateException(\"Sorry, deque too big\"); Object[] a = new Object[newCapacity]; // 将旧数组head之后的元素拷贝到新数组中 System.arraycopy(elements, p, a, 0, r); // 将旧数组下标0到head之间的元素拷贝到新数组中 System.arraycopy(elements, 0, a, r, p); // 赋值为新数组 elements = a; // head指向0，tail指向旧数组长度表示的位置 head = 0; tail = n; } 可视化 尾部入队public void addLast(E e) { if (e == null) throw new NullPointerException(); // 在尾指针的位置放入元素 // 可以看到tail指针指向的是队列最后一个元素的下一个位置 elements[tail] = e; // tail指针加1，如果到数组尾了就从头开始 if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity(); } 入队有两种方式，从队列头或者从队列尾； 如果容量不够了，直接扩大为两倍； 通过取模的方式让头尾指针在数组范围内循环； x &amp; (len - 1) = x % len，使用&amp;的方式更快(len=2的幂次等式成立)； 出队头部出队public E pollFirst() { int h = head; @SuppressWarnings(\"unchecked\") // 取队列头元素 E result = (E) elements[h]; // Element is null if deque empty if (result == null) return null; // 队头元素为空 elements[h] = null; // Must null out slot // 队头右移 head = (h + 1) &amp; (elements.length - 1); return result; } 尾部出队public E pollLast() { // 因为队尾标记的是最后一个为不为空的元素的后一位 int t = (tail - 1) &amp; (elements.length - 1); @SuppressWarnings(\"unchecked\") // 获取队尾元素 E result = (E) elements[t]; if (result == null) return null; // 队尾设置为空 elements[t] = null; // 重新设置tail tail = t; return result; } 以下是一次ArrayDeque的头部入队, 尾部出队的可视化操作 ArrayDeque&lt;Integer&gt; arrayDeque = new ArrayDeque&lt;&gt;(6); ArrayDequeUtil.getField(arrayDeque); for (int i = 1; i &lt;=10; i++) { arrayDeque.addFirst(i); ArrayDequeUtil.getField(arrayDeque); } arrayDeque.pollLast(); ArrayDequeUtil.getField(arrayDeque); 栈的实现入栈以下是Deque实现入栈的操作 public void push(E e) { addFirst(e); } public void addFirst(E e) { if (e == null) throw new NullPointerException(); elements[head = (head - 1) &amp; (elements.length - 1)] = e; if (head == tail) doubleCapacity(); } 最后, 其依赖的还是addFirst(), 也就是从头部添加元素 出栈以下是Deque实现出栈的操作 public E pop() { return removeFirst(); } public E removeFirst() { E x = pollFirst(); if (x == null) throw new NoSuchElementException(); return x; } 最后, 其依赖的还是pollFirst(), 也就是从头部删除元素, 也就是后入的元素先出 说白了实现栈的方式就是仅仅只操作队列头即可 总结&amp;面试小问题 什么是双端队列？ 双端队列是一种特殊的队列，它的两端都可以进出元素，故而得名双端队列 ArrayDeque是怎么实现双端队列的？ 底层为数组, 然后通过取模的方式构造一个循环数组, 出队入队是通过头尾指针循环利用数组实现的. ArrayDeque是线程安全的吗？ 不是线程安全 ArrayDeque的扩容机制？ ArrayDeque在容量不足时(head == tail)会出发扩容, 扩容为原先的两倍, 具体的扩容机制, 可以看上述可视化过程","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"Queue","slug":"Queue","permalink":"https://winniekun.github.io/tags/Queue/"}]},{"title":"trie","slug":"算法/trie","date":"2020-07-07T11:58:58.000Z","updated":"2020-08-30T04:50:22.259Z","comments":true,"path":"trie/","link":"","permalink":"https://winniekun.github.io/trie/","excerpt":"前缀树原理","text":"前缀树原理 Trie, 由Edward Fredkin提出, 来自英文单词retrieval, Trie也称为前缀树, 用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。 对于字符Trie而言, 如果使用二叉树那样的两个分支明显是不够的. 举个例子, 英语中一共有26个字母, 每个字母还区分大小写, 如果忽略大小写的话, 那么可以使用简单的限定分支(子树)个数为26. 如下图所示为一个字符串Trie Trie 一个保存了8个键的trie结构，”A”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn 这只是针对于不区分大小写的英语字母, 若是区分大小写, 同时还有标点等, 那么分之的数量会更加的庞大且不确定, 这是我们可以使用散列表来解决动态数量的分支. Trie的出现, 解决了散列表无法解决的字符串数集问题: 找到具有同一前缀的全部键值。 按词典序枚举字符串的数据集。 同时Trie由散列表的另一方面是: 随着数据量的增大, 散列表的查找效率可能会降低到$O(n)$, 与哈希表相比, Trie 树在存储多个具有相同前缀的键时可以使用较少的空间. 此时Trie只需要$O(m)$的时间复杂度，其中$m$为键长。 前缀树的实现Trie 树是一个有根的树，其结点具有以下字段：。 最多$R$个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母, 简单起见, 假定$R$为 26, 小写英语字母数量 布尔字段, 以指定节点是对应键的结尾还是只是键前缀. 节点构造在构造之前, 先展示包含三个单词”sea”,”sells”,”she”的 Trie的样子, 加深理解 class TrieNode { private TrieNode[] links; private boolean isEnd; private final int R = 26; public TrieNode() { links = new TrieNode[R]; } public boolean containsKey(char ch) { return links[ch - 'a'] != null; } public void put(char ch, TrieNode node) { links[ch - 'a'] = node; } public TrieNode get(char ch) { return links[ch - 'a']; } public void setEnd() { isEnd = true; } public boolean isEnd() { return isEnd; } } 插入/** * 插入 */ public void insert(String word) { // 从根节点开始, 根节点为空 TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) { char current = word.charAt(i); if (!node.containsKey(current)) { node.put(current, new TrieNode()); } node = node.get(current); } node.setEnd(); } 查找每个键在 trie 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始，。检查当前节点中与键字符对应的链接。有两种情况： 存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。 不存在链接。若已无键字符，且当前结点标记为 isEnd，则返回 true。否则有两种可能，均返回 false : 还有键字符剩余，但无法跟随 Trie 树的键路径，找不到键。 没有键字符剩余，但当前结点没有标记为 isEnd。也就是说，待查找键只是Trie树中另一个键的前缀。 private TrieNode searchPrefix(String word) { TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) { char current = word.charAt(i); if (node.containsKey(current)) { node = node.get(current); } else { return null; } } return node; } public boolean search(String word) { TrieNode node = searchPrefix(word); return node != null &amp;&amp; node.isEnd(); } /** * 是否存在输入前缀的字符 */ public boolean startsWith(String prefix) { TrieNode node = searchPrefix(prefix); return node != null; } 整体class Trie { private TrieNode root; /** * 初始化 */ public Trie() { root = new TrieNode(); } /** * 插入 */ public void insert(String word) { TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) { char current = word.charAt(i); if (!node.containsKey(current)) { node.put(current, new TrieNode()); } node = node.get(current); } node.setEnd(); } /** * 删除 */ public boolean search(String word) { TrieNode node = searchPrefix(word); return node != null &amp;&amp; node.isEnd(); } private TrieNode searchPrefix(String word) { TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) { char current = word.charAt(i); if (node.containsKey(current)) { node = node.get(current); } else { return null; } } return node; } /** * 是否存在输入前缀的字符 */ public boolean startsWith(String prefix) { TrieNode node = searchPrefix(prefix); return node != null; } class TrieNode { private TrieNode[] links; private boolean isEnd; private final int R = 26; public TrieNode() { links = new TrieNode[R]; } public boolean containsKey(char ch) { return links[ch - 'a'] != null; } public void put(char ch, TrieNode node) { links[ch - 'a'] = node; } public TrieNode get(char ch) { return links[ch - 'a']; } public void setEnd() { isEnd = true; } public boolean isEnd() { return isEnd; } } } 敏感词过滤的前缀树实现因为敏感词除了英文字母之外, 还有其他的字符, 所以使用散列表来实现, public class Trie{ // 根节点 private TrieNode rootNode = new TrieNode(); // 将一个敏感词添加到前缀树中 private void addKeyword(String keyword) { TrieNode tempNode = rootNode; for (int i = 0; i &lt; keyword.length(); i++) { char c = keyword.charAt(i); TrieNode subNode = tempNode.getSubNode(c); if(!tempNode.containsKey(c)){ tempNode.addSubNode(c, new TrieNode()); } tempNode = tempNode.getSubNode(c); } tempNode.setKeywordEnd(true); } // 前缀树 private class TrieNode { // 关键词结束标识 private boolean isKeywordEnd = false; // 子节点(key是下级字符,value是下级节点) private Map&lt;Character, TrieNode&gt; subNodes = new HashMap&lt;&gt;(); public boolean isKeywordEnd() { return isKeywordEnd; } public void setKeywordEnd(boolean keywordEnd) { isKeywordEnd = keywordEnd; } // 添加子节点 public void addSubNode(Character c, TrieNode node) { subNodes.put(c, node); } // 获取子节点 public TrieNode getSubNode(Character c) { return subNodes.get(c); } } } 实例讲解最终实现public class SensitiveFilter { // 替换符 private static final String REPLACEMENT = \"***\"; // 根节点 private TrieNode rootNode = new TrieNode(); // 加载敏感字符, 只加载一次 @PostConstruct public void init() { try ( InputStream is = this.getClass().getClassLoader().getResourceAsStream(\"sensitive-word.txt\"); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); ) { String keyword; while ((keyword = reader.readLine()) != null) { // 添加到前缀树 this.addKeyword(keyword); } } catch (IOException e) { logger.error(\"加载敏感词文件失败: \" + e.getMessage()); } } // 将一个敏感词添加到前缀树中 private void addKeyword(String keyword) { TrieNode tempNode = rootNode; for (int i = 0; i &lt; keyword.length(); i++) { char c = keyword.charAt(i); TrieNode subNode = tempNode.getSubNode(c); if(!tempNode.containsKey(c)){ tempNode.addSubNode(c, new TrieNode()); } tempNode = tempNode.getSubNode(c); } tempNode.setKeywordEnd(true); } /** * 过滤敏感词 * * @param text 待过滤的文本 * @return 过滤后的文本 */ public String filter(String text) { if (StringUtils.isBlank(text)) { return null; } // 指针1 TrieNode tempNode = rootNode; // 指针2 int begin = 0; // 指针3 int position = 0; // 结果 StringBuilder sb = new StringBuilder(); while (position &lt; text.length()) { char c = text.charAt(position); // 跳过符号 if (isSymbol(c)) { // 若指针1处于根节点,将此符号计入结果,让指针2向下走一步 if (tempNode == rootNode) { sb.append(c); begin++; } // 无论符号在开头或中间,指针3都向下走一步 position++; continue; } // 检查下级节点 tempNode = tempNode.getSubNode(c); if (tempNode == null) { // 以begin开头的字符串不是敏感词 sb.append(text.charAt(begin)); // 进入下一个位置 position = ++begin; // 重新指向根节点 tempNode = rootNode; } else if (tempNode.isKeywordEnd()) { // 发现敏感词,将begin~position字符串替换掉 sb.append(REPLACEMENT); // 进入下一个位置 begin = ++position; // 重新指向根节点 tempNode = rootNode; } else { // 检查下一个字符 position++; } } // 将最后一批字符计入结果 sb.append(text.substring(begin)); return sb.toString(); } // 判断是否为符号 private boolean isSymbol(Character c) { // 0x2E80~0x9FFF 是东亚文字范围 return !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (c &lt; 0x2E80 || c &gt; 0x9FFF); } // 前缀树 private class TrieNode { // 关键词结束标识 private boolean isKeywordEnd = false; // 子节点(key是下级字符,value是下级节点) private Map&lt;Character, TrieNode&gt; subNodes = new HashMap&lt;&gt;(); public boolean isKeywordEnd() { return isKeywordEnd; } public void setKeywordEnd(boolean keywordEnd) { isKeywordEnd = keywordEnd; } // 添加子节点 public void addSubNode(Character c, TrieNode node) { subNodes.put(c, node); } // 获取子节点 public TrieNode getSubNode(Character c) { return subNodes.get(c); } public boolean containsKey(Character c){ return subNodes.containsKey(c); } } } References 算法新解 实现 Trie (前缀树) 问答社区-敏感词过滤 基于前缀树图文详解敏感词过滤 Trie Tree 的实现 (适合初学者) 面试被虐 说说游戏中的敏感词过滤是如何实现的？","categories":[{"name":"算法","slug":"算法","permalink":"https://winniekun.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"trie","slug":"trie","permalink":"https://winniekun.github.io/tags/trie/"}]},{"title":"Cookie和Session","slug":"网络/Cookie-Session","date":"2020-07-06T01:36:34.000Z","updated":"2020-08-30T04:50:22.262Z","comments":true,"path":"Cookie-Session/","link":"","permalink":"https://winniekun.github.io/Cookie-Session/","excerpt":"前言","text":"前言 Session和Cookie的作用是为了保持访问用户与后端服务器的交互状态 CookieCookie的作用通俗来讲就是当一个用户通过HTTP请求访问服务器的时候, 服务器将一些Key/Value的键值对返回给客户端, 并且还可以给这些数据添加一些限制条件: 存活时间, 生效范围等, 在符合限制条件的情况下, 该用户再次发起请求, 数据将会被完整的返回给服务器. @RequestMapping(value = \"/cookie/set\", method = RequestMethod.GET) @ResponseBody public String setCookie(HttpServletResponse response){ // 生成cookie Cookie cookie = new Cookie(\"wkk\", CommunityUtil.generateUUID()); // 设置生效范围 cookie.setPath(\"/community/alpha\"); // 设置cookie的生效时间（默认存在内存中， 设置时间之后会存在硬盘中） cookie.setMaxAge(10); // 发送给客户端 response.addCookie(cookie); return \"set cookie\"; } Cookie W3C在设计Cookie的时候, 实际上考虑的是为了记录用户在一段时间的web应用的行为路径. 因为HTTP是无状态协议, 当用户访问完一次请求结束之后, 后端服务器无法知道下一次来访的是否还是上次访问的用户. 使用Cookies带来的优势: 短时间内, 如果与用户相关的数据频繁被访问, 可以为该数据添加缓存, 提高数据的访问性能 若是同一客户端发送的请求, 每次发出的请求都会包含第一次访问服务器之后, 服务器设置的信息, 这样服务器就可以根据Cookie来划分用户. Session虽然Cookie的出现可以让服务器识别每个客户的请求, 但是每次客户的访问都必须返回这些Cookie, 如果Cookie很多, 无疑是增加了客户端和服务端之间数据的传输量, 而Session的存在就是为了解决这个问题. Session 同一个客户端每次和服务端交互的时候, 不需要每次都传回所有的Cookie值, 而只要传回一个ID, 这个ID是客户端第一次访问服务器时生成的, 而且每个客户端是唯一的, 这样每个客户端就有了唯一的ID, 客户端只要返回ID即可, 这个ID就是名为JSSIONID的一个Cookie 安全问题虽然Cookie和Session都可以跟踪客户端的访问记录, 但是工作方式不同, Cookie是通过把所有要保存的数据通过HTTP的头部从客户端传递到服务度端, 然后又从服务端传到客户端, 所有的数据都存储到客户端的浏览器中, 这些Cookie数据可以直接访问到, 设置可以修改, 所以安全性受到很大的挑战 相比而言, Session的安全性高很多, 因为Session的数据存储在服务器里, 只是通过Cookie传递一个SessionID而已, 所以Session更适合存储用户隐私和重要的数据","categories":[{"name":"网络","slug":"网络","permalink":"https://winniekun.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"http","slug":"http","permalink":"https://winniekun.github.io/tags/http/"}]},{"title":"单例模式","slug":"设计模式/SingletonPattern","date":"2020-07-02T13:35:20.000Z","updated":"2021-03-31T11:22:40.128Z","comments":true,"path":"SingletonPattern/","link":"","permalink":"https://winniekun.github.io/SingletonPattern/","excerpt":"前言","text":"前言 “你知道茴香豆的‘茴’字有几种写法吗？” 纠结单例模式有几种写法有用吗? 有点用, 面试中经常选择其中一种或几种写法作为话头, 以此展开考察面试者的code style 以及其他相关的知识点. 但是过于纠结这些写法, 反而类似于”茴”字有几个写法… 思想, 思想, 思想. 重要事情说三遍 类加载顺序类加载(classLoader)机制一般遵从下面的加载顺序 如果类还没有被加载： 先执行父类的静态代码块和静态变量初始化，静态代码块和静态变量的执行顺序跟代码中出现的顺序有关。 执行子类的静态代码块和静态变量初始化。 执行父类的实例变量初始化 执行父类的构造函数 执行子类的实例变量初始化 执行子类的构造函数 同时，加载类的过程是线程私有的，别的线程无法进入。 如果类已经被加载： 静态代码块和静态变量不在重复执行，再创建类对象时，只执行与实例相关的变量初始化和构造方法。 static关键字一个类中如果有成员变量或者方法被static关键字修饰，那么该成员变量或方法将独立于该类的任何对象。它不依赖类特定的实例，被类的所有实例共享，只要这个类被加载，该成员变量或方法就可以通过类名去进行访问，它的作用用一句话来描述就是，不用创建对象就可以调用方法或者变量，这简直就是为单例模式的代码实现量身打造的。 饿汉模式public class Singleton { private static Singleton instance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return instance; } } 在类加载的时候就完成了实例化, 避免了多线程的同步问题. 当然缺点也是有的, 因为类加载时就实例化了, 没有达到Lazy Loading (懒加载) 的效果, 如果该实例没被使用, 内存就浪费了. 懒汉模式顾名思义, 就是初始化的时候, 不会主动的去创建实例, 而是在调用getInstance()的时候, 才会被动的去创建. public class Singleton { private static Singleton instance = null; private LazySingleton(){ } public static Singleton getInstance(){ if(instance == null){ instance = new Singleton(); } return instance; } } 在单线程的情况下, 没有任何问题, 但是因为其为线程不安全的, 在多线程的情况下, 譬如两个线程A, B都执行了getInstance()方法, 并且都执行到了第9行代码, 然后A因为其他原因, 休眠了一会儿, 待B创建了实例对象之后, A有创建了一个, 显然, 这是不符合单利模式的 解决1在getInstance()方法内部添加同步代码块, 或者直接将该方法改为同步方法 public class Singleton { private static Singleton instance = null; private LazySingleton(){ } public synchronized static Singleton getInstance(){ if(instance == null){ instance = new Singleton(); } return instance; } } 好处是写起来简单, 且绝对线程安全; 坏处是并发性能极差, 事实上完全退化到了串行. 单例只需要初始化一次, 但就算初始化以后, synchronized的锁也无法避开, 从而getInstance()完全变成了串行操作. 性能不敏感的场景建议使用。 解决2也就是臭名昭著的双重检验方法 public class Singleton { private static Singleton instance; // 双重锁检验 public static Singleton getInstance() { if (instance == null) { // 第7行 synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); // 第10行 } } } return instance; } } 由于指令重排序的问题, 可能会被重排序为如下: instance = new Singleton(); // 第10行 // 可以分解为以下三个步骤 1 memory=allocate();// 分配内存 相当于c的malloc 2 ctorInstanc(memory) //初始化对象 3 s=memory //设置s指向刚分配的地址 // 上述三个步骤可能会被重排序为 1-3-2，也就是： 1 memory=allocate();// 分配内存 相当于c的malloc 3 s=memory //设置s指向刚分配的地址 2 ctorInstanc(memory) //初始化对象 而一旦假设发生了这样的重排序，比如线程A在第10行执行了步骤1和步骤3，但是步骤2还没有执行完。这个时候另一个线程B执行到了第7行，它会判定instance不为空，然后直接返回了一个未初始化完成的instance！ 解决3public class Singleton { private static volatile Singleton instance; // 双重锁检验 public static Singleton getInstance() { if (instance == null) { // 第7行 synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); // 第10行 } } } return instance; } } 这样就保证了线程的安全 枚举模式// 枚举 // ThreadSafe public enum Singleton4 { SINGLETON; } 使用javap进行反编译得到如下结果 // 枚举 // ThreadSafe public class Singleton4 extends Enum&lt;Singleton4&gt; { ... public static final Singleton4 SINGLETON = new Singleton4(); ... } 可以看到, 其本质也还是饿汉模式 静态内部类实现/** * JVM在类的初始化阶段（class被加在后，且被线程使用之前）会执行类的初始化 * 执行类的初始化期间，JVM会去获取一个锁，锁会同步多个线程对同一个类的初始化 * @author weikunkun * @since 2021/3/20 */ public class InstanceFactory { private static class InstanceHolder { public static Object object = new Object(); } public static Object getInstance() { return InstanceHolder.object; } }","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://winniekun.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://winniekun.github.io/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java中异常类体系","slug":"Java基础/面试36讲/Throwable","date":"2020-07-02T11:57:04.000Z","updated":"2021-07-21T02:46:30.041Z","comments":true,"path":"Throwable/","link":"","permalink":"https://winniekun.github.io/Throwable/","excerpt":"","text":"解答Exception和Error均继承自Trowable, 如下图所示: 依赖图 Throwablepublic Throwable() {...} public Throwable(String message) {...} public Throwable(String message, Throwable cause) {...} public Throwable(Throwable cause) {...} ... 通过构造函数，可以看出，核心的参数为两个： message 表示异常信息 cause 造成异常的异常（套娃行为！！！） 上层的异常通过底层的异常触发一层一层的抛上来 Exception、Error在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型, Exception和Error代表了对不同异常情况的分类 Exception: 程序正常运行的情况下, 可以预料的意外情况, 可以并且应该被捕获, 之后进行处理, 最后仍能程序继续正常运行 又可以被细分为可检查异常和不可检查异常 可检查异常: 编译期间出现的异常, 必须进行捕获处理 不可检查异常: 运行期间出现的异常, 譬如ArrayIndexOutOfBoundsException, NullPointerException之类 Error: 正常情况下, 不大可能出现的异常, 绝大多数Error的出现会导致程序崩溃, 不便于也不需要捕获, 譬如OutOfMemoryError之类, 都是Error的子类 粗略了解了上述的Exception和Error的关系和概述之后，再来个详细的图，加深理解 Java 异常大家族 有这么多的异常类型，主要还是为了能够更加准确的捕获异常，增加代码的可读性、可维护性。同时可以自定义异常，更加精确阐述异常原因。通常是继承Exception或者Exception中的某个子类。 异常处理try-catch最直接的解决方式就是出现异常，解决异常。 try { // doSomething(); } catch (Exception e) { // 1. 记录异常 log.error(\"something error\"); // 2. 执行异常的业务逻辑 doExcepptionHandler(); // 3. 也可以执行完异常逻辑之后，再抛出异常 throw e } finallytry { } catch (Exception e) { } finally { } 无论是否发生异常，都会执行。 也可以这样： try { } finally { } 不捕获出现的异常，异常继续向上传递。 总结对于异常的处理，总有一层代码需要为异常负责，可能是知道如何处理异常的代码，可能是面对用户的代码，可能是主程序。 有了异常机制后，程序的正确逻辑和异常逻辑可以相分离，异常情况可以集中处理，异常还可以向上传递，不需要每层方法都需要处理。","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://winniekun.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"面试36讲","slug":"面试36讲","permalink":"https://winniekun.github.io/tags/%E9%9D%A2%E8%AF%9536%E8%AE%B2/"}]},{"title":"Spring Bean的生命周期和作用域","slug":"Java基础/面试36讲/spring-bean-knowledge-point","date":"2020-07-01T12:38:31.000Z","updated":"2021-04-05T15:26:25.201Z","comments":true,"path":"spring-bean-knowledge-point/","link":"","permalink":"https://winniekun.github.io/spring-bean-knowledge-point/","excerpt":"Spring Bean的生命周期","text":"Spring Bean的生命周期 Spring的生命周期从总体上可以分为创建和销毁两个部分. 实例化Bean对象 设置Bean属性 若是通过各种Aware接口声明了依赖关系,则会注入 Bean 对容器基础设施层面的依赖 如果bean实现了BeanNameAware接口, 则将BeanId通过setBeanName注入Spring中. 如果bean实现了BeanFactoryAware接口, 则将BeanFactory容器实例通过setBeanFactory注入Spring中 如果bean实现了ApplicationContextAware接口, 则将bean所在的应用的上下文通过setApplicationContext注入Spring中 如果bean实现了BeanPostProcessor接口, 则调用前置初始化方法, postProcessorBeforeInitialization() 如果bean实现了InitializingBean接口, 则调用afterPropertiesSet()方法, 调用自身的初始化方法 如果bean实现了BeanPostProcessor接口, 则调用后置初始化方法, postProcessorAfterInitialization() bean已经准备就绪, 可以使用, 一直驻留在应用上下文中, 直到应用上下文被销毁 如果bean实现了DisposableBean接口, 则调用destroy()方法 调用自身的destroy方法 Spring Bean 的作用域Spring Bean 有五个作用域，其中最基础的为加粗的两种 singleton Spring的默认作用于, 为每个IOC容器创建唯一的Bean实例 prototype 针对每个getBean请求, 都会创建一个Bean实例 request 每次Http请求都会创建新的Bean, 仅适用于WebApplicationContext session 一个HttpSession定义一个Bean. 该作用于仅适用于WebApplicationContext globalSession 同一个全局Http Session 定义一个Bean. 该作用域同样仅适用于WebApplicationContext","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://winniekun.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"面试36讲","slug":"面试36讲","permalink":"https://winniekun.github.io/tags/%E9%9D%A2%E8%AF%9536%E8%AE%B2/"}]},{"title":"WeakHashMap源码解读","slug":"源码/JDK/map/weakhashmap-analysis","date":"2020-06-20T10:42:30.000Z","updated":"2020-08-30T04:50:22.256Z","comments":true,"path":"weakhashmap-analysis/","link":"","permalink":"https://winniekun.github.io/weakhashmap-analysis/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"LinkedHashMap源码解读","slug":"源码/JDK/map/linkedhashmap-analysis","date":"2020-06-20T10:38:04.000Z","updated":"2021-05-04T14:46:52.357Z","comments":true,"path":"linkedhashmap-analysis/","link":"","permalink":"https://winniekun.github.io/linkedhashmap-analysis/","excerpt":"LinkedHashMap源码解读","text":"LinkedHashMap源码解读 依赖 LinkedHashMap依赖 LinkedHashMap继承HashMap, 拥有HashMap的所有特性, 并且还额外增加了按一定顺序访问的功能 概述LinkedHashMap 继承自 HashMap，在 HashMap 基础上，通过维护一条双向链表，解决了 HashMap 不能随时保持遍历顺序和插入顺序一致的问题。除此之外，LinkedHashMap 对访问顺序也提供了相关支持。在一些场景下，该特性很有用，比如缓存。在实现上，LinkedHashMap 很多方法直接继承自 HashMap，仅为维护双向链表覆写了部分方法。 节点的构造static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; { Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) { super(hash, key, value, next); } } LinkedHashMap内部的Entry相较于Node节点多了两个before、after引用，用来维护LinkedHashMap内部元素的顺序(其内部使用双向链表)。这些还好理解，不过比较好奇的是，为什么HashMap内部的TreeNode节点反而继承的是Entry，而不是HashMap内部的Node TreeNode 继承 LinkedHashMap 的内部类 Entry 后，就具备了和其他 Entry 一起组成链表的能力。但是这里会有一个疑问。当我们使用 HashMap 时，TreeNode 并不需要具备组成链表能力。如果继承 LinkedHashMap 内部类 Entry ，TreeNode 就多了两个用不到的引用，这样做不是会浪费空间吗？简单说明一下这个问题（水平有限，不保证完全正确），这里这么做确实会浪费空间，但与 TreeNode 通过继承获取的组成链表的能力相比，这点浪费是值得的。在 HashMap 的设计思路注释中，有这样一段话： Because TreeNodes are about twice the size of regular nodes, weuse them only when bins contain enough nodes to warrant use(see TREEIFY_THRESHOLD). And when they become too small (due toremoval or resizing) they are converted back to plain bins. Inusages with well-distributed user hashCodes, tree bins arerarely used. TreeNode 对象的大小约是普通 Node 对象的2倍，我们仅在桶（bin）中包含足够多的节点时再使用。当桶中的节点数量变少时（取决于删除和扩容），TreeNode 会被转成 Node。当用户实现的 hashCode 方法具有良好分布性时，树类型的桶将会很少被使用。 通过上面的注释，我们可以了解到。一般情况下，只要 hashCode 的实现不糟糕，Node 组成的链表很少会被转成由 TreeNode 组成的红黑树。也就是说 TreeNode 使用的并不多，浪费那点空间是可接受的。假如 TreeNode 机制继承自 Node 类，那么它要想具备组成链表的能力，就需要 Node 去继承 LinkedHashMap 的内部类 Entry。这个时候就得不偿失了，浪费很多空间去获取不一定用得到的能力。 类的属性/** * The head (eldest) of the doubly linked list. */ transient LinkedHashMap.Entry&lt;K,V&gt; head; /** * The tail (youngest) of the doubly linked list. */ transient LinkedHashMap.Entry&lt;K,V&gt; tail; /** * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt; * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order. * * @serial */ final boolean accessOrder; 构造函数public LinkedHashMap() { super(); accessOrder = false; } public LinkedHashMap(int initialCapacity) { super(initialCapacity); accessOrder = false; } public LinkedHashMap(int initialCapacity, float loadFactor) { super(initialCapacity, loadFactor); accessOrder = false; } public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) { super(); accessOrder = false; putMapEntries(m, false); } public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) { super(initialCapacity, loadFactor); this.accessOrder = accessOrder; } 和HashMap的构造函数是类似的，不过可以通过入参accessOrder来判断内部维护什么顺序的双向链表。 增链表的建立过程是在插入键值对节点时开始的，初始情况下，让 LinkedHashMap 的 head 和 tail 引用同时指向新节点，链表就算建立起来了。随后不断有新节点插入，通过将新节点接在 tail 引用指向节点的后面，即可实现链表的更新。 因为LinkedHashMap继承了HashMap，其并未整体重写父类的put操作，而是直接使用父类的put操作，那么问题来了，LinkedHashMap 是怎么做到在未重写父类方法情况下，有使得内部的节点具有链表的能力呢？研读源码 putVal()public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { // 对应table数组 Node&lt;K,V&gt;[] tab; // 对应位置的 Node 节点 Node&lt;K,V&gt; p; // n table的长度 // 原tab中对应放入Node的位置 int n, i; // 如果 table 未初始化，或者容量为 0 ，则进行扩容 // (第一次见这种赋值和判断融合的操作，学到了学到了) if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 如果对应的位置的Node节点为空，则直接创建 Node 节点即可。 // (n-1)&amp;hash 获取所在table的位置 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { // 哈希冲突解决 // key 在 HashMap 对应的老节点 Node&lt;K,V&gt; e; K k; // hash相等 key相等 执行覆盖 if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 为红黑树的节点 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 为Node节点，则说明是链表，且不是覆盖操作。需要遍历查找 else { // 判断什么时候进行链表转红黑树，什么时候红黑树转链表 for (int binCount = 0; ; ++binCount) { // 如果链表遍历完了都没有找到相同key的元素，说明该key对应的元素不存在，则在链表 // 最后插入一个新节点 if ((e = p.next) == null) { // ===1⃣️核心点=== // newNode() p.next = newNode(hash, key, value, null); // 链表的长度如果数量达到 TREEIFY_THRESHOLD（8）时，则进行树化。 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } // 如果待插入的key在链表中找到了，则退出循环 if (e.hash == hash&amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } // 覆盖操作， 也就是相同的key的value进行覆盖 if (e != null) { // existing mapping for key V oldValue = e.value; // onlyIfAbsent进行判断是否需要覆盖oldValue if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 如果超过阀值，则进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } // LinkedHashMap中，重写了HashMap的`newNode()`方法 Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) { // 重写了newNode方法 // 使得返回的节点为Entry节点，具有before、next指针 LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p; } // 将最后新的节点加入到双向链表的尾部 private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) { LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else { p.before = last; last.after = p; } } 总结 整体来看，就是上述的方式，在整个putVal方法中，重写了newNode()方法，同时newNode方法中，LinkedHashMap还执行了自定义的linkedNodeLast()方法。 小知识点 通过阅读putVal方法，会发现还有三个after开头的方法 // Callbacks to allow LinkedHashMap post-actions // 回调方法，供LinekdHash执行一些后置处理 // 在hashmap中并未做出具体的实现 // 但是在linkedhashmap中做出了具体的实现 void afterNodeAccess(Node&lt;K,V&gt; p) { } void afterNodeInsertion(boolean evict) { } void afterNodeRemoval(Node&lt;K,V&gt; p) { } 删和插入操作一样，LinkedHashMap的删除操作也是直接调用父类的方法，不过父类的删除逻辑并不会修复LinkedHashMap内部维护的双向链表，这也不是父类删除方法的职责，所以LinkedHashMap是如何实现在删除过程中维护内部的双向链表的呢？上源码 removeNode(int hash, Object key, Object value,boolean matchValue, boolean movable)public boolean remove(Object key, Object value) { return removeNode(hash(key), key, value, true, true) != null; } final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { // 这些和增里面是差不多的 // tab：桶数组 p：待删除节点的前驱节点 n: 桶数组大小 index: 桶数组第i个位置 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null&amp;&amp;(n = tab.length)&gt;0 &amp;&amp;(p=tab[index=(n-1)&amp;hash])!= null) { // node为需要删除的节点 Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) { if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else { do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } // 找到对应的key进行remove核心 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); // 如果node == p，说明是链表头是待删除节点 else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; // 调用删除回调方法进行后续操作 afterNodeRemoval(node); return node; } } return null; } // LinkedHashMap中afterNodeRemoval具体实现 // 双向链表的正常删除操作 void afterNodeRemoval(Node&lt;K,V&gt; e) { // unlink LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b; } // linkedlist的删除操作 E unlink(Node&lt;E&gt; x) { // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; // 后继节点 final Node&lt;E&gt; prev = x.prev; // 前驱节点 // 删除的为第一个节点 if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } // 删除的为最后一个节点 if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } } 说白了就是双向链表的删除，具体删除逻辑和LinkedList是一样的，先确定当前节点的前驱、后继节点，之后先修改指向后断链防止整个链表断开，在此期间需要判断下要删除的节点是否为第一个节点、最后一个节点，防止爆NPE 总结删除的过程并不复杂，上面这么多代码其实就做了三件事： 根据 hash 定位到桶位置 遍历链表或调用红黑树相关的删除方法 从 LinkedHashMap 维护的双链表中移除要删除的节点 查因为LinkedHashMap内部有两种机制维护内部的双向链表（按照插入顺序、按照访问顺序）前面说了插入顺序的实现，接下来研究下访问顺序。默认情况下，LinkedHashMap 是按插入顺序维护链表。不过我们可以在初始化 LinkedHashMap，指定 accessOrder 参数为 true，即可让它按访问顺序维护链表。 插入顺序、访问顺序的区别插入顺序:是指LinkedHashMap在数据插入时的插入顺序 比如说1,2,3,4…数据依次从小到大插入 若按照插入顺序输出,输出结果就是1,2,3,4… 访问顺序:则是说同样按照插入1,2,3,4…从小到大有序的插入 1. 如果在插入后你随机访问了某个元素,那么那个元素则会排列到集合的最后一位 @Test public void insetAndVisitedOrder() { Map&lt;String, String&gt; map = orderMap(); System.out.println(map); System.out.println(\"=================\"); map.get(\"key-3\"); System.out.println(map); } public Map&lt;String, String&gt; orderMap() { Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(8, 0.75F, true); for (int i = 0; i &lt; 5; i++) { map.put(\"key-\" + i, \"value-\" + i); } return map; } // {key-0=value-0, key-1=value-1, key-2=value-2, key-3=value-3, key-4=value-4} // ================= // {key-0=value-0, key-1=value-1, key-2=value-2, key-4=value-4, key-3=value-3} 阐述完毕，接下来看下其内部如何维护这两种类型的访问顺序 get(Object key)public V get(Object key) { Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; // 如果 accessOrder 为 true，则调用 afterNodeAccess 将被访问节点移动到链表最后 if (accessOrder) afterNodeAccess(e); return e.value; } void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; // 不是尾部节点 if (accessOrder &amp;&amp; (last = tail) != e) { LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else { p.before = last; last.after = p; } tail = p; ++modCount; } } 整体的操作共为两步 删除当前节点所在的位置 将当前节点插入到双向链表的尾部 注意可能当前节点可能是head节点、tail节点 同理，因为是维护了访问的双向链表，所以在对外提供的API，包含有访问性质的，都会调用afterNodeAccess来维护该双向链表 如： get getOrDefault image-20210504201032288 应用LRU缓存操作 在阐述缓存实现之前，还有一个afterNodeInsertion没有讲解 void afterNodeInsertion(boolean evict) { // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) { K key = first.key; removeNode(hash(key), key, null, false, true); } } // 移除最近最少被访问条件之一，通过覆盖此方法可实现不同策略的缓存 protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) { return false; } 上面的源码的核心逻辑在一般情况下都不会被执行，所以之前并没有进行分析。上面的代码做的事情比较简单，就是通过一些条件，判断是否移除最近最少被访问的节点。看到这里，大家应该知道上面两个方法的用途了。当我们基于 LinkedHashMap 实现缓存时，通过覆写removeEldestEntry方法可以实现自定义策略的 LRU 缓存。比如我们可以根据节点数量判断是否移除最近最少被访问的节点，或者根据节点的存活时间判断是否移除该节点等 public class SimpleCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; { private static final int MAX_NODE_NUM = 100; private int limit; public SimpleCache() { this(MAX_NODE_NUM); } public SimpleCache(int limit) { super(limit, 0.75f, true); this.limit = limit; } public V save(K key, V val) { return put(key, val); } public V getOne(K key) { return get(key); } public boolean exists(K key) { return containsKey(key); } /** * 判断节点数是否超限 * @param eldest * @return 超限返回 true，否则返回 false */ @Override protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) { return size() &gt; limit; } } 总结 LinkedHashMap继承自HashMap，具有HashMap的所有特性 LinkedHashMap内部维护了一个双向链表，来维护节点直接的顺序 如果accessOrder为false，则可以按插入元素的顺序遍历元素 如果accessOrder为true， 则可以按访问元素的顺序遍历元素 LinkedHashMap的实现非常精妙，很多方法都是在HashMap中留的钩子（Hook），直接实现这些Hook就可以实现对应的功能了，并不需要再重写put()等方法 默认的LinkedHashMap并不会移除旧元素，如果需要移除旧元素，则需要重写removeEldestEntry()方法设定移除策略； LinkedHashMap可以用来实现LRU缓存淘汰策略； references LinkedHashMap源码详细分析（JDK1.8）","categories":[],"tags":[]},{"title":"CopyOnWriteArrayList源码解读","slug":"源码/JDK/list/copy-on-write-arraylist","date":"2020-06-19T11:18:54.000Z","updated":"2020-08-30T04:50:22.255Z","comments":true,"path":"copy-on-write-arraylist/","link":"","permalink":"https://winniekun.github.io/copy-on-write-arraylist/","excerpt":"CopyOnWriteArrayList源码解读","text":"CopyOnWriteArrayList源码解读 依赖 CopyOnWriteArrayList依赖 字段&amp;属性// 用于修改数组的时候加锁 final transient ReentrantLock lock = new ReentrantLock(); // 真正存储元素的地方 只能通过get set访问 // 使用volatile修饰 保证可见性(一个线程的修改 对其他线程可见) private transient volatile Object[] array; final Object[] getArray() { return array; } final void setArray(Object[] a) { array = a; } 构造方法// 创建空数组 public CopyOnWriteArrayList() { setArray(new Object[0]); } // public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) { Object[] elements; // 如果c也是CopyOnWriteArrayList类型 // 则直接将其的array拿来用, 属于浅拷贝 // c和新的CopyOnWriteArrayList共享同一个数组 if (c.getClass() == CopyOnWriteArrayList.class) elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray(); else { elements = c.toArray(); // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elements.getClass() != Object[].class) elements = Arrays.copyOf(elements, elements.length, Object[].class); } setArray(elements); } // 把toCopyIn的元素拷贝给当前list的数组。 public CopyOnWriteArrayList(E[] toCopyIn) { setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class)); } 增add(E e)// 添加一个元素在末尾 public boolean add(E e) { final ReentrantLock lock = this.lock; // 修改数组之前加锁 lock.lock(); try { Object[] elements = getArray(); int len = elements.length; // 将数组拷贝到新数组中, 新数组长度比旧数组长度多1 Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; // array指向新的数组 setArray(newElements); return true; } finally { // 释放锁 lock.unlock(); } } 总结在尾部添加一个元素步骤: 先加锁 获取元素数组 创建一个新的数组, 长度比原数组长度多1, 并把原数组的内容拷贝到新数组 在新数组末尾添加元素 把新数组赋值给当前对象的array属性，覆盖原数组 解锁 add(int index, E element)// 指定位置添加元素 public void add(int index, E element) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; // 判断添加位置是否合法 if (index &gt; len || index &lt; 0) throw new IndexOutOfBoundsException(\"Index: \"+index+ \", Size: \"+len); Object[] newElements; // 需要移动元素的个数 int numMoved = len - index; if (numMoved == 0) newElements = Arrays.copyOf(elements, len + 1); else { // 新数组的长度为元素组的长度+1 newElements = new Object[len + 1]; // 先将原数组index之前的元素复制到新数组 System.arraycopy(elements, 0, newElements, 0, index); // 再将原数组index之后的元素复制到新数组 System.arraycopy(elements, index, newElements, index + 1, numMoved); } // 新数组中index的位置赋值element newElements[index] = element; // array指向新的数组 setArray(newElements); } finally { // 解锁 lock.unlock(); } } 总结 执行步骤: 先加锁 判断位置是否合法 计算移动的位置, 若为0, 等同于在末尾添加元素 若是不为0, 则分步骤添加原数组元素到新数组, 先是index之前, 再是index之后, 最后是index 把新数组赋值给当前对象的array属性，覆盖原数组 解锁 为什么这里使用System.arraycopy(), 而不是copyOf() 因为新数组已经被初始化了, 直接将原数组中的元素复制过来即可, 若是使用copyOf()实现起来麻烦,而且需要创建两次新的数组, 还有局部temp数组, 总之, 怎么实现起来方便怎么来, 如前一个add(E e)方法, 直接使用copyOf()方法就能实现, 使用System.arraycopy()需要先初始化, 然后再复制, 反而麻烦了 addAll(Collection&lt;? extends E&gt; c)public boolean addAll(Collection&lt;? extends E&gt; c) { Object[] cs = (c.getClass() == CopyOnWriteArrayList.class) ? ((CopyOnWriteArrayList&lt;?&gt;)c).getArray() : c.toArray(); if (cs.length == 0) return false; final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; // 原数组长度为0 if (len == 0 &amp;&amp; cs.getClass() == Object[].class) setArray(cs); else { // 创建新数组, 长度为原数组长度 + c的元素个数 // 并将元素组的元素拷贝进去 Object[] newElements = Arrays.copyOf(elements, len + cs.length); // 将c的元素拷贝到新数组中, 从len位置开始 System.arraycopy(cs, 0, newElements, len, cs.length); setArray(newElements); } return true; } finally { lock.unlock(); } } addAll(int index, Collection&lt;? extends E&gt; c)同理 查get()就是简单的根据索引获取数组元素 public E get(int index) { return get(getArray(), index); } private E get(Object[] a, int index) { return (E) a[index]; } 删remove(int index)public E remove(int index) { final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try { Object[] elements = getArray(); int len = elements.length; // 获取旧值 E oldValue = get(elements, index); // 移动元素个数 int numMoved = len - index - 1; // 如果删除的是最后一个元素, 直接拷贝出一个新的len-1的数组即可 if (numMoved == 0) setArray(Arrays.copyOf(elements, len - 1)); else { Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); } return oldValue; } finally { lock.unlock(); } } 总结 步骤: 加锁 获取原数组及长度 获取旧值 计算需要移动元素的个数 若是移动次数=0, 即删除末尾元素, 直接复制一个长度为原数组长度-1的数组, 将原数组len-1的元素放入即可 若是移动次数&gt;0, 则现将index前的元素复制到新数组(新数组确定长度为原长度-1), 然后复制index之后的元素 返回旧值 解锁 为什么移动元素个数的计算和add`方法不一样 因为添加元素到指定位置时, 原数组的对应位置上的元素a不删除, 移动的时候a也需要移动 删除的时候, 直接原数组对应位置的上的元素直接删除, 所以不需要移动 数组长度在之前的ArrayList, LinkedList 中 size都是成员变量, 在对数组做修改的时候, size执行++ 或—即可, 但是这里却不是 public int size() { return getArray().length; } 我们发现, 每次修改都是拷贝一份正好可以存储目标个数元素的数组，所以不需要size属性了，数组的长度就是集合的大小，而不像ArrayList数组的长度实际是要大于集合的大小的。 总结 使用可重入锁和volatile保证线程安全 写操作都需要加锁, 然后在此期间创建新的数组, 并在新数组中做修改, 之后再用新数组替原数组, 空间复杂度为$O(n)$ 读操作不需要加锁, 支持随机访问, 空间复杂度为$O(1)$ 采用读写分离思想(读写者问题), 但是写操作占用大量的内存空间, 适用于读多, 写少的情景 只能保证最终一致性, 不能保证实时一致性 面试相关问题 CopyOnWriteArrayList是怎么保证并发安全的？ CopyOnWriteArrayList的实现采用了什么思想？ CopyOnWriteArrayList是不是强一致性的？ CopyOnWriteArrayList适用于什么样的场景？ CopyOnWriteArrayList插入、删除、查询元素的时间复杂度各是多少？ CopyOnWriteArrayList为什么没有size属性？","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"List","slug":"List","permalink":"https://winniekun.github.io/tags/List/"},{"name":"JUC","slug":"JUC","permalink":"https://winniekun.github.io/tags/JUC/"}]},{"title":"死磕动态规划","slug":"LeetCode/stick-to-dynamic-programming","date":"2020-06-16T02:54:10.000Z","updated":"2021-06-28T04:46:20.223Z","comments":true,"path":"stick-to-dynamic-programming/","link":"","permalink":"https://winniekun.github.io/stick-to-dynamic-programming/","excerpt":"前言LeetCode死磕系列七： DP 终于轮到了DP, 怎么说类, 感觉自己写DP的题挺玄幻的, 状态好了, 能找出转移方程, 就能瞬间解决, 搞不好还能优化, 状态不好了, 只知道可以用DP, 也只是知道….","text":"前言LeetCode死磕系列七： DP 终于轮到了DP, 怎么说类, 感觉自己写DP的题挺玄幻的, 状态好了, 能找出转移方程, 就能瞬间解决, 搞不好还能优化, 状态不好了, 只知道可以用DP, 也只是知道…. 的确, 和网上的很多总结类似, 做到后面也感觉DP使用的数学知识就是数学归纳法, 然后还有自身的优化, 譬如大多数情况自底向上的DP往往要比自顶向下的DP实现起来简约且效率高, 也可使用滚动数组将高纬的dp数组降维. 两大特性 无后效行 一旦f(i,j)确定，就不用关心 “我们如何计算出f(i,j)”。 想要确定f(i,j)，只需要知道f(i-1,j)和f(i,j-1)的值，而至于它们 是如何算出来的，对当前或之后的任何子问题都没有影响。 过去不依赖将来，将来不影响过去 —- 智巅语录 最优子结构 f(i,j)的定义就已经蕴含了“最优”。 大问题的最优解可以由若干个小 问题的最优解推出。(max, min, sum…) DP能适用的问题:能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。 题目特点 计数 有多少种方式走到右下角 有多少种方法选出k个数使得和是sum 求最大值最小值 从左上角走到右下角路径的最大数字和 最长上升子序列长度 求存在性 取石子游戏，先手是否必胜 能不能选出k个数使得和是sum 主要类型I:时间序列模型给出一个序列（字符串、数组），其中每一个元素可以认为一天，并且今天的状态只取决于昨天的状态 套路 定义$dp[i][j]$： 表示第i-th轮的第j种状态（j=1,2,3,..k） 千方百计将$dp[i][j]$和前一轮的状态$dp[i-1][j]$产生关系（j=1,2,3,..k） 最后的结果就是$dp[last][j]$的某种操作（sum、max、min…） image-20210503140232767 II:时间序列加强版(子序列模型)给出一个序列（数组、字符串），其中每一个元素可以认为一天，但是今天的状态和之前的某一天相关，需要进行挑选 套路 定义$dp[i]$: 表示第i-th轮的状态，一般这个状体要求和元素i直接相关❓ 千方百计的将$dp[i]$与之前的状态$dp[i’]$产生关系（i=1,2,3..i-1）操作如（sum、max、min） $dp[i]$肯定不能与大于 i的轮次有任何关系，否 则违反了DP 的无后效性。 最终的结果为$dp[i]$中的某一个 III:双序列模型给出两个序列$S$和$T$ (数组、字符串)，对它们两个搞事情 编辑距离公式 套路： 定于$dp[i][j]$: 表示针对$S[1:i]$和$T[1:j]$的子问题的求解 千方百计将$dp[i][j]$往之前的状态去转移：$dp[i-1][j], dp[i][j-1], dp[i-1][j-1]$ 最终的结果为$dp[m][n]$ IV:第I类区间型DP给出一个序列（数组、字符串），明确要求分割成k个连续空间，要你计算这些区间的某个最优性质。 套路 状态定义：$dp[i][k]$表示针对$S[1:i]$分成k个区间，此时能够得到的最优解 搜寻最后一个区间的起始位置$j$，将$dp[i][k]$分割成$dp[j-1][k-1]$和$两个部分 最终的结果是$dp[N][K]$ image-20210503143245100 V:第II类区间型DP只给出一个序列S（数组、字符串），求一个针对这个序列的最优解 适合条件： 这个最优解对于序列的index而言，没有“无后效性”。即无法设计$dp[i]$使得 $dp[i]$仅依赖于$dp[j] (j&lt;i)$. 但是大区间的最优解，可以依赖小区间的最优解。 套路： 定义$dp[i][j]$:表示针对$s[i:j]$的子问题的求解。 千方百计将最大区间的$dp[i][j]$往小区间的$dp[i’][j’]$转移 第一层循环是区间大小；第二层循环是起始点 最终的结果是$dp[1][N]$ image-20210503144732050 VI:背包入门题目抽象：给出N件物品，每个物品可用不可用（若干种不同的用法）需要消耗一定的代价。要求以某个有上限C的代价来实现最大收益。（有时候反过来，要求以某个有下限的收益来实现 最小代价。） 套路： 定义$dp[i][j]$表示只从前i件物品的子集里面选择、代价为$j$的最大收益 j = 1、2、3、4…C 千方百计的将$dp[i][j]$往$dp[i-1][j’]$转移：考虑如何使用物品i，对代价/收益的影响 第一层建议循环物品 第二层建议循环容量/代价 最后的结果$max{dp[N][c]} | c \\in {1,2,..c}$ LeetCode&amp;Offer DP题目整理(按照上述的分类整理)牢记动归的步骤： 确定dp的数组和下标的含义 确定递归公式 dp数组的初始化 确定遍历顺序 列举dp数组 时间序列模型❌ 198. 打家劫舍 ✅ 213. 打家劫舍 II ✅ 337. 打家劫舍 III ✅ 121. 买卖股票的最佳时机 ✅ 122. 买卖股票的最佳时机 II✅ 123. 买卖股票的最佳时机 III✅ 188. 买卖股票的最佳时机 IV✅ 309. 最佳买卖股票时机含冷冻期 376. 摆动序列 487. 最大连续1的个数 II✅ 1186. 删除一次得到子数组最大和✅ 714. 买卖股票的最佳时机含手续费 剑指 Offer 63. 股票的最大利润 时间序列模型加强版(子序列问题)✅ 300. 最长递增子序列✅ 368. 最大整除子集✅ 双序列模型✅备注：设置dp空间是，看有效位从0还是1开始。 从1开始，是为了让dp转移方程更加具有适用性，能从最开始的字符串就能计算 从0开始，需要额外考虑初始化过程。行、列 题目： 72. 编辑距离 32. 最长有效括号 115. 不同的子序列 1143. 最长公共子序列 最长公共子串 字符串交错组成 区间序列模型 1278. 分割回文串 III 813. 最大平均值和的分组 区间序列模型加强版背包模型数组系列 70. 爬楼梯 746. 使用最小花费爬楼梯 72. 编辑距离 198. 打家劫舍 213. 打家劫舍 II 337. 打家劫舍 III 53. 最大子序和 322. 零钱兑换 518. 零钱兑换 II 120 三角形最小路径和 300 最长上升子序列 354. 俄罗斯套娃信封 64 最小路径和 174 地下城游戏 不同路径 不同路径II 题解时间序列模型❌198. 打家劫舍 ✅时间序列模型：其中每一个元素可以认为一天，并且今天的状态只取决于昨天的状态 定于状态$dp[i][j]$ 表示第i家，偷或不偷 $j\\in {0,1}, i \\in {N_i}$ 转移方程 $ dp[i][j]=\\left{ \\begin{array}{rcl} dp[i][0]= dp[i-1][1] + val[i] &amp;&amp; {偷}\\ dp[i][1]=Math.max(dp[i-1][0], dp[i-1][1]) &amp;&amp;{不偷}\\end{array} \\right. $ class Solution { public int rob(int[] nums) { // 0表示偷 // 1表示不偷 int[][] dp = new int[nums.length][2]; dp[0][0] = nums[0]; for (int i = 1; i &lt; nums.length; i++) { dp[i][0] = dp[i-1][1] + nums[i]; dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]); int temp = Math.max(dp[i][0], dp[i][1]); } int len = nums.length; return Math.max(dp[len-1][0], dp[len-1][1]); } } 一维解法 定义状态 $dp[i]$表到第i家能偷到的最高金额 寻找状态转移方程 $dp[0]=nums[0]$ : 目前只有一家, 所以对于小偷来说, 就偷这一家就是最高金额 $dp[1] = Math.max(nums[0], nums[1])$: 目前有两家, 对于小偷来说因为条件限制, 所以只能偷两家中金额最大的那家 $dp[2] = Math.max(dp[0]+nums[2], dp[1])$: 目前有三家, 对于小偷来说因为条件限制, 有两种可能 $dp[3] = Math.max(dp[2], dp[1]+nums[3])$ $dp[i] = Math.max(dp[i-1], dp[i-2]+nums[i])$ 确定边界值 $dp[0] = nums[0]$ $dp[1] = Math.max(nums[0], nums[1])$ public int rob(int[] nums) { // TODO 校验 int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(nums[1], nums[0]); for (int i = 2; i &lt; nums.length; i++) { dp[i] = Math.max(dp[i-1], nums[i] + dp[i-2]); } return dp[nums.length-1]; } 213. 打家劫舍 II ✅绕圈圈的打家劫舍，在循环数组中打家劫舍，思路是一样的，不过需要分类讨论了（注意数组的边界，可能会出现越界问题） Trick:首位和末位不能同时抢，这说明至少有一个不能抢。 考虑首位的房子我不抢，那么对于house[1]~house[last]就是一个基本的 House Robber问题。 考虑末位的房子我不抢，那么对于house[0]~house[last-1]就是一个基本的 House Robber问题。 class Solution { public int rob(int[] nums) { // 环形 // 1. 首位和末位不能同时抢 // 1.1 首位抢 array[1:N-1]; // 1.2 末位抢 array[2:N]; if (nums.length == 1) { return nums[0]; } int len = nums.length; int first = rob(nums, 0, len - 2); int last = rob(nums, 1, len - 1); return Math.max(first, last); } private int rob(int[] nums, int first, int last) { int len = last - first + 1; if (last == first) { return nums[first]; } int[][] dp = new int[len][2]; // 0 表示偷. dp[i][0] = dp[i-1][0] + val[i]; // 1 表示不偷 dp[i][1] = max(dp[i-1][0], dp[i-1][1]); dp[0][0] = nums[first]; for (int i = 1; i &lt; len; i++) { dp[i][0] = dp[i-1][1] + nums[first + i]; dp[i][1] = Math.max(dp[i-1][0], dp[i-1][1]); } return Math.max(dp[len - 1][0], dp[len - 1][1]); } } 一维解法 image-20210412181723948 不管是环形的还是正常的数组，数组的位置是不会改变的，所以不会因为偷了i家之后，i-1和i+1就成为邻居了，下次可以考虑在i-1和i+1偷了 public int rob(int[] nums) { // dp // 定义dp数组和下标含义 // dp[i] 到第i间房子后，能获取的最大金额 // dp[i] = Max(dp[i-1],dp[i-2] + nums[i]); // 按照分类 // 1. 小偷偷的房间不包含头尾 // 2. 小偷偷的房间包含头部 // 3. 小偷偷的房间包含尾部 // 1 包含在了2、3两种情况中了 if (nums == null || nums.length == 0) { return 0; } if (nums.length == 1) { return nums[0]; } int left = 0; int right = nums.length - 1; int first = rob(nums, 0, right - 1); int second = rob(nums, 1, right); return Math.max(first, second); } private int rob(int[] nums, int left, int right) { if (left == right) { return nums[left]; } int len = right - left + 1; int[] dp = new int[len]; dp[0] = nums[left]; dp[1] = Math.max(nums[left], nums[left + 1]); for (int i = 2; i &lt; len; i++) { dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i+left]); } return dp[len-1]; } 337. 打家劫舍 III ✅在树上偷。。。 使用后序遍历，已经包含了遍历，所以只需要确定后序面遍历，遍历过程中向上传递什么内容，按照时间序列模型定义，可以直接返回一个二维数组 $ arrayi[2]=\\left{ \\begin{array}{rcl}array_i[0]=array{left}[1] + array{right}[1] + root.val &amp;&amp; {偷}\\ array[1]=Max(array{left}[0], array{right}[1]) + Max(arry{right}[0], aray_{right}[1]) &amp;&amp;{不偷}\\end{array} \\right. $ class Solution { public int rob(TreeNode root) { if (root == null) { return 0; } int[] array = postOrer(root); return Math.max(array[0], array[1]); } private int[] postOrer(TreeNode root) { int[] array = new int[2]; if (root == null) { return array; } int[] left = postOrer(root.left); int[] right = postOrer(root.right); // int[] array = new int[2]; // 0 表示偷 max(left[1], right[1]) + root.val; // 1 表示不偷 // 向上传递整个array数组 // 偷当前节点 int first = root.val+left[1]+right[1]; // 不偷当前节点 int second = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); // ans = Math.max() array[0] = first; array[1] = second; return array; } } 121. 买卖股票的最佳时机✅买卖股票有约束，根据题目意思，有以下两个约束条件： 条件 1：你不能在买入股票前卖出股票； 条件 2：最多只允许完成一笔交易。 因此 当天是否持股 是一个很重要的因素，而当前是否持股和昨天是否持股有关系，所以也为时间序列模型 若是昨天不持股，今天持股，则和第一天持股一个道理，则当前的金额数量为$-V[i]$，最后我们只需要返回最后一天不持股的最大金额数量即可。 $ dp[i][2]=\\left{ \\begin{array}{rcl}dp[i][0]= Max(dp[i-1][0], -v[i]]) &amp;&amp; {持股}\\ dp[i][1]=Max(dp[i-1][0] + v[i], dp[i-1][1]) &amp;&amp;{不持股}\\end{array} \\right. $ class Solution { public int maxProfit(int[] prices) { int len = prices.length; if (len &lt; 2) { return 0; } // 可以理解为折线统计图，然后求上升最高的线段 // 不过这次使用动规 // 0 持股 -prices[i] // 1 不持股 +prices[i] int[][] dp = new int[len][2]; dp[0][0] = -prices[0]; // 第0天持股手上的现金 dp[0][1] = 0; //第0天不持股，手上的现金 for (int i = 1; i &lt; len; i++) { dp[i][0] = Math.max(dp[i-1][0], -prices[i]); dp[i][1] = Math.max(dp[i-1][0] + prices[i], dp[i-1][1]); } return dp[len - 1][1]; } } 附加一题剑指 Offer 63. 股票的最大利润，一摸一样。 122. 买卖股票的最佳时机 II ✅ 根据上述的转移方式，可以得到如下状态转换 $ dp[i][2]=\\left{ \\begin{array}{rcl}dp[i][0]= Max(dp[i-1][0], dp[i-1][1]-v[i]]) &amp;&amp; {持股}\\ dp[i][1]=Max(dp[i-1][0] + v[i], dp[i-1][1]) &amp;&amp;{不持股}\\end{array} \\right. $ class Solution { public int maxProfit(int[] prices) { // 动归 int len = prices.length; int[][] dp = new int[len][2]; // 初始化 // 0 表示 第i天持有股票 // 1 表示 第i不持有股票 dp[0][1] = 0; dp[0][0] = -prices[0]; for (int i = 1; i &lt; len; i++) { dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] - prices[i]); dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]); } return dp[len-1][1]; } } 714. 买卖股票的最佳时机含手续费✅和上述同理，需要添加手续费 class Solution { public int maxProfit(int[] prices, int fee) { int len = prices.length; // 0 : 持股（买入） // 1 : 不持股（售出） // dp 定义第i天持股/不持股 所得最多现金 int[][] dp = new int[len][2]; dp[0][0] = -prices[0]; for (int i = 1; i &lt; len; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]); dp[i][1] = Math.max(dp[i - 1][0] + prices[i] - fee, dp[i - 1][1]); } return Math.max(dp[len - 1][0], dp[len - 1][1]); } } 123. 买卖股票的最佳时机 III✅ image-20210503100324818 思路 最高持有两股，分为四种状态 $ dp[i][j]=\\left{ \\begin{array}{rcl} dp[i][0] = Max(dp[i-1][0], -val[i]) &amp;&amp; {第i天，持第有1股的最大利润}\\ dp[i][1]=Max(dp[i-1][1], dp[i-1][0] + val[i]) &amp;&amp; {第i天，售出第1股的最大收益} \\dp[i][2] = Max(dp[i-1][2], dp[i-1][1] - val[i] &amp;&amp; {第i天，持有第2股的最大收益} \\dp[i][3] = Max(dp[i-1][3], dp[i-1][2] + val[i]) &amp;&amp; {第i天，售出第2股的最大收益} \\end{array} \\right. $ 最后的结果为$Max{dp[N][i]} (i = 0, 1, 2, 3)$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; long[][] dp = new long[n][4]; // 0 持有1股 // 1 售出1股 // 2 持有2股 // 3 售出2股 // 第0天 持有一股， 第0天不可能出现售出的现象，只有持有第一股的可能 dp[0][0] = -prices[0]; dp[0][2] = -prices[0]; for (int i = 1; i &lt; n; i++) { dp[i][0] = Math.max(dp[i-1][0], -prices[i]); dp[i][1] = Math.max(dp[i-1][0] + prices[i], dp[i-1][1]); dp[i][2] = Math.max(dp[i-1][1] - prices[i], dp[i-1][2]); dp[i][3] = Math.max(dp[i-1][2] + prices[i], dp[i-1][3]); } long res = 0; for(int i = 0; i &lt; 4; i++) { res = Math.max(res, dp[n-1][i]); } return (int)res; } } 188. 买卖股票的最佳时机 IV✅属于123题的抽象类型，k次买卖，则我们会出现2*k次的持有、售卖状态，然后我们假设偶数为持有股票，奇数为售卖股票 image-20210503202846471 class Solution { public int maxProfit(int k, int[] prices) { // 类比买卖股票III if (prices == null || prices.length == 0) { return 0; } int len = prices.length; int[][] dp = new int[len][2*k]; for (int i = 0; i &lt; 2 * k; i++) { if (i % 2 == 0) { dp[0][i] = -prices[0]; } } for (int i = 1; i &lt; len; i++) { for (int j = 0; j &lt; 2 * k ; j++) { if (j == 0) { dp[i][j] = Math.max(dp[i-1][0], -prices[i]); } else if (j % 2 == 0) { dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-1] - prices[i]); } else { dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-1] + prices[i]); } } } // return Arrays.stream(dp[n -1]).max().getAsInt(); int res = 0; for (int i = 0; i &lt; 2 * k; i++) { res = Math.max(dp[len-1][i], res); } return res; } } 309. 最佳买卖股票时机含冷冻期✅ image-20210625160741945 $ dp[i][j]=\\left{ \\begin{array}{rcl} dp[i][0] = Max(dp[i-1][0], dp[i - 1][1] - priece[i]]) &amp;&amp; {第i天，刚持有股票的最大利益}\\ dp[i][1]=Max(dp[i-1][1], dp[i-1][2]) &amp;&amp; {冷冻的最大收益} \\dp[i][2] = Max(dp[i-1][2], dp[i-1][0] + val[i] &amp;&amp; {这一轮已经清空股票的最大收益} \\end{array} \\right. $ class Solution { public int maxProfit(int[] prices) { int n = prices.length; if (n &lt; 2) { return 0; } //定义 前i天 不同状态的最大利润 int[][] dp = new int[n][3]; // 初始化 // 0 : 买入 // 1 : 冷冻 // 2 : 清空 dp[0][0] = -prices[0]; dp[0][1] = 0; dp[0][2] = 0; for (int i = 1; i &lt; n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][2]); dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][0] + prices[i]); } return Arrays.stream(dp[n - 1]).max().getAsInt(); } } 276. 栅栏涂色256. 粉刷房子265. 粉刷房子 II487. 最大连续1的个数 II✅ image-20210503235309983 class Solution { public int findMaxConsecutiveOnes(int[] nums) { int len = nums.length; // 以 当前元素为结尾，是否形式翻转权利的最长连续的1 int[][] dp = new int[len][2]; // 0 未翻转1 // 1 翻转1 dp[0][1] = 1; dp[0][0] = nums[0] == 1 ? 1 : 0; int ans = Math.max(dp[0][1], dp[0][0]); for (int i = 1; i &lt; len; i++) { if (nums[i] == 1) { dp[i][0] = dp[i-1][0] + 1; dp[i][1] = dp[i-1][1] + 1; } else { dp[i][1] = dp[i-1][0] + 1; dp[i][0] = 0; } ans = Math.max(ans, Math.max(dp[i][0], dp[i][1])); } return ans; } } 1186. 删除一次得到子数组最大和✅ image-20210503235251921 class Solution { public int maximumSum(int[] nums) { int len = nums.length; // 0 不删除 // 1 删除 int ans = nums[0]; int[][] dp = new int[len][2]; dp[0][0] = nums[0]; dp[0][1] = 0; for (int i = 1; i &lt; len; i++) { dp[i][0] = Math.max(dp[i-1][0]+nums[i], nums[i]); dp[i][1] = Math.max(dp[i-1][0], dp[i-1][1] + nums[i]); int temp = Math.max(dp[i][0], dp[i][1]); ans = Math.max(ans, temp); } return ans; } } 时间序列模型加强版（子序列模型）✅300. 最长递增子序列✅class Solution { public int lengthOfLIS(int[] nums) { int len = nums.length; if (len &lt; 2) { return len; } int[] dp = new int[len]; Arrays.fill(dp, 1); dp[0] = 1; int ans = 1; for (int i = 1; i &lt; len; i++) { for (int j = 0; j &lt; i; j++) { if (nums[i] &gt; nums[j]) { dp[i] = Math.max(dp[j] + 1, dp[i]); } } ans = Math.max(dp[i], ans); } return ans; } } 368. 最大整除子集✅class Solution { public List&lt;Integer&gt; largestDivisibleSubset(int[] nums) { int len = nums.length; // 第 1 步：动态规划找出最大子集的个数、最大子集中的最大整数 int[] dp = new int[len]; Arrays.sort(nums); Arrays.fill(dp, 1); int maxSize = 1; int maxVal = dp[0]; for (int i = 1; i &lt; len; i++) { for (int j = 0; j &lt; i; j++) { if (nums[i] % nums[j] == 0) { dp[i] = Math.max(dp[i], dp[j] + 1); } } if (dp[i] &gt; maxSize) { maxSize = dp[i]; maxVal = nums[i]; } } // 第 2 步：倒推获得最大子集 List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (maxSize == 1) { res.add(nums[0]); return res; } for (int i = len - 1; i &gt;= 0 &amp;&amp; maxSize &gt; 0; i--) { if (dp[i] == maxSize &amp;&amp; maxVal % nums[i] == 0) { res.add(nums[i]); maxVal = nums[i]; maxSize--; } } return res; } } 1105. 填充书架双序列模型✅区间序列模型做到现在，其实可以感觉到，对于区间序列模型，其实基本思想是和子序列模型是类似的，不过子序列模型是从前面的多种状态里面获取最优结果，而区间序列是依据前面多种状态+剩余的元素构成的结果 共同决定的最优结果。 1278. 分割回文串 III明确要求分割成K个连续区间 思路：（经典的区间序列DP） 首先需要预处理每个区间$[i, j]$变成回文所需修改的字符数量(直接暴力就能获得)， 计为$cost[i,j]$ 设$dp[i][j]$表示前$i$个字符，分为$j$段，最少所需要修改的字符数量，有效字符的下标从$1$开始 初始时$dp[i,j]$为$+\\infty$, $dp[0,0] = 0$ 转移时，枚举前一次的分割点$l \\in {0, i-1}$ 这次转移所产生的新的区间为$[l+1, i]$，$dp[i][j] = min(dp[l][j-1] + g(l+1, j))$。 最终的答案$dp[N][K]$ 复杂度分析 预处理需要$O(n^3)$ 动态规划需要$O(nk)$空间 总时间复杂度$O(n^3)$ public static int palindromePartition(String s, int _k) { int n = s.length(); s = \"#\" + s; int K = _k; int[][] dp = new int[n+1][K+1]; int[][] cost = new int[n+1][n+1]; // fill for (int[] temp : dp) { Arrays.fill(temp, 1000); } for (int i = 1; i &lt;= n; i++){ dp[i][1]=calc(s.substring(1, i+1)); } for (int i = 1; i &lt;= n; i++) { for (int j = i; j &lt;= n; j++) { cost[i][j] = cost[i][j] = calc(s.substring(i, j + 1)); } } dp[1][1] = 0; for (int i = 1; i &lt;= n; i++) { for (int k = 1; k &lt;= Math.min(i, K); k++) { for (int l = 0; l &lt;= i - 1; l++) { dp[i][k] = Math.min(dp[i][k], dp[l][k-1] + cost[l + 1][i]); } } } return dp[n][K]; } private static int calc(String t) { int a = 0; int left = 0; int right = t.length() - 1; while (left &lt; right) { if (t.charAt(left) != t.charAt(right)) { a++; } left++; right--; } return a; } 813. 最大平均值和的分组本题求“最大值”，一般可以朝DP的方向考虑。另外，题意里有明确的分成k个subarray的要求，大概率就是区间型DP。 套路: 定义$dp[i][k]$，表示将前$i$个元素分成$k$个subarray的最优解，这里表示前$i$个元素，构成$k$个组，得到的最大平均数的值。突破口就是针对最后一个元素$A[i]$，它必定是在当前的最后一个subarray。 考虑最后的区间的首元素$j$会在哪里？如果选定了这个位置$j$，那么$dp[i][k]$就分解为了两个子问题，一个是$dp[j-1][k-1]$，是以前已经解决的状态，另一个就是$s[j:i]$这段区间的平均值。两者相加就是$dp[i][k]$.我们搜索所有的$j$的位置，选择使$dp[i][k]$最大化的结果。 public static double largestSumOfAverages(int[] nums, int k) { if (nums == null || nums.length == 0) { return 0D; } int len = nums.length; // dp[i][j]: 前i个元素，划分为j组，获得的最大平均总值 double[][] dp = new double[len+1][k+1]; // 优化 获取前缀和 //存储前缀和 double[] prefixSum = getPrefixSum(nums); // int[] prefixSum = new int[len + 1]; // for(int i = 1; i &lt;= len; i++){ // prefixSum[i] = prefixSum[i - 1] + nums[i - 1]; // } for (int i = 1; i &lt;= len; i++) { // 元素 for (int j = 1; j &lt;= Math.min(i, k); j++) { // 组 if(j == 1){ //针对只有1个分组的情况 dp[i][j] = (double)prefixSum[i] / i; continue; } for (int l = 0; l &lt;= i - 1; l++) { dp[i][j] = Math.max(dp[i][j], dp[l][j-1] + (double)(prefixSum[i] - prefixSum[l]) / (i - l)); } } } return dp[len][k]; } private static double[] getPrefixSum(int[] nums) { int len = nums.length; double[] prefixSum = new double[len + 1]; for (int i = 1; i &lt;= len; i++) { prefixSum[i] = prefixSum[i-1] + nums[i-1]; } return prefixSum; } 区间序列模型加强版背包模型数组系列 70. 爬楼梯 定义状态: $dp[i]$ 代表到达第$i$阶台阶, 有多少种走法 寻找状态转移方程 $dp[1] = 1$: 到达第1阶台阶只有一种走法$[1]$ $dp[2] = 2$: 到达第2阶台阶有两种走法$[1,1], [2]$ $dp[3] = 3$: 到达第3阶台阶有三种走法$[1,1,1], [1,2], [2, 1]$ $dp[4] = 5$: 到达第4阶台阶有五种走法$[1,1,1,1], [1,1,2],[1,2,1],[2,2][2,1,1]$ 通过上述的推演, 可以归纳, $dp[i]=dp[i-1] + dp[i-2]$, 也就是到达第$i$阶的台阶共有两种可能方式, 第一种是通过第$i-1$阶再走1步, 第二种是通过第$i-2$阶再走2步, 同时到达第$i-1$阶的走法有$dp[i-1]$种, 到达第$i-2$阶的走法有$dp[i-2]$种, 则$dp[i] = dp[i-1] + dp[i-2]$ 确定边界值 刚才找状态转移方程的时候已经确定好了 $dp[1] = 1$ $dp[2] = 2$ 因为计算机中, 索引是从0开始的, 如果我们定义长度为n的数组, 则最后一个数组的索引为n-1(我们理解上的dp[n]也就是数组中的dp[n-1]), 则我们定义的边界值$dp[0] = 1$, $dp[1] = 2$, 同理, 若是想直接返回dp[n], 则我们就需要将索引为0的数组元素空出来, 也就是dp[0] = 0, dp[1] = 1, dp[2] = 2 public int climbStairsI(int n) { if(n &lt;= 2){ return n; } int[] dp = new int[n]; dp[0] = 1; dp[1] = 2; for(int i = 2; i&lt;n; i++){ dp[i] = dp[i-1] + dp[i-2]; } return dp[n-1]; } public int climbStairsII(int n) { if(n &lt;= 2){ return n; } int[] dp = new int[n+1]; dp[0] = 0; dp[1] = 1; dp[2] = 2; for(int i = 3; i&lt;=n; i++){ dp[i] = dp[i-1] + dp[i-2]; } return dp[n]; } 最后优化 因为我们上述的算法, 消耗了$O(n)$的空间, 同时我们能感觉到可以使用累加的方式进行计算, 而且也只需要返回最终结果, 中间结果我们没必要存储起来, 所以可以做加法运算 public int climbStairs(int n) { if(n &lt;= 2){ return n; } int a = 1; int b = 2; int temp; for(int i = 3; i&lt;=n; i++){ temp = a + b; a = b; b = temp; } return b; } 746. 使用最小花费爬楼梯$ f[i] = cost[i] + min(f[i+1], f[i+2])$ public int minCostClimbingStairs(int[] cost) { int f1 = 0, f2 = 0; for (int i = cost.length - 1; i &gt;= 0; --i) { int f0 = cost[i] + Math.min(f1, f2); f2 = f1; f1 = f0; } return Math.min(f1, f2); } 73. 编辑距离 定义状态: $dp[i][j]$ 表示A的前i个字符到B的前j个字符之间的编辑距离 寻找状态转移方程 我觉得二维的状态, 画在纸上更加的简单明了 $dp[0][j]$表示一个空字符串A到B的前j个字符之间的距离 $dp[i][0]$表示一个空字符串B到字符串A的前i个字符之间的距离 $d[i,j]=min(d[i-1,j]+1 、d[i,j-1]+1、d[i-1,j-1]+temp)$ 这三个当中的最小值 $str1[i] == str2[j]$，表示相同, 用temp记录它，为0。否则temp记为1 $dp[i-1][j]$ 表示增加操作 $dp[i][j-1]$表示删除操作 $dp[i-1][j-1] + temp$表示替换操作 边界值 $dp[i][0]$ $dp[0][j]$ public static int minDistance(String word1, String word2) { int m = word1.length(); int n = word2.length(); int[][] dp = new int[m+1][n+1]; dp[0][0] = 0; // 初始化dp for(int i = 1; i&lt;=m; i++){ dp[i][0] = dp[i-1][0] + 1; } for(int j = 1; j&lt;=n; j++){ dp[0][j] = dp[0][j-1] + 1; } int temp = 0; // 转移方程: dp[i][j] = Math.min(dp[i-1][j-1]+temp, // dp[i][j-1]+1, dp[i-1][j]+1); for(int i = 1; i&lt;=m; i++){ for(int j = 1; j&lt;=n; j++){ // 因为我们的数组这只有效位从1开始 // 所以标记当前遍历到的字符串的位置为i-1|j-1 if(word1.charAt(i-1) == word2.charAt(j-1)){ temp = 0; }else { temp = 1; } dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]) + 1, dp[i-1][j-1] + temp); } } return dp[m][n]; } 337. 打家劫舍 III在树上偷。。。 使用后序遍历，定义一个二维数组 dp[0] : 不偷当前节点的结果 $dp[0] = Math.max(left[0], left[1]) + Math.max(rigth[0] + right[1])$ dp[1]：偷当前节点的结果 $dp[1] = root.val + left[0] + right[0]$ public int rob(TreeNode root) { int[] res = postOrder(root); return Math.max(res[0], res[1]); } private int[] postOrder(TreeNode root) { if (root == null) { return new int[2]; } int[] left = postOrder(root.left); int[] right = postOrder(root.right); int[] res = new int[2]; // 不偷当前节点 int first = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); // 偷当前节点 int second = root.val+left[0]+right[0]; res[0] = first; res[1] = second; return res; } 53. 最大子序和322. 零钱兑换518. 零钱兑换 II120 三角形最小路径和300 最长上升子序列354. 俄罗斯套娃信封最后的思路和最长上升子序列一样，不过在此之之前需要整理好数据 /** * 354 俄罗斯套娃信封 * 思路： 详见程序员代码面试指南216页 * @author weikunkun * @since 2021/4/2 */ public class LC_354 { public int maxEnvelopes(int[][] envelopes) { // 思路 // 封装一个信封对象，然后按照信封的宽度进行排序 小-大 // 如果宽度相同，按照高度排序 大到小 // 之后 对 高度序列 求最长递增子序列即可 Envelope[] array = genEnvelope(envelopes); int[] heights = genHeightArray(array); int[] dp = new int[heights.length]; Arrays.fill(dp, 1); int maxNumber = 0; for (int i = 0; i &lt; heights.length; i++) { int cur = heights[i]; int j = 0; int max = 0; while (j &lt; i) { if (heights[j] &lt; cur) { max = Math.max(max, dp[j]); } j++; } dp[i] = max + 1; maxNumber = Math.max(dp[i], maxNumber); } return maxNumber; } private Envelope[] genEnvelope(int[][] envelopes) { Envelope[] array = new Envelope[envelopes.length]; int i = 0; for (int[] envelope : envelopes) { Envelope env = new Envelope(envelope[0], envelope[1]); array[i++] = env; } Arrays.sort(array, new EnvelopComparetor()); return array; } private int[] genHeightArray(Envelope[] array) { int[] heights = new int[array.length]; int i = 0; for (Envelope envelope : array) { heights[i++] = envelope.height; } return heights; } } // 构建一个信封对象 class Envelope { public int wight; public int height; public Envelope(int wight, int height) { this.wight = wight; this.height = height; } } class EnvelopComparetor implements Comparator&lt;Envelope&gt; { @Override public int compare(Envelope o1, Envelope o2) { return o1.wight != o2.wight ? o1.wight - o2.wight : o2.height - o1.height; } } 64 最小路径和174 地下城游戏从下至上，然后每次当前位置的血量，为 dp[i+1][j+1] - dungeon[i][j] public int calculateMinimumHP(int[][] dungeon) { int[][] dp = new int[dungeon.length][dungeon[0].length]; int rows = dungeon.length; int cols = dungeon[0].length; dp[rows-1][cols-1] = Math.max(1-dungeon[rows-1][cols-1], 1); for (int i = rows-2; i &gt;= 0; i--) { dp[i][cols-1] = Math.max(1, dp[i+1][cols-1] - dungeon[i][cols-1]); } for (int i = cols-2; i &gt;= 0; i--) { dp[rows-1][i] = Math.max(1, dp[rows - 1][i + 1] - dungeon[rows-1][i]); } for (int i = rows - 2; i &gt;= 0; i--) { for (int j = cols - 2; j &gt;= 0; j--) { int min = Math.min(dp[i+1][j], dp[i][j+1]); dp[i][j] = Math.max(1, min - dungeon[i][j]); } } return dp[0][0]; } 62. 不同路径public int uniquePaths(int m, int n) { int[][] dp = new int[m][n]; dp[0][0] = 1; for(int i = 1; i &lt; m; i++) { dp[i][0] = 1; } for (int i = 1; i &lt; n; i++) { dp[0][i] = 1; } for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m-1][n-1]; } 63. 不同路径IIpublic int uniquePathsWithObstacles(int[][] obstacleGrid) { if (null == obstacleGrid || obstacleGrid.length == 0 || null == obstacleGrid[0] || obstacleGrid[0].length == 0) { return 0; } int m = obstacleGrid.length; int n = obstacleGrid[0].length; if (obstacleGrid[0][0] == 1) { return 0; } int[][] dp = new int[m][n]; dp[0][0] = 1; for(int i = 1; i &lt; m; i++) { if (obstacleGrid[i][0] == 1) { dp[i][0] = 0; break; } else { dp[i][0] = 1; } } for (int i = 1; i &lt; n; i++) { if (obstacleGrid[0][i] == 1) { dp[0][i] = 0; break; } else { dp[0][i] = 1; } } for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { if (obstacleGrid[i][j] == 0) { dp[i][j] = dp[i-1][j] + dp[i][j-1]; } else { dp[i][j] = 0; } } } return dp[m-1][n-1]; } 字符串系列72. 编辑距离这个在数组部分已经讲解过了。 32. 最长有效括号 确定dp数组，和索引下标意义 $dp[i]$ 表示 以s[i]结尾的最长有效括号 确定递归公式 s[i]是'('，以它为结尾的子串，肯定不是有效括号子串——dp[i] = 0 s[i]是')'， 以它为结尾的子串，分类讨论 s[i-1] == '(' dp[i] = dp[i-2] + 1; s[i-1] == ')' s[i-1]的最长子串为dp[i-1], 所以减去得s[i-dp[i-1]-1] s[i-dp[i-1]-1]不存在或为')'，则s[i]找不到匹配，直接gg——dp[i]=0 s[i-dp[i-1]-1]是'('，与s[i]匹配，有效长度 = 2 + 跨过的dp[i-1]+ 前方的dp[i-dp[i-1]-2]。等一下，s[i-dp[i-1]-2]要存在才行！ s[i-dp[i-1]-2]存在，dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2s[i-dp[i-1]-2]不存在，dp[i] = dp[i-1] + 2 public int longestValidParentheses(String s) { int maxans = 0; int[] dp = new int[s.length()]; for (int i = 1; i &lt; s.length(); i++) { if (s.charAt(i) == ')') { if (s.charAt(i - 1) == '(') { dp[i] = (i &gt;= 2 ? dp[i - 2] : 0) + 2; } else if (i - dp[i - 1] &gt; 0 &amp;&amp; s.charAt(i - dp[i - 1] - 1) == '(') { dp[i] = dp[i - 1] + ((i - dp[i - 1]) &gt;= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2; } maxans = Math.max(maxans, dp[i]); } } return maxans; } 115. 不同的子序列这道题感觉和编辑距离公式的思路差不多，不过，没有那么复杂，只需要考虑减这一个步骤即可。 还是那一个例子来说吧： 输入：S=\"bagbagbag\", T=\"bag\" 输出：5 Support/typora-user-images/image-20200907231246178.png 定义状态 $dp[i][j]$ 表示为$T$的前$i$个字符可以由$S$的前$j$个字符组成最多的个数 寻找状态转移方程 $S[i] == T[j]$ 取$S[i]$，那么当前情况总数，应该和字符串$S$的前$i-1$个字符所构成的子序列中出现字符串$T$的前$j-1$个字符的情况总数相等。$dp[i][j] = dp[i-1][j-1]$ 不取$S[i]$,那么当前情况总数，应该和字符串$S$的前$i$个字符所构成的子序列中出现字符串$T$的前$j-1$个字符的情况总数相等。$dp[i][j] = dp[i][j-1]$那么$dp[i][j]$应等于这两种情况的和。$dp[i][j] = dp[i-1][j-1] + dp[i][j-1]$ $S[i] != T[j]$ 只有一种情况，和$S[i] == T[j]$的第二种情况是一样的，因为当前不相等，也就不能取（图中蓝色框）。 $dp[i][j] = dp[i][j-1]$ 状态转移方程 $ dp[i][j]=\\left{ \\begin{array}{rcl} dp[i][j] = dp[i-1][j-1] + dp[i][j-1] &amp; &amp; {S[i] == T[j]}\\ dp[i][j]=dp[i][j-1] &amp; &amp; {S[i] != T[j]} \\end{array} \\right. $ 确定边界值 $dp[0][j]=1$，此时表示为T==NULL，也就是空字符串T可以由非空的S组成的最多的个数，很明显为1。 $dp[i][0] = 0$，此时表示为S==NULL，也就是非空字符串T可以由空的字符串S组成的最多的个数，很明显为0。 public int numDistinct(String s, String t) { int m = s.length(); int n = t.length(); int[][] dp = new int[n + 1][m + 1]; dp[0][0] = 1; for (int i = 1; i &lt;= n; i++) { dp[i][0] = 0; } for (int i = 1; i &lt;= m; i++) { dp[0][i] = 1; } // 注意i和j和题解上的是相反的 for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if (t.charAt(i - 1) == s.charAt(j - 1)) { dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1]; } else { dp[i][j] = dp[i][j - 1]; } } } return dp[n][m]; } 1143. 最长公共子序列思路和编辑距离差不多，编辑距离返回最后的结果，这里需要遍历整个dp矩阵，返回最大。 /** * 首先定义好第一行和第一列 * 假设 行 text2 * 假设 列 text1 * 对于行： text1[0] 和text2[i]中任意一位置字符相同，则i-len位置为1 * 对于列： 同理 * 非首行和首列： 1. dp[i-1][j] dp[i][j-1] dp[i-1][j-1]+1 最大 * @param text1 * @param text2 * @return */ public int longestCommonSubsequence(String text1, String text2) { int[][] dp = new int[text1.length()][text2.length()]; int max = 0; // 初始化行 // 初始化列 // 遍历整个 int rows = dp.length; int cols = dp[0].length; dp[0][0] = text1.charAt(0) == text2.charAt(0) ? 1 : 0; for (int i = 1; i &lt; rows; i++) { dp[i][0] = Math.max(dp[i-1][0], text1.charAt(i) == text2.charAt(0) ? 1 : 0); max = Math.max(dp[i][0], max); } for (int i = 1; i &lt; cols; i++) { dp[0][i] = Math.max(dp[0][i-1], text1.charAt(0) == text2.charAt(i) ? 1 : 0); max = Math.max(dp[0][i], max); } for (int i = 1; i &lt; rows; i++) { for (int j = 1; j &lt; cols; j++) { dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); if (text2.charAt(j) == text1.charAt(i)) { dp[i][j] = Math.max(dp[i][j], dp[i-1][j-1] + 1); } max = Math.max(dp[i][j], max); } } return max; } 最长公共子串找到了和公共子串类似的数组，就拿着替代一下 image-20210413155100877 public int findLengthII(int[] nums1, int[] nums2) { int len1 = nums1.length; int len2 = nums2.length; int[][] dp = new int[len1][len2]; // // if nums1[i] == nums2[j] dp[i][j] = dp[i-1][j-1] + 1; // else dp[i][j] = 0; int max = 0; for (int i = 0; i &lt; len1; i++) { if (nums1[i] == nums2[0]) { dp[i][0] = 1; max = Math.max(max, dp[i][0]); } } for (int i = 0; i &lt; len2; i++) { if (nums2[i] == nums1[0]) { dp[0][i] = 1; max = Math.max(max, dp[0][i]); } } for (int i = 1; i &lt; len1; i++) { for (int j = 1; j &lt; len2; j++) { if (nums1[i] == nums2[j]) { dp[i][j] = dp[i-1][j-1] + 1; max = Math.max(dp[i][j], max); } } } return max; } 字符串交错组成class Solution { public boolean isInterleave(String s1, String s2, String s3) { int n = s1.length(), m = s2.length(), t = s3.length(); if (n + m != t) { return false; } boolean[][] f = new boolean[n + 1][m + 1]; f[0][0] = true; for (int i = 0; i &lt;= n; ++i) { for (int j = 0; j &lt;= m; ++j) { int p = i + j - 1; if (i &gt; 0) { f[i][j] = f[i][j] || (f[i - 1][j] &amp;&amp; s1.charAt(i - 1) == s3.charAt(p)); } if (j &gt; 0) { f[i][j] = f[i][j] || (f[i][j - 1] &amp;&amp; s2.charAt(j - 1) == s3.charAt(p)); } } } return f[n][m]; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://winniekun.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"}]},{"title":"死磕单调栈","slug":"LeetCode/stick-to-monotonicity-stack","date":"2020-06-14T11:56:11.000Z","updated":"2021-05-16T16:40:37.343Z","comments":true,"path":"stick-to-monotonicity-stack/","link":"","permalink":"https://winniekun.github.io/stick-to-monotonicity-stack/","excerpt":"","text":"单调栈前几天刷每日一题的时候, 遇到了一个很有趣的题, 刚开始自己直接暴力AC了, 然后优化的时候, 发现了单调栈这么个特殊的数据结构, 很有趣. 首先, 单调栈的作用范围不大, 只适合用来做一类题目—Next Greater Element 题目接雨水思路参考甜姨题解 public int trap(int[] height) { // 思路 维护一个最小栈 if (height == null || height.length == 0) { return 0; } int ans = 0; Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; height.length; i++) { while (!stack.isEmpty() &amp;&amp; height[stack.peek()] &lt; height[i]) { int curIdx = stack.pop(); while(!stack.isEmpty() &amp;&amp; height[stack.peek()] == height[curIdx]) { stack.pop(); } if (!stack.isEmpty()) { int left = stack.peek(); int len = i - left -1 ; int high = Math.min(height[i], height[left]) - height[curIdx]; ans += len * high; } } stack.push(i); } return ans; }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"单调栈","slug":"单调栈","permalink":"https://winniekun.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"排序算法总结","slug":"算法/排序/sorting-algorithms-summary","date":"2020-06-10T05:30:17.000Z","updated":"2021-06-30T16:47:34.280Z","comments":true,"path":"sorting-algorithms-summary/","link":"","permalink":"https://winniekun.github.io/sorting-algorithms-summary/","excerpt":"排序算法总结","text":"排序算法总结 常用排序算法 时间复杂度 空间复杂度 是否为稳定排序 是否为原地排序 直接插入排序 $O(n^2)$ $O(1)$ ✔ ✔ 折半插入排序 $ O(n^2)$ (只优化了比较的过程) $O(1)$ ✔ ✔ 希尔排序 和增量有关，最坏$O(n^2)$ $O(1)$ ❌ ✔ 冒泡排序 $O(n^2)$ $O(1)$ ✔ ✔ 快速排序 $O(nlog_2n)$ $O(log_2n)$ ❌ ✔ 简单选择排序 $O(n^2)$ $O(1)$ ❌ ✔ 堆排序 $O(nlog_2n)$ $O(1)$ ❌ ✔ 归并排序 $O(nlog_2n)$ $O(n)$ ✔ ❌ ==基数排序== $O(dn) d是位数$ $O(d)$ ✔ ❌ ==桶排序== $O(n+k)$ k为桶个数，n为元素数量 $O(n+k)$ ✔ ❌ References 严版数据结构 数据结构与算法之美","categories":[{"name":"排序","slug":"排序","permalink":"https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[]},{"title":"lock","slug":"Java进阶/并发/lock","date":"2020-05-30T02:26:14.000Z","updated":"2020-08-30T04:50:22.248Z","comments":true,"path":"lock/","link":"","permalink":"https://winniekun.github.io/lock/","excerpt":"简介","text":"简介 锁用来控制多个线程的同步访问共享资源, 一个锁可以防止多个线程同时访问共享资源(读写锁允许多个线程并发访问共享资源), 在Java中, 内置锁—-基于对象的锁 , 它一般是配合synchronized关键字使用的, 同时synchronized的一系列优化 , 衍生出了偏向锁 , 轻量级锁, 重量级锁. 同时在java.util.concurrent.locks包下, 还提供了几个关于锁的接口, 抽象类及具体是实现的锁. 他们的拥有更高的灵活性和更加强大的功能. 基础使用 Lock lock = new ReentraLock(); lock.lock(); try{ // 业务逻辑 }final{ // 释放锁 lock.unlock() } 锁的分类锁可以根据以下几种方式来进行分类. 当然还有其他类型的锁类型, 如: 公平锁, 非公平锁; 偏向锁, 轻量级锁, 重量级锁; 乐观锁, 悲观锁; 重入锁和非重入锁能否重新进入锁, 也就是说锁支持一个线程对资源重复加锁. synchronized关键字就是使用的重入锁。比如说，你在一个synchronized实例方法里面调用另一个本实例的synchronized实例方法，它可以重新进入这个锁，不会出现任何异常。 公平锁和非公平锁公平和非公平的通俗意义就是FIFO先来后到 , 对于一个锁来说, 先对锁请求的线程会先被满足, 后对锁发起请求的线程会后被满足, 其就是公平锁 一般情况下，非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况。所以要根据实际的需求来选择非公平锁和公平锁。 读写锁和排它锁synchronized用的锁和ReentrantLock 都是排它锁, 也就是同一时刻仅允许一个线程访问资源 读写锁允许同一时刻多个线程并发访问资源, 其内部维护了一个读锁和写锁 通过分离读锁和写锁，使得在“读多写少”的环境下，大大地提高了性能。(操作系统中的读写者问题) juc.locks包 locks包一览 接口: Lock ReadWriteLock ConditionLock获取锁和释放锁的方法声明 public interface Lock { void lock(); void unlock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; Condition newCondition(); } ReadWriteLock返回读锁和写锁 public interface ReadWriteLock { /** * Returns the lock used for reading. * * @return the lock used for reading */ Lock readLock(); /** * Returns the lock used for writing. * * @return the lock used for writing */ Lock writeLock(); } Condition感觉和Object类中的wait和notify/notifyAll机制很像, 不过更加高端吧 public interface Condition { void await() throws InterruptedException; boolean await(long time, TimeUnit unit) throws InterruptedException; long awaitNanos(long nanosTimeout) throws InterruptedException; void awaitUninterruptibly(); boolean awaitUntil(Date deadline) throws InterruptedException; void signal(); void signalAll(); } 看下两者的区别吧 对比项 Object监视器 Condition 前置条件 获取对象的锁 调用Lock.lock获取锁，调用Lock.newCondition获取Condition对象 调用方式 直接调用，比如object.notify() 直接调用，比如condition.await() 等待队列的个数 一个 多个 当前线程释放锁进入等待状态 支持 支持 当前线程释放锁进入等待状态，在等待状态中不中断 不支持 支持 当前线程释放锁并进入超时等待状态 支持 支持 当前线程释放锁并进入等待状态直到将来的某个时间 不支持 支持 唤醒等待队列中的一个线程 支持 支持 唤醒等待队列中的全部线程 支持 支持 抽象类: AQS AQLS AOSAQS之前已经细讲了, AQLS和AQS实现原理一样, 只不过 state类型改为了long AOS是AQS和AQLS的父类, 根据源码可以推测出, 其作用是表示锁和持有者(线程)的关系 AOS public abstract class AbstractOwnableSynchronizer implements java.io.Serializable { /** Use serial ID even though all fields transient. */ private static final long serialVersionUID = 3737899427754241961L; /** * Empty constructor for use by subclasses. */ protected AbstractOwnableSynchronizer() { } /** * 独占模式，锁的持有者 */ private transient Thread exclusiveOwnerThread; /** * 设置锁持有者 */ protected final void setExclusiveOwnerThread(Thread thread) { exclusiveOwnerThread = thread; } /** * 获取锁的持有线程 */ protected final Thread getExclusiveOwnerThread() { return exclusiveOwnerThread; } } 具体实现类ReentrantLock之前讲过的重入锁和非重入锁以及公平锁和非公平锁在ReentrantLock均涉及到了. 我们可以根据源码看下具体的实现方式 public class ReentrantLock implements Lock, java.io.Serializable { private static final long serialVersionUID = 7373984872572414699L; /** Synchronizer providing all implementation mechanics */ private final Sync sync; abstract static class Sync extends AbstractQueuedSynchronizer { // 具体实现 } /** * Sync object for non-fair locks */ static final class NonfairSync extends Sync { // 具体实现 } /** * Sync object for fair locks */ static final class FairSync extends Sync { // 具体实现 } public ReentrantLock() { sync = new NonfairSync(); } public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } // Lock接口的方法实现 ... // 自己一些逻辑 ... public final boolean isFair() { return sync instanceof FairSync; } } 从整体上看, ReentrantLock有一个抽象内部类Sync继承AQS, 用于实现自己的同步器, 同时有两个非抽象内部类NonfairSync和FairSync, 继承了Sync, 从字面意思来看, 就是公平同步器和非公平同步容器 这意味着, ReentrantLock支持公平锁和非公平锁, 在构造函数里面可以传入一个boolean类型的参数，来指定它是否是一个公平锁，默认情况下是非公平的。这个参数一旦实例化后就不能修改，只能通过isFair()方法来查看。 我们来看下非公平锁实现的实现, 走一遍流程: abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = -5179523762034025860L; abstract void lock(); // 非公平的获取资源 final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); // 资源可用 if (c == 0) { if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } // 若是当前线程已经获取了锁 可重入 else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; } return false; } // other method } 在实现非公平锁的同时, 通过增加了再次获取资源的处理逻辑实现了可重入锁: 判断当前线程是否为获取锁的线程 来判断操作是否成功, 如果是同一线程, 则同步状态值进行增加并返回true 表示获取同步成功. 那么同理, 释放锁在释放同步状态的时候, 减少同步状态值, 为0 则表示释放完全 protected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) { free = true; // 全部释放的话直接把独占线程设置为null setExclusiveOwnerThread(null); } setState(c); return free; } 非公平锁的实现, 就是后申请资源的线程和先申请资源的线程一样, 谁能通过compareAndSetState设置成功, 则开始执行任务. ReentrantReadWriteLock它与ReentrantLock的功能类似，同样是可重入的，支持非公平锁和公平锁。不同的是，它还支持”读写锁“。 // 内部结构 private final ReentrantReadWriteLock.ReadLock readerLock; private final ReentrantReadWriteLock.WriteLock writerLock; final Sync sync; abstract static class Sync extends AbstractQueuedSynchronizer { // 具体实现 } static final class NonfairSync extends Sync { // 具体实现 } static final class FairSync extends Sync { // 具体实现 } public static class ReadLock implements Lock, java.io.Serializable { private final Sync sync; protected ReadLock(ReentrantReadWriteLock lock) { sync = lock.sync; } // 具体实现 } public static class WriteLock implements Lock, java.io.Serializable { private final Sync sync; protected WriteLock(ReentrantReadWriteLock lock) { sync = lock.sync; } // 具体实现 } // 构造方法，初始化两个锁 public ReentrantReadWriteLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); readerLock = new ReadLock(this); writerLock = new WriteLock(this); } // 获取读锁和写锁的方法 public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; } public ReentrantReadWriteLock.ReadLock readLock() { return readerLock; } ReentrantReadWriteLock实现了读写锁，但它有一个小弊端，就是在“写”操作的时候，其它线程不能写也不能读。我们称这种现象为写饥饿. StampedLockStampedLock类是在Java 8 才发布的，也是Doug Lea大神所写，有人号称它为锁的性能之王。它没有实现Lock接口和ReadWriteLock接口，但它其实是实现了“读写锁”的功能，并且性能比ReentrantReadWriteLock更高。StampedLock还把读锁分为了“乐观读锁”和“悲观读锁”两种。 等有大段时间的时候, 再好好分析源码 References Java并发编程的艺术 深入浅出Java多线程","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://winniekun.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"锁","slug":"锁","permalink":"https://winniekun.github.io/tags/%E9%94%81/"}]},{"title":"cas","slug":"Java进阶/并发/cas","date":"2020-05-28T03:45:05.000Z","updated":"2021-03-30T11:24:56.012Z","comments":true,"path":"cas/","link":"","permalink":"https://winniekun.github.io/cas/","excerpt":"CAS概念","text":"CAS概念 CAS ，Compare And Swap ，即比较并交换。Doug Lea 大神在实现同步组件时，大量使用CAS 技术，鬼斧神工地实现了Java 多线程的并发操作。整个 AQS 同步组件、Atomic 原子类操作等等都是基 CAS 实现的，甚至 ConcurrentHashMap 在 JDK 1.8 的版本中，也调整为 CAS + synchronized 。可以说，CAS 是整个 J.U.C 的基石。 CAS 在CAS中，有这样三个值： V：要更新的变量(var) E：预期值(expected)/原值(old value) N：新值(new) 比较并交换的过程如下： 判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。 所以这里的预期值E本质上指的是“旧值”。 我们以一个简单的例子来解释这个过程： 如果有一个多个线程共享的变量i原本等于5，我现在在线程A中，想把它设置为新的值6; 我们使用CAS来做这个事情； 首先我们用i去与5对比，发现它等于5，说明没有被其它线程改过，那我就把它设置为新的值6，此次CAS成功，i的值被设置成了6； 如果不等于5，说明i被其它线程改过了（比如现在i的值为2），那么我就什么也不做，此次CAS失败，i的值仍然为2。 在这个例子中，i就是V，5就是E，6就是N。 那有没有可能我在判断了i为5之后，正准备更新它的新值的时候，被其它线程更改了i的值呢？ 不会的。因为CAS是一种原子操作，它是一种系统原语，是一条CPU的原子指令，从CPU层面保证它的原子性 当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。 CAS 的实现Java实现CAS的原理 - Unsafe类在Java中, 如果有一个方法是native的, 那么Java不负责实现它, 而是交由底层的JVM使用C或C++去实现. 在Java中有一个Unsafe类, 位于sun.misc包中, 里面是native方法, 其中有几个关于CAS的 public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5); public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6); J.U.C 下的 Atomic 类，都是通过 CAS 来实现的, 以AtomicInteger为例子, 阐述CAS的实现 AtomicInteger// setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); } catch (Exception ex) { throw new Error(ex); } } private volatile int value; Unsafe 是 CAS 的核心类，Java 无法直接访问底层操作系统，而是通过本地 native 方法来访问。不过尽管如此，JVM还是开了一个后门：Unsafe ，它提供了硬件级别的原子操作。 valueOffset 为变量值在内存中的偏移地址，Unsafe 就是通过偏移地址来得到数据的原值的。 value 当前值，使用 volatile 修饰，保证多线程环境下看见的是同一个。 // AtomicInterger类 public final int addAndGet(int delta) { return unsafe.getAndAddInt(this, valueOffset, delta) + delta; } // Unsafe(核心) CAS的具体实现 public final int getAndAddInt(Object var1, long var2, int var4) { int var5; do { // 放入do内, 时刻获取最新的期望值(期望值在多线程中会被其他的线程修改) var5 = this.getIntVolatile(var1, var2); } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; } // Unsafe // var1: 对象 // var2: 对象地址 // var4: 预期值 // var5: 新值 public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); CAS是无锁的基础，它允许更新失败。所以经常会与while循环搭配，在失败后不断去重试。 getAndInt()方法, 其返回的值是预期值(E), 也就是旧值, 新值(N)是var5+var4 这里使用的是do-while循环。这种循环不多见，它的目的是保证循环体内的语句至少会被执行一遍。这样才能保证return 的值v是我们期望的值。 The difference between do-while and while is that do-while evaluates its expression at the bottom of the loop instead of the top. Therefore, the statements within the do block are always executed at least once. Java Documents CAS实现原子操作的三大问题&amp;解决方案CAS 虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方面： 循环时间太长 只能保证一个共享变量原子操作 ABA 问题 循环时间过长 如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋 CAS 长时间地不成功，则会给 CPU 带来非常大的开销。在 J.U.C 中，有些地方就限制了 CAS 自旋的次数，例如： BlockingQueue 的 SynchronousQueue 。 只能保证一个共享变量原子操作 使用JDK 1.5开始就提供的AtomicReference类保证对象之间的原子性，把多个变量放到一个对象里面进行CAS操作； 使用锁。锁内的临界区代码可以保证只有当前线程能操作。 ABA问题所谓的ABA问题就是, 一个值原先是A, 然后改为B, 后面又改为A, 之后用CAS进行检测是检测不出来的. 但是实际上是更新了两次. 解决该问题通常是在变量前面追加版本号或者时间戳. 从JDK 1.5开始，JDK的atomic包里提供了一个类AtomicStampedReference类来解决ABA问题。 References 深入分析CAS CAS与原子操作","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://winniekun.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"剑指offer题解","slug":"LeetCode/coding-interviews","date":"2020-05-28T02:37:49.000Z","updated":"2021-07-05T05:19:16.366Z","comments":true,"path":"coding-interviews/","link":"","permalink":"https://winniekun.github.io/coding-interviews/","excerpt":"数据结构类题目","text":"数据结构类题目 Array 面试题3: 数组中重复的数字 面试题4: 二维数组中的查找 面试题11: 旋转数组中的最小数字 面试题21: 调整数组顺序使奇数位于偶数前面 面试题29: 顺时针打印矩阵 面试题39: 数组中出现次数操作一半的数字 面试题42: 连续子数组的最大和 面试题45: 把数组排成最小的数 面试题47: 礼物的最大值 面试题51: 数组中的逆序对 面试题53: 在排序数组中查找数字 面试题53-I: 在排序数组中查找数字I 面试题53-II: 0 ~ n-1 中缺失的数字 面试题56: 数组中数字出现的次数 面试题66: 构建乘积数组 LinkedList 面试题6：从尾到头打印链表 面试题18：删除链表的节点 面试题22：链表中倒数第k个结点 面试题23：链表中环的入口节点 面试题24：反转链表 面试题25：合并两个或k个有序链表 面试题35：复杂链表的复制 面试题36： 二叉搜索树与双向链表 面试题52：两个链表的第一个公共结点 面试题56：删除链表中重复的结点 Tree 面试题7：重建二叉树 面试题26：树的子结构 面试题27：二叉树的镜像 面试题28：对称的二叉树 面试题32-I：从上到下打印二叉树 面试题32-II：从上到下打印二叉树 II 面试题32-III：从上到下打印二叉树 III 面试题33：二叉搜索树的后序遍历序列 面试题34： 二叉树中和为某一值的路径 面试题36：二叉搜索树与双向链表 面试题37：序列化二叉树 面试题54：二叉搜索树的第k大节点 面试题55-I： 二叉树的深度 面试题55-II：平衡二叉树 面试题68-I：二叉搜索树的最近公共祖先 面试题68-II：二叉树的最近公共祖先 Stack &amp; Queue 面试题9：用两个栈实现队列 面试题9-I: 两个队列实现栈 面试题30：包含min函数的栈 面试题31：栈的压入、弹出序列 面试题58-I：翻转单词顺序 面试题59-I：滑动窗口的最大值 Heap 面试题29: 最小的k个数 面试题41: 数据流中的中位数 Hash Table 面试题3: 数组中重复的数字 图 面试题12: 矩阵中的路径 面试题13: 机器人的运动范围 具体算法类题目搜索算法 面试题4: 二维数组中的查找 面试题11: 旋转数组的最小数字 面试题39: 数组中出现次数超过一半的数字 动态规划 面试题10-I: 10- I. 斐波那契数列 面试题10-II: 10- II. 青蛙跳台阶问题 面试题19: 19. 正则表达式匹配 面试题42: 42. 连续子数组的最大和 面试题46: 46. 把数字翻译成字符串 面试题47: 47. 礼物的最大价值 面试题48: 48. 最长不含重复字符的子字符串 面试题49: 49. 丑数 面试题60: 60. n 个骰子的点数 面试题63: 63. 股票的最大利润 回溯 面试题12: 矩阵中的路径 面试题13: 机器人的运动范围 排序 面试题29: 最小的k个数 (堆排序) 面试题39: 数组中出现次数超过一半的数字 (快排序) 面试题51: 数组中的逆序对(归并排序) 位运算 面试题15: 二进制中1的个数 面试题56-I: 数组中数字出现的次数 面试题56-II: 数组中数字出现的次数 II 刷题记录面试题3-I：数组中重复的数字题目一：找出数组中的重复数字方法一: 排序之后 查找排序，之后遇到有重复的返回该数字即可 时间复杂度： O(nlogn) 空间复杂度：O(1) // 内置排序算法 public int findRepeatNumber(int[] arrays) { Arrays.sort(arrays); int t = 0; for (int i = 0; i &lt; arrays.length-1; i++) { if (arrays[i] == arrays[i + 1]) { t = arrays[i]; } } return t; } // 使用快排 public int findRepeatNumber(int[] nums) { quickSort(nums); for(int i = 1; i&lt;nums.length; i++){ if(nums[i] == nums[i-1]){ return nums[i]; } } return -1; } private void quickSort(int[] nums){ quickSort(nums, 0, nums.length-1); } private void quickSort(int[] nums, int low, int high){ if(low &gt; high){ return; } else{ int position = patition(nums, low, high); quickSort(nums, low, position-1); quickSort(nums, position+1, high); } } private int patition(int[] nums, int low, int high){ int position = nums[low]; while(low &lt; high){ while(low &lt; high &amp;&amp; nums[high] &gt;= position){ high--; } nums[low] = nums[high]; while(low &lt; high &amp;&amp; nums[low] &lt;= position){ low++; } nums[high] = nums[low]; } nums[low] = position; return low; } 方法二: 散列表 将所有的元素当做key存如散列表，value表示key出现的个数 public int findRepeatNumber(int[] nums) { int a = 0; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i : nums) { if (map.containsKey(i)) { Integer integer = map.get(i); integer += 1; a = i; } else { map.put(i, 0); } } return a; } 方法三: 位图 具体可参见编程珠玑或算法新解 面试题3-II：不修改数组，找出重复的数字二分查找287. 寻找重复数 public int findDuplicate(int[] nums) { int i = 0; int j = nums.length - 1; while( i &lt; j ){ // j = mid // 所以 mid = (i+j)/2 // 若果i = mid // 则 mid = (i + j + 1)/2 int mid = (i + j) /2; int count = 0; // 统计小于中值的数量 for(int num : nums){ if(num &lt;= mid){ count++; } } // 如果统计出的数量&gt;中值 // 重复的元素可定出现在i~mid区间, 所以mid+1~j区间就可以不用考虑了 if(count &gt; mid){ j = mid; }else { i = mid + 1; } } return i; } 面试题4：二维数组查找从左下角开始 public boolean findNumberIn2DArray(int[][] matrix, int target) { int m = matrix.length -1; int n = 0; while(m &gt;= 0 &amp;&amp; n&lt;=matrix[0].length-1){ if(matrix[m][n] &lt; target){ n++; }else if(matrix[m][n] &gt; target){ m--; } else { return true; } } return false; } 面试题5：替换空格public String replaceSpace(String s) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; s.length(); i++) { if(s.charAt(i) == ' '){ sb.append(\"%20\"); } else{ sb.append(s.charAt(i)); } } return sb.toString(); } 面试题6：从尾到头打印链表public int[] reversePrint(ListNode head) { // 使用栈 ListNode p = head; Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); while (p != null){ stack.push(p); p = p.next; } int[] res = new int[stack.size()]; int i = 0; while (!stack.isEmpty()){ res[i++] = stack.pop().val; } return res; } // 头插法重新构造链表 然后依次放入 public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) { ListNode dummy = new ListNode(-1); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(listNode != null){ ListNode temp = listNode.next; listNode.next = dummy.next; dummy.next = listNode; listNode = temp; } listNode = dummy.next; while(listNode != null){ list.add(listNode.val); listNode = listNode.next; } return list; } 面试题7： 重建二叉树public static TreeNode buildTree(int[] preorder, int[] inorder) { Map&lt;Integer, Integer&gt; inMap = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; inorder.length; i++) { inMap.put(inorder[i], i); } TreeNode root = buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, inMap); return root; } public static TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd, Map&lt;Integer, Integer&gt; inMap) { if (preStart &gt; preEnd) { return null; } TreeNode root = new TreeNode(preorder[preStart]); // 当前根节点所在中序遍历位置 int inRoot = inMap.get(root.val); // 该根节点左边子节点的个数 int numsLeft = inRoot - inStart; root.left = buildTree(preorder, preStart + 1, preStart + numsLeft, inorder, inStart, inRoot - 1, inMap); root.right = buildTree(preorder, preStart + numsLeft + 1 , preEnd, inorder, inRoot + 1, inEnd, inMap); return root; } 面试题8： 二叉树的下一个节点面试题9： 两个栈实现队列// 使用两个栈实现队列 Deque&lt;Integer&gt; A, B; public interview9() { A = new ArrayDeque&lt;&gt;(); B = new ArrayDeque&lt;&gt;(); } public void appendTail(int value) { A.push(value); } public int deleteHead() { if (!B.isEmpty()) { return B.removeLast(); } // 表明两个栈都为空了, 所以没有能返回的值了 if (A.isEmpty()) { return -1; } while (!A.isEmpty()) { B.addLast(A.removeLast()); } return B.removeLast(); } 面试题10： 斐波那契数列方法一：递归 方法二：DP 题目二：青蛙跳台阶题目三： 矩阵覆盖面试题11： 旋转数组中的最小数字二分查找, 注意元素会重复 public int minArray(int[] numbers) { int i = 0; int j = numbers.length -1; while(i &lt; j){ int mid = (i + j )/2; if(numbers[mid] &gt; numbers[j]){ i = mid + 1; }else if(numbers[mid] &lt; numbers[j]){ j = mid; }else { j -= 1; } } return numbers[i]; } 面试题12：矩阵中的路径public boolean exist(char[][] matrix, String str) { int n = matrix.length; int m = matrix[0].length; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (hasPathCore(matrix, str, 0, i, j)) { return true; } } } return false; } public boolean hasPathCore(char[][] matrix, String str, int start, int row, int col) { int n = matrix.length; int m = matrix[0].length; if (start == str.length()) { return true; } if (row &lt; 0 || row &gt;= n || col &lt; 0 || col &gt;= m || matrix[row][col] != str.charAt(start)) { return false; } char c = matrix[row][col]; matrix[row][col] = ' '; boolean result = hasPathCore(matrix, str, start + 1, row + 1, col) || hasPathCore(matrix, str, start + 1, row - 1, col) || hasPathCore(matrix, str, start + 1, row, col + 1) || hasPathCore(matrix, str, start + 1, row, col - 1); matrix[row][col] = c; return result; } 面试题13：机器人的运动范围private int count = 0; public int movingCount(int m, int n, int k) { boolean[][] vistied = new boolean[m][n]; visit(vistied, k, m, n, 0, 0); return count; } public void visit(boolean visited[][], int k , int m, int n, int i, int j){ if(i &lt;0 || i&gt;=m || j &lt; 0 || j&gt;= n || visited[i][j] || cal(i, j) &gt; k){ return; } visited[i][j] = true; count++; visit(visited, k, m, n, i+1, j); visit(visited, k, m, n, i-1, j); visit(visited, k, m, n, i, j+1); visit(visited, k, m, n, i, j -1); } private int cal(int i, int j) { int calI = calculate(i); int calJ = calculate(j); return calI + calJ; } private int calculate(int num){ int sum = 0; while (num != 0){ sum += (num%10); num /= 10; } return sum; } 面试题14：剪绳子动态规划 //理解不好 public int cuttingRope(int n) { if (n &lt;= 3) { return n - 1; } int a = n / 3; int b = n % 3; if (b == 0) { return (int) Math.pow(3, a); } else if (b == 1) { return (int) (Math.pow(3, a - 1) * 4); } return (int) Math.pow(3, a) * 2; } public int cuttingRopeII(int n) { int[] dp = new int[n+1]; if(n&lt;=1){ return 0; } if(n==2){ return 1; } if(n==3){ return 2; } dp[0] = 0; dp[1] = 1; dp[2] = 2; dp[3] = 3; int max = 0; int temp = 0; for(int i = 4; i&lt;=n; i++){ for(int k=1; k&lt;=i/2; k++){ temp = dp[k] * dp[i-k]; if(max &lt; temp){ max = temp; } } dp[i] = max; } return dp[n]; } 面试题15：二进制中1个个数public static int numberOf2(int n){ // n &amp; (n - 1) 会消除 n 中最后一位中的 1。 int res = 0; while (n != 0){ n &amp;= (n-1); res++; } return res; } 面试题16：数值的整数次方面试题17：打印从1到最大的n位整数public int[] printNumbers(int n ){ int nums = (int) Math.pow(10, n); int[] res = new int[nums-1]; for (int i = 0; i &lt; nums-1; i++) { res[i] = i+1; } return res; } 面试题18：删除链表的节点public static ListNode deleteNode(ListNode head, ListNode q) { ListNode dummy = new ListNode(-1); if (head == null) { return null; } dummy.next = head; ListNode pre = dummy; ListNode p = head; while (p != null) { if (p == q) { pre.next = p.next; p = pre.next; } else { pre = p; p = p.next; } } return dummy.next; } 面试题19：正则表达式匹配还没理好 面试题20：表示数值的字符串按照题目提示写就是了 .: .之前不能出现.和e e: e之前不能出现e, 且前一位必须是数字,且后面必须还要有数字 +/-: +/-只能出现在0位置或者e后面 public static boolean isNumber(String s) { if(s == null || s.length() == 0){ return false; } boolean res = true; boolean isNums = false; boolean isDot = false; boolean isE = false; String trim = s.trim(); for (int i = 0; i &lt; trim.length(); i++) { if (trim.charAt(i) &lt;= '9' &amp;&amp; trim.charAt(i) &gt;= '0') { isNums = true; } else if (trim.charAt(i) == 'e' || trim.charAt(i) == 'E') { if (!isNums || isE) { return false; } isE = true; // 防止出现12e的情况(不能表示数字) isNums = false; } else if (trim.charAt(i) == '.') { if (isE || isDot) { return false; } isDot = true; } else if (trim.charAt(i) == '+' || trim.charAt(i) == '-') { if (i != 0 &amp;&amp; trim.charAt(i - 1) != 'E' &amp;&amp; trim.charAt(i - 1) != 'e') { return false; } } else { return false; } } return isNums; } 面试题21：调整数组顺序使奇数位于偶数前面// 最直白的做法，依次遍历，然后遇到偶数的时候 // 后面的元素调前面，该元素放置末尾 public int[] exchange(int[] nums) { if (nums == null || nums.length &lt; 2) { return nums; } int left = 0; int right = nums.length - 1; int temp[] = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) { if ((nums[i] &amp; 1) == 0) {//偶数 temp[right--] = nums[i]; } else {//奇数 temp[left++] = nums[i]; } } return temp; } // 双指针方法 public static int[] exchangeII(int[] nums) { int p = 0; int q = nums.length - 1; while (p &lt; q) { while (p &lt; q &amp;&amp; nums[p] % 2 == 0) { if(nums[q] %2 == 1){ int temp = nums[p]; nums[p] = nums[q]; nums[q] = temp; p++; q--; }else if(nums[q] %2 == 0){ q--; } } while (p &lt; q &amp;&amp; nums[p]%2 == 1){ p++; } } return nums; } // 上面的逻辑 是基于正常交换逻辑 // 但是是依次处理， 可以先假设符合条件， 之后将不符合条件的一一处理 // 类似快排的枢轴处理 // 代码的可读性更高 public static int[] exchangeIII(int[] nums){ int pBegin = 0; int pRear = nums.length-1; while (pBegin &lt; pRear){ while (pBegin &lt; pRear &amp;&amp; nums[pBegin]%2 == 1){ pBegin ++; } while (pBegin &lt; pRear &amp;&amp; nums[pRear] %2 == 0){ pRear--; } if(pBegin &lt; pRear){ int temp = nums[pBegin]; nums[pBegin] = nums[pRear]; nums[pRear] = temp; } } return nums; } 面试题22：链表中倒数第K个节点// 遍历两次链表 public static ListNode getKthFromEnd(ListNode head, int k){ if(head==null){ return null; } int length = getLength(head); if(k&gt;length){ return null; } if(k==length){ return head; } ListNode preNode = getPreNode(head, length - k); return preNode.next; } private static ListNode getPreNode(ListNode head, int preK){ while (preK &gt; 1){ head = head.next; preK--; } return head; } private static int getLength(ListNode head){ int length = 0; while (head != null){ head = head.next; length ++; } return length; } // 双指针解决 public static ListNode getKthFromEndII(ListNode head, int k){ if(head == null || k==0){ return null; } ListNode fast = head; ListNode slow = head; while (k-1 &gt; 0){ fast = fast.next; k--; } while (fast.next != null){ fast = fast.next; slow = slow.next; } return slow; } 面试题23：链表中环的入口节点双指针之快慢指针 public ListNode meetingNode(ListNode head) { ListNode entry = null; if (head == null) { return entry; } ListNode fast = head; ListNode slow = head; while (fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { ListNode slowII = head; while (slow != slowII) { slowII = slowII.next; slow = slowII.next; } return slow; } } return null; } 面试题24：反转链表头插法 public static ListNode reverseList(ListNode head){ ListNode dummmy = new ListNode(-1); ListNode p = head; while (p != null){ ListNode temp = p.next; p.next = dummmy.next; dummmy.next = p; p = temp; } return dummmy.next; } 面试题25： 合并两个排序的链表// 尾插法 public ListNode mergeTwoLists(ListNode l1, ListNode l2){ ListNode dummy = new ListNode(-1); ListNode rear = dummy; while (l1!= null &amp;&amp; l2!= null){ if(l1.value &lt;= l2.value){ rear.next = l1; l1 = l1.next; }else { rear.next = l2; l2 = l2.next; } rear = rear.next; } if (l1 != null){ rear.next = l1; } if (l2!= null) { rear.next = l2; } return dummy.next; } 面试题26：树的子结构public boolean isSubStructure(TreeNode A, TreeNode B){ boolean res = false; if(A!=null &amp;&amp; B!=null){ if(A.val == B.val){ res = doesHaveTree2(A, B); }if(!res){ res = isSubStructure(A.left, B); }if(!res){ res = isSubStructure(A.right, B); } } return res; } private boolean doesHaveTree2(TreeNode A, TreeNode B){ if(B == null) { return true; } if(A == null){ return false; } if(A.val != B.val){ return false; } return doesHaveTree2(A.left, B.left) &amp;&amp; doesHaveTree2(A.right, B.right); } 面试题27：二叉树的镜像public TreeNode mirrorTree(TreeNode root) { if (root != null) { TreeNode temp = root.left; root.left = root.right; root.right = temp; mirrorTree(root.left); mirrorTree(root.right); } return root; } 面试题28：对称二叉树// 递归 public boolean isSymmetric(TreeNode root) { if (root == null) { return true; } return isSymmetric(root.left, root.right); } private boolean isSymmetric(TreeNode left, TreeNode right) { if (left == null &amp;&amp; right == null) { return true; } if ((left != null &amp;&amp; right == null) || (left == null &amp;&amp; right != null) || (left.value != right.value)){ return false; } return isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left); } 面试题29： 顺时针打印矩阵打印矩阵的顺序是 “从左向右、从上向下、从右向左、从下向上” 循环。基础点为（0,0） 流程 空值处理 初始化， 初始化 上下左右的四个边界t、 b、 l、r 循环打印 根据边界依次添加到res尾部 边界修改（内缩1） 边界是否相遇，若相遇则打印完毕 | 打印方向 | 根据边界打印 | 边界内缩 | 是否打印完毕 || :———: | :—————————: | :———: | :—————: || 从左到右 | 左边界：l，右边界: r | t+1 | 是否t+1&gt;b || 从上到下 | 上边界: t，下边界: b | r-1 | 是否r-1","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://winniekun.github.io/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://winniekun.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"Vector&Stack源码解读","slug":"源码/JDK/list/vector&stack-analysis","date":"2020-05-26T08:29:05.000Z","updated":"2020-08-30T04:50:22.255Z","comments":true,"path":"vector&stack-analysis/","link":"","permalink":"https://winniekun.github.io/vector&stack-analysis/","excerpt":"Vector源码解读","text":"Vector源码解读 Vector依赖 支持泛型, 继承了AbstractList类, 实现了List接口 RandomAccess用来表明其支持随机访问 Cloneable用来表明其支持拷贝 Serializable用来表明支持序列化 Vector的实现和ArrayLis基本类似, 底层使用的都是Object类型的数组, 只不过Vector在方法上添加了关键字synchronized, 实现了线程安全. 所以具体的实现就不一一展开来了, 但是其扩容机制大小和ArrayList的不容,其他的部分, 分析Stack源码的时候相关涉及会再分析下 构造函数Vector()// 无参构造 public Vector() { this(10); } Vector(int initialCapacity)// 指定初始化容量 public Vector(int initialCapacity) { this(initialCapacity, 0); } Vector(int initialCapacity, int capacityIncrement)// 即指定初始化容量又指定扩容大小 public Vector(int initialCapacity, int capacityIncrement) { super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement; } Vector(Collection&lt;? extends E&gt; c)// 构造包含指定collection元素的Vector public Vector(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); elementCount = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, elementCount, Object[].class); } 扩容机制private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); } 可以看到其扩容机制和ArrayList的不同, ArrayList的扩容是原容量的1.5倍, 但是Vector的扩容机制和capacityIncrement相关 capacityIncrement&gt;0 则 扩容容量为 capacityIncrement, 最后的容量为 oldCapacity + capacityIncrement capacityIncrement&lt;0 则 扩容容量为 oldCapacity , 最后的容量为 2倍oldCapacity 总结共四个构造函数, 默认的初始化数组容量为10, 扩容大小不是程序内部实现, 而是用户定义, 默认为原数组的两倍, 若是用户指定了扩容大小, 则扩容为指定的容量 Stack源码解读 Stack方法 empty()public boolean empty() { return size() == 0; } peek()public synchronized E peek() { int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); } peek()函数调用了父类Vector的 elementAt()方法 public synchronized E elementAt(int index) { if (index &gt;= elementCount) { throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" + elementCount); } return elementData(index); } elementData()函数和ArrayList中的一样 说白了就是返回数组中最后一位的元素 pop()public synchronized E pop() { E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; } pop()函数调用了父类Vector的 removeElementAt()方法 这个方法和ArrayList的remove(int index)是一样的, 只不过添加了synchronized关键字实现线程安全 public synchronized void removeElementAt(int index) { modCount++; if (index &gt;= elementCount) { throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" + elementCount); } else if (index &lt; 0) { throw new ArrayIndexOutOfBoundsException(index); } int j = elementCount - index - 1; if (j &gt; 0) { System.arraycopy(elementData, index + 1, elementData, index, j); } elementCount--; elementData[elementCount] = null; /* to let gc do its work */ } 移除最后一个元素, 基本上不会执行前面的判断分支, 会直接执行 elementCount--; elementData[elementCount] = null; /* to let gc do its work */ push()public E push(E item) { addElement(item); return item; } push()调用了addElement()方法, 该方法首先会确定elementCount是否大于现在数组的容量大小, 若大扩容, 否则直接添加 public synchronized void addElement(E obj) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj; } 然后在数组尾部添加元素. search()返回对应元素所在堆的位置 这个对于底层的数组而言, 是相反的, 所以从尾到头遍历元素,同时因为允许元素为空, 所以首先会先判断查询元素是否为空 感觉这些索引位置和数组第几个元素的问题很恼火, 两者始终差个1 public synchronized int search(Object o) { int i = lastIndexOf(o); // 逆序返回 if (i &gt;= 0) { return size() - i; } return -1; } // elementCount记录为数组中的元素个数 // 但是数组是从位置0开始 // 所以在数组中最后一个元素的位置为elementCount-1 public synchronized int lastIndexOf(Object o) { return lastIndexOf(o, elementCount-1); } public synchronized int lastIndexOf(Object o, int index) { if (index &gt;= elementCount) throw new IndexOutOfBoundsException(index + \" &gt;= \"+ elementCount); if (o == null) { for (int i = index; i &gt;= 0; i--) if (elementData[i]==null) return i; } else { for (int i = index; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; } return -1; } 总结Vector和ArrayList的异同:异: Vector通过在涉及到线程不安全的方法上添加synchronized关键字实现了线程安全,而ArrayList为线程不安全 Vector的扩容机制可由用户自定义, 若为定义则扩为原数组的两倍 ArrayList的扩容机制不能通过用户自定义, 正常情况扩容为原数组的1.5倍 同: 底层都是Object数组 remove方法都不会改变底层数组的大小 Stack继承Vector类, 所有是线程安全的, 同时底层也是Object数组, 入栈等同于在数组中依次添加元素, 出栈在数组中就是删除数组中最后的元素, 然后将最后的位置设置为空, 数组整体的大小是不会随着出栈而改变的.","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"List","slug":"List","permalink":"https://winniekun.github.io/tags/List/"}]},{"title":"死磕二分查找","slug":"LeetCode/stick-to-binary-search","date":"2020-05-23T06:21:39.000Z","updated":"2020-08-30T04:50:22.250Z","comments":true,"path":"stick-to-binary-search/","link":"","permalink":"https://winniekun.github.io/stick-to-binary-search/","excerpt":"前言LeetCode死磕系列六：二分查找","text":"前言LeetCode死磕系列六：二分查找 二分查找是计算机科学中最基本、最有用的算法之一，在基础算法的学习中是非常重要的。 二分查找的最基本问题是在有序数组里查找一个特定的元素 二分查找算法是典型的「减治思想」的应用，我们使用二分查找将待搜索的区间逐渐缩小，以达到「缩减问题规模」的目的； 掌握二分查找的两种思路： 思路 1：在循环体内部查找元素：while (left &lt;= right)； 思路 2：在循环体内部排除元素：while (left &lt; right)。 全部使用左闭右闭区间，不建议使用左闭右开区间，反而使得问题变得复杂； 应用1、在半有序（旋转有序或者是山脉）数组里查找元素； 2、确定一个有范围的整数； 3、需要查找的目标元素满足某个特定的性质。 模板一class Solution { public int search(int[] nums, int target) { // 特殊用例判断 int len = nums.length; if (len == 0) { return -1; } // 在 [left, right] 区间里查找 target int left = 0; int right = len - 1; while (left &lt;= right) { // 为了防止 left + right 整形溢出，写成如下形式 int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] &gt; target) { // 下一轮搜索区间：[left, mid - 1] right = mid - 1; } else { // 此时：nums[mid] &lt; target // 下一轮搜索区间：[mid + 1, right] left = mid + 1; } } return -1; } } lower_bound：查找第一个大于或等于 target 的数字； upper_bound：查找第一个大于 target 的数字。 这一类问题的描述经常让人觉得头晕，使用模板一，就需要考虑返回 left 还是 right。 如果使用模板二，由于退出循环以后一定有 left == right，就只需要单独判断 left或right 是否满足题意。 模板二public int search(int[] nums, int left, int right, int target) { while (left &lt; right) { // 选择中位数时下取整 int mid = left + (right - left) / 2; if (check(mid)) { // 下一轮搜索区间是 [mid + 1, right] left = mid + 1 } else { // 下一轮搜索区间是 [left, mid] right = mid } } // 退出循环的时候，程序只剩下一个元素没有看到。 // 视情况，是否需要单独判断 left（或者 right）这个下标的元素是否符合题意 } public int search(int[] nums, int left, int right, int target) { while (left &lt; right) { // 选择中位数时上取整 int mid = left + (right - left + 1) / 2; if (check(mid)) { // 下一轮搜索区间是 [left, mid - 1] right = mid - 1; } else { // 下一轮搜索区间是 [mid, right] left = mid; } } // 退出循环的时候，程序只剩下一个元素没有看到。 // 视情况，是否需要单独判断 left（或者 right）这个下标的元素是否符合题意 } 特征：while (left &lt; right)，这里使用严格小于 &lt; 表示的临界条件是：当区间里的元素只有 2 个时，依然可以执行循环体。换句话说，退出循环的时候一定有 left == right 成立，这一点在定位元素下标的时候极其有用； 在循环体中，先考虑 nums[mid] 在满足什么条件下不是目标元素，进而考虑两个区间 [left, mid - 1] 以及 [mid + 1, right] 里元素的性质，目的依然是确定下一轮搜索的区间； 根据边界情况，看取中间数的时候是否需要上取整(也就是mid 是否的计算是否需要加1) 注意事项： 先写分支，再决定中间数是否上取整； 在使用多了以后，就很容易记住，只要看到 left = mid ，它对应的取中位数的取法一定是 int mid = left + (right - left + 1) / 2;。 LeetCode 二分查找题目整理 704 二分查找 (基础,经典应用) 35 插入搜索位置 69 x的平方根 34 在排序数组中查找元素的第一个和最后一个位置(经典, 很好的模板) 题解704. 二分查找 关于写left = mid + 1;还是写right = mid - 1; 上感到困惑，一个行之有效的思考策略是： 永远去想下一轮目标元素应该在哪个区间里: 如果目标元素在区间 [left, mid - 1] 里，就需要设置设置 right = mid - 1； 如果目标元素在区间 [mid + 1, right] 里，就需要设置设置 left = mid + 1； 考虑不仔细是初学二分法容易出错的地方，这里切忌跳步，需要仔细想清楚每一行代码的含义； 循环可以继续的条件是 while (left &lt;= right)，特别地，当 left == right 即当待搜索区间里只有一个元素的时候，查找也必须进行下去； public int search(int[] nums, int target) { int i = 0; int j = nums.length - 1; while (i &lt;= j) { // 防止整型溢出 // int mid = i + (j-i)/2; int mid = (i+j)/2; if(nums[mid] == target){ return mid; }else if(nums[mid] &lt; target){ i = mid+1; }else if(nums[mid] &gt; target){ j = mid-1; } } return -1; } 35. 搜索插入位置使用上述的模板来的话,需要考虑是返回i, 还是j 使用模板二的话,不用考虑 // 模板一解法 public static int searchInsert(int[] nums, int target) { if(target &gt; nums[nums.length-1]){ return nums.length; } int low = 0; int high = nums.length - 1; while (low &lt;= high) { int mid = (low + high) / 2; if(target == nums[mid]){ return mid; }else if(nums[mid] &lt; target){ low = mid+1; }else { high = mid-1; } } return high; } // 模板二解法 public static int searchInsertII(int[] nums, int target) { int len = nums.length; if (len == 0) { return 0; } // 特判 if (nums[len - 1] &lt; target) { return len; } int left = 0; int right = len - 1; while (left &lt; right) { int mid = left + (right - left) / 2; // 严格小于 target 的元素一定不是解 if (nums[mid] &lt; target) { // 下一轮搜索区间是 [mid + 1, right] left = mid + 1; } else { right = mid; } } return left; } 69. x 的平方根public int mySqrt(int x) { if (x == 0) { return 0; } if (x == 1) { return 1; } int i = 1; int j = x / 2; while (i &lt; j) { int mid = (i + j + 1) / 2; // 大于一定无 if (mid &gt; x / mid){ // 下一轮搜索的区间是 [left, mid - 1] j = mid -1; }else { // 下一轮搜索的区间是 [mid, right] i = mid; } } return i; } 34. 在排序数组中查找元素的第一个和最后一个位置public int[] searchRange(int[] nums, int target) { int i = 0; int j = nums.length - 1; int first = findFirstPosition(nums, target); if(first == 1){ return new int[]{-1, -1}; } int secondPosition = findSecondPosition(nums, target); return new int[]{first, secondPosition}; } public int findFirstPosition(int[] nums, int target) { int i = 0; int j = nums.length - 1; while (i &lt; j) { int mid = (i + j) / 2; // 小于一定没有解 if (nums[mid] &lt; target) { i = mid + 1; } else { j = mid; } } if (nums[i] == target) { return i; } else { return -1; } } public int findSecondPosition(int[] nums, int target) { int i = 0; int j = nums.length - 1; while (i &lt; j){ int mid = (i + j + 1)/2; if(nums[mid] &gt; target){ j = mid-1; }else { i = mid; } } if (nums[i] == target){ return i; }else { return -1; } } 278. 第一个错误的版本若是中间位置的版本为false, 说明第一个错误版本在[mid+1, right]; public int firstBadVersion(int n) { int left = 1, right = n; while (left &lt; right) { int mid = left + (right - left) / 2; if (!isBadVersion(mid)) { left = mid + 1; } else { right = mid; } } return left; } References 二分查找算法 特别好用的二分查找法模板（第 2 版）","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"二分搜索","slug":"二分搜索","permalink":"https://winniekun.github.io/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"}]},{"title":"聊天室的BIO NIO实现","slug":"Java进阶/IO/chat-room","date":"2020-05-21T13:03:39.000Z","updated":"2020-08-30T04:50:22.244Z","comments":true,"path":"chat-room/","link":"","permalink":"https://winniekun.github.io/chat-room/","excerpt":"简易客户端-服务端","text":"简易客户端-服务端 服务端创建一个ServerSocket实例, 绑定对应的端口之后, 在while循环中阻塞等待客户端的请求, 客户端请求成功之后,创建一个输入流和一个输出流 再进行数据交互. 创建一个ServerSocket并绑定端口 阻塞等待客户端请求 链接之后, 交互数据 public static void main(String[] args) { final int DEFAULT_PORT = 8888; final String QUIET = \"quiet\"; ServerSocket server = null; try { server = new ServerSocket(DEFAULT_PORT); System.out.println(\"[启动服务器， 监听端口 \" + DEFAULT_PORT + \"]\"); while (true) { // 等待链接 Socket client = server.accept(); System.out.println(\"[客户端 \" + client.getPort() + \" 已经链接]\"); BufferedReader reader = new BufferedReader( new InputStreamReader(client.getInputStream())); BufferedWriter writer = new BufferedWriter( new OutputStreamWriter(client.getOutputStream())); // 读取客户端数据 String msg = null; while (((msg = reader.readLine()) != null)) { System.out.println(\"[客户端 \" + client.getPort() + \"发送数据 \" + msg + \"]\"); // 返回个客户端数据 writer.write(\"{ echo \" + msg + \"} \\n\"); writer.flush(); if(QUIET.equalsIgnoreCase(msg)){ break; } } } } catch (IOException e) { e.printStackTrace(); } finally { if (server != null) { try { server.close(); } catch (IOException e) { e.printStackTrace(); } } } } 客户端创建一个Socket实例(服务器地址, 端口), 之后将创建两个输入流(一个用于读取服务端发送的数据, 一个用于读取用户输入的数据), 一个输出流(将用户输入的数据发送个服务端) 创建Socket 链接服务器 和服务器交互 public static void main(String[] args) { final String DEFAULT_SERVER_HOST = \"localhost\"; final String QUIET = \"quiet\"; final int DEFAULT_SERVER_PORT = 8888; try ( Socket client = new Socket(DEFAULT_SERVER_HOST, DEFAULT_SERVER_PORT); // 创建IO流 BufferedReader reader = new BufferedReader( new InputStreamReader(client.getInputStream())); BufferedWriter writer = new BufferedWriter( new OutputStreamWriter(client.getOutputStream())); // 等待用户输入信息 BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in)); ) { while (true) { // 读取用户输入数据 String input = consoleReader.readLine(); // 发送给服务器 writer.write(input + \"\\n\"); writer.flush(); // 输出服务器返回数据 String accept = reader.readLine(); System.out.println(\"[服务器 发送数据 \" + accept + \"]\"); // 查看是否退出 if(QUIET.equalsIgnoreCase(input)){ break; } } } catch (IOException e) { e.printStackTrace(); } } 总结上述一个简单的聊天室程序完成,但是因为 server.accept() InputStream.read() OutputStream.write() 均存在阻塞问题, 当有新的客户端发起请求时,服务端需要执行完上一个请求之后,才能去执行这个请求.所有我们可以将阻塞的部分独立出来用一个新的线程执行这部分内容. 将用户的输入处理用一个新的线程处理 将服务端中的数据处理独立出来, 创建一个对应的线程来执行对应客户端的数据交互 优化1: 服务端为每个请求创建线程处理 服务端Constant用于存放一些静态常量 public interface Constant { /** * 默认端口 */ int DEFAULT_PORT = 8888; /** * IP地址 */ String DEFAULT_HOST = \"localhost\"; /** * 退出命令 */ String QUIT = \"quit\"; } Server和基础的版本有所不同的是, 服务端转发消息给客户端,是除了发送消息的那个客户端. public class ChatServer implements Constant { private ServerSocket server = null; private ExecutorService executor; private Map&lt;Integer, Writer&gt; connectionClients; public ChatServer() { this.connectionClients = new HashMap&lt;&gt;(); this.executor = Executors.newFixedThreadPool(10); } // 新增用户添加到map public synchronized void add(Socket socket) throws IOException { if (socket != null) { int port = socket.getPort(); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); connectionClients.put(port, writer); System.out.println(\"客户端 [\" + port + \"] 已经连接服务器\"); } } // 下线客户移除 public synchronized void removeClient(Socket socket) throws IOException { if (socket != null) { int port = socket.getPort(); if (connectionClients.containsKey(port)) { connectionClients.get(port).close(); } connectionClients.remove(port); System.out.println(\"客户端 [\" + port + \"]已经断开连接\"); } } // 转发消息 public synchronized void forwardMSG(Socket socket, String msg) throws IOException { // 转发给除去发送者的其他在线用户 for (Integer integer : connectionClients.keySet()) { if (!integer.equals(socket.getPort())) { Writer writer = connectionClients.get(integer); writer.write(msg); writer.flush(); } } } // 全部转发 public synchronized void forwardAllMSG(String msg) throws IOException { for (Integer integer : connectionClients.keySet()) { connectionClients.get(integer).write(msg); connectionClients.get(integer).flush(); } } public synchronized void close(){ if(server != null){ try { server.close(); System.out.println(\"关闭服务器\"); } catch (IOException e) { e.printStackTrace(); } } } public void start() { try { // 绑定监听端口 server = new ServerSocket(DEFAULT_PORT); System.out.println(\"[启动服务器， 监听端口 \" + DEFAULT_PORT + \"]\"); while (true) { // 等待客户端连接 Socket socket = server.accept(); // 创建新的线程, 用于处理客户端数据 new Thread(new ChatHandler(socket, this)).start(); //executor.execute(new ChatHandler(socket, this)); } } catch (IOException e) { e.printStackTrace(); }finally { close(); } } public static void main(String[] args) { ChatServer server = new ChatServer(); server.start(); } } ChatHandler用于处理和客户端交互的线程 public class ChatHandler implements Runnable, Constant { Socket client; ChatServer chatServer; public ChatHandler(Socket socket, ChatServer chatServer){ this.client = socket; this.chatServer = chatServer; } @Override public void run() { try { // 存储新上线用户 chatServer.add(client); BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream())); String msg = null; while ((msg = reader.readLine()) != null){ // 读入客户端的消息 String fwdMSG = \"客户端 [\" + client.getPort() + \"] 消息为 \" + msg + \"\\n\"; System.out.print(fwdMSG); // 读出转发给其他的客户端 chatServer.forwardMSG(client, fwdMSG); // 检测是否退出 if(QUIT.equalsIgnoreCase(msg)){ break; } } } catch (IOException e) { e.printStackTrace(); }finally { try { chatServer.removeClient(client); } catch (IOException e) { e.printStackTrace(); } } } } 客户端除了将数据发送给服务端以及接受服务端的数据,还需要一个接受用户产生的数据的线程 Clientpublic class ChatClient implements Constant { private Socket socket; private BufferedReader reader; private BufferedWriter writer; // 发送给服务器数据 public void send(String msg) throws IOException { if (!socket.isOutputShutdown()) { writer.write(msg + \"\\n\"); writer.flush(); } } // 接受服务器转发的信息 public String receive() throws IOException { String msg = null; if (!socket.isInputShutdown()) { msg = reader.readLine(); } return msg; } // 关闭 public void close() { if (writer != null) { try { System.out.println(\"客户端\" + socket.getLocalPort() + \"关闭\"); writer.close(); } catch (IOException e) { e.printStackTrace(); } } } // 准备退出 public boolean readyQuit(String s) { return s.equalsIgnoreCase(QUIT); } // 开始 public void start() { try { socket = new Socket(DEFAULT_HOST, DEFAULT_PORT); writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 等待用户输入信息 new Thread(new UserInputHandler(this)).start(); // 读取服务器数据 String msg = null; while ((msg = receive()) != null){ System.out.println(msg); } } catch (IOException e) { e.printStackTrace(); } finally { close(); } } public static void main(String[] args) { ChatClient chatClient = new ChatClient(); chatClient.start(); } } UserInputHandlerpublic class UserInputHandler implements Runnable, Constant { ChatClient chatClient; public UserInputHandler(ChatClient chatClient) { this.chatClient = chatClient; } @Override public void run() { try { // 等待用户输入 BufferedReader consoleReader = new BufferedReader( new InputStreamReader(System.in)); while (true) { // 获取用户输入数据 String input = consoleReader.readLine(); // 向服务器发送输入数据 chatClient.send(input); if(chatClient.readyQuit(input)){ break; } } } catch (IOException e) { e.printStackTrace(); } } } 总结该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈1:1的正比关系，Java中的线程也是比较宝贵的系统资源，线程数量快速膨胀后，系统的性能将急剧下降，随着访问量的继续增大，系统最终就死掉了。 优化2: 服务端使用线程池来处理客户端的请求为了改进这种一连接一线程的模型，我们可以使用线程池来管理这些线程，实现一个或多个线程处理多个客户端请求的模型（服务端的线程个数和客户端并发访问数呈M:N的关系，N可以远远大于M，但是底层还是使用的同步阻塞I/O），通常被称为“伪异步I/O模型“。伪异步I/O模型图： 和优化1绝大多数部分的代码是类似的,所以只展示服务端需要修改的部分 private ExecutorService executor; public void start() { try { // 绑定监听端口 server = new ServerSocket(DEFAULT_PORT); System.out.println(\"[启动服务器， 监听端口 \" + DEFAULT_PORT + \"]\"); while (true) { // 等待客户端连接 Socket socket = server.accept(); // 创建新的线程, 用于处理客户端数据 new Thread(new ChatHandler(socket, this)).start(); executor.execute(new ChatHandler(socket, this)); } } catch (IOException e) { e.printStackTrace(); }finally { close(); } } 优化3: NIO服务端public class ChatServer implements NioConstant { private ServerSocketChannel server; private Selector selector; // 读取 buffer private ByteBuffer rBuffer = ByteBuffer.allocate(BUFFER); // 写入 buffer private ByteBuffer wBuffer = ByteBuffer.allocate(BUFFER); private Charset charset = Charset.forName(\"UTF-8\"); // 自定义端口 private int port; public ChatServer(){ this(DEFAULT_PORT); } public ChatServer(int port){ this.port = port; } public void start(){ try { // 打开一个ServerSocket 的 Channel server = ServerSocketChannel.open(); // 设置非阻塞 server.configureBlocking(false); // 得到一个关于该ServerSocketChannel的ServerSocket、并且绑定端口 server.socket().bind(new InetSocketAddress(port)); // 打开Selector selector = Selector.open(); // 把ServerSocketChannel注册到Selector ， 设置监听事件为ACCEPT server.register(selector , SelectionKey.OP_ACCEPT); System.out.println(\"启动服务器，监听端口：\"+ port +\"...\"); while(true){ // 本身是阻塞式调用 selector.select(); // 触发事件集 Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); for(SelectionKey key : selectionKeys){ // 处理被触发的事件 handles(key); } // 处理完成后，手动清空 selectionKeys.clear(); } } catch (IOException e) { e.printStackTrace(); } finally{ close(selector); } } private boolean readyToQuit(String msg){ return QUIT.equalsIgnoreCase(msg); } private synchronized void close(Closeable closeable){ if(closeable != null){ try { closeable.close(); } catch (IOException e) { e.printStackTrace(); } } } private String receive(SocketChannel client) throws IOException { // 写模式 rBuffer.clear(); while((client.read(rBuffer)) &gt; 0); // 读模式 rBuffer.flip(); return String.valueOf(charset.decode(rBuffer)); } private void forwardMessage(SocketChannel client , String fwdMsg) throws IOException { for(SelectionKey key : selector.keys()){ Channel connectedClient = key.channel(); if(connectedClient instanceof ServerSocketChannel){ continue; } if(key.isValid() &amp;&amp; !client.equals(connectedClient)){ // 写模式 wBuffer.clear(); wBuffer.put(charset.encode(getClientName(client) +\":\"+fwdMsg)); // 读模式 wBuffer.flip(); while(wBuffer.hasRemaining()){ ((SocketChannel) connectedClient).write(wBuffer); } } } } private String getClientName(SocketChannel client){ return \"客户端[\"+client.socket().getPort()+\"]\"; } private void handles(SelectionKey key) throws IOException { // ACCEPT事件 - 和客户端建立了连接 if(key.isAcceptable()){ ServerSocketChannel server = (ServerSocketChannel) key.channel(); SocketChannel client = server.accept(); // 设置成非阻塞 client.configureBlocking(false); client.register(selector , SelectionKey.OP_READ); System.out.println(getClientName(client)+\"已连接\"); } // READ事件 - 客户端发送了消息 else if(key.isReadable()){ SocketChannel client = (SocketChannel) key.channel(); String fwdMsg = receive(client); if(fwdMsg.isEmpty()){ // 客户端异常 , 不再监听这个事件 key.cancel(); // 更新监听事件状态 selector.wakeup(); } else{ forwardMessage(client , fwdMsg); // 检查用户是否准备退出 if(readyToQuit(fwdMsg)){ key.cancel(); selector.wakeup(); System.out.println(getClientName(client)+\"已断开\"); } } } } public static void main(String[] args) { ChatServer server = new ChatServer(); server.start(); } } 客户端public class ChatClient implements NioConstant { private String host; private int port; private SocketChannel client; private ByteBuffer rBuffer = ByteBuffer.allocate(BUFFER); private ByteBuffer wBuffer = ByteBuffer.allocate(BUFFER); private Selector selector; private Charset charset = Charset.forName(\"UTF-8\"); public ChatClient(){ this(DEFAULT_HOST , DEFAULT_PORT); } public ChatClient(String host , int port){ this.host = host; this.port = port; } // 检查用户是否准备退出 public boolean readyQuit(String msg){ return QUIT.equalsIgnoreCase(msg); } public void close(Closeable closeable){ if(closeable != null){ try { closeable.close(); } catch (IOException e) { e.printStackTrace(); } } } public void start(){ try { selector = Selector.open(); client = SocketChannel.open(); // 设置非阻塞 client.configureBlocking(false); client.register(selector , SelectionKey.OP_CONNECT); client.connect(new InetSocketAddress(host , port)); while(true){ selector.select(); Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); for(SelectionKey key : selectionKeys){ handles(key); } } } catch (IOException e) { e.printStackTrace(); } catch (ClosedSelectorException e){ // 用户正常退出，产生的异常 } finally { close(selector); } } private void handles(SelectionKey key) throws IOException { // CONNECT事件 - 连接就绪事件 if(key.isConnectable()){ SocketChannel client = (SocketChannel) key.channel(); if(client.isConnectionPending()){ client.finishConnect(); // 处理用户的输入 new Thread(new UserInputHandler(this)).start(); } client.register(selector , SelectionKey.OP_READ); } // READ事件 - 服务器转发消息 else if(key.isReadable()){ SocketChannel client = (SocketChannel) key.channel(); String msg = receive(client); if(msg.isEmpty()){ // 服务器异常 close(selector); } else{ System.out.println(msg); } } } private String receive(SocketChannel client) throws IOException { // 写模式 rBuffer.clear(); while(client.read(rBuffer) &gt; 0); // 写模式 rBuffer.flip(); return String.valueOf(charset.decode(rBuffer)); } public void send(String msg) throws IOException { if(msg.isEmpty()){ return ; } // 写模式 wBuffer.clear(); wBuffer.put(charset.encode(msg)); wBuffer.flip(); while(wBuffer.hasRemaining()){ client.write(wBuffer); } // 检查用户是否准备退出 if(readyQuit(msg)){ close(selector); } } public static void main(String[] args) { ChatClient client = new ChatClient(); client.start(); } }","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"I/O","slug":"I-O","permalink":"https://winniekun.github.io/tags/I-O/"}]},{"title":"Java的几种文件拷贝方式","slug":"Java基础/面试36讲/copy-methods-of-java","date":"2020-05-14T03:18:51.000Z","updated":"2021-09-12T13:35:17.254Z","comments":true,"path":"copy-methods-of-java/","link":"","permalink":"https://winniekun.github.io/copy-methods-of-java/","excerpt":"前言","text":"前言 Java中文件的拷贝方式，大体上分为两个派系 stream的方式实现拷贝 NIO的方式实现拷贝 以下举例四个经典的拷贝方式的实现，尽管Java中有自己的Copy实现，还是想使用BIO或NIO实现下面的四个方式 四种拷贝方式无Buffer的输入输出流拷贝方式public class NoBufferStreamCopy implements FileCopyRunner { @Override public void copyFile(File source, File target) { try ( InputStream input = new FileInputStream(source); OutputStream output = new FileOutputStream(target); ) { int read; while ((read = input.read())!= -1){ output.write(read); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } @Override public String toString() { return \"NoBufferStreamCopy\"; } } 有Buffer的输入输出流拷贝方式public class BufferStreamCopy implements FileCopyRunner { @Override public void copyFile(File source, File target) { try ( InputStream input = new FileInputStream(source); OutputStream output = new FileOutputStream(target); ) { byte[] buffer = new byte[1024]; int leng; while ((leng = input.read(buffer)) != -1){ output.write(buffer, 0, leng); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } @Override public String toString() { return \"BufferStreamCopy\"; } } NIO基础的拷贝实现public class NioBufferCopy implements FileCopyRunner { @Override public void copyFile(File source, File target) { try ( FileChannel input = new FileInputStream(source).getChannel(); FileChannel output = new FileOutputStream(target).getChannel(); ) { ByteBuffer buffer = ByteBuffer.allocate(1024); while (input.read(buffer) != -1){ buffer.flip(); while (buffer.hasRemaining()) { output.write(buffer); } buffer.clear(); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } @Override public String toString() { return \"NioBufferCopy\"; } } NIO Transfer实现拷贝public class NioTransferCopy implements FileCopyRunner { @Override public void copyFile(File source, File target) { try ( FileChannel inputChannel = new FileInputStream(source).getChannel(); FileChannel ouputChannel = new FileOutputStream(target).getChannel(); ) { for (long count = inputChannel.size(); count &gt; 0;) { long transferTo = inputChannel.transferTo(inputChannel.position(), count, ouputChannel); count -= transferTo; } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } @Override public String toString() { return \"NioTransferCopy\"; } } 对比测试类public class FileCopyDemo { private static final int ROUNDS = 5; private static final File sourceBig = new File(\"/home/kongweikun/Downloads/test/ccc.txt\"); private static final File sourceMid = new File(\"/home/kongweikun/Downloads/test/bbb.txt\"); private static final File sourceSmal = new File(\"/home/kongweikun/Downloads/test/aaa.txt\"); private static final File target = new File(\"/home/kongweikun/Downloads/test/ddd.txt\"); public static void benchMark(FileCopyRunner test, File source, File target, String name) { long elapsed = 0L; for (int i = 0; i &lt; ROUNDS; i++) { long start = System.currentTimeMillis(); test.copyFile(source, target); elapsed = System.currentTimeMillis() - start; // 删除copy之后的文件 target.delete(); } System.out.println(test + name + \" : \" + elapsed / ROUNDS + \"毫秒\"); } public static void main(String[] args) { FileCopyRunner noBufferStreamCopy = new NoBufferStreamCopy(); FileCopyRunner bufferedStreamCopy = new BufferStreamCopy(); FileCopyRunner nioBufferCopy = new NioBufferCopy(); FileCopyRunner nioTransferCopy = new NioTransferCopy(); // 测试 1 System.out.println(\"-----------------------------------------\"); System.out.println(\"无Buffer的BIO\"); benchMark(noBufferStreamCopy, sourceBig, target, \"大文件\"); benchMark(noBufferStreamCopy, sourceMid, target, \"中等文件\"); benchMark(noBufferStreamCopy, sourceSmal, target, \"小文件\"); System.out.println(\"-----------------------------------------\"); System.out.println(\"有Buffer的BIO\"); benchMark(bufferedStreamCopy, sourceBig, target, \"大文件\"); benchMark(bufferedStreamCopy, sourceMid, target, \"中等文件\"); benchMark(bufferedStreamCopy, sourceSmal, target, \"小文件\"); // System.out.println(\"-----------------------------------------\"); System.out.println(\"NIO基础\"); benchMark(nioBufferCopy, sourceBig, target, \"大文件\"); benchMark(nioBufferCopy, sourceMid, target, \"中等文件\"); benchMark(noBufferStreamCopy, sourceSmal, target, \"小文件\"); System.out.println(\"-----------------------------------------\"); System.out.println(\"NIO的TransferTo\"); benchMark(nioTransferCopy, sourceBig, target, \"大文件\"); benchMark(nioTransferCopy, sourceMid, target, \"中等文件\"); benchMark(nioTransferCopy, sourceSmal, target, \"小文件\"); } } ----------------------------------------- 无Buffer的BIO NoBufferStreamCopy大文件 : 614毫秒 NoBufferStreamCopy中等文件 : 0毫秒 NoBufferStreamCopy小文件 : 0毫秒 ----------------------------------------- 有Buffer的BIO BufferStreamCopy大文件 : 1毫秒 BufferStreamCopy中等文件 : 0毫秒 BufferStreamCopy小文件 : 0毫秒 ----------------------------------------- NIO基础 NioBufferCopy大文件 : 1毫秒 NioBufferCopy中等文件 : 0毫秒 NoBufferStreamCopy小文件 : 0毫秒 ----------------------------------------- NIO的TransferTo NioTransferCopy大文件 : 0毫秒 NioTransferCopy中等文件 : 0毫秒 NioTransferCopy小文件 : 0毫秒 总结对于 Copy 的效率,这个其实与操作系统和配置等情况相关,总体上来说,NIOtransferTo/From 的方式可能更快,因为它更能利用现代操作系统底层机制,避免不必要拷贝和上下文切换。 不同的 copy 方式,底层机制有什么区别?这里涉及到了用户态空间和内核态空间,这是操作系统层面的基本概念,操作系统内核、硬件驱动等运行在内核态空间,具有相对高的特权.而用户态空间,则是给普通应用和服务使用. 当我们使用输入输出流的进行读写的时候,实际上经历了多次的上下文切换: 应用数据的读取: 首先内核态将数据从磁盘读取到内核缓存,再切换到用户态将数据从内核缓存读取到用户缓存 用户态-内核态 所以,这种方式会带来一定的额外开销,可能会降低 IO 效率。 但是NIO的transferTo的实现, 会涉及到零拷贝, 也就是数据传输并不会涉及到用户态,省去了上下文的切换和不必要的拷贝. transferTo的传输过程是:","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://winniekun.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"面试36讲","slug":"面试36讲","permalink":"https://winniekun.github.io/tags/%E9%9D%A2%E8%AF%9536%E8%AE%B2/"}]},{"title":"接口和抽象类的区别","slug":"Java基础/面试36讲/interface-Abstarct-diff","date":"2020-05-13T13:03:31.000Z","updated":"2020-08-30T04:50:22.244Z","comments":true,"path":"interface-Abstarct-diff/","link":"","permalink":"https://winniekun.github.io/interface-Abstarct-diff/","excerpt":"接口","text":"接口 接口是不是类，是对类的一组需求的描述，这些类要遵从接口描述的同一格式进行定义（其是对行为的抽象，是抽象方法的集合）。有两个方面的职责： 抽象方法的集合（主要） 声明某些东西（Mark Interface） 通过接口，可以达到API和实现的分离，譬如MVC中的dao层或service层，但是不能实例化，同时也不能包含任何非常量成员，所以，也隐含表明，任何的field都具有public static final的意义。同时对于方法来说，接口中要么是抽象方法，要么是静态方法。如Collection框架中root interface java.util.Collection 疑问1：为什么常量成员默认修饰为public static final 接口必须要具体类实现才有意义，所以必须是public。 接口中的属性对所有实现类只有一份，所以是static。 要使实现类为了向上转型成功，所以必须是final的。 疑问2：为什么方法要么是抽象方法，要么是静态方法 抽象方法和接口定义的方法，你可以理解为是一种协议或者规范。比如我们是行业的达人，需要定义车的规范，它能启动、跑起来、刹车和停止，这4项功能就是抽象方法。至于用什么引擎启动、跑地多快、怎么刹车，我们就不想管了，你爱怎么实现是你的事，但你必须实现我们定义好的抽象方法，否则你生产的就不是车子了。 以最常用的java.util.List为例，它的继承树及其庞大。但这些实现类和继承类，都有共同的方法，也就是List定义的方法，比如get/add/remove/size。这样就保证了后续子孙都是一个模样的，但有个性。 List list = new 实现类();list.add(obj);list.get(0);int size = list.size();// 这行代码不需要修改实现类可以是ArrayList，也可以是LinkedList，或者是线程安全的CopyOnWriteArrayList。爱换那个换那个，但第二行的代码不需要修改，因为它们都使用了List的规范。 1、接口是一种约束和规范，是一种更加更高级的抽象类，抽象类的方法必须是公开的，因为要给人继承和使用啊，不用public，别人怎么看得到，所以在接口实现时，定义的方法修饰符必须是public；因此子类在实现接口重写方法时的修饰符必须是public。2、另外再扩展一下，接口中没有变量（既然是约束和规范，怎么能够定义一个大家都可以改的东西呢？），只能是常量，接口中定义常量默认的修饰符为public static final。 抽象类类似于模板，但又不同，目的是提高代码的复用，其抽取了相关的Java类的共用方法，或共用的成员变量，通过继承的方法达到代码复用目的。譬如Collection框架中的各种AbstractXXX类。抽象类除了不能实例化，形式上和Java类没有太大区别。 总结接口： 只有常量 方法要么是抽象方法、要么是静态方法 不能被实例化 一个类可以实现多个接口 抽象类： 除了不能实例化，其他和普通类没太大区别 一个类只能继承一个抽象类（Java 不支持多继承） 核心区别 行为规范: 接口 通用功能: 抽象 在一些情况下存在特定场景,需要抽象出与具体实现、实例化无关的通用逻辑,或者纯调用关系的逻辑，这样的话，因为Java不支持多继承，就无法使用抽象类进行实现，常用的方法是实现由静态方法构成的工具类，比如java.util.Collections 接口的职责也不仅仅限于抽象方法的集合,其实有各种不同的实践。有一类没有任何方法的接口,通常叫作 Marker Interface,顾名思义,它的目的就是为了声明某些东西,比如我们熟知的 Cloneable、Serializable 等。这种用法,也存在于业界其他的 Java 产品代码中。 References Java核心卷I","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://winniekun.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"面试36讲","slug":"面试36讲","permalink":"https://winniekun.github.io/tags/%E9%9D%A2%E8%AF%9536%E8%AE%B2/"}]},{"title":"JDK源码分析计划","slug":"源码/jdk-source-analysis","date":"2020-05-13T05:40:58.000Z","updated":"2020-08-30T04:50:22.257Z","comments":true,"path":"jdk-source-analysis/","link":"","permalink":"https://winniekun.github.io/jdk-source-analysis/","excerpt":"前言","text":"前言 自己也断断续续的读了一些JDK的源码了，并且也写了总结，但是尴尬的是，该忘得还是忘了，所以打算系统的理理，然后没看完一个除了总结，再做个思维导图。阅读JDK的目的有三： 学好数据结构以及相关算法 毕竟是内功，该硬啃还是要硬啃 不希望自己到时候追悔莫及 能让自己的Java的理解和熟练度更上一层楼 莫问Python嘞，问就是爱过 面试 这也是没得办法，感觉目前面试不问个源码问题，都不像面试 顺带把LeetCode相关的算法刷一遍😄 总体进程 常用数据结构手撸一遍 算法第四版 数据结构与算法分析 阅读JDK源码，记录 参考其他大佬的总结，查缺补漏 相关LeetCode题目刷了 JDK 集合类 所有集合 太复杂, 然后去除JUC上的一些实现类, 再看一下 collection-map-不包含JUC中的类 CollectionListList中的元素是有序的, 可重复的, 主要的实现方式是动态数组和链表 List Java中提供的List的实现主要有ArrayList、LinkedList、CopyOnWriteArrayList，另外还有两个古老的类Vector和Stack。 java.util.LinkedList ✔ java.util.Vector ✔ java.util.Stack ✔ java.util.ArrayList✔ java.util.concurrent.CopyOnWriteArrayList ✔ Queue队列是遵循着一定原则的入队出队操作的集合, 先进先出, 一般来说在堆尾添加元素(入队), 在队头删除元素(出队), 但是也不一定, 不如优先队列的原则就不同 Java中提供的Queue的实现有: PriorityQueue、ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue、LinkedTransferQueue、DelayQueue、ConcurrentLinkedQueue。 java.util.PriorityQueue java.util.concurrent.ArrayBlockingQueue java.util.concurrent.LinkedBlockingQueue java.util.concurrent.SynchronousQueue java.util.concurrent.PriorityBlockingQueue java.util.concurrent.LinkedTransferQueue java.util.concurrent.DelayQueue java.util.concurrent.ConcurrentLinkedQueue DequeDeque是一种特殊的队列，它的两端都可以进出元素，故而得名双端队列（Double Ended Queue）。 Deque Java中提供的Deque的实现主要有ArrayDeque、LinkedBlockingDeque、ConcurrentLinkedDeque、LinkedList。 java.util.Deque java.util.ArrayDeque java.util.concurrent.ConcurrentDeque Set Set Java中提供的Set的实现主要有HashSet、LinkedHashSet、TreeSet、CopyOnWriteArraySet、ConcurrentSkipListSet。 java.util.HashSet java.util.TreeSet java.util.LinkedHashSet java.util.concurrent.CopyOnWriteArraySet java.util.concurrent.ConcurrentSkipListSet Map Map java中提供的Map的实现主要有HashMap、LinkedHashMap、WeakHashMap、TreeMap、ConcurrentHashMap、ConcurrentSkipListMap，另外还有两个比较古老的Map实现HashTable、Properties。 java.util.TreeMap ✔ java.util.WeakHashMap java.util.LinkedHashMap java.util.HashMap ✔ java.util.concurrent.ConcurrentHashMap java.util.concurrent.ConcurrentSkipListMap java.util.Hashtable java.util.Properties 集合类概述逛博客的时候，发现一张神图 java-collection-cheat-sheet Java Collections Framework Cheat Sheet 阅读套路大体上的阅读框架写好了，接下来就是细致的硬啃了，可以先从顶层的接口开始，然后是Abstact类，这样方便理解不同的具体的集合类必备的通用方法等，然后再看这些具体类对这些通用方法的具体实现。顺序还是老样子：增、删、改、查，然后是其他的细节部分。 References 【死磕 Java 集合】— 总结篇","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"}]},{"title":"网站部署实录","slug":"配置/网站部署实录","date":"2020-05-10T12:23:05.000Z","updated":"2021-04-08T12:46:31.070Z","comments":true,"path":"网站部署实录/","link":"","permalink":"https://winniekun.github.io/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2%E5%AE%9E%E5%BD%95/","excerpt":"前言最近一个星期在做论坛形式的web应用，逻辑越写越多，脑子也是越写越乱，也越要越感觉SpringBoot和Flask的思想上好像。今天终于撸完了所有的业务逻辑，以及测试。开始部署，以下，记录部署的整个过程。😄","text":"前言最近一个星期在做论坛形式的web应用，逻辑越写越多，脑子也是越写越乱，也越要越感觉SpringBoot和Flask的思想上好像。今天终于撸完了所有的业务逻辑，以及测试。开始部署，以下，记录部署的整个过程。😄 环境依赖 部署 项目中的环境依赖如上图所述，按照步骤来， 先ssh链接服务器， 之后配置Java环境、MySQL、Redis、Kafka、Maven。之后配置Tomcat、Nginx。服务器使用的是Ubuntu18.04LTS SSH因为，ssh长时间不操作就断开，所以还是需要进行配置下 服务器配置1、 连接SSH ssh root@ip 2、编辑sshd_config vim /etc/ssh/sshd_config 3、找到ClientAliveInterval，将前面的#去掉（懒得找的话，直接在最后添加即可） # 服务器每隔60秒会给客户端发送一次保活信息包给客户端，可以将这个值设置大一点 ClientAliveInterval 60 4、找到ClientAliveCountMax，将前面的#去掉（同理） # 服务器发出的请求如果客户端没有响应，则判断超时1次，这个参数是表示允许超时的次数。可以将这个值设置大一点。 ClientAliveCountMax 888 Java环境oracle官网下载JDK，个人使用的是JDK8。之后将下载好的JDK上传服务器，也可以直接服务器安装，个人想试试scp命令，而且自己系统也是Ubuntu的，所有依赖环境压缩上传即可，更加方便 scp filepath/filename username@ip:/targetfilepath 譬如，下载好的本地JDK在Downloads文件夹下，想传入服务器root用户根目录下的community目录下，方便同一管理，后续的文件都传入community目录下 scp /Downloads/jdk-8u251-linux-x64.tar.gz root@ip:/community 之后使用终端登录服务器，解压JDK，配置环境(/etc/profile) ssh root@ip -p xxx (如果更改ssh端口的话) vim /etc/profile （配置环境变量） profile的配置如下 ## java environment export JAVA_HOME=/community/jdk1.8.0_251 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 之后，激活 source /etc/profile 最后，使用命令java -version检测是否配置成功 java version \"1.8.0_251\" Java(TM) SE Runtime Environment (build 1.8.0_191-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode) MySQL官网下载，点击MySQL APT Repository下载即可 MySQL 之后同理，传入服务， scp mysq-apt-config_0.8.15-1_all.deb root@ip:/community 之后通过之前ssh链接服务器的终端，安装MySQL sudo dpkg -i mysq-apt-config_0.8.15-1_all.deb 期间有让选择MySQL的版本，个人选择的是5.7的，因为开发的时候用的是5.7。之后更新source.list，下载MySQL即可 sudo apt-get update sudo apt-get install mysql-server 等待片刻后，会弹出mysql一个小的配置程序界面，要求你输入下root用户的密码（输入2次）等等。安装成功之后，登录尝试下即可 mysql -u root -p ## 输出信息 Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 24 Server version: 5.7.30-0ubuntu0.18.04.1 (Ubuntu) Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql&gt; MySQL的卸载在Ubuntu18.04系统下彻底删除MySQL的方法 Redis在此之前安装 add-apt-respository sudo apt-get update sudo apt-get install software-properties-common 步骤 $ sudo add-apt-repository ppa:redislabs/redis $ sudo apt-get update $ sudo apt-get install redis KafkaKafka官网，个人下载的是 kafka_2.12-2.5.0.tgz，前缀2.12是支持的Scala版本，本机电脑安装的Scala版本是2.12 下载之后，直接上传即可， 没有特别需要配置的东西，个人更改了log的地址，因为是服务器， 所以需要长期的运行，可执行如下命令 # zookeeper bin/zookeeper-server-start.sh -daemon config/zookeeper.properties # kafka server nohup bin/kafka-server-start.sh config/server.properties 1&gt;/dev/null 2&gt;&amp;1 &amp; Maven[Maven 3.6.3](https://apache.website-solution.net/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz，因为墙的问题，所以自己配置了setting.xml里面的`localRepository`和`mirrors` &lt;localRepository&gt;/home/kongweikun/maven&lt;/localRepository&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;uk&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://uk.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;CN&lt;/id&gt; &lt;name&gt;OSChina Central&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;internal nexus repository&lt;/name&gt; &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 同理，需要在/etc/profile中配置 ## maven export M2_HOME=/community/apache-maven-3.6.3 export PATH=${M2_HOME}/bin:$PATH 激活 Tomcattomcat 9.0.34，下载之后，上传服务器即可，之后解压，/etc/profile配置 ## tomcat export CATALINA_HOME=/community/apache-tomcat-9.0.34 export CLASSPATH=${CLASSPATH}:${CATALINA_HOME}/lib export PATH=${PATH}:${CATALINA_HOME}/bin 之后，终端运行startup.sh，过一会儿用浏览器访问IP:8080查看是否能访问，不能访问的话，检查8080端口是否开发 netstat -apn | grep 8080 # 观察8080端口是否开放 netstat -ntpl # 显示网络状态, 可查看8080端口状态 ps -ef | grep tomcat # 查看tomcat进程 Nginxsudo apt-get install nginx 安装之后，可将/etc/nginx/sites-available/的default文件删除，但记得做备份。 之后在/etc/nginx/nginx.conf中的http中添加如下部分即可 upstream myserver{ server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; } server { listen 80; server_name ip; location / { proxy_pass http://myserver; } } nginx命令sudo systemctl restart nginx # 重启nginx systemctl status nginx # 检测nginx状态 部署最后，所有的环境安装成功之后，就是最重要的应用程序部署了。因为，Tomcat默认启动的是其webapps下的ROOT应用。其内部的应用程序，在路由上添加对应的名字即可，但是，因为我们想直接将ip绑定到应用程序，不加前缀，所以可以用如下的方式解决： 将自己的应用打包为war包，命名为ROOT，替换为Tomcat自带的ROOT应用。将properties中的server.servlet.context-path = xxx 后面的xxx去除，然后应用中涉及到context-path的也修改 pom.xml &lt;!--打成war包--&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;build&gt; &lt;!--打包名字--&gt; &lt;finalName&gt;ROOT&lt;/finalName&gt; &lt;plugins&gt; xxx &lt;/plugins&gt; &lt;/build&gt; 编写CommunityServleInitializer，继承SpringBootServletInitializer public class CommunityServleInitializer extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { return builder.sources(CommunityApplication.class); } } 将自己的应用程序上传服务器，然后使用maven打包 mvn clean package -Dmaven.test.skip=true 之后将target下的ROOT.war移动到Tomcat下的webapps中即可， 然后startup.sh over 部署成功展示 看来，这几年用Ubuntu还是有成果的，最起码，服务器上部署应用不用再那么恼火了，可以快速部署了。","categories":[{"name":"配置","slug":"配置","permalink":"https://winniekun.github.io/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"配置","slug":"配置","permalink":"https://winniekun.github.io/tags/%E9%85%8D%E7%BD%AE/"}]},{"title":"死磕位运算","slug":"LeetCode/stick-to-bit-operation","date":"2020-04-26T10:40:01.000Z","updated":"2021-08-18T08:54:33.166Z","comments":true,"path":"stick-to-bit-operation/","link":"","permalink":"https://winniekun.github.io/stick-to-bit-operation/","excerpt":"前言LeetCode死磕系列五： 位运算 位运算，在性能上是超过加减乘除的，只不过，费些脑细胞。基础的与&amp; 或| 异或^ 运算，以及左移动、右移。","text":"前言LeetCode死磕系列五： 位运算 位运算，在性能上是超过加减乘除的，只不过，费些脑细胞。基础的与&amp; 或| 异或^ 运算，以及左移动、右移。 常用操作&amp;、| 、^、&gt;&gt;、&lt;&lt;、&gt;&gt;&gt;假设整数变量 A 的值为 60 和变量 B 的值为 13： 操作符 描述 例子 ＆ 如果相对应位都是1，则结果为1，否则为0 （A＆B），得到12，即0000 1100 \\ 如果相对应位都是 0，则结果为 0，否则为 1 （A \\ B）得到61，即 0011 1101 ^ 如果相对应位值相同，则结果为0，否则为1 （A ^ B）得到49，即 0011 0001 〜 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。 （〜A）得到-61，即1100 0011 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数。 A &lt;&lt; 2得到240，即 1111 0000 &gt;&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数。 A &gt;&gt; 2得到15即 1111 &gt;&gt;&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 A&gt;&gt;&gt;2得到15即0000 1111 异或 2 ^ 2 = 0; 与 0 &amp; 1 = 0； 1 &amp; 1 = 0； n &amp; (n-1)10000000； 01111111; &lt;----- binary ----&gt; n n n-1 n&amp;(n-1) -- ---- ---- ------- 0 0000 0111 0000 * 1 0001 0000 0000 * 2 0010 0001 0000 * 3 0011 0010 0010 4 0100 0011 0000 * 5 0101 0100 0100 6 0110 0101 0100 7 0111 0110 0110 8 1000 0111 0000 * 9 1001 1000 1000 10 1010 1001 1000 11 1011 1010 1010 12 1100 1011 1000 13 1101 1100 1100 14 1110 1101 1100 15 1111 1110 1110 可以看到，其第一个方式是用于判断是否为2的幂次，n&amp;(n-1)的结果为0的话，则为2的幂次。 从运算结果分析（以12为例）： 12二进制表示为：1100，减去1之后，为1011，可以发现，减去1之后，是将该数字的二进制的最右边的1改为0，n&amp;(n-1)之后的结果为1000，比较1100和1000，这个操作可以总结为：将当前数字二进制最右边的1去除。最右边的1左边部分不变。所以，也可可以用于统计数字的二进制中1的个数问题。 补码： ~x + 1 是 x的补码; 补码 1 + 11111111111111111 = 000000000000000000; 2 + 11111111111111110 = 000000000000000000 (s | 1&lt;&lt;k)s: 集合（二进制表示包含的元素） 集合元素$s = {1,4,6}$ 则 $s = 1010010{2} = 82{10}$ k: 元素 将元素k放入集合s中 举例说明 当前$s=82$, 此时$k=2$，将$k$放入集合$s$中 $(1&lt;&lt;k) = 4 = 100_{2}$ $(s | 1&lt;&lt; k) == 1010110{2} == 86{10}$ 神奇的操作，适用于压缩状态dp LeetCode &amp; 剑指offer 位运算题目整理 面试题15：二进制中1的个数 136 Single Number LeetCode 位运算题目整理面试题15：二进制中1的个数public static int numberOf(int n){ // n &amp; (n - 1) 会消除 n 中最后一位中的 1。 int res = 0; while (n != 0){ res++; n &amp;= (n-1); } return res; } 136 Single Number这题是去除数组中的重复元素（给的测试集是只有一个不重复的元素），用了异或运算， 思路： 相等的数相异或结果为0，0和任何数相异或结果为这个数本身。根据这个特点，可以先设置一个初始值为0，然后分别和数组中的每个元素相异或，最后保留的肯定为唯一一个不重复的值。 相等的元素相异或的值为0，不是特指相等的元素必须相连，也可以不相连。 public singleNumber(int[] nums){ int res = 0; for( int i : nums){ res ^= i; } return res; } References n &amp; (n-1) what does this expression do? duplicate","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"位运算","slug":"位运算","permalink":"https://winniekun.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"匈牙利算法实现","slug":"算法/实现-图论/匈牙利算法实现","date":"2020-04-22T02:07:40.000Z","updated":"2020-08-30T04:50:22.260Z","comments":true,"path":"匈牙利算法实现/","link":"","permalink":"https://winniekun.github.io/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/","excerpt":"TODO","text":"TODO 前言匈牙利算法记录，并且添加了几道实战题目 简介&amp;思路匈牙利算法是一种在多项式时间内求解任务分配问题的组合优化算法，并推动了后来的原始对偶方法。美国数学家哈罗德·库恩于1955年提出该算法。此算法之所以被称作匈牙利算法，是因为算法很大一部分是基于以前匈牙利数学家Dénes Kőnig和Jenő Egerváry的工作之上创建起来的。匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径(是指从M中没有用到的顶点)开始，并从M中没有用到的顶点结束的交替路径)，它是一种用增广路径求二分图最大匹配的算法。 概念：匹配&amp;最大匹配&amp;完美匹配 匹配： 一种边的集合，其中任意两条边没有公共顶点 最大匹配: 一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。 完美匹配： 如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。 交替路径&amp;增广路径 交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。 增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路。 思路&amp;实现该思路和主要为最佳匹配问题， 题目References 维基百科 Hungarian Algorithm","categories":[{"name":"算法","slug":"算法","permalink":"https://winniekun.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://winniekun.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Java实现生产者-消费者模型","slug":"Java进阶/并发/Java实现生产者-消费者模型","date":"2020-04-21T13:27:00.000Z","updated":"2020-08-30T04:50:22.246Z","comments":true,"path":"Java实现生产者-消费者模型/","link":"","permalink":"https://winniekun.github.io/Java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/","excerpt":"前言","text":"前言 最近在看线程池的实现原理，后面又看了源码，发现其内部是一个生产者-消费者模型，用户是提交的任务（task）是生产者，线程池中的线程（worker）是消费者。 然后感觉对生产者-消费者模型的实现，磕磕绊绊的，所以记录一下。下面会涉及多种生产者-消费者模型的实现，可以先抽象出关键的接口，并实现一些抽象类： 准备生产者消费者接口生产者接口public interface Producer { void produce() throws InterruptedException; } 消费者接口public interface Consumer { void consume() throws InterruptedException; } 生产者消费者抽象类生产者抽象类abstract class AbstractProducer implements Runnable, Producer { @Override public void run() { while (true){ try{ produce(); }catch (Exception e){ e.printStackTrace(); } } } } 消费者抽象类abstract class AbstractConsumer implements Consumer, Runnable { @Override public void run() { while (true){ try{ consume(); }catch (Exception e){ e.printStackTrace(); } } } } Model接口对应的实现生产者-消费者模型，不同的生产者-消费者实现模型都实现该接口， public interface Model { Runnable newRunnableConsumer(); Runnable newRunnableProducer(); } Task将Task作为生产和消费的基本单位 public class Task { private int no; public Task(int no){ this.no = no; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } } 实现一：BlockingQueueBlockingQueue的写法最简单。核心思想是，把并发和容量控制封装在缓冲区中。而BlockingQueue的性质天生满足这个要求。 package com.train.concurrent.procon; import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingDeque; import java.util.concurrent.atomic.AtomicInteger; /** * @Time: 2020/4/21下午8:54 * @Author: kongwiki * @Email: kongwiki@163.com */ public class BlockingQueueModel implements Model { private BlockingQueue&lt;Task&gt; queue; private final AtomicInteger increTaskNo = new AtomicInteger(0); public BlockingQueueModel(int cap){ this.queue = new LinkedBlockingDeque&lt;&gt;(cap); } @Override public Runnable newRunnableConsumer() { return new ConsumerImpl(); } @Override public Runnable newRunnableProducer() { return new ProducerImpl(); } private class ConsumerImpl extends AbstractConsumer implements Runnable, Consumer{ @Override public void consume() throws InterruptedException { Task task = queue.take(); Thread.sleep(500 + (long) (Math.random() * 500)); System.out.println(\"consume: \" + task.getNo()); } } private class ProducerImpl extends AbstractProducer implements Runnable, Producer{ @Override public void produce() throws InterruptedException { Thread.sleep((long) (500 + (Math.random()) * 1000)); Task task = new Task(increTaskNo.getAndIncrement()); System.out.println(\"produce: \" + task.getNo()); queue.put(task); } } public static void main(String[] args) { Model model = new BlockingQueueModel(3); for (int i = 0; i &lt; 2; i++) { new Thread(model.newRunnableConsumer()).start(); } for (int i = 0; i &lt; 5; i++) { new Thread(model.newRunnableProducer()).start(); } } } 实现二：wait&amp;notifypackage com.train.concurrent.procon; import java.util.LinkedList; import java.util.Queue; import java.util.concurrent.atomic.AtomicInteger; /** * @Time: 2020/4/22上午7:40 * @Author: kongwiki * @Email: kongwiki@163.com */ public class WaitNotifyModel implements Model { private int integer; private final Object buffer_lock = new Object(); private final Queue&lt;Task&gt; buffer = new LinkedList&lt;&gt;(); private int cap; public WaitNotifyModel(int cap){ this.cap = cap; } @Override public Runnable newRunnableConsumer() { return new ConsumerImpl(); } @Override public Runnable newRunnableProducer() { return new ProducerImpl(); } public class ProducerImpl extends AbstractProducer implements Runnable, Producer{ @Override public void produce() throws InterruptedException { Thread.sleep((long) (500 + (Math.random() * 1000))); synchronized (buffer_lock){ while (buffer.size() == cap){ buffer_lock.wait(); } Task task = new Task(integer++); buffer.add(task); System.out.println(\"produce: \" + task.getNo()); buffer_lock.notifyAll(); } } } public class ConsumerImpl extends AbstractConsumer implements Runnable, Consumer{ @Override public void consume() throws InterruptedException { synchronized (buffer_lock){ while (buffer.size() == 0){ buffer_lock.wait(); } Task task = buffer.poll(); assert task != null; Thread.sleep((long) (500 + (Math.random() * 1000))); System.out.println(\"consume: \" + task.getNo()); buffer_lock.notifyAll(); } } } public static void main(String[] args) { Model model = new WaitNotifyModel(3); for (int i = 0; i &lt; 3; i++) { new Thread(model.newRunnableConsumer()).start(); } for (int i = 0; i &lt; 5; i++) { new Thread(model.newRunnableProducer()).start(); } } } 实现三：lock &amp;&amp; conditionpackage com.train.concurrent.procon; import java.util.LinkedList; import java.util.Queue; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * @Time: 2020/4/22上午8:01 * @Author: kongwiki * @Email: kongwiki@163.com */ public class LockConditionModel implements Model { private final Lock BUFFER_LOCK = new ReentrantLock(); private final Condition BUFFER_COND = BUFFER_LOCK.newCondition(); private int integer; private Queue&lt;Task&gt; buffer = new LinkedList&lt;&gt;(); private int cap; public LockConditionModel(int cap){ this.cap = cap; } @Override public Runnable newRunnableConsumer() { return new ConsumerImpl(); } @Override public Runnable newRunnableProducer() { return new ProducerImpl(); } public class ProducerImpl extends AbstractProducer implements Producer, Runnable{ @Override public void produce() throws InterruptedException { Thread.sleep((long) (500 + (Math.random() * 1000))); BUFFER_LOCK.lockInterruptibly(); try{ while (buffer.size() == cap){ BUFFER_COND.await(); } Task task = new Task(integer++); buffer.offer(task); System.out.println(\"produce: \"+ task.getNo()); BUFFER_COND.signalAll(); }catch (Exception e){ e.printStackTrace(); }finally { BUFFER_LOCK.unlock(); } } } public class ConsumerImpl extends AbstractConsumer implements Consumer, Runnable{ @Override public void consume() throws InterruptedException { BUFFER_LOCK.lockInterruptibly(); try{ while (buffer.size() == 0){ BUFFER_COND.await(); } Task task = buffer.poll(); assert task != null; System.out.println(\"consume: \" + task.getNo()); BUFFER_COND.signalAll(); }catch (Exception e){ e.printStackTrace(); }finally { BUFFER_LOCK.unlock(); } } } public static void main(String[] args) { Model model = new LockConditionModel(3); for (int i = 0; i &lt; 3; i++) { new Thread(model.newRunnableConsumer()).start(); } for (int i = 0; i &lt; 5; i++) { new Thread(model.newRunnableProducer()).start(); } } }","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://winniekun.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"线程池理解","slug":"Java进阶/并发/线程池理解","date":"2020-04-20T12:23:43.000Z","updated":"2021-04-25T07:50:26.859Z","comments":true,"path":"线程池理解/","link":"","permalink":"https://winniekun.github.io/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%90%86%E8%A7%A3/","excerpt":"线程池的概述","text":"线程池的概述 线程池的内部构建了一个生产者-消费者模型，将线程和任务进行解耦，从而能够良好的缓冲任务，复用线程。同时线程池的运行主要分成两个部分：任务管理、线程管理。 那么生产者-消费者模型体现在哪儿？任务管理可以视为生产者，线程管理视为消费者。任务进入线程池中，线程池会判断其后续的流程： 直接申请线程执行任务 任务缓冲进入阻塞队列，等待线程执行 拒绝该任务 以上属于任务管理，线程管理主要为根据任务请求进行线程的分配，线程执行完之后，继续获取新的任务执行，最后线程获取不到任务，到一定时间之后，该线程被回收。 在Java中，线程池的主要实现类为ThreadPoolExecutor，其实阅读其源码，就可以理解线程池中的所有的思想，以及如何实现。阅读套路：构造方法—-&gt;其他方法及属性。 四个构造方法：其共有四中构造方法，参数分别有5、6、6、7个 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) { ... } public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) { ... } public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) { ... } public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { ... } 必备的参数(5个) corePoolSize：线程池中核心线程的数量 可以形象理解为餐馆就餐中的餐桌，正常情况下的餐桌数量就是corePoolSize。 maximumPoolSize：线程池中线程总数最大值 同上的例子，比作为就餐时间，因为人流量多，老板从后厨新加几个餐桌之后的数量。 在线程池中，从某方面可以将线程分为核心线程和非核心线程，核心线程默认会一直存在在线程池中，即使什么也不干。核心线程数量就是corePoolSize，非核心线程，如果长时间限制的话，会被回收(这和餐桌的例子很契合哇😄)。最大线程总数（maximumPoolSize）= 核心线程数量（corePoolSize） + 非核心线程数量 keepAliveTime：非核心线闲置超时时长 非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程。 TimeUnit unit 枚举类型： 包含有纳秒、微妙、毫秒、秒、分、小时、天 BlockingQueue\\ workQueue：阻塞队列，用于维护等待执行的Runnable任务对象 常用的几个阻塞队列： LinkedBlockingQueue 链式阻塞队列，底层数据结构是链表，默认大小是Integer.MAX_VALUE，也可以指定大小。 ArrayBlockingQueue 数组阻塞队列，底层数据结构是数组，需要指定队列的大小。 SynchronousQueue 同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。 DelayQueue 延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。 非必备的核心参数(2个) ThreadFactory threadFactory 用于自定义线程池的名字、以及兜底的异常处理策略等 RejectedExecutionHandler handler 拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为 ： ThreadPoolExecutor.AbortPolicy：默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：丢弃新来的任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。 ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务。 使用线程池的主要原因有如下: 创建/销毁线程需要消耗系统资源，线程池可以复用已创建的线程。 控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因） 可以对线程做统一管理。 线程池的生命周期线程池本身有一个调度线程，这个线程就是用于管理布控整个线程池里的各种任务和事务，例如创建线程、销毁线程、任务队列管理、线程队列管理等等。所以线程池中也有自己的状态。通过源码了解到ThreadPoolExecutor类中通过volatile int 定义了runState变量表示线程池的状态。 // runState is stored in the high-order bits private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; private static final int STOP = 1 &lt;&lt; COUNT_BITS; private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 运行状态 状态描述 转换方法 RUNNING 能够接受新的任务，并且也能处理阻塞队列中的任务 线程池创建之后 SHUTDOWN 不再接收新提交的任务，清除一些空闲worker，会等待阻塞队列中存储的任务执行完成。 shutdown（） STOP 停止接受新的任务，中断所有线程（包括正在执行的），阻塞队列中为执行的任务全部抛弃，此时poosize = 0, 阻塞队列size = 0; shutdownNow() TIDYING 所有的任务已经终止，workerCount（有效线程数量）数量为0 TERMINATED terminated()方法执行后，进入该状态 任务的管理概述中已经提及，线程池内部就是一个生产者-消费者模型，任务管理视为生产者，线程管理视为消费者，所以接下来详细阐述任务管理和线程管理 任务的调度任务的调度，感觉和操作系统中处理机的调度类似，任务提交之后，进行判断 判断线程池的状态是否为RUNNING，如不执行了，拒绝接收该任务（线程池要保证在RUNNING状态下执行任务）。 如果workerCount &lt; corePoolSize, 创建并启动一个线程，执行该任务。 如果workerCount &gt;= corePoolSize &amp;&amp; 阻塞队列未满，将该任务添加到阻塞队列中。 如果workerCount &gt;=corePoolSize &amp;&amp; 阻塞队里已满&amp;&amp;workerCount &lt; maximumPoolSize，创建并启动一个线程，执行该任务 如果workerCount &gt;= maximumPoolSize &amp;&amp; 阻塞队列已满， 根据拒策略进行拒绝，默认使用是AbortPolicy，放弃任务并抛出异常。 任务调度流程图.png ThreadPoolExecutor中任务调度的实现 public void execute(Runnable command) { if (command == null) throw new NullPointerException(); // 获取线程池状态 int c = ctl.get(); // ② if (workerCountOf(c) &lt; corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } // ③ if (isRunning(c) &amp;&amp; workQueue.offer(command)) { int recheck = ctl.get(); // 3.1 如果isRunning返回false(状态检查)，则remove这个任务，然后执行拒绝策略。 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); // 3.2 线程池处于running状态，但是没有线程，则创建线程 else if (workerCountOf(recheck) == 0) addWorker(null, false); } // ④如果workerCount &gt;=corePoolSize &amp;&amp; 阻塞队里已满&amp;&amp;workerCount &lt; maximumPoolSize，创建并启 // 动一个线程，执行该任务 else if (!addWorker(command, false)) reject(command); } 任务的缓冲（BlockingQueue）这是线程池的关键，其等同于生产者-消费者中的缓冲区，在线程池中，核心是对任务和线程的管理，上述也讲过了核心就是任务和线程的解耦，解耦的方式就是添加缓冲区。在线程池中通过阻塞队列实现缓冲区，暂存任务，工作线程从阻塞队列中获取任务。 阻塞队列常用用于生产者-消费者场景，其除了支持存储任务的线程存储元素，获取任务的线程获取元素之外，还有两个附加的操作（自己编写生产者-消费者最麻烦的地方）： 当队列为空的时候，获取任务的线程会等待队列非空 当队列满的时候，存放任务的线程会等待队列可用。 这样之后，我们就可以只管往里面存、取就行，而不用担心多线程环境下存、取共享变量的线程安全问题。简而言之，阻塞队列（BlockQueue就是生产者存放元素的容器），其提供了四中不同插入、移除、检测元素的方法： 方法 抛出异常 返回特殊值 一直阻塞 超时退出 插入 add(e) offer() put(e) offer(e, time , unit) 移除 remove() poll() take() poll(time, unit) 检查 element() peek() BlockingQueue的实现类有如下的一些 ArrayBlockingQueue LinkedBlockingQueue DelayQueue PriorityBlockingQueue SynchronousQueue 后续会看相应的源码，并整理为博客。目前就不详细解释其区别。 任务的申请由任务的调度可以总结出，任务的执行有两种可能 任务直接由新创建的线程执行 复用线程从阻塞队列中获取任务，执行 第一种情况出现在线程初始创建的时候，以及出现峰值的时候。第二种是线程获取任务绝大多数的情况。这里可以顺便分析ThreadPoolExecutor是如何实现线程的复用的。 第二种的任务的申请使用的是线程池中的getTask的方法 private Runnable getTask() { boolean timedOut = false; // Did the last poll() time out? for (;;) { int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) { decrementWorkerCount(); return null; } int wc = workerCountOf(c); // Are workers subject to culling? // boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; // 如果运行线程数超过了最大线程数，但是缓存队列已经空了，这时递减worker数量 if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) { if (compareAndDecrementWorkerCount(c)) return null; continue; } try { Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; } catch (InterruptedException retry) { timedOut = false; } } } 任务的拒绝任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。 决绝策略在构造方法的时候，就已经讲解了，共四种： ThreadPoolExecutor.AbortPolicy：默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：丢弃新来的任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。 ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务。 线程的管理Worker线程线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。 private final class Worker extends AbstractQueuedSynchronizer implements Runnable{ ... } Worker继承了AbstractQueueSynchronnizer，实现了Runnable接口。 构造方法Worker(Runnable firstTask) { setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); } 通过ThreadFactory方法创建线程，firstTask可为空，为空的时候，也就对应线程去阻塞队列中去获取任务，若是不为空，对应的为直接执行任务。 run方法public void run() { runWorker(this); } Worker线程增加(涉及到线程的复用)Worker线程的增加是通过线程池中的addWorker()方法 上篇private boolean addWorker(Runnable firstTask, boolean core) { // 源码中的上半部分 retry: for (;;) { int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) { // 当前线程的总数 int wc = workerCountOf(c); if (wc &gt;= CAPACITY || // 1.如果core是ture,证明需要创建的线程为核心线程，则先判断当前线程是否大于核心线程 // 如果core是false,证明需要创建的是非核心线程，则先判断当前线程数是否大于总线程数 // 如果不小于，则返回false wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop } } 以上的部分用于判断线程数量是否超出阀值，超过了就返回为false 下篇boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try { // 创建worker对象 w = new Worker(firstTask); // 实例化thread对象 final Thread t = w.thread; if (t != null) { // 全局锁 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) { if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); // 加入到workers set中 workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; } } finally { mainLock.unlock(); } if (workerAdded) { // 启动线程 t.start(); workerStarted = true; } } } finally { if (! workerStarted) addWorkerFailed(w); } return workerStarted; 创建worker对象，并初始化一个Thread对象，然后启动这个线程对象。t.start()方法会调用Worker中的run方法，run方法又使用了runWorker()方法，也就是线程的任务执行 线程的任务执行runWorker()方法final void runWorker(Worker w) { Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); boolean completedAbruptly = true; try { // Worker执行firstTask或从workQueue中获取任务，如果getTask方法不返回null,循环不退出 while (task != null || (task = getTask()) != null) { w.lock(); if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try { beforeExecute(wt, task); Throwable thrown = null; try { // 执行任务 task.run(); } catch (RuntimeException x) { thrown = x; throw x; } catch (Error x) { thrown = x; throw x; } catch (Throwable x) { thrown = x; throw new Error(x); } finally { afterExecute(task, thrown); } } finally { task = null; w.completedTasks++; w.unlock(); } } completedAbruptly = false; } finally { processWorkerExit(w, completedAbruptly); } } 首先去执行创建这个worker时就有的任务，当执行完这个任务后，worker的生命周期并没有结束，在while循环中，worker会不断地调用getTask方法从阻塞队列中获取任务然后调用task.run()执行任务,从而达到复用线程的目的。只要getTask方法不返回null,此线程就不会退出。 常见的线程池Executors类中提供的几个静态方法来创建线程池。通过前面的ThreadPoolExecutor的构造方法，就可以明白这些线程池具体干啥的，很可惜，阻塞队列的具体实现还没有看，而且线程池的demo写的也不多，认识不深刻，所以就暂时先不写。 newCachedThreadPoolpublic static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); } newFixedThreadPoolpublic static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); } newSingleThreadExecutorpublic static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); } newScheduledThreadPoolpublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } //ScheduledThreadPoolExecutor(): public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue()); } Executor框架 ThreadExecutorUML.png References 线程池原理 深入理解线程池 —— Java线程池是如何诞生的 Java线程池实现原理及其在美团业务中的实践","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://winniekun.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"Java线程之间通信方式","slug":"Java进阶/并发/Java线程之间通信方式","date":"2020-04-19T08:49:54.000Z","updated":"2021-04-27T07:42:26.716Z","comments":true,"path":"Java线程之间通信方式/","link":"","permalink":"https://winniekun.github.io/Java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/","excerpt":"线程通信","text":"线程通信 合理的使用Java多线程可以更好地利用服务器资源。一般来讲，线程内部有自己私有的线程上下文，互不干扰。但是当我们需要多个线程之间相互协作的时候，就需要我们掌握Java线程的通信方式。本文将介绍Java线程之间的几种通信原理。 锁同步机制使用synchronized public class lockSyn { static class ThreadA implements Runnable{ @Override public void run() { synchronized (this) { for (int i = 0; i &lt; 10; i++) { System.out.println(\"ThreadA \" + i); } } } } static class ThreadB implements Runnable{ @Override public void run() { synchronized (this) { for (int i = 0; i &lt; 10; i++) { System.out.println(\"ThreadB \" + i); } } } } public static void main(String[] args) throws InterruptedException { new Thread(new ThreadA()).start(); Thread.sleep(1000); new Thread(new ThreadB()).start(); } } 这段程序能够保证先执行线程A，之后再执行线程B。 等待/通知机制使用wait()/notify()机制 public class waitNotify { private static Object lock = new Object(); static class A implements Runnable{ @Override public void run() { synchronized (lock){ for (int i = 0; i &lt; 5; i++) { System.out.println(\"A:\" + i); lock.notify(); try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } lock.notify(); } } } static class B implements Runnable{ @Override public void run() { synchronized (lock){ for (int i = 0; i &lt; 5; i++) { System.out.println(\"B:\" + i); lock.notify(); try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } lock.notify(); } } } public static void main(String[] args) throws InterruptedException { new Thread(new A()).start(); Thread.sleep(1000); new Thread(new B()).start(); } } wait(): 会释放锁。 信号量机制使用volatile定义信号量(涉及JMM—-Java内存模型) public class semaphore { private static volatile int signal = 0; static class ThreadA implements Runnable{ @Override public void run() { while (signal &lt; 10){ if(signal % 2 == 0){ System.out.println(\"ThreadA: \" + signal); signal++; } } } } static class ThreadB implements Runnable{ @Override public void run() { while (signal &lt; 10){ if(signal % 2 == 1){ System.out.println(\"ThreadB: \"+ signal); signal++; } } } } public static void main(String[] args) throws InterruptedException { new Thread(new ThreadA()).start(); Thread.sleep(1000); new Thread(new ThreadB()).start(); } }","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://winniekun.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"TCP/IP通识","slug":"网络/TCP-IP通识","date":"2020-04-17T01:36:34.000Z","updated":"2020-08-30T04:50:22.262Z","comments":true,"path":"TCP-IP通识/","link":"","permalink":"https://winniekun.github.io/TCP-IP%E9%80%9A%E8%AF%86/","excerpt":"OSI参考模型","text":"OSI参考模型 序号 层 常用协议 应用 7 应用层 HTTP、SMTP、SSH 针对特定应用的协议 6 表示层 同上 设备固有数据格式和网路标准格式转化 5 会话层 同上 通信管理。负责建立和断开通信链接 4 传输层 TCP、UDP、UDP-Lite、SCTP、DCCP 管理两个节点之间的数据传输。 3 网络层 IP、ARP、IPv4、IPv6、ICMP 地址管理和路由器选择 2 数据链路层 以太网、无线LAN、PPP… 互联设备之间传送和识别数据帧（将0 、1序列划分为具有意义的数据帧传送给终端） 1 物理层 同上 0 、1数字信号 TCP/IP的具体意义从字面意思上说，TCP/IP指的就是TCP、IP两个协议。虽然有些情况下就是这两个协议，其实不然。在大多数情况下，它是利用IP进行通信时所必须用到的协议群的统称。譬如：IP或ICMP、TCP或UDP、TELNET或FTP、以及 HTTP都属于TCP/IP协议。TCP/IP泛指这些协议。有时也统称TCP/IP为网际协议族。 TCP/IP协议分层模型 序号 层 常用协议 5 应用层 HTTP、SMTP、SSH 4 传输层 TCP、UDP 3 网络层 IP、ICMP、ARP 2 数据链路层 PPP 1 物理层 OSI模型和TCP/IP模型的区别OSI: 注重通信协议必要的功能是什么 TCP/IP: 注重在计算机实上现协议应该开发哪种程序 一些协议之间的区别IP和ICMPIP协议: 能使得整个互联网都能收到数据的协议，使用IP地址作为主机的标识，将数据包发送给目标地址。但是其不具有重发机制，即使发送失败，也不会重发，所以是一种非可靠性传输协议。 ICMP: IP数据包发送途中出现异常而无法发送到目标地址，这时使用ICMP协议给发送者发送一个发送异常的通知 TCP和UDPTCP：面向连接的可靠性传输协议，其为了建立和断开链接，需要至少7次的发包收包（3次握手、4次分手） UDP：面向无连接的不可靠性传输协议，其不会关注目标是否真的接收到了数据包（多媒体领域） References 图解TCP/IP协议","categories":[{"name":"网络","slug":"网络","permalink":"https://winniekun.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"ip","slug":"ip","permalink":"https://winniekun.github.io/tags/ip/"},{"name":"tcp","slug":"tcp","permalink":"https://winniekun.github.io/tags/tcp/"}]},{"title":"矩阵树的定理","slug":"算法/实现-图论/矩阵树的实现","date":"2020-04-10T02:07:19.000Z","updated":"2020-08-30T04:50:22.260Z","comments":true,"path":"矩阵树的实现/","link":"","permalink":"https://winniekun.github.io/%E7%9F%A9%E9%98%B5%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"TODO","text":"TODO 前言矩阵树定理的理解，且代码实现。并且添加了几道实战题目 简介&amp;思路Kirchhoff 矩阵树定理（简称矩阵树定理）解决了一张图的生成树个数计数问题。 无向图设$G$是一个有n个顶点的无向图。定义度数矩阵$D(G)$为： $D{ii}(G) = \\mathrm{deg}(i), D{ij} = 0, i\\neq j$ G的邻接矩阵$A(G)$为： $A{ij}(G) = A{ij}(G)$ 定义 Laplace 矩阵（亦称 Kirchhoff 矩阵）$L$为： $L(G) = D(G) - A(G)$ $G$的所有不同的生成树的个数等于其Laplace矩阵（$L(G)$）的任何一个n-1主子式的绝对值，所谓 n-1 阶主子式,就是对于 r(1≤r≤n),将$G$的第 r 行、第 r 列同时去掉后得到的新矩阵$G_r$ 举例： 无向图$G$如下图所示 则$A(G)$表示为： $\\begin{matrix}0 &amp; 1 &amp; 1 &amp; 0\\\\ 1 &amp; 0 &amp; 1 &amp; 1\\\\ 1 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\\\end{matrix} $ $D(G)$表示为: $\\begin{matrix}2 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 3 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 2 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1\\\\\\end{matrix} $ $L(G)$表示为： $\\begin{matrix}2 &amp; -1 &amp; -1 &amp; 0\\\\ -1 &amp; 3 &amp; -1 &amp; -1\\\\ -1 &amp; -1 &amp; 2 &amp; 0\\\\0&amp;-1&amp;0&amp;1\\\\ \\end{matrix} $ 去除$r$ = 1之后得到主子式$G_r$的绝对值即为该图的生成树个数。 $G_r$ = $\\begin{matrix} 3 &amp; -1 &amp; -1 \\\\-1&amp;2&amp;0\\\\-1&amp;0&amp;1\\\\ \\end{matrix} $ 根据公式计算的 $|G_r|$ = 3 所以该图共有三种生成树。 生成树个数.png 是不是很神奇， 我也觉得很神奇，然后去看了证明，也很神奇😑 有向图同理同理 行列式的变换 交换两行/列位置，行列式取相反数 对一行/列乘以某数，行列式也乘以某数 用一行的倍数减去另一行，行列式的值不变 一个上三角行列式的值等于对角线的乘积 转置矩阵，行列式不变 ACM矩阵行列式计算 实现按照数学公式计算余子式的值的话，复杂度达到$O(N!)*N $ ，所以需要通过行列式的性质，进行基础的变换之后再计算。 题目 「HEOI2015」小 Z 的房间 「FJOI2007」轮状病毒 小Z的房间矩阵树定理的裸题，题目给定的限制为1≤n,m≤9 矩阵维度限制在了个位数，算法有待优化。 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; typedef long long LL; const int N = 100; const LL mod = 1e9; int n, m, ed; LL ans = 1; int h[N][N], vis[N]; LL f[N][N]; char s[N]; int main() { scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { scanf(\"%s\", s); for (int j = 0; j &lt; m; j++) if (s[j] == '.') h[i][j + 1] = 1; //记录下房间的位置 else vis[(i - 1) * m + j + 1] = 1; //重要！！为墙的行一定全为0！！ } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) if (h[i][j]) { //若为房间 ed = 0; //纪录度数矩阵 if (h[i][j - 1]) f[(i - 1) * m + j][(i - 1) * m + j - 1] = -1, ed++; //左 if (h[i][j + 1]) f[(i - 1) * m + j][(i - 1) * m + j + 1] = -1, ed++; //右 if (h[i - 1][j]) f[(i - 1) * m + j][(i - 2) * m + j] = -1, ed++; //上 if (h[i + 1][j]) f[(i - 1) * m + j][i * m + j] = -1, ed++; //下 f[(i - 1) * m + j][(i - 1) * m + j] = ed; //加上度数矩阵 } } n = n * m - 1; //删去最后一行最后一列，并计算行列式的大小 for (int i = 1; i &lt;= n; i++) if (!vis[i]) { //注意！ 非墙的才继续 for (int j = i + 1; j &lt;= n; j++) if (!vis[j]) //同上 while (f[j][i]) { //辗转相除 LL r = f[i][i] / f[j][i]; for (int k = 1; k &lt;= n; k++) f[i][k] = (f[i][k] - f[j][k] * r % mod + mod) % mod, swap(f[i][k], f[j][k]); ans = (mod - ans) % mod; //交换两行，答案取负 } if (f[i][i] == 0) { puts(\"0\"); return 0; } //若主对角线有0，则答案为0 ans = (ans * f[i][i] + mod) % mod; //计算答案 } printf(\"%lld\\n\", ans); } 一下是测试结果 矩阵树定理-小Z的房间.png 轮状病毒总结引用周东老师的结束语吧： 扎实的数学功底是解决问题的保证,创造性地联想是解决问题的灵魂。 References 生成树的计数及其应用 —- 周东","categories":[{"name":"算法","slug":"算法","permalink":"https://winniekun.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://winniekun.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"程序员的魔法---命令行","slug":"操作系统/linux/linux-command-lines","date":"2020-04-10T01:13:07.000Z","updated":"2020-08-30T04:50:22.253Z","comments":true,"path":"linux-command-lines/","link":"","permalink":"https://winniekun.github.io/linux-command-lines/","excerpt":"前言不知不觉已经使用Ubuntu四年了，算是一只老白了。命令行，感觉对于程序员来说，简直和魔法一样，输入一行命令，然后就能得到你想要的结果，极其的amazing。当然，也和魔法一样难以使用，因为要记住很多很多的内容。","text":"前言不知不觉已经使用Ubuntu四年了，算是一只老白了。命令行，感觉对于程序员来说，简直和魔法一样，输入一行命令，然后就能得到你想要的结果，极其的amazing。当然，也和魔法一样难以使用，因为要记住很多很多的内容。 常用操作自言自语 echo 在哪儿 pwd(Print Working Directory) 换个地方 cd (change directory) 瞅瞅 ls ls ls -l 显示当前目录下文件信息 ls -la 列出所有文件，包括以.开头的隐藏文件 ls -lh 做单位换算，将byte换算成K，M，G等. 寻求帮助 man（manual）、 xxx -h xxx —help 文件内容 打印文件内容 cat(concatenate and print files) cat a.txt 头和尾 head、tail head a.txt tail a.txt 交互浏览 less less a.txt 内容查找 / 、grep less | grep xxx (grep -n 显示行数) 单词统计 wc 管道和重定向 重定向: 改变输入输出设备 标准输入/ 输出: 控制台/键盘 / 屏幕 echo hello &gt; hello.txt hello 输入到hello.txt echo world &gt;&gt; hello.txt world 追加输入到hello.txt的下一行 再追加输入下一行仍然使用&gt;&gt; cat &lt; hello.txt 将hello.txt文件输出到控制台 管道: 建一个命令的标准输出作为下一个命令的标准输出 man less | grep sim 查看less的用户手册, 然后匹配出包含sim的行 man less | grep sim - n | grep That &gt; that.txt 查看less的用户手册, 然后匹配出包含sim的行, 之后将又包含that的行存入that.txt 文件权限(chmod)Change Mode改变文件权限, Owner - Group - Others chmod +x foo 增加可执行权限/ +w +r chmod -x foo 移除可执行权限/ -w -r chmod 740 foo 把foo的权限设置成740 Owner: 7 = 1 + 2 + 4 = 可执行 + 可写 +可读 Group: 4 = 4 = 可读 Others: 0 = 没有任何权限 常见: -rw-r—r—r 默认(644) -rwxr-xr-x 755 -rwxrwxrwx 777 文件基本操作 mv(移动文件 重命名 剪切+粘贴) mv 需要移动文件 /指定目录 (移动文件) mv hwllo.txt hello.txt (重命名) cp(复制文件 复制文件夹) cp a.txt a_copy.txt cp -r dir1 dir2 rm(删除文件 删除文件夹) rm a.txt (删除一个文件) rm a.txt b.txt c.txt(删除多个文件 也可使用 rm *.txt) rm -r dir (删除文件夹) yes: 不停输出 进程管理 top: 显示或者更新排序过的进程信息 默认按照CPU占用率排序(导致风扇很响的那个玩意儿) ps: 显示进程状态(Process Status) 默认显示当前用户有控制终端的进程 ps aux : 显示所有进程, 包括其他用户 ps aux | grep idea | wc -l : 查看idea起了多少进程 kill/killall: 杀进程 kill: 终止或者给进程信号 kill -singal_number/-singal_name PID kill PID kill -9/-KILL PID killall: 按照名字终止进程","categories":[{"name":"Linux","slug":"Linux","permalink":"https://winniekun.github.io/categories/Linux/"}],"tags":[{"name":"命令行","slug":"命令行","permalink":"https://winniekun.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"}]},{"title":"JavaIO的前世-BIO阻塞模型","slug":"Java进阶/IO/java-bio","date":"2020-04-08T02:50:53.000Z","updated":"2020-08-30T04:50:22.244Z","comments":true,"path":"java-bio/","link":"","permalink":"https://winniekun.github.io/java-bio/","excerpt":"流","text":"流 基础使用","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"I/O","slug":"I-O","permalink":"https://winniekun.github.io/tags/I-O/"}]},{"title":"JavaIO的今世-NIO","slug":"Java进阶/IO/java-nio","date":"2020-04-07T06:16:56.000Z","updated":"2020-08-30T04:50:22.245Z","comments":true,"path":"java-nio/","link":"","permalink":"https://winniekun.github.io/java-nio/","excerpt":"Java NIO新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。","text":"Java NIO新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。 BIO带来的挑战BIO(blocking-IO) 不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputStream 读取时都有可能会阻塞。一旦有线程阻塞将会失去 CPU 的使用权，这在当前的大规模访问量和有性能要求情况下是不能接受的。虽然当前的网络 I/O 有一些解决办法，如一个客户端一个处理线程，出现阻塞时只是一个线程阻塞而不会影响其它线程工作，还有为了减少系统线程的开销，采用线程池的办法来减少线程创建和回收的成本，但是有一些使用场景仍然是无法解决的。如当前一些需要大量 HTTP 长连接的情况，像淘宝现在使用的 Web 旺旺项目，服务端需要同时保持几百万的 HTTP 连接，但是并不是每时每刻这些连接都在传输数据，这种情况下不可能同时创建这么多线程来保持连接。即使线程的数量不是问题，仍然有一些问题还是无法避免的。如这种情况，我们想给某些客户端更高的服务优先级，很难通过设计线程的优先级来完成，另外一种情况是，我们需要让每个客户端的请求在服务端可能需要访问一些竞争资源，由于这些客户端是在不同线程中，因此需要同步，而往往要实现这些同步操作要远远比用单线程复杂很多。以上这些情况都说明，我们需要另外一种新的 I/O 操作方式。 NIO 简介NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel 、Selector、Buffer 等抽象。 NIO有两种解释：一种叫非阻塞IO（Non-blocking I/O），另一种叫新的IO（New I/O），其实是同一个概念。它是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。(只有Socket Channel 才能配置为非阻塞，而 FileChannel 不能， 为 FileChannel 配置非阻塞也没有意义) NIO是一种基于通道和缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存（区别于JVM的运行时数据区），然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的直接引用进行操作。这样能在一些场景显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 ChannelChannel是对 BIO 中的流的模拟，可以通过它读写数据(真正读写数据的是Buffer)，永远不会出现直接向Channel写入数据或者直接从Channel中读取数据的操作。 通道与流的不同之处在于： 流是单向的 - 一个流只能单纯的负责读或写。 通道是双向的 - 一个通道可以同时用于读写。 因为Channel是双向的，其能更好的反应底层操作系统的真实情况（如操作系统中的通道）。同时Channel包括以下类型(标粗的是常用的类型)： FileChannel：从文件中读写数据； DatagramChannel：通过 UDP 读写网络中数据； SocketChannel：通过 TCP 读写网络中数据； ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。 基本使用 从Channel进行读取数据 首先会创建一个Buffer，Channel将数据读入其中，之后在Bufer中读取数据 public static void read() throws IOException { FileInputStream fileInputStream = new FileInputStream(\"aaa.txt\"); FileChannel inputChannel = fileInputStream.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(1024); inputChannel.read(buffer); // 切换为读模式 buffer.flip(); while (buffer.hasRemaining()){ byte b = buffer.get(); System.out.println(\"Character: \" + (char)b); } buffer.clear(); fileInputStream.close(); } 向Channel写入数据 创建Buffer，填充数据。之后Channel去写出数据 public static void write() throws IOException { FileOutputStream fileOutputStream = new FileOutputStream(\"bbb.txt\"); FileChannel outChannel = fileOutputStream.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(1024); byte[] msg = \"hello i'm wkk\".getBytes(); buffer.put(msg); buffer.flip(); outChannel.write(buffer); fileOutputStream.close(); } Buffer A buffer is a linear, finite sequence of elements of a specific * primitive type. Aside from its content, the essential properties of a * buffer are its capacity, limit, and position: --- 摘自Buffer源码 Buffer本身就是一块内存，底层实现上，实际是一个数组。数据的读写均是通过Buffer实现。 public class NioBase { public static void main(String[] args) { // 初始化一个Buffer IntBuffer buffer = IntBuffer.allocate(1024); // 向Buffer中随机写入10个数字 for (int i = 0; i &lt; 10; i++) { int randomNumber = new SecureRandom().nextInt(20); buffer.put(randomNumber); } // 切换为读模式 buffer.flip(); while (buffer.hasRemaining()){ System.out.print(buffer.get() + \" \"); } } } Capacity、Position、Limit * &lt;p&gt; A buffer's &lt;i&gt;capacity&lt;/i&gt; is the number of elements it contains. The * capacity of a buffer is never negative and never changes. &lt;/p&gt; * * &lt;p&gt; A buffer's &lt;i&gt;limit&lt;/i&gt; is the index of the first element that should * not be read or written. A buffer's limit is never negative and is never * greater than its capacity. &lt;/p&gt; * * &lt;p&gt; A buffer's &lt;i&gt;position&lt;/i&gt; is the index of the next element to be * read or written. A buffer's position is never negative and is never * greater than its limit. &lt;/p&gt; 在NIO中，真正和数据打交道的是Buffer。可以将Buffer简单的理解为一组基本数据类型的元素列表，其通过以下的基本变量来保存这个数据的当前位置状态，共有四个索引（mark用于记录以下三个索引，所以没有记录）。 索引 说明 capacity 缓冲数组的总长度 position 下一个要操作的数据元素的位置 limit 缓冲区数组不可操作的下一个元素的位置， limit&lt;=capacity image demopublic static void main(String[] args) { // 创建缓冲区 ByteBuffer buffer = ByteBuffer.allocate(1024); //buffer中四个变量的值 System.out.println(\"初始时----&gt;limit----&gt;\" + buffer.limit()); System.out.println(\"初始时----&gt;capacity----&gt;\" + buffer.capacity()); System.out.println(\"初始时----&gt;position----&gt;\" + buffer.position()); System.out.println(\"初始时----&gt;mark----&gt;\" + buffer.mark()); System.out.println(\"--------------------------------\"); //初始时----&gt;limit----&gt;1024 //初始时----&gt;capacity----&gt;1024 //初始时----&gt;position----&gt;0 //初始时----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=0 lim=1024 cap=1024] String s = \"abcd\"; buffer.put(s.getBytes()); //buffer添加数据之后，四个变量的值 System.out.println(\"put完之后----&gt;limit----&gt;\" + buffer.limit()); System.out.println(\"put完之后----&gt;capacity----&gt;\" + buffer.capacity()); System.out.println(\"put完之后----&gt;position----&gt;\" + buffer.position()); System.out.println(\"put完之后----&gt;mark----&gt;\" + buffer.mark()); //put完之后----&gt;limit----&gt;1024 //put完之后----&gt;capacity----&gt;1024 //put完之后----&gt;position----&gt;4 //put完之后----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=4 lim=1024 cap=1024] buffer.flip(); System.out.println(\"-------------------------------------------\"); System.out.println(\"flip()之后----&gt;limit----&gt;\" + buffer.limit()); System.out.println(\"flip()之后----&gt;capacity----&gt;\" + buffer.capacity()); System.out.println(\"flip()之后----&gt;position----&gt;\" + buffer.position()); System.out.println(\"flip()之后----&gt;mark----&gt;\" + buffer.mark()); byte[] bytes = new byte[buffer.limit()]; buffer.get(bytes); System.out.println(new String(bytes, 0, bytes.length)); //flip()之后----&gt;limit----&gt;4 //flip()之后----&gt;capacity----&gt;1024 //flip()之后----&gt;position----&gt;0 //flip()之后----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=0 lim=4 cap=1024] //abc System.out.println(\"-------------------------------------------\"); System.out.println(\"读完之后----&gt;limit----&gt;\" + buffer.limit()); System.out.println(\"读完之后----&gt;capacity----&gt;\" + buffer.capacity()); System.out.println(\"读完之后----&gt;position----&gt;\" + buffer.position()); System.out.println(\"读完之后----&gt;mark----&gt;\" + buffer.mark()); //读完之后----&gt;limit----&gt;4 //读完之后----&gt;capacity----&gt;1024 //读完之后----&gt;position----&gt;3 //读完之后----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=3 lim=4 cap=1024] System.out.println(\"----------------清空缓冲区-------------\"); buffer.clear(); System.out.println(\"清空之后----&gt;limit----&gt;\" + buffer.limit()); System.out.println(\"清空之后----&gt;capacity----&gt;\" + buffer.capacity()); System.out.println(\"清空之后----&gt;position----&gt;\" + buffer.position()); System.out.println(\"清空之后----&gt;mark----&gt;\" + buffer.mark()); //清空之后----&gt;limit----&gt;1024 //清空之后----&gt;capacity----&gt;1024 //清空之后----&gt;position----&gt;0 //清空之后----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=0 lim=1024 cap=1024] } 关于这三种索引的实际关系，以及flip() clear()在下述Buffer的读写中会详细阐述 Buffer 类型Buffer实现了java的所有的基础数据类型 ByteBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer CharBuffer MappedByteBuffer 使用Buffer对象之前需要先进行分配，每个类型的Buffer类都可以使用静态方法allocate（）分配该Buffer的容量大小 读和写向Buffer中写入数据：有两种方式： 通过channel.read(buffer)写入数据 RandomAccessFile file = new RandomAccessFile(\"../../Downloads/aaa.txt\", \"rw\"); FileChannel inChannel = file.getChannel(); // 创建缓冲区 ByteBuffer buffer = ByteBuffer.allocate(1024); // 从channel中写入数据 int read = inChannel.read(buffer); 直接通过buffer.put()写入数据 // 创建缓冲区 ByteBuffer buffer = ByteBuffer.allocate(18); String s = \"abcd\"; buffer.put(s.getBytes()); flip()方法 使用该方法之后，position索引会指向0，limit索引会指向缓冲区数组不可操作的下一个元素的位置（也可表示为当前缓冲数组可读元素的长度） flip__方法索引变化.png 所以，flip()方法也可以理解为切换读模式，输入一定的元素之后，感觉需要读出数据，使用flip()方法，切换为读的模式。 从Buffer中读出数据同理，也有两种方式从Buffer中读出数据 channel.write(buffer) buffer.get() clear()方法，操作数据的索引重归初始状态，类似于数据被清空，可以理解为切换写模式 Selector用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。即用选择器，借助单一线程，就可对数量庞大的活动I/O通道实施监控和维护。其和单片机中的事件轮询是一个道理,可惜本科上单片机的时候,并没有好好听(对不起小邹邹) NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。 NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式 去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。 通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时， 就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。 因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件， 对于 IO 密集型的应用具有很好地性能。 应该注意的是，只有Socket的Channel 才能配置为非阻塞，而 FileChannel 不能， 为 FileChannel 配置非阻塞也没有意义。 使用Selector的优点: 使用更少的线程来处理任务, 相比更多的线程,避免了线程上下文的切换开销 可以将上图做更细致的绘制: NIO模型的服务器端如何实现非阻塞？服务器上所有Channel需要向Selector注册，而Selector则负责监视这些Channel的IO状态(观察者)，当其中任意一个或者多个Channel具有可用的IO操作时，该Selector的select()方法将会返回大于0的整数(表示该Selector上有多少个Channel具有可用的IO操作)，并提供了selectedKeys()方法来返回这些Channel对应的SelectionKey集合(一个SelectionKey对应一个就绪的通道)。正是通过Selector，使得服务器端只需要不断地调用Selector实例的select()，即可知道当前所有Channel是否有需要处理的IO操作。 步骤创建选择器Selector selector = Selector.open(); 绑定端口,通道注册到选择器// 绑定端口 ServerSocketChannel server = ServerSocketChannel.open(); server.configureBlocking(false); // 设置为非阻塞 ServerSocket socket = server.socket(); socket.bind(new InetSocketAddress(port)); // 将通道注册到该线程的选择器 server.register(selector, SelectionKey.OP_ACCEPT); 通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。 在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类： SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE 监听事件selector.select(); 使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。 获取可达事件// 可达事件 Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; iterator = selectionKeys.interator(); while(iterator.hasnext()){ SelectionKey key = iterator.next(); if(key.isAcceptable()){ // ... }else if(key.isReadable()){ //... } // remove已经处理的事件 iterator.remove(); } 事件循环因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。 while(true){ // 监听事件 selector.select(); // 获取可达事件 Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; iterator = selectionKeys.interator(); while(iterator.hasnext()){ SelectionKey key = iterator.next(); if(key.isAcceptable()){ // ... }else if(key.isReadable()){ //... } // remove已经处理的事件 iterator.remove(); } } 整合public void start(){ // 1. 创建选择器 Selector selector = Selector.open(); // 2. 绑定端口 通道注册到选择器 ServerSocketChannel serverChannel = ServerSocketChannel.open(); serverChannel.configureBlocking(false); ServerSocket socket = serverChannel.socket(); socket.bind(new InetSocketAddress(port)); // 通道注册到selector上 serverChannel.register(selector, SelectionKey.OP_ACCEPT); // 事件轮询 while(true){ // 3 监听事件 selector.select(); // 4 获取可达事件 Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator(); while(iterator.hasNext()){ SelectionKey key = itrator.next(); if (key.isAcceptable()) { ServerSocketChannel server = (ServerSocketChannel) key.channel(); // 服务器会为每个新连接创建一个 SocketChannel SocketChannel client = server.accept(); client.configureBlocking(false); // 这个新连接的channel主要用于从客户端读取数据 client.register(selector, SelectionKey.OP_READ); }else if(key.isReadable()){ SocketChannel client = (SocketChannel)key.channel(); // 数据的处理 ByteBuffer buffer = ByteBuffer.allocate(1024); buffer.clear(); while (channel.read(buffer) &gt; 0); buffer.flip(); channel.write(buffer); } iterator.remove(); } } } 应用创建一个简单的服务端 public static void main(String[] args) throws IOException { // 服务端监听5个端口 int[] ports = new int[5]; int base = 9000; for (int i = 0; i &lt; 5; i++) { ports[i] = base++; } // 创建选择器 Selector selector = Selector.open(); // 绑定端口 通道注册到选择器 for (int port : ports) { ServerSocketChannel server = ServerSocketChannel.open(); server.configureBlocking(false); ServerSocket socket = server.socket(); socket.bind(new InetSocketAddress(port)); server.register(selector, SelectionKey.OP_ACCEPT); System.out.println(\"监听端口: \" + port); } // 事件轮询 while (true) { // 监听事件 int num = selector.select(); System.out.println(\"numbers: \" + num); // 获取可达事件 Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); System.out.println(\"可达事件集有: \" + selectionKeys.size()); for (SelectionKey selectionKey : selectionKeys) { System.out.println(\"可达事件集类型有: \" + selectionKey); } // 事件处理 Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator(); while (iterator.hasNext()) { SelectionKey key = iterator.next(); if (key.isAcceptable()) { ServerSocketChannel server = (ServerSocketChannel) key.channel(); SocketChannel client = server.accept(); client.configureBlocking(false); client.register(selector, SelectionKey.OP_READ); System.out.println(\"获得客户端的链接\" + client); } else if (key.isReadable()) { SocketChannel channel = (SocketChannel) key.channel(); ByteBuffer buffer = ByteBuffer.allocate(1024); buffer.clear(); while (channel.read(buffer) &gt; 0); buffer.flip(); channel.write(buffer); System.out.println(\"读取: \" + buffer + \", 来自于\" + channel); } // 记得remove iterator.remove(); } } } References Java NIO IBM NIO 入门","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"I/O","slug":"I-O","permalink":"https://winniekun.github.io/tags/I-O/"}]},{"title":"堆排序","slug":"算法/排序/堆排序","date":"2020-04-03T13:35:01.000Z","updated":"2020-08-30T04:50:22.261Z","comments":true,"path":"堆排序/","link":"","permalink":"https://winniekun.github.io/%E5%A0%86%E6%8E%92%E5%BA%8F/","excerpt":"堆排序","text":"堆排序 堆排序在 top K 问题中使用比较频繁，并且经常被用来实现优先级队列。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 。 堆的定义如下： $L(i) \\leq L(2i)$ 且 $L(i) \\leq L(2i+1)$ (小根堆) $L(i) \\geq L(2i)$且 $L(i) \\geq L(2i+1)$ （大根堆） 大根堆示意图.png 堆排序的关键是构造初始堆，对初始序列建堆，就是一个反复筛选的过程，因为是近似于完全二叉树，所以从第$\\lfloor n/2 \\rfloor$为根的子树开始调整（对于大根堆，根节点的关键字和其左右子女中关键字相比较大的进行交换）之后依次对各个节点$\\lfloor n/2 \\rfloor -1 ～ 1$为根的子树进行筛选。 实例对关键字序列：53、17、 78、 9、 45、 65、 87 、32 构建大根堆 大根堆的构建.png 插入插入是从尾部插入(当前堆有n个元素，在第n+1位置中插入)，然后调整 删除删除是从根节点开始删除，删除之后再进行调整 Java代码实现public void buildMaxHeap(int[] nums) { int length = (nums.length - 1) / 2; // 从n/2开始构建初始堆 for (int i = length; i &gt;= 0; i--) { adjustDown(nums, i, nums.length-1); } } private void adjustDown(int[] nums, int k, int len) { nums[0] = nums[k]; // 以第k个节点为根的子树进行调整 for (int i = 2 * k; i &lt;= len; i *= 2) { // 寻找子树中的最值 if(i &lt; len &amp;&amp; nums[i] &lt; nums[i+1]){ i ++; } if(nums[0] &gt;= nums[i]){ break; } else { nums[k] = nums[i]; k = i; } } nums[k] = nums[0]; }","categories":[{"name":"排序","slug":"排序","permalink":"https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"选择","slug":"选择","permalink":"https://winniekun.github.io/tags/%E9%80%89%E6%8B%A9/"}]},{"title":"AVL树详解","slug":"数据结构/AVL树详解","date":"2020-03-28T02:23:42.000Z","updated":"2020-08-30T04:50:22.253Z","comments":true,"path":"AVL树详解/","link":"","permalink":"https://winniekun.github.io/AVL%E6%A0%91%E8%AF%A6%E8%A7%A3/","excerpt":"简介","text":"简介 AVL树的引入是因为BST在极端的情况下，会退化为链表，那么查找的时间从$O(logN)$ —-&gt; $O(N)$ AVL树是一种自平衡的二叉树，定义如下 BST 左、右子树高度差的绝对值不超过1(平衡因子Balance Factor)空树、左右子树都是AVL AVL树.png 插入&amp;旋转三节点单旋转左旋 AVL_左旋.png 右旋 AVL_右旋.png 三节点双旋转LR旋转 AVL_LR.png RL旋转同理 什么时候需要旋转插入关键字key后，节点p的平衡因子由原来的1或者-1，变成了2或者-2，则需要旋转；只考虑插入key到左子树left的情形，即平衡因子为2 情况1：key&lt;left.key, 即插入到left的左子树，需要进行单旋转，将节点p右旋 情况2：key&gt;left.key, 即插入到left的右子树，需要进行双旋转，先将left左旋，再将p右旋 插入到右子树right、平衡因子为-2，完全对称 情况1 AVL_插入_情况1.png 情况2 AVL_插入_情况2_1.png 删除类似插入，假设删除了p右子树的某个节点，引起了p的平衡因子d[p]=2，分析p的左子树left，三种情况如下： 情况1：left的平衡因子d[left]=1，将p右旋 情况2：left的平衡因子d[left]=0，将p右旋 情况3：left的平衡因子d[left]= -1，先左旋left，再右旋p 删除左子树，即d[p]= -2的情形，与d[p]=2对称 情况1 AVL_删除_情况1.png 情况2 AVL_删除_情况2.png 情况3 AVL_删除_情况3.png 面试排序数组（链表）转AVL108. Convert Sorted Array to Binary Search Tree109. Convert Sorted List to Binary Search Tree判断是否为平衡二叉树LeetCode 110. Balanced Binary Tree相关题目会持续添加 References TreeMapSourceAnalysis","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://winniekun.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"AVL树","slug":"AVL树","permalink":"https://winniekun.github.io/tags/AVL%E6%A0%91/"}]},{"title":"2020Flag集","slug":"碎碎念/2020Flag集","date":"2020-03-24T01:58:39.000Z","updated":"2021-05-08T15:45:33.268Z","comments":true,"path":"2020Flag集/","link":"","permalink":"https://winniekun.github.io/2020Flag%E9%9B%86/","excerpt":"前言最近刷题刷的特别丧，被LeetCode虐的体无完肤，然后又在不停地感慨，握草，这是人想出来的解法。瞬间感觉自己太low了。需要打点鸡血！！！","text":"前言最近刷题刷的特别丧，被LeetCode虐的体无完肤，然后又在不停地感慨，握草，这是人想出来的解法。瞬间感觉自己太low了。需要打点鸡血！！！ Flag们第一次flags🎏 LeetCode400题 ❌ 虽然已经进入千题时代，个人觉得把前400题刷完就已经很胖胖了 5月之前完成（平均下来，每天还要刷7-8题。。。。） 这个flag会不会插的太深了， 后面拔不掉！！！ LeetCode精刷250题 😕 Cspiration上看到的，不管其他的，但刷题，我觉得很棒 剑指offer 一刷 3月底刷完 第二次flags🎏 LeetCode400题 ✔ 实习期间刷题太累了，有点儿怀疑刷题的目的在哪儿了，并没有感觉到自己的编码能力有多少提高 现在只求不要成为斐波那契猿就很开心了 11月20号 LeetCode500题❌ 不想刷了，感觉太功利了，而且越刷感觉越效果不好 总是陷入自己熟练的内容。。。 第三次flags🎏 年前突破500大关❌","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"flag","slug":"flag","permalink":"https://winniekun.github.io/tags/flag/"}]},{"title":"图论-搜索策略","slug":"算法/实现-图论/图论-搜索策略","date":"2020-03-20T03:22:56.000Z","updated":"2020-08-30T04:50:22.260Z","comments":true,"path":"图论-搜索策略/","link":"","permalink":"https://winniekun.github.io/%E5%9B%BE%E8%AE%BA-%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5/","excerpt":"前言","text":"前言 以下算法的是实现，BFS、DFS是基于图的邻接表存储方式实现的， A*基于图的邻接矩阵存储 BFSBFS，广度优先遍历，其遍历的形式可以理解为树的层次遍历，直到找到对应的节点，然后停止。所以，可以通过一个队列来实现该算法。 图论-bfs.png package com.wkk.utils; import com.wkk.graph.LGraph; import org.omg.CORBA.INTERNAL; import java.util.LinkedList; import java.util.Queue; import java.util.Stack; /** * @Time: 20-3-20下午3:16 * @Author: kongwiki * @Email: kongwiki@163.com */ public class BFS { // 图使用邻接表进行存储 private boolean[] marked; private int[] edgeTo; private final int s; public BFS(LGraph graph, int s) { marked = new boolean[graph.V()]; edgeTo = new int[graph.V()]; this.s = s; bfs(graph, s); } private void bfs(LGraph graph, int s) { Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); queue.offer(s); marked[s] = true; while (!queue.isEmpty()){ Integer v = queue.poll(); for (Integer element : graph.adj(v)) { if(!marked[element]){ edgeTo[element] = v; marked[element] = true; queue.offer(element); } } } } // 判断是否存在路径 s ---&gt; v public boolean hasPathTo(int v){ return marked[v]; } // 存储s---&gt;v的路径 public Stack&lt;Integer&gt; pathTo(int v){ if (!hasPathTo(v)) {return null;} Stack&lt;Integer&gt; path = new Stack&lt;Integer&gt;(); for (int x = v; x != s; x = edgeTo[x]) { path.push(x); } path.push(s); return path; } } 总结BFS算法能够找到 s —-&gt; v路径中的最优解 DFS关于dfs， 其应用范围很广，譬如可以解决排列组合问题等等等。首先，会从开始节点朝某一个方向进发，直到遇到边界或者障碍物，才回溯。dfs算法需要一个栈进行从存储所扫描路径上的所有节点，递归其本身也是一个栈的使用， 所以完全可以使用递归实现DFS算法。 图论-dfs.png public class DFS { private boolean[] marked; private int count; public DFS(LGraph graph, int v){ marked = new boolean[graph.V()]; dfs(graph, v); } public void dfs(LGraph graph, int v){ marked[v] = true; count++; for (Integer w : graph.adj(v)) { if(!marked[w]){ dfs(graph, w); } } } public boolean marked(int w){ return marked[w]; } public int count(){ return count; } } 总结DFS算法存在问题有： 路径不可能是最优解 寻路时间比较长 A*官方定义A*搜索算法（A* search algorithm）是一种在图形平面上，有多个节点的路径，求出最低通过成本的算法。其应用非常的广，主要分为两大应用，第一就是游戏中的NPC的移动计算，第二就是地图导航的应用。简而言之，其就是一种寻路算法。 该算法综合了最良优先搜索和Dijkstra算法的优点：在进行启发式搜索提高算法效率的同时，可以保证找到一条最优路径（基于评估函数）。 Astar_progress_animation.gif A*算法的评估函数，其中$ g(n) $表示从起点到任意顶点n的实际距离，$h(n)$ 表示任意顶点$ n$ 到起点的估算距离。 $ f(n) = g(n) + h(n) $ 这个公式遵循以下特性： 如果$g(n)$为0，即只计算任意顶点$n$到目标的评估函数$h(n)$而不计算起点到顶点$n$的距离，则算法转化为使用贪心策略的最良优先搜索，速度最快，但可能得不出最优解； 如果$h(n)$不大于顶点$n$到目标顶点)的实际距离，则一定可以求出最优解，而且$h(n)$越小，需要计算的节点越多，算法效率越低，常见的评估函数有——欧几里得距离、曼哈顿距离、切比雪夫距离； 如果$ h(n) $为0，即只需求出起点到任意顶点的$ n $最短路径$ g(n) $，而不计算任何评估函数$ h(n) $，则转化为单源最短路径问题，即Dijkstra算法，此时需要计算最多的顶点； 以上的摘自维基百科，一些名词可能有些抽象，现做举例说明； 实例讲解 图论-A* 对于上图，从顶点s出发，均走了两步，分别到达了M1和M2，接下来应该选择哪条路线到达终点E，很明显，选择M1这条路， 因为从M1出发，到E的距离终于7步，比从M2出发到E的距离9步，要少。 回想刚才的思路，发现，我们不仅思考了从起始点到当前点的距离， 还考虑了当前点到终点的距离。这就是A*算法的核心。其相比于BFS算法，除了考虑中间某个点到出发点的距离以外，还考虑了这个点同目标点的距离。这就是A*算法比广度优先算法智能的地方。也就是所谓的启发式搜索。实例中的s 到M1的距离就是g(n), M1到E的距离就是h(n) 对于上述的公式， g(n)是已知的，但是h(n)是需要进行计算的。 对于h(n)的精确计算，可以按照刚才实例的方式，使用横向距离+纵向距离的方式进行计算（曼哈顿距离），理论上来说是可行的，但是遇到如下的问题，那么使用刚才的方式计算h(n)的精确值就是错误的了 图论-A-star1.png 因为有障碍物，M到E的就需要绕过这个障碍物。但是，我们完全没有必要计算h(n)的精确的值，只需要尽可能找那些f(n)=g(n)+h(n)小的点（其中h(n)是个估算值），当做我们的路径经过点，即使实际的h'(n)值可能和h(n)值不等也没关系，我们就当做一个参考（总比广度优先搜索好）。如果通过这个估算，能干掉很多明显很差的点，我们也就节省了很多不必要的花销。 比如，上图中， M点即使是绕路，也比M'点要强。在估算的时候，我们就可以将S左边的点基本上都抛弃掉，从而减少我们扩展的点数，节约计算的时间。 经过上述的分析，接下来就只需要解决如下的两个问题： 这个估算的函数h(M)怎么样去计算？ 曼哈顿距离 欧式距离 切比雪夫距离 … 对于不同的估算函数h(M)来讲，对于我们的搜索结果会有什么样的影响？ h'(n) = h(n) 也就是每次扩展的那个点我们都准确的知道，如果选他以后，我们的路径距离是多少，这样我们就不用乱选了，每次都选最小的那个，一路下去，肯定就是最优的解，而且基本不用扩展其他的点 h'(n) &lt; h(n) 我们到最后一定能找到一条最短路径(如果存在另外一条更短的评估路径，就会选择更小的那个)，但是有可能会经过很多无效的点。极端情况，当h==0的时候，最终的距离函数就变成： f(n)=g(n)+h(n) =&gt; f(n)=g(n)+0 =&gt; f(n)=g(n) 这也就是BFS算法。 h'(n) &gt; h(n) 有可能就很快找到一条通往目的地的路径，但是却不一定是最优的解。 总结A*算法最后留给我们的，就是在时间和距离上需要考虑的一个平衡。如果要求最短距离，则一定选择h小于等于实际距离；如果不一定求解最优解，而是要速度快，则可以选择h大于等于实际距离。 实现思路思路(如果有路径)采用结点与结点的父节点（前一个节点） 的关系从最终结点回溯到起点，得到路径。 定义$ f(n) = g(n) + h(n) $的实现 $g(n)$的实现方式： 计算方式有挺多种的，这里我们就用这种吧，假设每个结点代表一个正方形，横竖移动距离：斜移动距离=1 : 1.4（$\\sqrt(2)$），我们取个整数10和14吧，也就是说当前结点G值=父节点的G+（10或14）。 $ h(n)$的实现方式： 曼哈顿距离 图论-A-star实例.jpeg 每个方块代表一个节点， 方块中左下角为g(n) 方块中右下角为h(n) 方块中左上角为f(n) 辅助表：Open、Close列表在A算法中，需要使用两个辅助表来记录结点。 一个用于记录可被访问的结点，称为Open表；一个是记录已访问过的结点，称为Close表。 *这两个表决定了算法的结束：条件是最终结点在Close表中(找到路径)或Open表为空(找不到了路径)。 移动结点、相邻结点的处理每次从Open表中取出F值最小的结点出来（这里我们使用优先队列来处理比较好），作为当前结点；然后将当前结点的所有邻结点按照邻结点规则加入到Open表中；最后将当前结点放入Close表中，这里就是每次循环的执行内容。 邻结点规则： 当邻结点不在地图中，不加入Open表 当邻结点是障碍物，不加入Open表 当邻结点在Close表中，不加入Open表 当邻结点不在Open中，加入Open表，设该邻结点的父节点为当前结点 当邻结点在Open表中，我们需要做个比较:如果邻结点的G值&gt;当前结点的G值+当前结点到这个邻结点的代价（10或14），那么修改该邻结点的父节点为当前的结点(因为在Open表中的结点除了起点，都会有父节点)，修改G值=当前结点的G值+当前结点到这个邻结点的代价 如果邻结点的G值&lt;当前结点的G值+当前结点到这个邻结点的代价（10或14）, 如果没有一条路径可以通过使用当前格子得到改善，所以我们不做任何改变。 步骤 把起始格添加到开启列表。 重复如下的工作： a) 寻找开启列表中F值最低的格子。我们称它为当前格。 b) 把它切换到关闭列表。 c) 对相邻的8格中的每一个？ 如果它不可通过或者已经在关闭列表中，略过它。反之如下。 如果它不在开启列表中，把它添加进去。把当前格作为这一格的父节点。记录这一格的F,G,和H值。 如果它已经在开启列表中，用G值为参考检查新的路径是否更好。更低的G值意味着更好的路径。如果是这样，就把这一格的父节点改成当前格，并且重新计算这一格的G和F值。如果你保持你的开启列表按F值排序，改变之后你可能需要重新对开启列表排序。 d) 停止，当你 把目标格添加进了开启列表，这时候路径被找到，或者 没有找到目标格，开启列表已经空了。这时候，路径不存在。 保存路径。从目标格开始，沿着每一格的父节点移动直到回到起始格。这就是你的路径。 实现代码输入涉及数据结构： 代表地图二值二维数组(0表示可通路，1表示路障) int[][] maps = { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 }, { 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, }; 坐标类 public class Coord { /** * 坐标原点在左上角 所以y是高 x是宽 * y向下递增 x向右递增 * 将x和y封装成一个类 方便传参 * 重写equals方法比较坐标(x,y)是不是同一个。 */ public int x; public int y; public Coord(int x, int y) { this.x = x; this.y = y; } @Override public boolean equals(Object obj) { if (obj == null) { return false; } if (obj instanceof Coord) { Coord c = (Coord) obj; return x == c.x &amp;&amp; y == c.y; } return false; } } Node类 public class Node implements Comparable&lt;Node&gt; { // 坐标 public Coord coord; // 父结点 public Node parent; // G：是个准确的值，是起点到当前结点的代价 public int G; // H：是个估值，当前结点到目的结点的估计代价 public int H; public Node(int x, int y) { this.coord = new Coord(x, y); } public Node(Coord coord, Node parent, int g, int h) { this.coord = coord; this.parent = parent; G = g; H = h; } // 方便优先队列排序。 public int compareTo(Node o) { if (o == null) { return -1; } if (G + H &gt; o.G + o.H) { return 1; } else if (G + H &lt; o.G + o.H) { return -1; } return 0; } } A*算法输入的数据结构的封装 package com.wkk.a; /** * @Time: 20-3-21上午12:35 * @Author: kongwiki * @Email: kongwiki@163.com */ public class MapInfo { // 二维数组的地图 public int[][] maps; //地图的宽 public int width; // 地图的高 public int hight; // 起始结点 public Node start; // 最终结点 public Node end; public MapInfo(int[][] maps, int width, int hight, Node start, Node end) { this.maps = maps; this.width = width; this.hight = hight; this.start = start; this.end = end; } } 处理: 几个常量：二维数组中哪个值表示障碍物、二维数组中绘制路径的代表值、计算G值需要的横纵移动代价和斜移动代价。 // 障碍值 public final static int BAR = 1; // 路径 public final static int PATH = 2; // 横竖移动代价 public final static int DIRECT_VALUE = 10; // 斜移动代价 public final static int OBLIQUE_VALUE = 14; 定义两个辅助表：Open表和Close表。Open表的使用是需要取最小值，使用优先队列PriorityQueue，Close只是用来保存结点，没其他特殊用途，就用ArrayList。 // 优先队列(升序) Queue&lt;Node&gt; openList = new PriorityQueue&lt;Node&gt;() List&lt;Node&gt; closeList = new ArrayList&lt;Node&gt;(); 定义几个布尔判断方法：最终结点的判断、结点能否加入open表的判断、结点是否在Close表中的判断。 /** * 判断结点是否是最终结点 */ private boolean isEndNode(Coord end, Coord coord) { return coord != null &amp;&amp; end.equals(coord); } /** * 判断结点能否放入Open列表 */ private boolean canAddNodeToOpen(MapInfo mapInfo, int x, int y) { // 是否在地图中 if (x &lt; 0 || x &gt;= mapInfo.width || y &lt; 0 || y &gt;= mapInfo.hight) { return false; } // 判断是否是不可通过的结点 if (mapInfo.maps[y][x] == BAR) { return false; } // 判断结点是否存在close表 if (isCoordInClose(x, y)) { return false; } return true; } /** * 判断坐标是否在close表中 */ private boolean isCoordInClose(Coord coord) { return coord != null &amp;&amp; isCoordInClose(coord.x, coord.y); } /** * 判断坐标是否在close表中 */ private boolean isCoordInClose(int x, int y) { if (closeList.isEmpty()) { return false; } for (Node node : closeList) { if (node.coord.x == x &amp;&amp; node.coord.y == y) { return true; } } return false; } 回溯绘制路径 /** * 在二维数组中绘制路径 */ private void drawPath(int[][] maps, Node end) { if (end == null || maps == null) { return; } System.out.println(\"总代价：\" + end.G); while (end != null) { Coord c = end.coord; maps[c.y][c.x] = PATH; end = end.parent; } } 运行结果自定义Graph int[][] maps = { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 }, { 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, }; 开始节点为：（1,1） 结束节点为： （9， 5） 输出结果： 总代价：176 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2 2 2 2 2 2 2 2 0 0 0 0 1 1 0 0 0 0 0 0 1 1 1 2 0 0 0 0 1 0 0 0 0 0 1 1 2 2 0 0 0 0 0 1 1 1 1 1 1 1 2 0 0 0 0 0 0 0 1 0 0 1 0 0 2 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 待优化int类型 —-&gt; 泛型 异常数据处理 References 算法第四版 A*搜索算法 路径规划之 A* 算法 寻路 A* Pathfinding 那个传说中的算法——A*算法 GraphTree","categories":[{"name":"算法","slug":"算法","permalink":"https://winniekun.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://winniekun.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"HashMap源码解读","slug":"源码/JDK/map/hashmap-analysis","date":"2020-03-12T13:02:49.000Z","updated":"2021-03-29T23:16:05.822Z","comments":true,"path":"hashmap-analysis/","link":"","permalink":"https://winniekun.github.io/hashmap-analysis/","excerpt":"HashMap 源码解读","text":"HashMap 源码解读 前言 hash HashMap相较于之前的ArrayList和LinkedList，其理解上还是稍微有一些难度，其底层的实现是散列表, 散列表对于哈希冲突的解决方式有如下两种(开放寻址法, 链表法)： 开放寻址法以下为一些常用的开放寻址法。 有线性探测法hash(key)+0、hash(key)+1、hash(key)+2… 二次探测（平方探测法）hash(key)+0, hash(key)+1^2, hash(key)+2^2….. 双重散列第一次根据hash()函数计算得到的存储位置已经被占用，再用第二个hash()函数计算 链表法对于不同的关键字可能会通过散列函数映射到同一个地址。为了避免发生分歧，将同样的哈希结果，但是不同关键字的元素，可以将它们存储在一个线性链表中。 HashMap中的解决哈希冲突的方式就是链表法 概述HashMap主要用来存放键值对, 其基于哈希表的Map接口实现, 是常用的Java集合之一.JDK1.8之前HashMap由数组+链表组成, 其使用的是数组进行存储, 之后使用链接法解决哈希冲突. JDK1.8之后HashMap在解决哈希冲突时, 与之前不同的是, 当链表长度大于阈值(默认是8), 将链表转化为红黑树, 避免过长的链表从而降低性能(过长的话, 就相当于使用的是链表存储的了,每次的查找都会导致O(n)的时间), 同时转化为红黑树的时候也会进行判断（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间 HashMap的源码中，充斥个各种位运算代替常规运算的地方，以提升效率： 与运算替代模运算。用 hash &amp; (table.length-1) 替代 hash % (table.length) 用if ((e.hash &amp; oldCap) == 0)判断扩容后，节点e处于低区还是高区。 形象理解: HashMap的底层为数组, 可以将其称之为哈希桶 每个桶里放的是链表. 其是线程不安全的允许key为null, value为null遍历时无序. HashMap 依赖 HashMap依赖 实现了Serializable接口 实现了Cloneable接口 实现了Map接口，并继承了AbstractMap类 阅读套路按照正常的逻辑， 首先基础的数据构造, 然后了解其构造方法， 之后了解常用的API(CRUD)操作即可。 [x] 增 [x] 删 [x] 改 [x] 查 从节点的构造开始HashMap整体的构造 HashMap存储结构 在添加元素的时候, 会先根据hash值计算出其应在的位置, 若是没有冲突, 则直接放入, 若是有冲突, 则将该元素以俩表的形式插入到链表尾部 若是链表的长度超过阀值(默认是8), 则将链表转化为红黑树, 提高效率 数组的查询为$O(1)$ , 链表的查询为$O(k)$, 红黑树的查询为$O(logk)$, $k$表示为桶中的元素的个数, 所以当元素很多的时候, 转化为红黑树能提高查询效率 单个节点的构造static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; // 哈希值 final K key; // key V value; // value Node&lt;K,V&gt; next; // 链表中该元素指向的下一个节点 // 单个节点包含的信息 Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + \"=\" + value; } // 哈希函数 // 一个节点的hash值是将key的哈希值和value的哈希值异或得到 public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } // 设置新的value 同时返回旧的value public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; } return false; } } 总结: 一个节点的hash值是将key的哈希值和value的哈希值异或得到 单个节点包含的信息有 key value hash值 next指针（指向下一个节点） 红黑树节点的构造static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; { TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; // 默认为红色， 原因为红黑树的性质四 TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) { super(hash, key, val, next); } 类的属性//初始容量为16 注释中说明了 必须为2的幂次 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 // 最大容量 2^30 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认负载因子0.75(若是构造函数中未说明) static final float DEFAULT_LOAD_FACTOR = 0.75f; // 桶中的节点数量大于8时转为红黑树 static final int TREEIFY_THRESHOLD = 8; // 桶中的节点数量小于6时 转为链表 static final int UNTREEIFY_THRESHOLD = 6; // 桶中结构转化为红黑树对应的table的最小大小 static final int MIN_TREEIFY_CAPACITY = 64; // 哈希桶 存放链表 总是2的倍数 transient Node&lt;K,V&gt;[] table; // 存放具体元素的集 transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; // 存放元素的个数，注意这个不等于数组的长度。 transient int size; // 每次扩容和更改map结构的计数器 transient int modCount; // threshold = 哈希桶.length * loadFactor; 当桶的使用数量操作该值, 进行扩容 int threshold; // 装载因子，用于计算哈希表元素数量的阈值。 final float loadFactor; 总结：最为重要的属性为： table、size、threshold、loadFactor 构造方法HashMap()public HashMap() { // 默认构造方法 将负载因子设置为默认值 0.75, 其他的属性均为默认 // 假设默认初始化空间大小为16, 则元素数量达到16*0.75=12时, 会进行扩容. this.loadFactor = DEFAULT_LOAD_FACTOR; } 这是一个默认构造器，潜在的问题是初始容量16太小了，可能中间需要不断扩容的问题，会影响插入的效率。 HashMap(int)public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } 用这种构造函数创建HashMap的对象，如果知道map要存放的元素个数，可以直接指定容量的大小， 减除不停的扩容，提高效率 内部调用下述的构造方法 HashMap(int , float)public HashMap(int initialCapacity, float loadFactor) { // 检查输入初始容量是否合法 if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); // MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 传入的初始化容量 &lt;=最大容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 检查输入加载因子是否合法 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } // 取与cap最近的且大于cap的2的次方值 static final int tableSizeFor(int cap) { int n = cap - 1; // 执行或运算 n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } 先是对初始化容量、装载因子的合理性检测，之后进行赋值，loadFactor: 自定义值， 默认为0.75，threshold: 取与cap最近的且大于cap的2的次方值 总结1. 为什么 threshold 要返回大于等于 initialCapacity 的最小 2 的 N 次方？ 计算元素table中的位置的时候，概述中有讲，使用的是hash &amp; (table.length-1) 而不是我们认为的 hash % table.length，而这两个方式在table.length是2的N次方的时候是等价的，从性能上而言，&amp;性能更好，所以，仅需要满足数组的容量n尽可能为2的N次方即可。 2. 为什么给的是初始化容量， 计算的却是阀值，而不是容量？ 1.8中， 将table的初始化放入了resize()中，并且在类属性中也注意到了没有capacity这个属性， 所以这里只能重新计算threshold，而resize()后面就会根据threshold来重新计算capacity，来进行 table数组的初始化，然后再重新按照装载因子计算threshold。 HashMap(Map&lt;?extends K, ?extends V&gt;)// 将已有map m里的所有元素加入当前的map中 public HashMap(Map&lt;? extends K, ? extends V&gt; m) { this.loadFactor = DEFAULT_LOAD_FACTOR; // 核心 批量添加到table中 putMapEntries(m, false); } putMapEntries(m, false)// 其实就是一个一个取出m中的元素调用putVal,一个个放入table中的过程。 final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) { int s = m.size(); if (s &gt; 0) { // ① table为空。说明还没初始化，适合在构造方法的情况 if (table == null) { // pre-size // +1.0F 的目的，是因为下面 (int) 直接取整，避免不够。 float ft = ((float)s / loadFactor) + 1.0F; // 修正，防止超出 int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 如果计算出来的 t 大于阀值，则计算新的阀值 if (t &gt; threshold) threshold = tableSizeFor(t); } // ② 如果 table 非空，说明已经初始化，需要不断扩容到阀值超过 s 的数量 else if (s &gt; threshold) resize(); // ③ 正常情况 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) { K key = e.getKey(); V value = e.getValue(); // 添加元素 putVal(hash(key), key, value, false, evict); } } } 整体的意思就是必须保证新的map的table容量够，如何保证？确保原map的元素数量小于新map的threshold。 构造方法总结 若是不知道需要创建的map的容量大小，使用默认构造方法 默认的容量大小为16 若是能确定map的容量大小，可使用第二种构造方法 threshold的值为最小的大于输入容量的2的指数 将原oldMap放入另一个newMap 若oldMap为空（没有元素） 若是oldMap不是新建的，其自身有一定容量 确保newMap能够容下oldMap， 不行进行扩容 增、改put(K key, V value)public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } hash(key) static final int hash(Object key) { int h; //为了使计算出的hash更分散 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } JDK1.8哈希计算， 取得key的hashcode后，高16位与整个Hash异或运算重新计算hash值 putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { // 对应table数组 Node&lt;K,V&gt;[] tab; // 对应位置的 Node 节点 Node&lt;K,V&gt; p; // n table的长度 // 原tab中对应放入Node的位置 int n, i; // 如果 table 未初始化，或者容量为 0 ，则进行扩容 // (第一次见这种赋值和判断融合的操作，学到了学到了) if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 如果对应的位置的Node节点为空，则直接创建 Node 节点即可。 // (n-1)&amp;hash 获取所在table的位置 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { // 哈希冲突解决 // key 在 HashMap 对应的老节点 Node&lt;K,V&gt; e; K k; // hash相等 key相等 执行覆盖 if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 为红黑树的节点 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 为Node节点，则说明是链表，且不是覆盖操作。需要遍历查找 else { // 判断什么时候进行链表转红黑树，什么时候红黑树转链表 for (int binCount = 0; ; ++binCount) { // 如果链表遍历完了都没有找到相同key的元素，说明该key对应的元素不存在，则在链表 // 最后插入一个新节点 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // 链表的长度如果数量达到 TREEIFY_THRESHOLD（8）时，则进行树化。 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } // 如果待插入的key在链表中找到了，则退出循环 if (e.hash == hash&amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } // 覆盖操作， 也就是相同的key的value进行覆盖 if (e != null) { // existing mapping for key V oldValue = e.value; // onlyIfAbsent进行判断是否需要覆盖oldValue if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 如果超过阀值，则进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } 总结一下图片为putVal方法的总体逻辑 hashmap_put.png 摘自 Hashmap源码解析 putAll(Map&lt;? extends K, ? extends V&gt; m)public void putAll(Map&lt;? extends K, ? extends V&gt; m) { this.putMapEntries(m, true); } putMapEntries在构造方法四中已经讲解了。 扩容机制resize()// 扩容方法 final Node&lt;K,V&gt;[] resize() { // oldTab 表示当前的哈希桶 Node&lt;K,V&gt;[] oldTab = table; // oldCap表示当前哈希桶的容量 length int oldCap = (oldTab == null) ? 0 : oldTab.length; // 当前哈希桶的阀值 int oldThr = threshold; // 初始化新的容量和阀值 int newCap, newThr = 0; // 1. 如果当前的容量不为空 if (oldCap &gt; 0) { // 如果当前的容量已经达到了上限 if (oldCap &gt;= MAXIMUM_CAPACITY) { // 阀值为2^32-1 threshold = Integer.MAX_VALUE; // 返回当前的哈希桶不再扩容 return oldTab; } // 否者新的容量为原先容量的两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)// 如果旧的容量大于等于默认的初始容量 16 // 新的阀值也为原先的两倍 newThr = oldThr &lt;&lt; 1; // double threshold } // 2. 如果当前表是空的，但是有阈值。代表是初始化时指定了容量、阈值的情况(上述的第三种构造方法) else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; // 新的容量为旧的阀值 // 3. 此处的判断用于初始化 else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } //如果新的阈值是0，对应的是 当前表是空的，但是有阈值的情况 if (newThr == 0) { //根据新表容量 和 加载因子 求出新的阈值 float ft = (float)newCap * loadFactor; // 进行越界修复 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } // 更新阀值 threshold = newThr; @SuppressWarnings({\"rawtypes\",\"unchecked\"}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; // 更新哈希桶的引用 table = newTab; // 如果以前的哈希桶有元素 // 以下执行将原哈希桶中的元素转入新的哈希桶中 if (oldTab != null) { // 遍历老的哈希桶 for (int j = 0; j &lt; oldCap; ++j) { // 取出当前的节点e Node&lt;K,V&gt; e; // 如果当前桶中有元素, 则将链表复制给e if ((e = oldTab[j]) != null) { // 将原哈希桶置空以便GC oldTab[j] = null; // 当前链表中只有一个元素, 没有发生哈希碰撞 if (e.next == null) //直接将这个元素放置在新的哈希桶里。 //注意这里取下标 是用 哈希值 与 桶的长度-1 。 //由于桶的长度是2的n次方，这么做其实是等于 一个模运算。但是效率更高 newTab[e.hash &amp; (newCap - 1)] = e; // 发生碰撞, 而且节点的个数超过8, 则转化为红黑树 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); //发生碰撞, 节点个数＜8 则进行处理, 依次放入新的哈希桶对应的下标位置 //因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下 //标,即low位， 或者扩容后的下标，即high位。 high位=low位+原哈希桶容量 else { // preserve order //低位链表的头结点、尾节点 Node&lt;K,V&gt; loHead = null, loTail = null; //高位链表的头结点、尾节点 Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; // 将同一桶中的元素根据(e.hash &amp; oldCap)是否为0进行分割，分成高位链表和低位 链表以完成rehash do { next = e.next; //这里又是一个利用位运算 代替常规运算的高效点： 利用哈希值与旧的容量， //可以得到哈希值取模后，是大于等于oldCap还是小于oldCap，等于0代表小于 //oldCap，应该存放在低位，否则存放在高位 if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 总结步骤: 如果使用的是默认构造方法, 则第一次插入元素的时候初始化为默认的容量16, 扩容阀值为12 如果使用的是非默认方法, 则第一次插入元素时初始化容量为扩容阀值, 扩容的阀值为初始化的时候, 扩容门槛在构造方法里等于传入容量向上最近的2的n次方 如果旧容量＞0, 则新容量为旧容量的2倍, 但不超过最大容量($2^{30}$), 新的扩容阀值为旧的扩容阀值2倍 创建新的容量桶 搬移元素，原链表分化成两个链表，低位链表存储在原来桶的位置，高位链表搬移到原来桶的位置加旧容量的位置 删remove(Object key)public V remove(Object key) { Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; } final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { // 这些和增里面是差不多的 // tab：桶数组 p：待删除节点的前驱节点 n: 桶数组大小 index: 桶数组第i个位置 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null&amp;&amp;(n = tab.length)&gt;0 &amp;&amp;(p=tab[index=(n-1)&amp;hash])!= null) { // node为需要删除的节点 Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) { if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else { do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } // 找到对应的key进行remove核心 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); // 如果node == p，说明是链表头是待删除节点 else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; } } return null; } 除去复杂的判断，也就是单链表删除指定的节点，共有两种情况： 1.删除的为头结点。2. 删除的为中间节点 remove(Object key, Object value)public boolean remove(Object key, Object value) { return removeNode(hash(key), key, value, true, true) != null; } 查get(Object key)public V get(Object key) { HashMap.Node e; return (e = this.getNode(hash(key), key)) == null ? null } // 根据key获取对应的节点 final HashMap.Node&lt;K, V&gt; getNode(int hash, Object key) { HashMap.Node[] tab; HashMap.Node first; int n; if ((tab = this.table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[n - 1 &amp; hash]) != null) { Object k; if (first.hash == hash &amp;&amp; ((k = first.key) == key || key != null &amp;&amp; key.equals(k))) { return first; } HashMap.Node e; if ((e = first.next) != null) { if (first instanceof HashMap.TreeNode) { return ((HashMap.TreeNode)first).getTreeNode(hash, key); } do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || key != null &amp;&amp; key.equals(k))) { return e; } } while((e = e.next) != null); } } return null; } 使用first.hash == hash &amp;&amp; ((k = first.key) == key || key != null &amp;&amp; key.equals(k))判断是否为同一个key(因为相同的hash可能并不是同一个key，因为先是使用(n - 1) &amp; hash寻找桶的位置，之后再依次查找key) Note负数的二进制表示: 取绝对值求二进制 获得原码 之后各个位取反获得反码 反码在最后一位＋1获得补码 补码极为负数的表示 &gt;&gt;&gt;和&gt;&gt;的区别 &gt;&gt;&gt;适合高位的运算低位运算两者无区别 hashCode与equals的深入理解&gt;&gt; hashCode 的常规协定是：在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，==前提是对象上 equals 比较中所用的信息没有被修改。==从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。==如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。==以下情况不是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） ==当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。== hashCode的存在主要是用于查找的快捷性,如HashTable, HashMap等. 用来在散列存储数据结构中确定对象的存储地址的. 若是两个对象相同,那么equals(java.lang.Object)方法为true, 那么两个对象的hashCode必须相同. 如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上一条. 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。 ==hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的== 底层数据结构分析一些操作符号解析 ^ 异或 &gt;&gt;&gt; 向右移动xxx位, 无视符号, 高位填0，不能左移 &gt;&gt; 同理右移xxx位, 能左移 总结&amp;面试相关问题 HashMap是一种散列表, 使用(数组+链表+红黑树)的结构 HashMap的默认初始容量为16, 默认装载因子为0.75, 且容量总是$2^n$ 正常情况下, 扩容为原来的两倍 桶的长度小于64 时, 不会进行树化 桶的长度大于64且链表长度大于8时, 进行树化 当单个桶中的元素小于6时, 进行反树化(转化为链表) 查询时间为$O(1)$ 添加时间$O(1)$ 1.判断key，根据key算出索引。2.根据索引获得索引位置所对应的键值对链表。3.遍历键值对链表，根据key找到对应的Entry键值对。4.拿到value。分析：以上四步要保证HashMap的时间复杂度O(1)，需要保证每一步都是O(1)，现在看起来就第三步对链表的循环的时间复杂度影响最大，链表查找的时间复杂度为O(n)，与链表长度有关。我们要保证那个链表长度为1，才可以说时间复杂度能满足O(1)。但这么说来只有那个hash算法尽量减少冲突，才能使链表长度尽可能短，理想状态为1。因此可以得出结论：HashMap的查找时间复杂度只有在最理想的情况下才会为O(1)， HashMap是非线程安全的 HashMap的线程不安全在哪儿 在JDK1.7之前的版本会出现死循环的问题 数据覆盖问题 A, B两个线程都需要put操作, 然后当A, B线程都获得了尾节点之后, A的时间片用完了, B开始执行尾插, 之后A再执行, 这时A获取的还是旧的尾部节点 , 所以就会导致数据被覆盖, B插入的数据丢失 解决线程安全问题: Collections.SynchronizedMap() Map&lt;String, Integer&gt; testMap = new HashMap&lt;&gt;(); ... // 转为线程安全的map Map&lt;String, Integer&gt; map = Collections.synchronizedMap(testMap); 使用ConcurrentHashMap references 数据结构与算法之美 Java-Guid jdk-source-analysis","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"Map","slug":"Map","permalink":"https://winniekun.github.io/tags/Map/"}]},{"title":"Ubuntu中MySQL5.7插入中文设置","slug":"配置/Ubuntu中MySQL5-7插入中文设置","date":"2020-03-11T09:44:55.000Z","updated":"2020-08-30T04:50:22.263Z","comments":true,"path":"Ubuntu中MySQL5-7插入中文设置/","link":"","permalink":"https://winniekun.github.io/Ubuntu%E4%B8%ADMySQL5-7%E6%8F%92%E5%85%A5%E4%B8%AD%E6%96%87%E8%AE%BE%E7%BD%AE/","excerpt":"前言其实关MySQL中插入中文,自己前年是设置过的,之后就一直没有管过,后来系统重装之后,重新安装配置各种环境之后,今天开始用MySQL的时候,才发现这个问题还没有解决,然后一时也想不起来怎么弄了,就重新网上搜索教程,最后想了下还是写一下配置过程吧,以后备用","text":"前言其实关MySQL中插入中文,自己前年是设置过的,之后就一直没有管过,后来系统重装之后,重新安装配置各种环境之后,今天开始用MySQL的时候,才发现这个问题还没有解决,然后一时也想不起来怎么弄了,就重新网上搜索教程,最后想了下还是写一下配置过程吧,以后备用 第一步cp /etc/mysql/mysql.conf.d/mysqld.cnf /etc/mysql/my.cnf 第二步修改/etc/mysql/my.cnf文件，找到[client]标记后在下方添加一行代码： default-character-set=utf8 如果找不到[client]标记，就直接在文件末尾插入： [client] default-character-set=utf8 第三步找到[mysqld]标记，在该标记下方添加两行 character-set-server=utf8 collation-server=utf8_general_ci 最后执行重启mysql命令：sudo service mysql restart 查看修改结果进入MySQL，之后输入如下命令 show variables like 'character%';","categories":[{"name":"mysql","slug":"mysql","permalink":"https://winniekun.github.io/categories/mysql/"}],"tags":[{"name":"配置","slug":"配置","permalink":"https://winniekun.github.io/tags/%E9%85%8D%E7%BD%AE/"}]},{"title":"个人博客事件","slug":"碎碎念/个人博客事件","date":"2020-03-11T09:10:30.000Z","updated":"2021-05-16T16:33:27.776Z","comments":true,"path":"个人博客事件/","link":"","permalink":"https://winniekun.github.io/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BA%8B%E4%BB%B6/","excerpt":"前言自己是从大二下开始写博客的，期间使用过很多的博客平台：Jekyll + GitHub Pages 、WordPress 、Typecho Hexo + GitHub Pages 自己也用Django 、Flask搭建过，博客的界面也改版了一次又一次，最后还是确定下来使用我目前这个了","text":"前言自己是从大二下开始写博客的，期间使用过很多的博客平台：Jekyll + GitHub Pages 、WordPress 、Typecho Hexo + GitHub Pages 自己也用Django 、Flask搭建过，博客的界面也改版了一次又一次，最后还是确定下来使用我目前这个了 就这样吧，我也不知道这次能坚持多久🙂 关于之前的内容全没了，点儿都不剩的全删了，有些文章删了的确是很可惜，谨记教训！！！自己强行又加了一个19年的书单，之前17年、18年的真的没法补了，记不住是几号写的了，也忘了都看了些啥子。","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"springboot---配置","slug":"spring/springboot/springboot-配置","date":"2020-03-11T03:06:54.000Z","updated":"2020-08-30T04:50:22.252Z","comments":true,"path":"springboot-配置/","link":"","permalink":"https://winniekun.github.io/springboot-%E9%85%8D%E7%BD%AE/","excerpt":"","text":"","categories":[{"name":"spring","slug":"spring","permalink":"https://winniekun.github.io/categories/spring/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://winniekun.github.io/tags/springboot/"}]},{"title":"红黑树","slug":"源码/JDK/map/rbtree-analysis","date":"2020-03-10T01:39:12.000Z","updated":"2020-08-30T04:50:22.256Z","comments":true,"path":"rbtree-analysis/","link":"","permalink":"https://winniekun.github.io/rbtree-analysis/","excerpt":"红黑树剖析","text":"红黑树剖析 BST部分二叉排序树、二叉搜索树性质： 定义的空树是BST 左子树所有节点的值均小于根节点的值 右子树所有节点的值均大于根节点的值 中序遍历序列为升序 实现二插排序树：节点定义、插入 节点： AVLEntry 字典：AVLMap int compara(K a, K b) 比较关键字a和b的大小 boolean isEmpty() 判断map是否为空 V put(K key, V value) 添加元素 迭代器 LeetCode173 binary search tree iterator 要点： 利用中序遍历 方案1： 递归添加进入线性集合， 迭代线性集合 方案2： 非递归， 使左路径节点压栈 AVL迭代器 属性stack ， 存储BST的节点 hasNext, 是否还有下一个节点 next 下一个节点的值 remove 线程安全问题 AVLMap继承Iterable， 并重写Iterator方法， 返回AVL迭代器即可 查找原理： 若是根节点的值小于key， 递归从右子树查找 若是根节点的值大于key， 递归从左子树查找 如是根节点等于key， 成功 若是子树为空， 失败 实现模拟TreeMap的代码结构， 实现以下方法 AVLEntry getEntry(K key) 私有方法 主要查找逻辑 boolean containsKey(K key) 是否能找到关键字 V get(K key) 根据关键字返回对应的value boolean containsValue(V value) 能够找到value 删除（重点）原理删除操作较为繁琐， 需要考虑断链的情况，以及删除之后， 还需满足BST的特性 共分为三种情况， 假设删除的节点为p， 父节点为f p为叶子节点， 直接删除 p的左子树（右子树）不为空，删除之后， 其左子树（右子树）填补p的空缺位置 p既有左子树又有右子树， 找到右子树的最小值节点M（左子树的最大值）将该值替换p的值，之后按照1、2两种情况删除M即可 实现 AVLEntry deleteEntry() 递归函数（主逻辑） V remote(K key) 删除关键字key 返回对应的value void levelOrder 辅助函数 层次遍历 用于输出观察 面试经典： 寻找最大最小节点 BST的前驱和 BST的前驱和后继节点前驱结点：节点val值小于该节点val值并且值最大的节点 后继节点：节点val值大于该节点val值并且值最小的节点 前驱节点（有父指针的情况） 若一个节点有左子树，那么该节点的前驱节点是其左子树中val值最大的节点（也就是左子树中所谓的rightMostNode） 若一个节点没有左子树，那么判断该节点和其父节点的关系2.1 若该节点是其父节点的右边孩子，那么该节点的前驱结点即为其父节点。2.2 若该节点是其父节点的左边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的右边孩子，那么Q就是该节点的后继节点 后继节点（有父指针的情况） 若一个节点有右子树，那么该节点的后继节点是其右子树中val值最小的节点（也就是右子树中所谓的leftMostNode） 若一个节点没有右子树，那么判断该节点和其父节点的关系2.1 若该节点是其父节点的左边孩子，那么该节点的后继结点即为其父节点2.2 若该节点是其父节点的右边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的左边孩子，那么Q就是该节点的后继节点 LIntCode 448 Inorder Successor in BST p为最大节点， 返回null p有右子树 p没有右子树 进行二叉查找， 并压栈， 之后弹栈 AVL定义BST和TreeMap的效率对比 情况 BST TreeMap 升序序列（降序序列） Slow OK 随机序列 OK OK AVL是一种自平衡的二叉树 BST 左右子树的高度差绝对值&lt;1 空树、左右子树都是AVL 旋转与插入旋转 右旋 右旋 先左旋再右旋 左旋 同理 什么时候需要旋转 插入关键字key后，节点p的平衡因子由原来的1或者-1，变成了2或者-2，则需要旋转；只考虑插入key到左子树left的情形，即平衡因子为2 情况1：key&lt;left.key, 即插入到left的左子树，需要进行单旋转，将节点p右旋 情况2：key&gt;left.key, 即插入到left的右子树，需要进行双旋转，先将left左旋，再将p右旋插入到右子树right 平衡因子为-2，完全对称 对于检测是否平衡并旋转的调整过程自顶向下OR自底向上 对于BST的插入， 是自顶向下的，AVL的插入和BST的插入是一样的也是自顶向下 在检测节点p是否平衡之前，必须先保证左右子树已经平衡 子问题成立 —-&gt; 总问题成立 ： ==自底向上== 有parent指针， 直接向上回溯 无parent指针， 后续遍历、递归 无parent指针， 栈实现非递归 LeetCode110. Balanced Binary Tree 插入代码实现 AVLEnrty增加height属性，表示树的高度 ==&gt; 平衡因子可以实时计算 单旋转：右旋rotateRight、左旋rotateLeft 双旋转：先左后右firstLeftThenRight、先右后左firstRightThenLeft 辅助栈stack，将插入时候所经过的路径压栈 插入调整函数fixAfterInsertion 辅助函数checkBalance，断言AVL树的平衡性，检测算法的正确性 算法改进&amp;&amp;时间复杂度分析弹栈的时候，一旦发现某个节点并未改变，则停止弹栈 指针回溯次数：最坏为O(logN)最好为O(log1) , 平均为O(logN) 旋转次数： 无需旋转、单旋转、双旋转、不会超过两次 时间复杂度： BST插入O(logN)+指针回溯O(logN) + 旋转O(1) = O(logN) 空间复杂度： 有parent指针为O(1) 无parent指针为O(logN) 面试经典：排序数组转化为AVL和RBTtreeMap中buildFromSorted实现功能类似 删除原理类似插入，假设删除了p右子树的某个节点，引起了p的平衡因子d[p]=2，分析p的左子树left，三种情况如下： left的平衡因子d[left]=1，将p右旋 left的平衡因子d[left]=0，将p右旋 left的平衡因子d[left]= -1，先左旋left，再右旋p 删除左子树，即d[p]= -2的情形，与d[p]=2对称 实现 fixAfterDeletion：调整某个节点p deleteEntry直接调用fixAfterDeletion 红黑树红黑树定义 任意节点要么是红色，要么是黑色 根节点为黑色 所有的叶子节点为黑色（叶子节点为空） 如果一个节点为红色，那么它的两个子节点都为黑色 任意节点从它出发， 到所有叶子节点的路径上包含相同数量的黑色节点 简称为黑高（BlackHeight、BH） 由此衍生出的性质： 任意一颗以黑色节点为根的子树也必定是一颗红黑树 左（右）子树的高度最多是右（左）子树的两倍 其必定是一个BST 红黑树在JDK源码中的实现(TreeMap中的fixAfterInsertion和fixAfterDeletion)： 插入操作==自底向上== RBT中的插入调整： fixAfterInsersion: cast1、case2、case3 RBT中的删除调整：fixAfterDeletion: case1、case2、case3、case4 插入原则 若插入的为黑色的节点，违法性质5 只能插入红色节点，可能违反性质4，继续调整 from 插入正确性证明 是否会引起左右子树的BH不一致 有无继续破坏性质4的可能 插入调整无需调整的情况为： X为根节点，将X由红染黑，简称rootOver 父节点P为黑色，BlackParentOver，简称bpOver while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) 需要调整的情况为： 仅仅需要考虑父节点P为红色的情形，由于性质4，爷爷节点G必定为黑色，分为三种情况：case1: Y为红色，X可左可右；P、Y染黑，G染红，X回溯至Gcase2: Y为黑色，X为右孩子；左旋P，X指向P，转化为case3case3: Y为黑色，X为左孩子；P染黑，G染红，右旋G，结束结论：RBT的插入调整最多旋转2次 case1 条件P为红色，为G的左孩子， Y为红色， X可左可右， 处理方式： 将P、Y染黑， G然为红色，X回溯至G即可 条件简称： 红左父、红叔、红左右子 处理方式简称： 父叔变黑、爷变红，子变爷 if (parentOf(x) == leftOf(parentOf(parentOf(x)))) { Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) { setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); } } case2 条件： P为G的左孩子，Y为黑色，X为右孩子 处理方式：左旋P，X指向P，转化为case3 条件简称：红左父，黑叔，红右子 处理方式简称：左旋父、子变父、变为case3 else { if (x == rightOf(parentOf(x))) { x = parentOf(x); // X指向P rotateLeft(x); // 左旋P } case3 条件：P为G的左孩子，Y为黑色，X为左孩子 处理方式：P染黑，G染红，右旋G，结束 条件简称：红左父，黑叔，红左子 处理方式简称：父变黑、爷变红、右旋爷 setColor(parentOf(x), BLACK); // P染黑 setColor(parentOf(parentOf(x)), RED); // G 染红 rotateRight(parentOf(parentOf(x))); // 右旋G 当P为G的右孩子，同理 rightCase1：Y为红，X可左可右；P、Y变黑，G变红，X变GrightCase2：Y为黑，X为左孩子；右旋P，X变P，转case3rightCase3：Y为黑，X为右孩子；G变红，P变黑，左旋G 删除操作二插排序树的删除： 三种情况 AVL树的删除：两种情况 红黑树的删除： 四种情况 删除原则 删除的节点为红色，则直接删除，并不影响整体结果，需要注意防止断链 删除的节点为黑色，所在的BH—，需要进行调整 删除调整 from 删除正确性证明 是否违反性质五 X的BH只能保持或者不变，否者X要比S的BH要小 是否违反性质四 若谷违反了，继续染黑还是回溯 删除调整无需调整的情况 当前X为根节点，无论root为什么颜色，都将root染黑， rootOver 当前X为红色， 将X染黑， redOver while (x != root &amp;&amp; colorOf(x) == BLACK) 删除左孩子X 四种情况case1条件：S为红色隐含条件：由于性质4，P、LN、RN必定都为黑色处理方式：S染黑，P染红，左旋P，LN成为新的sib if (x == leftOf(parentOf(x))) { Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) { setColor(sib, BLACK); setColor(parentOf(x), RED); rotateLeft(parentOf(x)); sib = rightOf(parentOf(x)); } case2条件； case2-1条件：S、LN、RN均为黑色，P为黑色 case2-2条件：S、LN、RN均为黑色，P为红色 隐含条件：由于性质4，P、LN、RN必定都为黑色处理方式：S染黑，P染红，左旋P，LN成为新的sib处理方式相同：S染红，X回溯至P case3条件：S为黑色，LN为红色，RN为黑色处理方式：LN染黑、S染红，右旋S，S指向LN转化为case4-1、case4-2 case4S为黑色，LN随意，红RN；S变P的颜色，P和S染黑，左旋P Comparable和ComparatorComparableComparable简介Comparable是排序接口。 若一个类实现了Comparable接口，就意味着“该类支持排序”。 即然实现Comparable接口的类支持排序，假设现在存在“实现Comparable接口的类的对象的List列表(或数组)”，则该List列表(或数组)可以通过 Collections.sort（或 Arrays.sort）进行排序。 此外，“实现Comparable接口的类的对象”可以用作“有序映射(如TreeMap)”中的键或“有序集合(TreeSet)”中的元素，而不需要指定比较器。 Comparable 定义Comparable 接口仅仅只包括一个函数，它的定义如下： package java.lang; import java.util.*; public interface Comparable&lt;T&gt; { public int compareTo(T o); } 假设我们通过 x.compareTo(y) 来“比较x和y的大小”。若返回“负数”，意味着“x比y小”；返回“零”，意味着“x等于y”；返回“正数”，意味着“x大于y”。 ComparatorComparator简介Comparator 是比较器接口。 我们若需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)；那么，我们可以建立一个“该类的比较器”来进行排序。这个“比较器”只需要实现Comparator接口即可。 也就是说，我们可以通过“实现Comparator类来新建一个比较器”，然后通过该比较器对类进行排序。 Comparator定义Comparator 接口仅仅只包括两个个函数，它的定义如下： package java.util; public interface Comparator&lt;T&gt; { int compare(T o1, T o2); boolean equals(Object obj); } 总结相同 Comparable和Comparator都是用来实现对象的比较、排序 要想对象比较、排序，都需要实现Comparable或Comparator接口 Comparable和Comparator都是Java的接口 区别 Comparator位于java.util包下，而Comparable位于java.lang包下 Comparable接口的实现是在类的内部（如 String、Integer已经实现了Comparable接口，自己就可以完成比较大小操作），Comparator接口的实现是在类的外部（可以理解为一个是自已完成比较，一个是外部程序实现比较） 实现Comparable接口要重写compareTo方法, 在compareTo方法里面实现比较","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"Map","slug":"Map","permalink":"https://winniekun.github.io/tags/Map/"}]},{"title":"死磕回溯","slug":"LeetCode/stick-to-backtrack","date":"2020-02-25T14:18:18.000Z","updated":"2021-02-16T09:33:45.356Z","comments":true,"path":"stick-to-backtrack/","link":"","permalink":"https://winniekun.github.io/stick-to-backtrack/","excerpt":"前言LeetCode死磕系列四： 回溯","text":"前言LeetCode死磕系列四： 回溯 组合、排列 切割问题 子集问题 棋盘问题 回溯可抽象为树形结构（n叉树） for循环嵌套递归 优化： 剪枝操作 需要注意题目中一次的结果中元素能否重复，所有结果中，顺序不同，是否会造成一个新的结果。 LeetCode 回溯题目整理排列组合区分： 排列有序，相同元素不同顺序，则不同 组合无序，相同元素不同顺序，则相同(需要添加start索引) 77 combine 组合问题 78 Subsets 组合问题 46 Permutations 排列问题 47 PermutationsII 排列问题 36 Combination Sum 组合问题 40 Combination Sum II 组合问题 216 Combination Sum III 组合问题 90 Subsets II 组合问题 60 Permutation Sequence 和Permutations是一样的，只需要返回results中第k个值即可 二维问题 79 Word Search 经典的二维问题的回溯 剑指offer第12题 题解77 Combine78 Subsets组合问题 public static List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { List&lt;List&lt;Integer&gt;&gt; results = new LinkedList&lt;&gt;(); List&lt;Integer&gt; out = new LinkedList&lt;&gt;(); backtrack(nums, results, out, 0); return results; } private static void backtrack(int[] nums, List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; track, int start) { results.add(new LinkedList&lt;&gt;(track)); for (int i = start; i &lt; nums.length; i++) { track.add(nums[i]); backtrack(nums, results, track, i+1); track.remove(track.size()-1); } } 46 Permutations排列问题 private List&lt;List&lt;Integer&gt;&gt; results = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { int k = 3; List&lt;Integer&gt; out = new LinkedList&lt;&gt;(); backtrack(nums, out, k); return results; } private void backtrack(int[] nums, List&lt;Integer&gt; track, int k) if(track.size() == k){ results.add(new LinkedList&lt;&gt;(track)); } for (int i = 0; i &lt; nums.length; i++) { // 剔除重复值 if(track.contains(nums[i])){ continue; } track.add(nums[i]); backtrack(nums, track, k); track.remove(track.size()-1); } } 47 PermutationsII排列问题 private static List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); public static List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { Arrays.sort(nums); List&lt;Integer&gt; out = new ArrayList&lt;&gt;(); backtrack(nums, out, new boolean[nums.length]); return results; } private static void backtrack(int[] nums, List&lt;Integer&gt; out, boolean[] visit if (out.size() == nums.length) { results.add(new ArrayList&lt;&gt;(out)); return; } for (int i = 0; i &lt; nums.length; i++) { //重复元素只按顺序选择，若当前元素未被选择且前一元素与当前元素值相等也未被选择则跳过， // 这一可能情况与先选小序号后选大序号的相同元素相同 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; visited[i-1] &amp;&amp;!visited[i] || continue; } out.add(nums[i]); visited[i] = true; backtrack(nums, out, visited); out.remove(out.size() - 1); visited[i] = false; } } 36 Combination Sum组合问题 元素无重复项 可重复使用 private List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;List&lt;Integer&gt;&gt;(); private List&lt;Integer&gt; curren = new ArrayList&lt;Integer&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target){ Arrays.sort(candidates); if(candidates == null){ return results; } backtrack(0, candidates, target, curren); return results; } private void backtrack(int start, int[] candidates, int target, List&lt;Integer&gt; out){ if(target &lt; 0){ return; } if(target == 0){ results.add(new ArrayList&lt;&gt;(out)); } for (int i = start; i &lt; candidates.length; i++) { out.add(candidates[i]); backtrack(i, candidates, target-candidates[i], curren); out.remove(out.size()-1); } } 40 Combination Sum II组合问题 元素有重复项 不能重复选 // 有重复项 private List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { if (candidates == null) { return results; } Arrays.sort(candidates); List&lt;Integer&gt; out = new ArrayList&lt;&gt;(); backtrack(0, out, candidates, target); return results; } private void backtrack(int start, List&lt;Integer&gt; out, int[] candidates, int targe if(target &lt; 0){ return; } if(target == 0){ results.add(new ArrayList&lt;&gt;(out)); } for (int i = start; i &lt; candidates.length; i++) { if(candidates[i] == candidates[i-1] &amp;&amp; i&gt; start){ continue; } out.add(candidates[i]); backtrack(i+1, out, candidates, target-candidates[i]); out.remove(out.size()-1); } } 216 Combination Sum III组合问题 元素无重复项，但是候选集改变 private List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n){ List&lt;Integer&gt; out = new ArrayList&lt;&gt;(); backtrack(1, out, n, k); return results; } private void backtrack(int start, List&lt;Integer&gt; out, int n, int k) { if(out.size() == k &amp;&amp; n==0){ results.add(new ArrayList&lt;&gt;(out)); } for (int i = start; i &lt;= n; i++) { if(i&gt;=10){ continue; } out.add(i); backtrack(i+1, out, n-i, k); out.remove(out.size()-1); } } 90 Subsets II组合问题 元素有重复项 private List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;() public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) { if(nums == null){ return results; } Arrays.sort(nums); List&lt;Integer&gt; out = new ArrayList&lt;&gt;(); backtrack(nums, out, 0); return results; } private void backtrack(int[] nums, List&lt;Integer&gt; out, i results.add(new ArrayList&lt;&gt;(out)); for (int i = start; i &lt; nums.length; i++) { if(i&gt;start &amp;&amp; nums[i] == nums[i-1]){ continue; } out.add(nums[i]); backtrack(nums, out, i+1); out.remove(out.size()-1); } } 79 Word Search二维平面内判断是否包含有字符串，最基础的二维回溯问题. 和一维回溯问题不同的是，回溯函数去除了for循环，而是判断其相邻的四个格子： (row+1, col) (row-1, col) (row, col+1) (row, col-1) 调用回溯的方法使用了for循环，因为二维的每个位置都需要进行深度遍历。 回溯部分： 需要判断是否越界，越界的地方不走 终止条件： 当前的第i步，对应的字符刚好是word的第i个字符 public boolean exist(char[][] board, String word) { if (board.length == 0 || board[0].length == 0) { return false; } int m = board.length; int n = board[0].length; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (search(board, word, 0, i, j)) { return true; } } } return false; } private boolean search(char[][] board, String word, int start, int i, int j) { if (start == word.length()) { return true; } int m = board.length; int n = board[0].length; if (i &lt; 0 || j &lt; 0 || i &gt;= m || j &gt;= n || board[i][j] != word.charAt(start)) { return false; } char c = board[i][j]; board[i][j] = '#'; boolean res = search(board, word, start + 1, i + 1, j) || search(board, word, start + 1, i - 1, j) || search(board, word, start + 1, i, j + 1) || search(board, word, start + 1, i, j - 1); board[i][j] = c; return res; }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"回溯","slug":"回溯","permalink":"https://winniekun.github.io/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"死磕DFS","slug":"LeetCode/stick-to-DFS","date":"2020-02-23T11:59:12.000Z","updated":"2020-08-30T04:50:22.249Z","comments":true,"path":"stick-to-DFS/","link":"","permalink":"https://winniekun.github.io/stick-to-DFS/","excerpt":"前言LeetCode死磕系列三： DFS 刷了那么多题， 感觉DFS应用很广泛哇，遇到排列组合、搜索等问题，理解题意之后，直接无脑DFS都能行的通。","text":"前言LeetCode死磕系列三： DFS 刷了那么多题， 感觉DFS应用很广泛哇，遇到排列组合、搜索等问题，理解题意之后，直接无脑DFS都能行的通。 LeetCode DFS题目整理 200 Number of Islands 题解200 Number of Islands数陆地， 其中1表示陆地，0表示水 思路： 使用dfs, 从（0,0）开始，顺序下、上、右、左 每次访问到的陆地都改为水。这样就略去了标记为数组，减少空间 private static final int[][] DIRS = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; private static final char L = '1', W = '0'; public int numIslands(char[][] grid){ int count = 0; for (int i = 0; i &lt; grid.length; i++) { for (int j = 0; j &lt; grid[0].length; j++) { if (grid[i][j] == L) { count++; dfs(grid, i, j); } } } return count; } private void dfs(char[][] grid, int x, int y) { // 边界判断 if (x &lt; 0 || x &gt; grid.length-1 || y &lt; 0 || y &gt; grid[0].length-1) { return; } if(grid[x][y] == L){ grid[x][y] = W; for (int[] dir : DIRS) { dfs(grid, x+dir[0], y+dir[1]); } } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"dfs","slug":"dfs","permalink":"https://winniekun.github.io/tags/dfs/"}]},{"title":"死磕链表","slug":"LeetCode/stick-to-linkedlist","date":"2020-02-15T12:42:11.000Z","updated":"2021-07-02T04:06:00.749Z","comments":true,"path":"stick-to-linkedlist/","link":"","permalink":"https://winniekun.github.io/stick-to-linkedlist/","excerpt":"前言LeetCode死磕系列二： 链表","text":"前言LeetCode死磕系列二： 链表 链表作为基础的数据结构，将链表的操作掌握了，其他的相关结构与算法，理论上来说为题不大了。LeetCode中， 链表的操作是有迹可循的， 当然也可当场理解，然后画图，找解法（奈何我太笨，编码功底还不够），反正链表的所有操作都离不开基础的CRUD, 还需要注意的是，当涉及到头结点的操作的时候，最好设置一个dummy节点指向头结点，这样方便统一处理。 刷了LeetCode中所有链表有关的题目（34题免费题目）做了如下总结 CRUD增需要注意构造新链表时的头插法 和尾插法 头插法： 逆序 尾插法： 正序 删根据前驱删除 pre.next = pre.next.next; 根据当前节点删除 ListNode next = cur.next; cur.val = next.val; cur.next = next.next; 改查链表的常用操作 两两之间的交换 多节点的交换 反转 环 LeetCode 链表题目整理 2 Add Two Numbers 445 Add Two Numbers II 题解2. Add Two NumbersExample: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. 思路： 链表的反转序列代表一个整数，然后整数的相加之后，结果用个位--&gt;十位---&gt;百位的顺序表示。所以可以使用两个队列存储两个链表，然后开始依次弹出，进行相加，使用尾插法构造输出链表 public ListNode addTwoNumbers(ListNode l1, ListNode l2) { Queue&lt;ListNode&gt; queue1 = list2Queue(l1); Queue&lt;ListNode&gt; queue2 = list2Queue(l2); // 应题目要求 使用尾插发 ListNode dummy = new ListNode(-1); ListNode real = dummy; int carry = 0; while (!queue1.isEmpty() || !queue2.isEmpty()) { int p1 = queue1.isEmpty() ? 0 : queue1.poll().val; int p2 = queue2.isEmpty() ? 0 : queue2.poll().val; int sum = p1 + p2 + carry; int i = sum % 10; // 尾插法 ListNode cur = new ListNode(i); real.next = cur; real = cur; carry = sum / 10; } if (carry &gt; 0) { ListNode node = new ListNode(carry); real.next = node; real = node; } return dummy.next; } public Queue&lt;ListNode&gt; list2Queue(ListNode node) { Queue&lt;ListNode&gt; queue = new LinkedList&lt;&gt;(); while (node != null) { queue.offer(node); node = node.next; } return queue; } 445 Add Two Numbers II思路 链表代表一个整数，两整数相加之后，结果用最高位---&gt;....---&gt;十位---&gt;个位顺序表示。所以可以使用两个栈存储两个链表，然后开始依次弹出，进行相加，使用头插法构造输出链表。 public ListNode addTwoNumbersII(ListNode l1, ListNode l2) { if (l1 == null &amp;&amp; l2 == null) { return null; } Stack&lt;ListNode&gt; s1 = new Stack(); while(l1 != null) { s1.push(l1); l1 = l1.next; } Stack&lt;ListNode&gt; s2 = new Stack(); while(l2 != null) { s2.push(l2); l2 = l2.next; } int carry = 0; ListNode resNode = null; while (!s1.isEmpty() || !s2.isEmpty()) { int n1 = s1.isEmpty() ? 0 : s1.pop().val; int n2 = s2.isEmpty() ? 0 : s2.pop().val; int sum = n1 + n2 + carry; ListNode n = new ListNode(sum % 10); // 头插法 n.next = resNode; resNode = n; carry = sum / 10; } // 最高位 if (carry &gt; 0) { ListNode n = new ListNode(carry); n.next = resNode; resNode = n; } return resNode; } 链表表示整数，进行加法计算，这是两个链表的操作，没有涉及链表的增删改查，实现方式数组中的Add Two Numbers同理。但是需要注意题目要求，上述两个题目思路是一样的，但是需要注意题目说明，给定的链表是如何代表一个整数的，然后输出结果是如何表示的，（因为我们的算法是从个位开始计算的） 正序表示整数 &amp;&amp; 从个位依次输出使用栈存储，尾插法构造结果 逆序表示整数 &amp;&amp; 从最高位依次输出使用队列存储，头插法构造结果 19. Remove Nth Node From End of List查、删 倒数第n个节点删除 先获取第n个节点的前驱节点，然后按照前驱结点删除法删除即可 public static ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(-1); dummy.next = head; ListNode preNode = getPreNode(dummy, n); preNode.next = preNode.next.next; return head; } public static ListNode getPreNode(ListNode head, int n){ int count = 0; ListNode p = head; while (p != null){ count ++; p = p.next; } p = head; while ( count-n-1 &gt; 0){ p = p.next; count --; } return p; } // 也可以直接使用第二种删除方法 public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(-1); dummy.next = head; ListNode fast = dummy; ListNode slow = dummy; while(n &gt; 0){ fast = fast.next; n--; } while(fast.next != null){ fast = fast.next; slow = slow.next; } slow.next = slow.next.next; return dummy.next; } 21. Merge Two Sorted Lists增、查 public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(-1); ListNode real = dummy; while (l1 != null &amp;&amp; l2 != null){ if(l1.val &lt;= l2.val){ real.next = l1; l1 = l1.next; }else { real.next = l2; l2 = l2.next; } real= real.next; } if (l1 != null){ real.next = l1; } if (l2 != null) { real.next = l2; } return dummy.next; } 23. Merge k Sorted Lists增，查 方法一多链表之间按照递增顺序进行整合。（根据上一题的思路，先两两合并，最后合并成一个链表） public ListNode mergeKLists(ListNode[] lists) { if (lists == null) { return null; } int length = lists.length; while (length &gt; 1) { int k = (length + 1) / 2; for (int i = 0; i &lt; (length / 2); i++) { // mergeTwo为21题函数 lists[i] = mergeTwo(lists[i], lists[i+k]); } length = k; } return lists[0]; } 方法二使用小根堆 public ListNode mergeKLists(ListNode[] lists) { PriorityQueue&lt;ListNode&gt; heap = new PriorityQueue&lt;&gt;(new Comparator&lt;ListNode&gt;() { @Override public int compare(ListNode o1, ListNode o2) { return o1.val - o2.val; } }); // 尾插法 ListNode dummy = new ListNode(-1); ListNode real = dummy; for (ListNode node : lists) { if (node != null) { heap.offer(node); } } while (!heap.isEmpty()) { real.next = heap.poll(); real = real.next; if (real.next != null) { heap.offer(real.next); } } return dummy.next; } 24. Swap Nodes in Pairs改 两两交换， 两个节点的交换， 必然牵引到四个指针的改变 具体步骤见图： 链表.png public static ListNode swapPairs(ListNode head){ if(head == null){ return head; } ListNode dummy = new ListNode(-1); dummy.next = head; ListNode pre = dummy; while (head!=null &amp;&amp; head.next!=null){ ListNode temp = head.next; head.next = temp.next; temp.next = pre.next; pre.next = temp; pre = head; head = head.next; } return dummy.next; } 25. Reverse Nodes in k-Group思路和上一题一样。但是需要注意pre的cur 92. Reverse Linked List II和上述同理 public static ListNode reverseBetween(ListNode head, int m, int n) { if (head == null || n - m == 0) { return head; } ListNode dummy = new ListNode(-1); dummy.next = head; ListNode pre = dummy; for (int i = 0; i &lt; m-1; i++) { pre = pre.next; } ListNode cur = pre.next; for (int i = m; i &lt; n; i++) { ListNode temp = cur.next; cur.next = temp.next; temp.next = pre.next; pre.next = temp; } return dummy.next; } 206. Reverse Linked List头插法解决 public ListNode reverseList(ListNode head) { ListNode dummy = new ListNode(-1); while(head != null){ ListNode curr = head.next; head.next = dummy.next; dummy.next = head; head = curr; } return dummy.next; } 61. Rotate List查 快慢指针法，fast指针先走k步，之后slow和fast一起走，fast到链表尾部，然后将链表头尾相连。此时slow指向新的头结点的前驱节点，然后重新设置头指针，断开链表即可。 // 快慢指针 public static ListNode roateRightII(ListNode head, int k){ if(head == null){ return null; } int length = getLength(head); k %= length; ListNode endNode = getEndNode(head); ListNode fast = head, slow = head; while (k &gt; 0){ fast = fast.next; k--; } while (fast.next != null){ fast = fast.next; slow = slow.next; } // 构成环 fast.next = head; // 重新设置 head = slow.next; slow.next = null; return head; } 83. Remove Duplicates from Sorted List删 删除有重复的节点 使用前驱节点删除法，所以需要一个pre指针，和cur指针。 public ListNode deleteDuplicates(ListNode head) { ListNode pre = head; ListNode cur; while (pre.next != null){ cur = pre.next; // 因为是和cur的前驱比较， 所以不用判断cur.next!=null, 而是使用cur!=null while (cur!=null &amp;&amp; cur.val == pre.val){ cur = cur.next; } if(pre.next != cur){ pre.next = cur; } else { pre = pre.next; } } return head; } 82. Remove Duplicates from Sorted List II删 删光重复的节点 使用前驱节点删除法，所以需要一个pre指针，和cur指针。 可能存在头结点会变换, 所以设置一个空的头结点 public ListNode deleteDuplicates(ListNode head) { if (head == null) { return null; } ListNode dummy = new ListNode(-1); dummy.next = head; ListNode cur = null; ListNode pre = dummy; while (pre.next != null) { cur = pre.next; while (cur.next != null &amp;&amp; cur.next.val == cur.val) { cur = cur.next; } if(cur != pre.next){ pre.next = cur.next; } else { pre = pre.next; } } return dummy.next; } 86. Partition List109. Convert Sorted List to Binary Search Tree138. 复制带随机指针的链表class Solution { public Node copyRandomList(Node head) { if (head == null) { return head; } // key 旧。value 新 Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;(); Node newHead = new Node(head.val); Node oddHead = head; map.put(oddHead, newHead); Node nCur = newHead; Node oCur = head.next; while (oCur != null) { nCur.next = new Node(oCur.val); nCur = nCur.next; map.put(oCur, nCur); oCur = oCur.next; } oCur = head; nCur = newHead; while (oCur != null) { if (oCur.random != null) { // random ！！！！ Node ran = map.get(oCur.random); nCur.random = ran; } oCur = oCur.next; nCur = nCur.next; } return newHead; } } 141. Linked List Cycle142. Linked List Cycle II143. Reorder List147. Insertion Sort List148. Sort List160. Intersection of Two Linked Lists解法1：暴力求解 解法2： 构造环 203. 移除链表元素// 双指针 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) { return head; } ListNode dummy = new ListNode(-1); dummy.next = head; ListNode pre = dummy; ListNode cur = head; while (cur != null) { if (cur.val != val) { pre = cur; cur = cur.next; } else { pre.next = cur.next; cur = pre.next; } } return dummy.next; } } 234. 回文链表class Solution { public boolean isPalindrome(ListNode head) { if (head == null) { return true; } Map&lt;Integer, ListNode&gt; map = new HashMap&lt;&gt;(); ListNode cur = head; int n = 0; while (cur != null) { map.put(n, cur); n++; cur = cur.next; } cur = head; for (int i = 0; i &lt; n / 2; i++) { System.out.println(cur.val); if (cur.val != map.get(n - i - 1).val) { return false; } cur = cur.next; } return true; } } 237. Delete Node in a Linked List328. 奇偶链表class Solution { public ListNode oddEvenList(ListNode head) { // 按照位置分奇偶 if (head == null) { return head; } ListNode odd = new ListNode(-1); ListNode even = new ListNode(-1); ListNode oddHead = odd; ListNode evenHead = even; int i = 1; while (head != null) { if (i % 2 == 1) { odd.next = head; odd = odd.next; } else { even.next = head; even = even.next; } head = head.next; i++; } // 断链 （注意注意注意） odd.next = evenHead.next; even.next = null; return oddHead.next; } } 369. Plus One Linked List379. Design Phone Directory426. Convert Binary Search Tree to Sorted Doubly Linked List430. Flatten a Multilevel Doubly Linked List445. Add Two Numbers II707. Design Linked List708. Insert into a Sorted Circular Linked List725. Split Linked List in Parts817. Linked List Components876. Middle of the Linked List1019. Next Greater Node In Linked List1171. Remove Zero Sum Consecutive Nodes from Linked List删 快慢指针 其实是和计算一个链表中是否存在和为n的子链表是一样的意思。 slow表示当前的元素，使用fast依次遍历其后续的元素，同时值相加，如果等于0，则slow.next = fast.next,如果fast遍历完了所有的元素了，没有等于0， 则slow移动到下一个元素 1290. Convert Binary Number in a Linked List to Integer查 1369. Linked List in Binary Tree","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"链表","slug":"链表","permalink":"https://winniekun.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"死磕二叉树","slug":"LeetCode/stick-to-binary-tree","date":"2020-02-15T12:40:45.000Z","updated":"2021-03-25T07:14:58.934Z","comments":true,"path":"stick-to-binary-tree/","link":"","permalink":"https://winniekun.github.io/stick-to-binary-tree/","excerpt":"前言LeetCode死磕系列一： 二叉树","text":"前言LeetCode死磕系列一： 二叉树 二叉树其自身就具有递归属性， 所以按道理，绝大多数题目用递归都是可以的 一般情况下:如果需要搜索整颗二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归 函数就需要返回值，因为遇到符合条件的路径了就要及时返回 常用操作 遍历 前序遍历 //递归前序遍历 public void preOrder(TreeNode root) { if (Objects.isNull(root)) { return; } // do something preOrder(root.left); preOrder(root.right); } //递归前序遍历 public void preOrder(TreeNode root) { } //非递归前序遍历 public void preOrderII(TreeNode root) { if (Objects.isNull(root)) { return; } Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); TreeNode p = root; while (!stack.isEmpty() || p != null) { while (p != null) { // do something stack.push(p); p = p.left; } if (!stack.isEmpty()) { p = stack.pop(); p = p.right; } } } 中序遍历 //递归中序遍历 public void inOrder(TreeNode root) { if (Objects.isNull(root)) { return; } inOrder(root.left); // do something inOrder(root.right); } //非递归中序遍历 public void inOrderII(TreeNode root) { if (Objects.isNull(root)) { return; } TreeNode p = root; Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); while (!stack.isEmpty() || p != null) { while (p != null) { stack.push(p); p = p.left; } if (!stack.isEmpty()) { p = stack.pop(); // do something p = p.right; } } } 后序遍历 //递归后序遍历 public void postOrder(TreeNode root) { if (Objects.isNull(root)) { return; } postOrder(root.left); postOrder(root.right); // do something } //非递归后序遍历 public void postOrderII(TreeNode root) { if (Objects.isNull(root)) { return; } Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); Deque&lt;TreeNode&gt; list = new ArrayDeque&lt;&gt;(); Deque&lt;TreeNode&gt; reverse = new ArrayDeque&lt;&gt;(); TreeNode p = root; stack.push(p); while (!stack.isEmpty()) { p = stack.pop(); list.push(p); if (p.right != null) { stack.push(p.left); } if (p.left != null) { stack.push(p.left); } } while (!list.isEmpty()) { reverse.add(list.pop()); } } 层次遍历 public void levelOrder(TreeNode root) { if (Objects.isNull(root)) { return; } Deque&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); TreeNode p = root; queue.offer(p); while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i &lt; size; i++) { p = queue.poll(); if (p.left != null) { queue.offer(p.left); } if (p.right != null) { queue.offer(p.right); } } } } 公共祖先 树转链表 重新构建二叉树 路径之和 深度和高度 求二叉树深度 和 二叉树高度的差异，求深度适合用前序遍历，而求高度适合用后序遍历 因为深度可以从上到下去查 所以需要前序遍历(根左右)，而高度只能从下到上去查，所以只能后序遍历(左右根) LeetCode&amp;剑指offer 二叉树题目整理 二叉树的前序遍历 二叉树的中序遍历 二叉树的后序遍历 二叉树的高度 二叉树的直径 二叉树的深度 二叉树的层次遍历 层次遍历能解决很多关于二叉树的问题，目前根据考研经验以及LeetCode刷题总结，其作用范围大概如下： 二叉树的深度 最大深度 一次正常的层次遍历 最小深度 第一次遇到当前节点为叶子节点时遍历结束 二叉树的宽度 最大宽度 最小宽度 以上两道题可以感觉出，层次遍历将二叉树定在了一个二维的坐标轴上，二叉树的层为一个方向，深度为一个方向。只要是和层和深度相关的内容都可以考虑试试层次遍历。以下的内容也都是在层和深度的基础上的一些小变化（最直白的简单题） 每一层的平均值、最大值、最小值等 二叉树的左视图、右视图 相关变种题目： 102.二叉树的层序遍历 107.二叉树的层次遍历II 199.二叉树的右视图 637.二叉树的层平均值 429.N叉树的层序遍历 515.在每个树行中找最大值 116.填充每个节点的下一个右侧节点指针 117.填充每个节点的下一个右侧节点指针II 104.二叉树的最大深度 解法不唯一，也可使用后序遍历解决。 111.二叉树的最小深度 和上一题一样的思路，但是条件不一样 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 222.完全二叉树的节点个数 路径问题 是否有满足和为sum的路径 求所有慢煮和为sum的路径 构造二叉树 给定一个数组，构造二叉树/构建平衡二叉树 根据前序中序、后序中序构建二叉树 二叉树的序列化 根据数组判断是否为二叉排序树 公共节点 题解二叉树的高度思路： 递归 辅助队列 二叉树的直径思路：感觉是二叉树的高度的延伸，思路是和二叉树的高度是类似的。 直径： 以当前节点为基础，然后依次获取当前节点的最大左子树深度L和右子树最大深度R，L+R=D即为结果，然后从每个节点的D中选取最大的即可 private int ans; public int diameterOfBinaryTree(TreeNode root) { if (Objects.isNull(root)) { return 0; } ans = 0; depth(root); return ans-1; } private int depth(TreeNode root) { if (Objects.isNull(root)) { return 0; } int left = depth(root.left); int right = depth(root.right); ans = Math.max(ans, left+right); return Math.max(left, right) + 1; } 二叉树的层次遍历102.二叉树的层序遍历层次遍历的基础模板题目 public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; out = new ArrayList&lt;&gt;(); if (Objects.isNull(root)) { return result; } Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); TreeNode p = root; queue.offer(p); while (!queue.isEmpty()) { int size = queue.size(); for(int i = 0; i &lt; size; i++) { p = queue.poll(); out.add(p.val); if (p.left != null) { queue.offer(p.left); } if (p.right != null) { queue.offer(p.right); } } result.add(out); out = new ArrayList&lt;&gt;(); } return result; } 107.二叉树的层次遍历II层次遍历的简单变形，根据list的特性，每次新增一层的结果的时，都在首位插入，即可完成逆序存储 public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; out = new ArrayList&lt;&gt;(); if (Objects.isNull(root)) { return result; } Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); TreeNode p = root; queue.offer(p); while (!queue.isEmpty()) { int size = queue.size(); for(int i = 0; i &lt; size; i++) { p = queue.poll(); out.add(p.val); if (p.left != null) { queue.offer(p.left); } if (p.right != null) { queue.offer(p.right); } } result.add(0, out); out = new ArrayList&lt;&gt;(); } return result; } 199.二叉树的右视图 二叉树层次遍历的简单变形。 思路： 每次遍历到当前层的最后一个非空节点的时候，存入到右视图的list中 public List&lt;Integer&gt; rightSideView(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (Objects.isNull(root)) { return result; } TreeNode p = root; Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(p); while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i &lt; size; i++) { p = queue.poll(); // 每一层的最后一个节点 if (i == size - 1) { result.add(p.val); } if (p.left != null) { queue.offer(p.left); } if (p.right != null) { queue.offer(p.right); } } } return result; } 637.二叉树的层平均值 二叉树层次遍历的简单变形。 思路： 求每一层的平均值 429.N叉树的层序遍历 515.在每个树行中找最大值116.填充每个节点的下一个右侧节点指针117.填充每个节点的下一个右侧节点指针II104.二叉树的最大深度思路1 广度遍历(层次遍历) public int maxDepth(TreeNode root) { if (Objects.isNull(root)) { return 0; } TreeNode p = root; Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(p); int count = 0; while (!queue.isEmpty()) { int size = queue.size(); count++; for (int i = 0; i &lt; size; i++) { p = queue.poll(); if (p.left != null) { queue.offer(p.left); } if (p.right != null) { queue.offer(p.right); } } } return count; } 思路2 深度遍历(后序遍历) public int maxDepth(TreeNode root) { if (Objects.isNull(root)) { return 0; } int left = maxDepthII(root.left); int right = maxDepthII(root.right); return Math.max(left, right) + 1; } 111.二叉树的最小深度最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 image-20210223220242873 /** * 深度遍历（后序） * @param root * @return */ public int minDepth(TreeNode root) { if (Objects.isNull(root)) { return 0; } int left = minDepth(root.left); int right = minDepth(root.right); if (root.left == null &amp;&amp; root.right != null) { return 1 + right; } else if (root.left != null &amp;&amp; root.right == null) { return 1 + left; } return Math.min(left, right) + 1; } /** * 广度遍历（层次） * @param root * @return */ public int minDepthII(TreeNode root) { int count = 0; if (Objects.isNull(root)) { return count; } Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); TreeNode p = root; queue.offer(p); while (!queue.isEmpty()) { int size = queue.size(); count++; for (int i = 0; i &lt; size; i++) { p = queue.poll(); if (p.left != null) { queue.offer(p.left); } if (p.right != null) { queue.offer(p.right); } if (p.left == null &amp;&amp; p.right == null) { return count; } } } return count; } 222.完全二叉树的节点个数references 代码随想录","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"二叉树","slug":"二叉树","permalink":"https://winniekun.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"LinkedList源码解读","slug":"源码/JDK/list/linkedlist-analysis","date":"2020-02-11T01:17:29.000Z","updated":"2020-08-30T04:50:22.255Z","comments":true,"path":"linkedlist-analysis/","link":"","permalink":"https://winniekun.github.io/linkedlist-analysis/","excerpt":"LinkedList源码解读概述LinkedList底层数据结构是链表，是实现了List接口和Deque接口的双端链表，其能够高效的实现插入删除操作, 而且也拥有了队列所拥有的特性。和ArrayList相比，因为其没有实现RandomAccess，是以下标进行访问元素， 所以对于元素访问不及ArrayList，随机访问元素慢。同时需要注意的是, LinkedList不是线程安全的，需要使用的别的方式实现线程安全。","text":"LinkedList源码解读概述LinkedList底层数据结构是链表，是实现了List接口和Deque接口的双端链表，其能够高效的实现插入删除操作, 而且也拥有了队列所拥有的特性。和ArrayList相比，因为其没有实现RandomAccess，是以下标进行访问元素， 所以对于元素访问不及ArrayList，随机访问元素慢。同时需要注意的是, LinkedList不是线程安全的，需要使用的别的方式实现线程安全。 依赖 image 阅读套路按照正常的逻辑，首先了解其构造方法， 之后了解常用的API(CRUD)操作即可。 [x] addAll(); [x] add(); [x] remove(); [x] get(); 从节点数据结构开始 image 按照正常的逻辑， 首先基础的数据构造, 然后了解其构造方法， 之后了解常用的API(CRUD)操作即可。 其实一个很明显的双向链表的数据结构。 构造函数 空的构造方法 public LinkedList() { } 用于构造一个空的链表。然后自行处理 含有参数的构造方法(用已有的集合创建链表) public LinkedList(Collection&lt;? extends E&gt; c) { this(); addAll(c); } 将已有的linkedlist添加到一个新的linkedlist中(尾插法，下文有提及)。其类似于copy() 增：add相关的方法可以看到， 初始化之后，使用无参的构造方法，返回的为一个空的链表，若是为含有参数的构造方法，会调用addAll()方法将一个链表的所有元素都拷贝到一个新的元素。 这个部分涉及了大量的双向链表的插入删除，可先理解了双向链表的操作（3、 4步骤的操作顺序在于采用的是哪个节点作为基础节点：也就是选择待插入位置的节点还是该节点的前驱节点，或者是两个都使用，若是两个都是用则3、 4无顺序先后）。 addAll() public boolean addAll(Collection&lt;? extends E&gt; c) { // 以size为插入下标，插入集合c中所有元素 return addAll(size, c); } public boolean addAll(int index, Collection&lt;? extends E&gt; c) { // 判断当前的索引是否越界， 若是越界， checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; // pred: 插入位置对应的节点的前驱节点 // succ: 插入位置对应的节点 // 以下为双向链表的插入操作需要的预备工作 Node&lt;E&gt; pred, succ; if (index == size) { // 在链表的尾部插入节点需要的预备工作 succ = null; pred = last; } else { // 在链表中间插入节点需要的预备工作 // 1. 确定插入位置的节点 // 2. 确定插入位置的节点的前驱节点 succ = node(index); pred = succ.prev; } // 插入节点 可画图理解 for (Object o : a) { @SuppressWarnings(\"unchecked\") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; } if (succ == null) { last = pred; } else { pred.next = succ; succ.prev = pred; } size += numNew; modCount++; return true; } addAll()主要为就是依次的遍历已有集合的所有元素，然后依次进行插入(尾插法，保证插入的顺序不会和最后的顺序不变) 判断越界方法private void checkPositionIndex(int index) { if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } private boolean isPositionIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt;= size; } 直接在if后跑出异常，可直接跑出异常信息，并且可以根据自己定义信息跑出异常。 add(E e)public boolean add(E e) { linkLast(e); return true; } void linkLast(E e) { // 在链表尾部插入元素 final Node&lt;E&gt; l = last; // 定义一个新的节点l, 指向尾节点，方便后续插入 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);// 创建插入元素的节点 // 以下为插入操作，可画图理解 last = newNode; if (l == null) // 说明原链表为空，更新头节点 first = newNode; else // 原链表不为空， 在尾部进行插入操作 l.next = newNode; size++; modCount++; } add(int index, E element)public void add(int index, E element) { checkPositionIndex(index); // 链表尾部插入元素 if (index == size) linkLast(element); // 在链表的中间部分插入元素 else linkBefore(element, node(index)); } void linkLast(E e) { // 在链表尾部插入元素 final Node&lt;E&gt; l = last; // 定义一个新的节点l, 指向尾节点，方便后续插入 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);// 创建插入元素的节点 // 以下为插入操作，可画图理解 last = newNode; if (l == null) // 说明原链表为空，更新头节点 first = newNode; else // 原链表不为空， 在尾部进行插入操作 l.next = newNode; size++; modCount++; } void linkBefore(E e, Node&lt;E&gt; succ) { // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); // 一下为双端链表的插入操作 succ.prev = newNode; // 若是在第一个节点前插入， 则插入节点为第一个节点 if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; } Node&lt;E&gt; node(int index) { // assert isElementIndex(index); // 根据索引创建节点 // 此处会有判断，判断是在链表的前半段还是后半段 // 加快查找效率 if (index &lt; (size &gt;&gt; 1)) { Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; } else { Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; } } 小结 链表批量增加，是靠for循环遍历原数组，依次执行插入节点操作。对比ArrayList是通过System.arraycopy完成批量增加的 通过下标获取某个node 的时候，（add select），会根据index处于前半段还是后半段 进行一个折半，以提升查询效率 删： remove相关的方法remove() public E remove() { // 默认是从链表的头部开始删除元素 return removeFirst(); } public E removeFirst() { final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); } private E unlinkFirst(Node&lt;E&gt; f) { // assert f == first &amp;&amp; f != null; // 删除第一个节点 final E element = f.item; final Node&lt;E&gt; next = f.next; // 防止删除时导致的断链 f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element; } remove(int index)下图为双向链表的删除操作，仅做参考，具体的写法依据个人采用基础节点。 mage public E remove(int index) { // 判断是否越界 checkElementIndex(index); return unlink(node(index)); } private void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } private boolean isElementIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt; size; } E unlink(Node&lt;E&gt; x) { // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; // 后继节点 final Node&lt;E&gt; prev = x.prev; // 前驱节点 // 删除的为第一个节点 if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } // 删除的为最后一个节点 if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; modCount++; return element; } 判断越界方法其实是和增里面的判断是一样的 private void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } private boolean isElementIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt; size; } remove(Object o)public boolean remove(Object o) { if (o == null) { for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) { unlink(x); return true; } } } return false; } E unlink(Node&lt;E&gt; x) { // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; // 后继节点 final Node&lt;E&gt; prev = x.prev; // 前驱节点 // 删除的为第一个节点 if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } // 删除的为最后一个节点 if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; modCount++; return element; } 小结删也一定会修改modCount。 按下标删，也是先根据index找到Node，然后去链表上unlink掉这个Node。 按元素删，会先去遍历链表寻找是否有该Node，考虑到允许null值，所以会遍历两遍，然后再去unlink它。 改：set()相关的方法set(int index, E element) public E set(int index, E element) { checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal; //返回原先的值 } private void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } private boolean isElementIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt; size; } Node&lt;E&gt; node(int index) { // assert isElementIndex(index); // 根据索引创建节点 // 此处会有判断，判断是在链表的前半段还是后半段 // 加快查找效率 if (index &lt; (size &gt;&gt; 1)) { Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; } else { Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; } } 小结set()也是根据索引去寻找对应Node()，之后替换，但是不会修改modCount 查： get相关方法get(int index)public E get(int index) { checkElementIndex(index); return node(index).item; } Node&lt;E&gt; node(int index) { // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) { Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; } else { Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; } } 判断越界方法其实是和增里面的判断是一样的 private void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } private boolean isElementIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt; size; } 小结按照索引查找对应的节点，之前的增、删、改都用到了 总结LinkedList是双向链表 链表的批量添加(addAll())是转化为数组之后使用for-each进行添加，默认在链表尾部添加， 会修改modCount 根据index获取节点时，会根据index处于后半段还是前半段进行查找，提升查找速率 所有的CRUD中都有涉及根据index去寻找节点 LinkedList中还有很多的API没有写，只是简单的写了基础的CRUD reference JavaGuid—-LinkedList 面试必备：LinkedList源码解读(JDK8) 王道考研数据结构—-链表一章 考研的时候看的，各种花式插入删除整合骚操作。 大话数据结构","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"List","slug":"List","permalink":"https://winniekun.github.io/tags/List/"}]},{"title":"ArrayList源码解读","slug":"源码/JDK/list/arrayList-analysis","date":"2020-02-10T01:49:19.000Z","updated":"2020-08-30T04:50:22.254Z","comments":true,"path":"arrayList-analysis/","link":"","permalink":"https://winniekun.github.io/arrayList-analysis/","excerpt":"ArrayList 源码解读","text":"ArrayList 源码解读 依赖 ArrayList依赖 关于为什么ArrayList已经继承了AbstractList还要实现List接口, 可参考 Why does LinkedHashSet extend HashSet and implement Set StackOverflow解释 可能这样增加可读性吧, 接口的第二个功能一样 字段 /** * Default initial capacity. * 默认初始化容量 */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances * 空实例的共享数组实例 * 若是无参构造方法 使用 DEFAULTCAPACITY_EMPTY_ELEMENTDATA; * 若是含参构造方法 使用 EMPTY_ELEMENTDATA */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. * */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */ transient Object[] elementData; // non-private to simplify nested class access /** * The size of the ArrayList (the number of elements it contains). * * @serial */ private int size; /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit * 某些 VM 保留数组头部用于存储一些 header words */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 可以发现, elementData 和 size 两个变量在ArrayList的运行中会有很大的变动, 可以使用反射进行观察 构造函数ArrayList()/** * 构造函数1: 默认构造函数, * DEFAULTCAPACITY_EMPTY_ELEMENTDATA = 0, * 初始是一个空数组, 当添加一个元素的时候, 扩充为10(如何扩充为10, 详见下述) * 原因详见 transient Object[] elementData上的注释 */ public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } 也就是在创建对象的时候，并没有立刻初始化容器的大小，直到第一次调用 add()方法的时候，才进行确定。 ArrayList(int initialCapacity)/** * 构造函数2 带初始容量参数的构造函数, (用户自己定义容量) */ public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } 初始化容量大小为initialCapactiy ArrayList(Collection&lt;? extends E&gt; c)/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null * 构造包含指定collection元素的列表 这些元素利用该集合的迭代按顺序返回 * 如果指定的集合为null, 抛出 NullPointerException */ public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; } } 总结 常量EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA是为了初始化elementData的。如果为无参构造函数，使用DEFAULTCAPACITY_EMPTY_ELEMENTDATA；如果为含参构造函数，使用EMPTY_ELEMENTDATA 以无参构造方法创建arraylist时, 实际上初始化的值是一个空数组. 添加第一个元素时 扩容为10 如果使用Collection实例初始化, 不为空将调用toArray()方法初始化elementData, 为空时初始化为空数组EMPTY_ELEMENTDATA 增add(E e)public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } 在调用 add()方法的时候，首先调用 ensureCapacityInternal()方法来确定是否还有容量来容纳新的值。size是表示数组的初始大小，默认为 0 。 ArrayList-add执行步骤 按照流程走一遍: 第一次调用的时候: 第一步, 因为还为添加成功元素, size = 0 , size + 1 = 1 第二步, 首先执行第三步, 传入两个参数elementData和minCapacity 第三步, 此时的elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATAT, 然后 minCapaciy==1, 返回DEFAULT_CAPACITY 第四步, 此时的minCapacity==10 , elementData.length = 0 所以执行if分支 第五步, oldCapacity==0 经计算newCapacity==0 然后newCapacity-minCapacity&lt;0, 所以newCapacity==10 之后进行数据的复制，这时，elementData的长度是 10.，第一个元素成功的添加到数组中。 第二次调用 第一步, 因为已经添加成功了一个元素, size = 1 , size + 1 = 2 第二步, 首先执行第三步, 传入两个参数elementData和minCapacity 第三步, 此时的elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATAT, 然后 minCapaciy==2, 不执行if分支, 返回 2 第四步, 此时的minCapacity==2 , elementData.length = 10 所以不执行执行if分支, 也就是无需扩容 反复添加直到添加第11个元素的时候, 再次出发第四步的grow, 进行扩容, 扩为原先的1.5倍. add(int index, E element)public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } 使用arraycopy方法, 可以看做将指定坐标位置以及右侧所有元素向后移动一位，腾出空间存放新元素。 addAll(Collection&lt;? extends E&gt; c)public boolean addAll(Collection&lt;? extends E&gt; c) { Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; } addAll(int index, Collection&lt;? extends E&gt; c)public boolean addAll(int index, Collection&lt;? extends E&gt; c) { rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; } 总结 共实现四中添加方法: 添加单个元素(默认在尾部添加) 在指定位置添加单个元素 添加一个集合(默认在末尾) 在指定位置添加一个集合 每次执行add操作时都会首先调用 ensureCapacityInternal()方法来确定是否还有容量来容纳新的值, 若是没有则进行扩容, 有则直接添加 删remove()方法用来从集合中删除一个元素，可以删除指定索引出的元素，也可以指定元素。 remove(Object o)public boolean remove(Object o) { if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } // 将index位置后的所有元素前移一位, 之后size-1 private void fastRemove(int index) { modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work } 流程走一遍 ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(\"a\"); arrayList.add(\"b\"); arrayList.add(\"c\"); arrayList.remove(\"a\"); 要删除a这个元素，把 a传入到 remove()这个方法，首先进行判断是否为null，因为 ArrayList可以存放 null，如果为 null 则用==判断元素是否相等，否则用 equals()方法进行判断。 然后循环遍历 elementData这个数组，size为数组元素个数，找到和 a相等的元素的索引，例子中 index = 0， 然后把 0 传入到 fastRemove()方法中，之后计算要移动的元素的个数： int numMoved = size - index -1; 例子中 numMoved = 3 - 0 -1 = 2，也就是一共要移动两个元素，然后把 a之后的两个元素往前移动，然后进行 size-1，把最后一个元素位置的值设置为 null。 这样即可在ArrayList中删除一个元素。 remove(int index)public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; } 总结没啥好总结的 查public E get(int index) { // 判断查询的位置是否符合要求 rangeCheck(index); return elementData(index); } private void rangeCheck(int index) { if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } E elementData(int index) { return (E) elementData[index]; } 没啥好说的, 就是正常数据的使用 附加hugeCapacity 方法 private static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 只有newCapacity &gt;MAX_ARRAY_SIZE 才回调用该方法, 方法中使用三元运算, 意思是若果minCapacity&gt; MAX_ARRAY_SIZE 则newCapacity的容量大小为Integer.MAX_VALUE也就是2**31次方, 若是minCapacity&lt; MAX_ARRAY_SIZE 则newCapacity的容量大小为Integer.MAX_VALUE-8 ensureCapacity用法Arraylist源码中有一个ensureCapacity方法 /*** * 如有必要，增加此 ArrayList 实例的容量， * 以确保它至少可以容纳由minimum capacity参数指定的元素数。 */ public void ensureCapacity(int minCapacity) { int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) { ensureExplicitCapacity(minCapacity); } } 该方法适用于添加大量的元素, 以减少上文的增量重新分配的次数 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); final int N = 10000000; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; N; i++) { list.add(i); } long endTime = System.currentTimeMillis(); System.out.println(\"使用ensureCapaticy方法之前: \"+ (endTime - startTime)); list = new ArrayList&lt;&gt;(); list.ensureCapacity(N); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; N; i++) { list.add(i); } endTime = System.currentTimeMillis(); System.out.println(\"使用ensureCapaticy方法之后: \"+ (endTime -startTime)); 使用ensureCapaticy方法之前: 3345 使用ensureCapaticy方法之后: 257 总结ArrayList集合底层是用一个 Object 数组来存放元素的，其可以存放 null 值，因为是使用数组来存放元素，所以在知道索引的情况下，进行元素的查找是很快的，但是也有缺点，如果数组的容量不能够存放新元素的时候，会进行数组的扩容，也就是把数组元素复制到一个容量更大的数组中，所以如果在经常进行元素添加和删除操作的情况下效率会比较低。还有一点，ArrayList不是线程安全的，要保证线程安全，可以使用 Vector代替。 System.arraycopy(src, srcPos, dest, destPos, length) 与 Arrays.copyOf(original, newLength)区别arraycopy()的参数 src:源数组; srcPos:源数组要复制的起始位置; dest:目的数组; destPos:目的数组放置的起始位置; length:复制的长度. 两者的区别在于，Arrays.copyOf()不仅仅只是拷贝数组中的元素，在拷贝元素时，会创建一个新的数组对象。而System.arrayCopy只拷贝已经存在数组元素, 是否创建新的数据对象,根据写法而定 //System.arraycopy,只拷贝已存在的数组元素 int[] src = {0, 1, 2}; int[] dest = new int[3]; System.arraycopy(src, 0, dest, 0, src.length); System.out.println(Arrays.toString(dest)); //[0, 1, 2] //Arrays.copyOf,会创建一个新的数组对象 int[] src = {0, 1, 2}; int[] dest = Arrays.copyOf(src, src.length); System.out.println(Arrays.toString(dest)); //[0, 1, 2] 实际上Arrays.copyOf方法的内部实现也是通过System.arraycopy方法实现，在Arrays类中有多个copyOf的重载方法，现以拷贝int[]为例： 1 public static int[] copyOf(int[] original, int newLength) { 2 int[] copy = new int[newLength]; 3 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); 4 return copy; 5 } References ArrayList源码 ArrayList源码分析","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"List","slug":"List","permalink":"https://winniekun.github.io/tags/List/"}]},{"title":"Volatile关键字内涵","slug":"Java进阶/并发/Volatile关键字内涵","date":"2020-01-18T04:35:26.000Z","updated":"2021-05-31T15:43:04.259Z","comments":true,"path":"Volatile关键字内涵/","link":"","permalink":"https://winniekun.github.io/Volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%86%85%E6%B6%B5/","excerpt":"内涵与表象","text":"内涵与表象 volatile主要有一下的功能： 保证变量的内存可见性 内存可见性：通俗来说就是，线程A对一个volatile变量的修改，对于其它线程来说是可见的，即线程每次获取volatile变量的值都是最新的 禁止volatile变量与普通变量重排序 定义: Volatile是轻量级的synchronized。它在多处理器开发过程中保证的共享变量的可见性、有序性 使用volatile的使用场景但是使用volatile必须满足两个条件： 对变量的写操作不依赖当前值，如多线程下执行a++，是无法通过volatile保证结果准确性的 该变量没有包含在具有其它变量的不变式中(如下例子解释) public class NumberRange { private volatile int lower = 0; private volatile int upper = 10; public int getLower() { return lower; } public int getUpper() { return upper; } public void setLower(int value) { if (value &gt; upper) throw new IllegalArgumentException(...); lower = value; } public void setUpper(int value) { if (value &lt; lower) throw new IllegalArgumentException(...); upper = value; } } 若是有两个线程同时分别执行了setLower(8)和setUpper(5) 然后 均通过了判断, 则最后的范围从$[0, 10]$ 变为了 $[8, 5]$成为了一个无效的范围, 这样就出现了问题. 这种场景下就只能使用synchronized, 同一时间只允许getLower和getUpper方法中其中一个执行 状态标记量public class ServerHandler { private volatile isopen; public void run() { if (isopen) { //促销逻辑 } else { //正常逻辑 } } public void setIsopen(boolean isopen) { this.isopen = isopen } } 单例模式的double check单例模式的一种实现方式，但很多人会忽略volatile关键字，因为没有该关键字，程序也可以很好的运行，只不过代码的稳定性总不是100%，说不定在未来的某个时刻，隐藏的bug就出来了。 public class Singleton{ private volatile static Singleton instance; public static Singleton getInstance(){ if(instance == null){ sychronized(Singleton.class){ if(instance == null){ instance = new Singleton(); } } } return instance; } } 在JMM中, 有主内存和本地内存, 每个线程都有一个本地内存, 且共享主内存中的数据, 普通变量和volatile变量的区别如下: 普通变量进行读操作的时候, 首先会读取本地内存中的数据, 若是不存在, 则去主内存中拷贝一份在本地内存, 写操作只会写入到本地内存. 这样其他变量就不会读取变量的最新值 voaltile遍历进行读操作的时候, JMM会将本地内存的数据设置为无效, 要求线程从主内存读取数据, 写操作时, JMM会将工作内存中的数据刷新到主内存中. 这样其他遍历就能够读取变量的最新值 可见性、有序性实现原理可见性： volatile修饰的变量进行写操作转换成汇编语言，会添加Lock前缀的指令 lock前缀的指令在多核处理器的情况下，会引发以下的两个事情： 会将当前处理器缓存的数据，写回主内存 同时写回内存的操作，会使得其他处理器缓存的该内存地址的数据无效 多处理器下，为了确保多处理器的缓存是一致的，会去实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检测自己缓存的数据是否过期。如果发现缓存的内存地址被修改，会将自身缓存的内存地址置为无效，然后下次操作该数据的时候，重新从主存中将数据重新读取缓存 有序性禁止重排序JVM通过内存屏障来实现限制处理器的重排序。 什么是内存屏障？硬件层面，内存屏障分两种：读屏障（Load Barrier）和写屏障（Store Barrier）。内存屏障有两个作用： 阻止屏障两侧的指令重排序； 强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。 编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。编译器选择了一个比较保守的JMM内存屏障插入策略，这样可以保证在任何处理器平台，任何程序中都能得到正确的volatile内存语义。这个策略是： 在每个volatile写操作前插入一个StoreStore屏障； 在每个volatile写操作后插入一个StoreLoad屏障； 在每个volatile读操作后插入一个LoadLoad屏障； 在每个volatile读操作后再插入一个LoadStore屏障。 大概示意图是这个样子： 内存屏障 再介绍一下volatile与普通变量的重排序规则: 如果第一个操作是volatile读，那无论第二个操作是什么，都不能重排序； 如果第二个操作是volatile写，那无论第一个操作是什么，都不能重排序； 如果第一个操作是volatile写，第二个操作是volatile读，那不能重排序。 References Java并发编程的艺术 深入浅出Java多线程","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://winniekun.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"Synchronize关键字内涵","slug":"Java进阶/并发/Synchronize关键字内涵","date":"2020-01-18T04:35:12.000Z","updated":"2021-06-05T08:52:56.318Z","comments":true,"path":"Synchronize关键字内涵/","link":"","permalink":"https://winniekun.github.io/Synchronize%E5%85%B3%E9%94%AE%E5%AD%97%E5%86%85%E6%B6%B5/","excerpt":"内涵与表象","text":"内涵与表象 synchronized关键字的解释如下： Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。 根据定义，会考虑两个方面的问题： synchronized是如何保证在同一时刻最多只有一个线程执行该段代码 保证在同一时刻最多只有一个线程执行该段代码，这又带来什么意义 老司机级别的解释： Java中的synchronized，通过使用内置锁，来实现对共享变量的同步操作，进而解决了对共享变量操作的原子性、保证了其他线程对共享变量的可见性、有序性，从而确保了并发情况下的线程安全。 原子性synchronized关键字的一个作用就是确保了原子性。 譬如使用count++而言，原先其执行需要三个步骤： 读取count值 count+1 写入count 值 其包含了三个步骤，且每次的步骤都依赖于上一次的结果。所以不是原子性的 synchronized(this){ count++; } 使用如上的方式，就确保了原子性。因为原子操作是线程安全的，这其实也是我们经常使用synchronize来实现线程安全的原因。 如何实现的原子性？ 因为synchronized被编译之后，使用的是monitorenter和monitroexit两个字节码指令，而这两个字节码指令实质上是依赖于操作系统中的互斥锁（mutex lock）实现。通过互斥锁，保证了同一时刻，只有一个线程修改了该共享变量，所以确保了原子性 可见性、有序性synchronize的确保原子性，其实是从使用synchronize的线程的角度来讲的，而如果我们从其他线程的角度来看，那么synchronize则是实现了可见性、有序性。 可见性：一个线程修改了共享变量的值，其他线程能够立即得知这个修改 有序性： Java程序中的天然有序性是指：如果在本线程内观察，所有的操作都是有序的，如果在另一个线程中观察另一个线程，那么所有的操作都是无序的 前半句是指线程内表现为串行的语义（as-if-serial规则） 后半句是指指令重排和工作内存和主内存同步延迟导致的现象 synchronzied如何保证可见性： JMM规定：一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。 synchronzied如何保证有序性： 锁自身的作用来或者说JMM的规定：一个变量在同一时刻只允许一条线程对其进行lock操作 内置锁在Java中，每个对象都有一把锁，放置于对象头中，用于记录当前对象被哪个线程所持有。相对于实例数据，对象头属于额外开销，所以被设计的极小来提高效率。对象头中的markword更加体现了这一点，且是非结构化的，这样在不同的锁状态下，能够复用相同的bit位，markword中就有存储锁的信息的部分。 markword 我们知道在Java中Synchronized能够实现的线程的同步，synchronized被编译之后会生成monirotenter和monitorexit两个字节码指令，依赖这两个字节码指令实现线程同步。 Monirtor：可以理解为只能容纳一名客人的房间，而线程可以等比于客人。整个状态的流转可以理解为一个状态机，同一时刻只有一个线程处于Active状态。 monitor Every object has an intrinsic lock associated with it. —— The Java™ Tutorials 普通同步方法 锁的是当前实例对象 静态同步方法 锁的是该类的Class对象 同步代码块儿 锁的是括号内的对象 因为synchronized被编译之后，使用的是monitorenter和monitroexit两个字节码指令，而这两个字节码指令实质上是依赖于操作系统中的互斥锁（mutex lock）实现，同时Java线程可以理解为对操作系统中线程的映射，所以每当挂起/唤醒一个线程，都需要涉及到操作系统的内核态内容的切换。属于重量级操作，甚至是有可能切换的时间远远超过于线程本身的运行时间。但是从Java6开始，引入了偏向锁、轻量级锁、重量级锁的锁优化过程，进而优化了其性能。 无锁定义：不锁住资源，多个线程中有一个能修改资源成功，其他线程会重试，通过CAS实现 偏向锁定义：偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。 依据：在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。 当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。==在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。==引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。 ==偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。== 偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。 轻量锁定义： 当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。 虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。 如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁 重量锁互斥锁 可重入：public class Widget{ public synchronized void doSomething(){ ... } } public class LoggingWidget extends Widget { public synchronized void doSomething(){ sout(\"...\"); super.doSomething(); } } 如果没有可重入性，那么该代码会产生死锁。 可重入的定义： 若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。 —- 维基百科 从设计上讲，当一个线程请求一个由其他线程持有的对象锁时，该线程会阻塞。当线程请求自己持有的对象锁时，如果该线程是重入锁，请求就会成功，否则阻塞。 synchronized拥有强制原子性的内部锁机制，是一个可重入锁。因此，在一个线程使用synchronized方法时调用该对象另一个synchronized方法或调用父类的synchronized方法，即一个线程得到一个对象锁后再次请求该对象锁，是永远可以拿到锁的。 在Java内部，同一个线程调用自己类中其他synchronized方法/块时不会阻碍该线程的执行，同一个线程对同一个对象锁是可重入的，同一个线程可以获取同一把锁多次，也就是可以多次重入。原因是Java中线程获得对象锁的操作是以线程为单位的，而不是以调用为单位的。 总结 Java中每个对象都有一个内置锁。 synchronized使用对象自带的内置锁来进行加锁，从而保证在同一时刻最多只有一个线程执行代码。 所有的加锁行为，都可以带来三个个保障——原子性、可见性、有序性。其中，原子性是相对锁所在的线程的角度而言，而可见性、有序性则是相对其他线程而言。 锁的持有者是线程，而不是调用，这也是锁的为什么是可重入的原因。 References Java并发编程实战 深入浅出Java多线程 Java多线程：synchronized的可重入性","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://winniekun.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"在IDEA中搭建JDK1.8阅读环境","slug":"配置/在IDEA中搭建JDK1-8阅读环境","date":"2020-01-15T12:27:15.000Z","updated":"2020-08-30T04:50:22.263Z","comments":true,"path":"在IDEA中搭建JDK1-8阅读环境/","link":"","permalink":"https://winniekun.github.io/%E5%9C%A8IDEA%E4%B8%AD%E6%90%AD%E5%BB%BAJDK1-8%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83/","excerpt":"前言自己从去年12月份开始看JDK上的部分源码，之前因为是懒，觉得看源码嘛，看嘛，突出看。直接就是阅读源码，然后每个代码逻辑都是靠自己推测， 还有理解， 并没有看输出， 现在才发现在IDEA中File | Settings | Build, Execution, Deployment | Debugger | Stepping中可以将Do not step into the classes即可，当然，若是想直接在源码中添加注释，需要进行一些配置。","text":"前言自己从去年12月份开始看JDK上的部分源码，之前因为是懒，觉得看源码嘛，看嘛，突出看。直接就是阅读源码，然后每个代码逻辑都是靠自己推测， 还有理解， 并没有看输出， 现在才发现在IDEA中File | Settings | Build, Execution, Deployment | Debugger | Stepping中可以将Do not step into the classes即可，当然，若是想直接在源码中添加注释，需要进行一些配置。 JDK1.8在IDEA中搭建阅读环境第一步解压系统JDK所在路径中的sc.zip 到自定义的文件中，譬如src中的source jdk-项目结构.png 第二步导入到自己的源码工程文件中 第三步修改工程文件中SDKs的Sourcepath 将sc,zip替换成图一中sc.zip解压到的文件。javafx-src.zip不动。如下图： jdk-sdks.png References JDK1.8源码分析03之idea搭建源码阅读环境 idea中搭建jdk1.8源码阅读环境","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"配置","slug":"配置","permalink":"https://winniekun.github.io/tags/%E9%85%8D%E7%BD%AE/"}]},{"title":"2020年书单【年终汇总】","slug":"碎碎念/2020年书单【年终汇总】","date":"2019-12-31T16:00:01.000Z","updated":"2022-07-16T02:00:27.581Z","comments":true,"path":"2020年书单【年终汇总】/","link":"","permalink":"https://winniekun.github.io/2020%E5%B9%B4%E4%B9%A6%E5%8D%95%E3%80%90%E5%B9%B4%E7%BB%88%E6%B1%87%E6%80%BB%E3%80%91/","excerpt":"我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 摘自鶸道场 趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。","text":"我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 摘自鶸道场 趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。 书籍相关 LaTeX快速入门与提高 剑指Offer Java并发编程的艺术 Java并发编程实战 图解密码学技术 Redis设计与实现 深入分析Java Web技术内幕 深入理解JVM虚拟机 记得刚买的时候，是真的完全看不懂 现在有一些知其然了 图解HTTP 面试的时候，网络太糟糕 Mysql必知必会 高性能MySQL Linux-UNIX系统编程手册（上册） Linux-UNIX系统编程手册（下册） Java 8函数式编程 太欺负人了，我咋就不知道用各种流和optional 论文 少数决：更安全的分布式一致性算法选举机制 欺诈游戏的应用？？？ 电影、电视剧、综艺、纪录片 黑镜 岬童夷 如实陈述 挺好看的 使徒行者 刚上映的时候看过了, 然后又重新看了一遍 这种兄弟情真的是很棒棒哇!!! 反转也有 四大名捕 I、IV 现在还记得当初的版权意识有多差，当初四大名捕I一上线，我晚上就搜到了高清资源 云飞丝路天 疫情宅家，和父母一起看的 致命弯道 I、II、III、IV 握草，一部比一部恶心，有点儿反胃 谤法 人体蜈蚣I、II 握草，太尼玛恶心了 致命弯道是物理攻击的话， 那么这个是灵魂攻击 握草，太恶心了 决胜法庭 和女朋友一起看的 钢琴家 一堵墙，隔绝了人性和人性；一堵墙，囚禁住所有的理性。 彗星来的那一夜 狼溪 发现最近的口味有些重啊！！！ 时空恋旅人 能穿越真好 享受当下 饥饿站台 和女朋友一起看的 法医秦明 第一部 图个乐呗 安家 不知道为啥， 看着挺过瘾的😄 一个下午加一个晚上刷完了 感觉后面烂尾了 夫妻的世界 哇，才发现原来男女主，都已经50多了 我靠， 当悬疑剧来看的 VIP 说真的，虽然我还没有进入职场 但是，感觉韩剧拍的职场剧才是真的职场剧 国内的总感觉是在玩儿 张娜拉还是那么漂亮 一人之下III 我靠，终于更新了 感觉打斗场面很棒棒 在我心里，国番第二，罗小黑永远第一！！！ 我靠，SB吧，有些人，因为一件衣服导致整改！！！ 怎么就有那么些人见不得别人好 大理寺日志 刚开始看，感觉很不错 庆余年 之前只是觉得很搞笑，没有看，但是这几天看了精彩剪辑，发现很好看。 感觉和宋大志是一个类型的。 38师机动队 马东锡!!! 38指韩国税金征收法 老师 好 哇, 悲情结局哇 活着 韩国的丧失拍的真好 雾山五行 ORZ !!! 灵笼 感觉哈，单纯的感觉，主体思想因该是和进击的巨人差不多 好看还是好看 元龙 修仙爽文 十面埋伏 在江湖和官府的这些恩怨纠葛中，登锋履刃、冲锋陷阵的永远都是无足轻重的小人物，在既是当权者又是施暴着统治的封建王朝中，连爱情和自由都无法获得的他们，更不会有揭竿而起，拯救苍生，悬壶济世的英雄战记。有的也只不过是“天地逍遥任我游”的最后一丝慰藉。 排球少年 暖 改编自莫言的小说《白狗秋千架》 对于爱情，年轻的我们都会迫不及待的用各种方式表达炽热和真心，承诺就是其中最轻易最有表现力的一种。 也希望能够清楚在每一份承诺的重量。 功夫梦 never say never 女王的棋局 围棋少年？？？江流儿？？？ 棋魂","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"书单","slug":"书单","permalink":"https://winniekun.github.io/tags/%E4%B9%A6%E5%8D%95/"}]},{"title":"注解和反射","slug":"Java基础/注解和反射","date":"2019-12-10T10:51:29.000Z","updated":"2020-08-30T04:50:22.244Z","comments":true,"path":"注解和反射/","link":"","permalink":"https://winniekun.github.io/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/","excerpt":"注解这里主要涉及的是四个基础的元注解(meta-annotation) Java中的注解，有四个基本的元注解target Retention Documented Inherited 这四个元注解Documented和Inherited使用不多，主要为target retention两个注解","text":"注解这里主要涉及的是四个基础的元注解(meta-annotation) Java中的注解，有四个基本的元注解target Retention Documented Inherited 这四个元注解Documented和Inherited使用不多，主要为target retention两个注解 Target描述注解的使用范围(即被修饰的注解可以用在什么地方). public @interface Target { /** * Returns an array of the kinds of elements an annotation type * can be applied to. * @return an array of the kinds of elements an annotation type * can be applied to */ ElementType[] value(); } 使用的范围也就是ElementType[]中的枚举类型数据 public enum ElementType { /** Class, interface (including annotation type), or enum declaration */ TYPE, // 类、接口、枚举 /** Field declaration (includes enum constants) */ FIELD, // 成员变量 /** Method declaration */ METHOD, // 成员方法 /** Formal parameter declaration */ PARAMETER, // 方法参数 /** Constructor declaration */ CONSTRUCTOR, // 构造方法 /** Local variable declaration */ LOCAL_VARIABLE, // 局部变量 /** Annotation type declaration */ ANNOTATION_TYPE, // 注解类 /** Package declaration */ PACKAGE, // 包 /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, // 类型参数（泛型） /** * Use of a type * * @since 1.8 */ TYPE_USE } Retention描述注解保留的时间范围(即：被描述的注解在它所修饰的类中可以被保留到何时). Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略 public enum RetentionPolicy { // 源文件保留 SOURCE, // 编译期保留，默认值 CLASS, // 运行期保留，可通过反射去获取注解信息 RUNTIME } 反射正常方式: 引入需要的包类名称 —-&gt; 通过 new实例化 —-&gt; 获取实例化对象 反射: 实例化对象 —-&gt; getClass()方法 —-&gt; 得到完整的包类名称 通过反射， 使得Java具有类似动态语言的特性 反射所提供的功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的成员变量和方法 在运行时获取泛型信息 在运行时处理注解 生成动态代理 …… 反射优点和缺点优点: 可以动态创建和编译，有很大的灵活性 缺点: 慢于直接执行相同的操作 获取Class类的实例 已知某个类的实例 User user = new User(); Class&lt;? extends User&gt; aClass1 = user.getClass(); 已知具体的类 Class&lt;User&gt; aClass2 = User.class; 已知类的全名称 Class&lt;?&gt; aClass3 = Class.forName(\"com.xxx.xxx\"); 类的加载过程|—————————| |——————————| |————————————| | 类的加载 | ------&gt; | 类的链接 | -------&gt; | 类的初始化 | | Load | -----&gt; | Link | -------&gt; | Initialize | |—————————| |——————————| |————————————| 获取Class对象之后可以做写什么 创建类的对象 aClass.newInstance(); // 本质是调用了无参构造器 若是没有无参构造器，可以通过明确调用对应的构造器，然后将参数传递进去即可 aClass.getDeclaredConstrutor(Class...parameterTypes) 可以调用类中的方法 User user = (User) aClass.newInstance(); Method setName = aClass.getDeclaredMethod(\"setName\", String.class); // invoke: 激活 // (对象, \"方法的值\") setName.invoke(user, \"维坤坤\"); System.out.println(user.getName()); 操作类中的属性 //反射操作属性 User user3 = (User) aClass.newInstance(); Field name = aClass.getDeclaredField(\"name\"); // 不能操作私有属性 需要关闭安全检测 name.setAccessible(true); name.set(user3, \"孔维坤\"); System.out.println(user3.getName()); 注解和反射的实际应用编写一个注解，适用于成员方法，然后运行保留 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface AAAA { String value() default \"\"; } 通过反射获取注解中的内容 public class ReAno { @AAAA(\"我是方法注解\") public void say(int a){ System.out.println(\"wtf \" + a); } public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException { // 通过反射获取类 Class&lt;ReAno&gt; reAnoClass = ReAno.class; Method say = reAnoClass.getDeclaredMethod(\"say\", int.class); AAAA annotation = say.getAnnotation(AAAA.class); System.out.println(annotation.value()); // 输出: 我是方法注解 } } 总结通过反射获取注解的方式就是注解应用在什么范围， 就先通过反射获取对应的方法、或者成员变量，然后获取其注解即可。","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://winniekun.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"并发&I/O基本概念","slug":"Java进阶/并发/并发基本概念","date":"2019-12-06T03:13:58.000Z","updated":"2021-06-05T08:46:59.809Z","comments":true,"path":"并发基本概念/","link":"","permalink":"https://winniekun.github.io/%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"同步与异步","text":"同步与异步 同步进程和线程都是并发执行的，不同的进程之间，存在不同的相互制约关系。为了协调这种制约关系，引入了同步的概念。 举例说明：系统计算1+2×3。假设有两个进程进行计算该公式，一个是加法进程，一个是乘法进程。如果要计算正确，要先执行乘法进程，然后执行加法进程。但是因为系统的异步性（并发、虚拟、异步、共享），若是不加以制约，无法保证乘法进程在加法进程之前执行的。所以要制定一些机制去约束加法进程，让他在乘法进程完成之后运行。 同步同步也称为直接制约关系，是指一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。 互斥互斥也称为间接制约关系，当个一个进程进入临界区使用临界资源的时候，另一个进程必须等待，当占用临界资源的进程退出临界区之后，另一个进程才允许访问此临界资源 同时为了禁止两个进程同时进入临界区，同步机制因遵循一下的原则： 临界区：进程访问临界资源的代码，它同一时刻只能由一个进程执行，如java中的synchronized关键字在方法上，那临界区就是整个方法内部。而如果是使用synchronized代码块，那临界区就指的是代码块内部的区域。 空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程进入临界区 忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待 有限等待：对已经请求进入临界区的进程，应保证其在有限的时间进入临界区 让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程忙等。 经典同步问题生产者-消费者问题、读写者问题、哲学家就餐问题 异步异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。 举例说明：发短信，A发短信给B，发送给B即可，发送完之后，可以做其他的事情，短信来了，手机会提醒 阻塞与非阻塞阻塞和非阻塞是从CPU的消耗而言的。 阻塞：就是CPU停下来等待一个慢操作完成之后CPU再继续执行其他的事情 非阻塞： 在慢操作执行的时候，CPU会去执行其他的事情，等这个慢操作完成之后，CPU继续完成其后续事情 虽然表面上看非阻塞的方式可以明显的提高 CPU 的利用率，但是也带了另外一种后果就是系统的线程切换增加。增加的 CPU使用时间能不能补偿系统的切换成本需要好好评估。 以上两种概念的花式组合这里主要是和I/O相关 排列组合之后，共四种情况：同步阻塞、同步非阻塞、异步阻塞、异步非阻塞 组合方式 性能 同步阻塞 最常用的一种用法，使用也是最简单的，但是 I/O 性能一般很差，CPU 大部分在空闲状态。(BIO) 同步非阻塞 提升 I/O 性能的常用手段，就是将 I/O 的阻塞改成非阻塞方式，尤其在网络 I/O 是长连接，同时传输数据也不是很多的情况下，提升性能非常有效。这种方式通常能提升 I/O 性能，但是会增加 CPU 消耗，要考虑增加的 I/O 性能能不能补偿 CPU 的消耗，也就是系统的瓶颈是在 I/O 还是在 CPU 上。(NIO) 异步阻塞 这种方式在分布式数据库中经常用到，例如在网一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，而还有两至三份是备份记录会写到其它机器上，这些备份记录通常都是采用异步阻塞的方式写 I/O。异步阻塞对网络 I/O 能够提升效率，尤其像上面这种同时写多份相同数据的情况。 异步非阻塞 这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下使用，像集群之间的消息同步机制一般用这种 I/O 组合方式。如 Cassandra 的 Gossip 通信机制就是采用异步非阻塞的方式。它适合同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大，但是却非常频繁。这种网络 I/O 用这个方式性能能达到最高。(AIO) 虽然异步和非阻塞能够提升 I/O 的性能，但是也会带来一些额外的性能成本，例如会增加线程数量从而增加 CPU 的消耗，同时也会导致程序设计的复杂度上升。如果设计的不合理的话反而会导致性能下降。在实际设计时要根据应用场景综合评估一下。","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://winniekun.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"I/O","slug":"I-O","permalink":"https://winniekun.github.io/tags/I-O/"}]},{"title":"2019的最后100天","slug":"碎碎念/2019的最后100天","date":"2019-10-01T08:53:43.000Z","updated":"2020-08-30T04:50:22.258Z","comments":true,"path":"2019的最后100天/","link":"","permalink":"https://winniekun.github.io/2019%E7%9A%84%E6%9C%80%E5%90%8E100%E5%A4%A9/","excerpt":"前言时间过得可真快啊，去年的这个时候还在备考，刷各种题，现在已经在实验室做自己的事情了，又是最后的100天，希望自己在2019年的最后100天拼一拼，努力完成自己的任务。","text":"前言时间过得可真快啊，去年的这个时候还在备考，刷各种题，现在已经在实验室做自己的事情了，又是最后的100天，希望自己在2019年的最后100天拼一拼，努力完成自己的任务。 计划 Java基础 是的，我又开始看Java了，因为发现自己的对Python的理解貌似止步不前了， 那就换个语言好好学学，或许，会有更深刻的理解呢～～～ Spring大家族实现一个框架的demo Spring是一个微型框架… Flask源码解读 自己其实一直想把flask的源码理解了，但是苦于自己懒癌，以及看的时候经常会忘了自己该去看哪儿了。 自己阅读源码的方式还有很多问题 Python进阶 并发最起码要刷完吧，要不然白费了自己去年苦心整理的os了 迭代器、生成器、新特性 数据结构树和图 之前的都是理论上明白了， 现在需要去自己手动实现了，虽然去年不知道手写写废了多少支笔 LeetCode 100题 O(∩_∩)O哈哈哈~","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"冒泡排序","slug":"算法/排序/冒泡排序","date":"2019-09-30T14:47:49.000Z","updated":"2020-08-30T04:50:22.261Z","comments":true,"path":"冒泡排序/","link":"","permalink":"https://winniekun.github.io/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","excerpt":"冒泡排序","text":"冒泡排序 冒泡排序每次检查相邻两个元素，以升序为例， 如果前面的元素大于后面的元素，就将相邻两个元素交换。当没有相邻的元素需要交换时，排序就完成了。 时间复杂度：$O(n^2)$ 冒泡排序是稳定排序 伪代码$ \\begin{array}{ll} 1 &amp; \\textbf{Input. } \\text{An array } A \\text{ consisting of }n\\text{ elements.} \\newline 2 &amp; \\textbf{Output. } A\\text{ will be sorted in nondecreasing order stably.} \\newline 3 &amp; \\textbf{Method. } \\newline 4 &amp; flag\\gets True \\newline 5 &amp; \\textbf{while }flag\\newline 6 &amp; \\qquad flag\\gets False\\newline 7 &amp; \\qquad\\textbf{for }i\\gets1\\textbf{ to }n-1\\newline 8 &amp; \\qquad\\qquad\\textbf{if }A[i] &gt;A[i + 1]\\newline 9 &amp; \\qquad\\qquad\\qquad flag\\gets True\\newline 10 &amp; \\qquad\\qquad\\qquad \\text{Swap } A[i]\\text{ and }A[i + 1] \\end{array}$ Java实现public void bubbleSorted(int[] nums){ boolean flag = true; while(flag){ flag = false; for(int i = 0; i&lt; nums.length-1; i++){ if(nums[i] &gt; nums[i+1]){ int temp = nums[i]; nums[i] = nums[i+1]; nums[i+1] = temp; flag = true; } } } }","categories":[{"name":"排序","slug":"排序","permalink":"https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"交换","slug":"交换","permalink":"https://winniekun.github.io/tags/%E4%BA%A4%E6%8D%A2/"}]},{"title":"暑期生活","slug":"碎碎念/暑期生活","date":"2019-08-11T08:53:28.000Z","updated":"2021-11-03T08:40:56.092Z","comments":true,"path":"暑期生活/","link":"","permalink":"https://winniekun.github.io/%E6%9A%91%E6%9C%9F%E7%94%9F%E6%B4%BB/","excerpt":"前言今年暑假又提前结束了，还有很多想去做的事情还没有完成，譬如：整理笔记、出去旅游等。这次暑假应该是自己目前回老家最多次的一回了，而且也是自己第一次一个人回老家。挺好，路线熟悉之后，以后就能自己办事情了，不用再找别人代办了。","text":"前言今年暑假又提前结束了，还有很多想去做的事情还没有完成，譬如：整理笔记、出去旅游等。这次暑假应该是自己目前回老家最多次的一回了，而且也是自己第一次一个人回老家。挺好，路线熟悉之后，以后就能自己办事情了，不用再找别人代办了。 老家基本每年暑假老妈都会带着我和弟弟回老家一趟，之前很期待回老家，现在也没有那种每天倒计时回老家的那种期待感了，鬼知道什么情况。。。一直感觉老妈带我们回老家就两个目的： 多陪陪爷爷奶奶 外公外婆 体验生活，在老家种地真的不容易当然今年也不例外，因为自己大了，回去之后，肯定是要尽可能的多去帮帮家人做一些农活。而老弟，可能就是让他去体验生活吧，本来是带有教育目的的，但是感觉他玩儿的很开心哇。。。以下是他开心的体验生活的照片。 《暑期生活》 自己还记得和老弟一样大的时候，帮爷爷去掐棉花枝，免得棉花长得太高，从下午3点多一直干到6点多，那次把我累惨了，又累又渴，干完活之后，还要摘一袋西瓜回家，还好能骑三轮车，每个西瓜差不多就和这个那么大。不过我记得是圆的，现在种的细长的，一个个长得跟个冬瓜一样。。。 《暑期生活》 今年卸西瓜、装西瓜很累，真的累，特别累，因为天热，所以只能在凌晨5点多，或者下午5点多再下地去卸西瓜，当然也不是每次都这样，因为西瓜的价钱不稳定，所以当打听到西瓜的价钱涨了，就会立马下地卸瓜，装好之后拉去卖掉。记得有一次下午5点多卸，还下着小雨，后面刚卸完，就突然下来大暴雨。。。还好外婆及时送来了雨伞，要不然全部都要淋成落汤鸡。 杭州本科学校清人最后一天，就拎着行李回杭州了。虽然已经寄走了两大包东西了，但是我的大花箱还是塞得满满的，贼沉，早知道当初就不乱买那么多东西。 《暑期生活》 回杭州之后，天天在家待着，本来计划找个兼职做做的，结果都不要！都不要！都不要!!!很难受，不过自己的厨艺突然开窍了，可能是和沈总混久了的原因，反正基本每天晚饭都是我来做。图文不相关，就是单纯的想放个照片 《暑期生活》 西安革命尚未结束，同志仍需加油！！！ 《暑期生活》","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"快速排序","slug":"算法/排序/快速排序","date":"2019-08-02T01:20:14.000Z","updated":"2020-08-30T04:50:22.261Z","comments":true,"path":"快速排序/","link":"","permalink":"https://winniekun.github.io/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","excerpt":"简介","text":"简介 时间复杂度：$O(nlogn)$ 快速排序是不稳定算法 步骤分为三个过程： 将集合划分为两部分（保证大小关系即可，partition函数） 递归的在两个划分好的部分分别进行快排 不用合并，因为此时集合已经完全有序 Java实现public static void quickSort(int[] data, int low, int high) throws Exception { if(low == high){ return; } if(low &lt; high){ int partition = partition(data, data.length, low, high); quickSort(data, low, partition-1); quickSort(data, partition+1, high); } } private static int partition(int data[], int length, int low, int high) throws Exception { if(data == null || data.length&lt;= 0 || low &lt; 0 || high &gt;= length ){ throw new Exception(\"Invalid Parameters\"); } // 默认选择首位作为枢轴 int position = data[low]; while (low &lt; high){ while (low&lt; high &amp;&amp; data[high] &gt;= position){ high--; } data[low] = data[high]; while (low&lt;high &amp;&amp; data[low] &lt;= position){ low++; } data[high] = data[low]; } data[low] = position; return low; } References 快速排序 算法第四版","categories":[{"name":"排序","slug":"排序","permalink":"https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"交换","slug":"交换","permalink":"https://winniekun.github.io/tags/%E4%BA%A4%E6%8D%A2/"}]},{"title":"BST详解","slug":"数据结构/BST详解","date":"2019-07-28T02:24:44.000Z","updated":"2020-08-30T04:50:22.254Z","comments":true,"path":"BST详解/","link":"","permalink":"https://winniekun.github.io/BST%E8%AF%A6%E8%A7%A3/","excerpt":"简介","text":"简介 BST有很多的名字，如二叉排序树、二叉搜索树、Binary Sort Tree、Binary Search Tree、BST其具有如下性质： 定义空树是一个BST 左子树所有结点的值均小于根结点的值 右子树所有结点的值均大于根结点的值 左右子树都是BST(递归定义) 中序遍历序列为升序 查找假设查找关键字key 若根结点的关键字值等于key，成功 若key小于根结点的关键字，递归查找左子树 若key大于根结点的关键字，递归查找右子树 若子树为空，查找不成功 插入按照元素的大小进行查找，与查找类似。然后插入到对应的位置（插入到当前BST的叶子节点） 删除假设删除节点p，其父节点为f，分如下3种情况进行讨论： p是叶子节点，直接删除 p只有左子树left(右子树right)，直接用p.left(p.right)替换p p既有左子树left，又有右子树right，找到右子树的最小节点rightMin(找到left的最大节点leftMax)，用rightMin(leftMax)的值替换p的值，再根据以上两种情况删除rightMin(leftMax) P是叶子节点 bst_删除_情况1.png P只有左子树或右子树 bst_删除_情况2.png P既有左子树又有右子树 bst_删除_情况3.png 面试汇总给定一个BST的节点，寻找以当前节点为根节点的最值private static TreeNode getLastEntry(TreeNode node) { while (node.right != null) { node = node.right; } return node; } private static TreeNode getFirstEntry(TreeNode node) { while (node.left != null) { node = node.left; } return node; } 给定节点t，后继(前驱)节点 t为最值节点 无前驱或后继 当t有右子树 直接寻找其右子树最小节点（左子树最大节点）即可 t无右子树 向上回溯，找到第一个孩子是左子树孩子（右子树孩子）的父亲p 向上回溯，找到第一个关键字比孩子大（小）的父亲p（利用BST特性） LintCode448. Inorder Successor in BST使用指针代替路径栈，将空间复杂度降到O(1) 栈是自底向上寻找结果，指针为自顶向下寻找结果 public static TreeNode inorderSuccessor(TreeNode root, TreeNode p) { if (root == null) { return null; } // 情况0: 本身就是最值 if (getLastEntry(root) == p) { return null; } // 情况1: 有右子树 if (p.right != null) { return getFirstEntry(p.right); } // 情况2: 没有右子树 TreeNode parent = root; // temp指针代替栈 TreeNode temp = root; while (parent != null) { if (parent == p) { break; } else if (parent.val &gt; p.val) { temp = parent; parent = parent.left; } else { parent = parent.right; } } return temp; } private static TreeNode getLastEntry(TreeNode node) { while (node.right != null) { node = node.right; } return node; } private static TreeNode getFirstEntry(TreeNode node) { while (node.left != null) { node = node.left; } return node; } 相关题目会持续添加 References TreeMapSourceAnalysis","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://winniekun.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"BST","slug":"BST","permalink":"https://winniekun.github.io/tags/BST/"}]},{"title":"大四下学期总结---各奔东西","slug":"总结/大四下学期总结-各奔东西","date":"2019-07-26T08:53:13.000Z","updated":"2020-08-30T04:50:22.253Z","comments":true,"path":"大四下学期总结-各奔东西/","link":"","permalink":"https://winniekun.github.io/%E5%A4%A7%E5%9B%9B%E4%B8%8B%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93-%E5%90%84%E5%A5%94%E4%B8%9C%E8%A5%BF/","excerpt":"前言本科毕业了，然后例行的一学期一总结一直拖着没有写，其实自己也不知道该怎么去写，写些啥，然后就这么拖着拖到了7月底。","text":"前言本科毕业了，然后例行的一学期一总结一直拖着没有写，其实自己也不知道该怎么去写，写些啥，然后就这么拖着拖到了7月底。 干了些啥复试最后一学期如果按照到校的时间作为开学的第一天的话，那么我的开学时间有些早，然后就是慢慢悠悠的准备复试，关于考研的整个过程，个人不想再多写些啥子，总之，经历了就行。确定有书读之后，就直接去找了工作干了。工作实习工作是从4月中旬开始，期间因为公司统一使用的是Winidows系统，所以自己又换了个系统盘，然后一步一步按照公司的文档配置环境，完全是瞎子摸象，自己慢慢的去摸索，因为管的不是很严，所以在空余时间深化学习了git，尝试去看了flask的源码，本来计划干到6月份，5月初的时候，何老师开始催促我们要抓紧做毕设了，当初自己完全没有开始做，只是去了解了自己觉得需要用到的技术，后面发现事情开始多了起来，如果自己还不开始准备的话，就要延迟毕业了。然后果断和leader提出了辞职，开始一心准备自己的毕业设计。赶毕设整个毕设如果算全部都在做的时间的话，应该有个240个小时左右，主要是论文，现在还记得被论文支配恐惧，一共给何老师发了6个版本，第一个版本格式乱的没办法看，第二-四版本不停的按照要求改内容，第五版本，老师说她感觉论文写的太像一个文档，然后最后我又开始大改，期间还通宵了三次，终于在截止论文提交当天完成了要求。对于个人的毕业设计，我觉得自己核心的内容写的不是很好，反而Coookies池和IpProxy池做的很好答辩6月初开始的毕业答辩，具体几号忘了。我的号比较靠后，自己听了一些前面的同学的答辩，感觉一般，自己期间准备了下自己可能会被问到的问题，然后就和女朋友还有基友在那儿吹壳子了。以下为自己和沈总互拍的答辩照片 《大四下学期总结 --- 各奔东西》 《大四下学期总结 --- 各奔东西》 我现在还记得自己答辩完，台下一句话都没有，老师了等了近一分钟才开始问问题….. 可能是自己做的东西，我们那组答辩老师涉及的不多吧。最后问了几个比较鶸的问题散伙饭先是班级聚餐，在学校外面的烧烤店，感觉那次是我目前喝酒喝最多的一次了，但是还是没有醉(￣▽￣”)接下来是我和沈总一起请了何老师吃了一顿饭，虽然说是请，但是现在我还没有把饭前转给沈总(・ω・)，何老师还和我们说，我们答辩小组原定的争优答辩的那个同学弃权了，其他老师想让我去争优，然后何老师了解我毕设的具体情况，帮我拒绝了，真是虚惊一场呢。然后领毕业证的时候，全寝室一起吃了一顿火锅。最后，也就是22号那天吧，因为一些原因，自己23号才回杭，然后宿管大伯通知的是23前所有人要搬离寝室，和大伯说明情况之后，自己待在寝室亲眼看到了整个班级的同学一个一个走了，那个时候才感觉到原来本科真的毕业了。那天晚上整个人都不好了，全寝室楼出奇的安静，很渗人。 结尾时间真的挺快的，回想自己本科的生活，用一句话来概括的话应该就是享受生活、随时养老了，贼喜欢大二大三每次做项目发钱了，拉着沈总去正门享受生活，改善伙食的日子，虽然基本每次都是去吃火锅，然后吃完发誓下次坚决不再吃火锅。","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://winniekun.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"选择排序","slug":"算法/排序/选择排序","date":"2019-05-30T12:11:52.000Z","updated":"2020-08-30T04:50:22.261Z","comments":true,"path":"选择排序/","link":"","permalink":"https://winniekun.github.io/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","excerpt":"选择排序","text":"选择排序 每次找出第$i$小的元素（$Ai..n$中最小的元素），然后将这个元素和数组中第$i$个元素交换位置 时间复杂度： $O(n^2)$ 因为交换操作的存在，所以选择排序是不稳定排序 伪代码$ \\begin{array}{ll} 1 &amp; \\textbf{Input. } \\text{An array } A \\text{ consisting of }n\\text{ elements.} \\newline 2 &amp; \\textbf{Output. } A\\text{ will be sorted in nondecreasing order.} \\newline 3 &amp; \\textbf{Method. } \\newline 4 &amp; \\textbf{for } i\\gets 1\\textbf{ to }n-1 \\newline 5 &amp; \\qquad ith\\gets i\\newline 6 &amp; \\qquad \\textbf{for }j\\gets i+1\\textbf{ to }n\\newline 7 &amp; \\qquad\\qquad\\textbf{if }A[j] &lt; A[ith]\\newline 8 &amp; \\qquad\\qquad\\qquad ith\\gets j\\newline 9 &amp; \\qquad \\text{swap }A[i]\\text{ and }A[ith]\\newline \\end{array} $ Java实现public void selectionSort(int[] nums){ for(int i = 0; i&lt;nums.length; i++){ int ith = i; // 记录当前需要选取的第i个最小元素 for(int j = i+1; j&lt;nums.length; j++){ if(nums[j] &lt; nums[ith]){ ith = j; } } int temp = nums[i]; nums[i] = nums[ith]; nums[ith] = temp; } } over","categories":[{"name":"排序","slug":"排序","permalink":"https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"选择","slug":"选择","permalink":"https://winniekun.github.io/tags/%E9%80%89%E6%8B%A9/"}]},{"title":"B树系列","slug":"数据结构/B树系列","date":"2019-05-17T11:25:36.000Z","updated":"2020-08-30T04:50:22.254Z","comments":true,"path":"B树系列/","link":"","permalink":"https://winniekun.github.io/B%E6%A0%91%E7%B3%BB%E5%88%97/","excerpt":"B树共分为两个部分， 首先是B的性质、B树的建立、插入和删除，之后是B+树性质、以及相比于B树，区别在哪儿","text":"B树共分为两个部分， 首先是B的性质、B树的建立、插入和删除，之后是B+树性质、以及相比于B树，区别在哪儿 B树的性质B树又称为多路平衡查找树，B树中所有结点的孩子结点数的最大值称为B树的阶。通常使用m表示。 一颗m阶B树或为空，或为满足如下特性的m叉树。 树中每个节点至多有m颗子树（m-1关键字） 若是根节点不是终端节点，至少有两颗子树 除根以外的所有非叶子节点至少 $\\lceil m/2 \\rceil$ 颗子树（$\\lceil m/2 \\rceil $ -1 关键字） 所有的非叶子结点的结构如下： 所有叶子节点都出现在同一层次上，并且不带任何信息 b树示例.png B树的高度$ n$ : 关键字的个数 $h \\le log_\\lceil m/2 \\rceil ((n+1)/2) + 1 $ 具体的证明，百度。。。 B树的查找因为其是有序的，其和二叉搜索树的查找类似，只不过不同的是每个节点其有多个关键字的有序表，然后根据该节点的子树做多路分支决定。 基本步骤 在B树中找到节点 在节点内找到关键字 由于B树通常是存储在磁盘上的， 所有第一次是在磁盘上进行， 之后第二次在内存中运行，即在找到目标节点之后，将其储存内存之后， 然后使用顺序查找或者折半查找，查找等于K的关键字。 B树的插入、B树的删除可根据参考书和可视化网站进行理解 B树每个节点的关键字个数范围 $[\\lceil m/2 \\rceil -1 , m-1]$ 其中删除的操作共分为两种情况，并且这两种情况又有细分 删除关键字k为非终端节点（终端节点 != 叶子节点）其实和AVL的删除是如出一辙的 小于k的子树中关键字的个数 &gt; $\\lceil m/2 \\rceil -1$ 则找出k的前驱k’替代k， 再递归的删除k‘ 大于k的子树中关键字的个数 &gt; $\\lceil m/2 \\rceil -1$ 则找出k的后继k’替代k， 再递归的删除k’ k的左右子树的关键字个数 均为 $\\lceil m/2 \\rceil-1$ 则进行合并两个子树，然后删除k即可 删除关键字k为终端节点 如果k所在的节点关键字个数&gt; $\\lceil m/2 \\rceil -1$ 直接删除 k所在的节点关键字个数=$\\lceil m/2 \\rceil -1$ 兄弟够借 兄弟不够借 B+树B+树的性质B+树是应数据库的所需， 所出现的一种B树的变形 一颗m阶的B+树需满足下列条件 每个分支节点最多有m颗子树 非叶子的根节点至少有两颗子树，其他的分支节点至少有$\\lceil m/2 \\rceil $ 颗子树 节点的子树个数和关键字个数相等 所有叶子节点包含所有关键字及指向相应记录的指针，并且叶子节点将关键字按大小顺序排列，并且相邻叶节点按大小顺序相互链接起来 所有分支节点中仅包含它的各个子节点中关键字的最大值和指向该子树的指针 B+树结构示意图 B_树结构示意图.png B+树的性质II：才发现，原来各种资料上关于B+树的性质，不经相同….. 以下为维基百科的定义 和王道的定义区别不大，但是分支节点关键字个数比子树个数小1， 也就是和B的节点定义一样。 1）B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。 2）B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。 3） m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。 4）内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。 5）每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。 B+树结构示意图II下图为一个三阶B+树的示意图 B_树结构示意图.png B和B+区别 B+ trees don’t store data pointer in interior nodes, they are ONLY stored in leaf nodes. This is not optional as in B-Tree. This means that interior nodes can fit more keys on block of memory and thus fan out better. The leaf nodes of B+ trees are linked, so doing a linear scan of all keys will requires just one pass through all the leaf nodes. A B tree, on the other hand, would require a traversal of every level in the tree. This property can be utilized for efficient search as well, since data is stored only in leafs. B+内部节点不存储数据，只有叶子节点存储信息，B树没有，这也就意味着，B+树比B树的内部节点能存储更多的信息 B+树叶节点的数据是链接的，可做一次线性扫描获取所有的数据， 但是B树就需要遍历整个B树 查找、插入、删除B+和B树相同，但是对于查找而言，如果非叶子节点上关键字值等于给定值时，并不终止，而是继续查找，直到找到叶子节点上的该关键字为止。所以，B+树的查找，无论成功与否，每次都是一条从根节点到叶子节点的路径。 reference 王道数据结构 B+ tree B树和B+树的插入、删除图文详解 Memory locality &amp; the magic of B-Trees!","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://winniekun.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"B树","slug":"B树","permalink":"https://winniekun.github.io/tags/B%E6%A0%91/"}]},{"title":"大四上学期总结---慢煨慢炖","slug":"总结/大四上学期总结-慢煨慢炖","date":"2019-04-22T16:00:00.000Z","updated":"2020-08-30T04:50:22.253Z","comments":true,"path":"大四上学期总结-慢煨慢炖/","link":"","permalink":"https://winniekun.github.io/%E5%A4%A7%E5%9B%9B%E4%B8%8A%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93-%E6%85%A2%E7%85%A8%E6%85%A2%E7%82%96/","excerpt":"前言这学期都已经过半了，因为开学一直有事情，就一直拖到现在。","text":"前言这学期都已经过半了，因为开学一直有事情，就一直拖到现在。 总结 学习上上学期基本就是三点一线的生活，寝室 &lt;—-&gt; 图书馆 &lt;—-&gt; 食堂其实没有啥好总结的，感觉的话，自己的计算机基础的确是深化了，那几个月的确 很难受，周围的朋友实习的去实习了，保研的保研了，自己一直还没有确定下来。不过好处还是有的，自己深刻的体会到了团队的重要性，之前一直认为任何时候， 自己一个人终究好比过一堆人一起。不管是从效率上来讲还是从技术上来讲，但是 经过上学期的备考，感觉到了当大家共同为一个目标努力的时候，那种效率和自控 力是很高的。 技术上大概有进半年没有撸过代码吧，博客也没有更新过了，编码能力讲真是有一定的退步的，但是目前的感觉是比之之前的学习速度快了（在脑子保持清醒的情况下），自己现在不是很热衷于去了解和掌握一些框架的使用，反而对一些的算法的研究比较感兴趣了，虽然看的云里雾里的。自己在极客上买了数据结构与算法之美这个课程，觉得作者的理解很棒，并不是理论层面的，而是结合了真正的实际开发中的各个情况，希望自己有朝一日能有如此见解 生活上有时候选择比努力更重要没有什么所谓的happily ever after","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://winniekun.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"final、static、this、super关键字总结","slug":"Java基础/final、static、this、super关键字总结","date":"2019-04-10T01:47:33.000Z","updated":"2020-08-30T04:50:22.243Z","comments":true,"path":"final、static、this、super关键字总结/","link":"","permalink":"https://winniekun.github.io/final%E3%80%81static%E3%80%81this%E3%80%81super%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/","excerpt":"final static this super关键字总结final 关键字主要用于三个地方：类、方法、变量 类：用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。 方法： 方法锁定： 防止任何继承了类修改该方法 效率 变量： 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。","text":"final static this super关键字总结final 关键字主要用于三个地方：类、方法、变量 类：用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。 方法： 方法锁定： 防止任何继承了类修改该方法 效率 变量： 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 static 关键字主要为四个地方放： 修饰成员变量和成员方法， 静态代码块、静态内部类、静态导包 修饰静态成员变量和成员方法 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名() 静态代码块 静态代码块定义在类中方法外, ==静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.== 静态内部类 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着： 它的创建是不需要依赖外围类的创建。 它不能使用任何外围类的非static成员变量和方法。 静态导包 mport static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。 ```javaimport static com.train.keywords.Test.*; public class FinalForKnow { // final 用于 类 方法 变量 private static final String a = \"1123\"; public static void main(String[] args) { System.out.println(a); System.out.println(name); System.out.println(age); // 1123 // 维坤坤 // 0 } } public class Test { public static int age; public static String name = “维坤坤”; } ### this 关键字 引用类的当前实例 ### super 关键字 从子类访问父类的方法和变量 ```java public class Super { protected int number; protected showNumber() { System.out.println(\"number = \" + number); } } public class Sub extends Super { void bar() { super.number = 10; super.showNumber(); } } 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。 this、super不能用在static方法中。","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://winniekun.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"插入排序","slug":"算法/排序/插入排序","date":"2019-03-11T09:35:45.000Z","updated":"2020-08-30T04:50:22.261Z","comments":true,"path":"插入排序/","link":"","permalink":"https://winniekun.github.io/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","excerpt":"插入排序","text":"插入排序 前言插入排序的思想很直观，其在性能上不如一些分治的排序策略，例如快速排序，归并排序。插入排序是一种基于比较的排序算法。 算法思想其类似于打牌的抓牌环节，抓到牌后都会按照点数插入到合适的位置，核心思想是保证一个已排序区间，剩下的未排序区间依次与前面的已排序区间进行比较，插入到对应的位置。 插入有关于插入，若是序列是使用数组进行存储，则可以从右向左扫描已排序数组，因为这样可以在性能上有所优化。因为对于数组的插入，其不像链表一样，只需要断链，然后链接，其需要移动大量的元素，才能够进行插入，若是从左向右，譬如数组的长度为n，在位置i插入，则需要扫描i次，然后移动n-i+1次，最后插入数据。若是从右向左，最多需要i次扫描，然后可以边扫描边右移动 基本插入算法 复杂度:O(n^2) 比较次数（查找）: O(n^2) 移动次数（插入后导致的移动）: O(n^2)def insertSort(arraylist): arrayLen = len(arraylist) for i in range(1, arrayLen): current = arraylist[i] j = i - 1 while j &gt; 0 and arraylist[j] &lt; current: arraylist[j+1] = arraylist[j] j = j - 1 arraylist[j+1] = current return arraylist 优化一： 使用鶸二分查找因为已经确定了前面的排序区间是有序的，所以可以直接使用二分查找来确定插入的位置，这样查找的时间就得到了优化 复杂度: O(n^2) 比较次数: O(nlgn) 移动次数: O(n^2)```pythondef binarySearch(arraylist, key): low = 0 high = len(arraylist) while low &lt; high: mid = (log + hig)//2 if arraylist[mid] == key: return mid elif arraylist[mid] &gt; key: high = mid else: low = mid + 1 return low def insertSort(arraylist): arrayLen = len(arraylist) for i in range(1, arrayLen): current = arraylist[i] position = binarySearch(arraylist[:i], key) for i in range(i, position, -1): arraylist[i] = arraylist[i-1] arraylist[position] = current return arraylist ## 优化二： 为了优化而优化的链表 使用链表之后，改变其数据结构，可以优化插入的时间，由最初的O(n)优化到了O(1) + 复杂度: O(n^2) + 比较次数: O(n^2) + 移动次数: O(1) ```python def insert(arrayList, next, i): j = -1 # print(\"当前j为{}, next[j]={}，arrayList[next[j]]={} arrayList[i]={}\".format(j, next[j], arrayList[next[j]], arrayList[i])) while next[j] != -1 and arrayList[next[j]] &lt; arrayList[i]: j = next[j] # print(\"目前j={}\".format(j)) next[j], next[i] = i, next[j] # print(\"交换后的next[j]={}, next[i]={} \\n\".format(next[j], next[i])) def reorder(arrayList, next): i = -1 ys = [] while next[i] != -1: ys.append(arrayList[next[i]]) i = next[i] return ys def insertSortIII(arrayList): arrayLen = len(arrayList) next = [-1]*(arrayLen+1) for i in range(arrayLen): insert(arrayList, next, i) return reorder(arrayList, next) 优化三： 终极进化之二叉搜索树对于以上的优化，只能在插入和查找之中二选一的进行优化。单独提高其中一个仍会使插入算法保持在O(n^2)中，使用二分查找能够将查找次数降到最低—-O(lgN),对于插入，为了能实现常数时间的插入，必定需要改变其数据结构。二叉搜索树刚好满足以上的所有的需求，但是对于这个，应该不算是严格意义的插入排序了，应是更宽泛的定位—-基于比较的排序。 第一，其本身定义就支持二分查找。 同时查找到对应的值之后，即可插入，所以插入的时间为常数项O(1)。 对于其频繁的插入删除导致的性能降低，目前的排序涉及不多 总结 复杂度: O(nlgn) 移动次数: O(1) 比较次数 O(lgn) 实现首先将数据构造为二叉搜索树，之后再进行中序遍历即可。 class TreeNode: def __init__(self, data): self.data = data self.leftChild = None self.rightChild = None def insert(self, newData): \"\"\" 插入数据 # edage case: 若是value相同如何解决 Word天 :param newData: :return: \"\"\" if newData == self.data: return False elif newData &lt; self.data: if self.leftChild == None: self.leftChild = TreeNode(newData) else: self.leftChild.insert(newData) else: if self.rightChild == None: self.rightChild = TreeNode(newData) else: self.rightChild.insert(newData) # 以下的前中后遍历均为递归的遍历 def preOrder(self): \"\"\" 前序遍历 根左右 :return: \"\"\" print(self.data) if self.leftChild: self.leftChild.preOrder() else: self.rightChild.preOrder() def inOrder(self): \"\"\" 中序遍历 左根右 :return: \"\"\" if self.leftChild: self.leftChild.inOrder() print(self.data) if self.rightChild: self.rightChild.inOrder() References 算法新解 算法第四版","categories":[{"name":"排序","slug":"排序","permalink":"https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"插入","slug":"插入","permalink":"https://winniekun.github.io/tags/%E6%8F%92%E5%85%A5/"}]},{"title":"泛型","slug":"Java基础/泛型","date":"2019-03-10T23:53:55.000Z","updated":"2021-06-03T13:14:19.545Z","comments":true,"path":"泛型/","link":"","permalink":"https://winniekun.github.io/%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"序在Java中一直强调数据类型的概念，其自身有8种基础的数据类型，同时我们自定义的类，也可以理解为自定义的数据类型。我们熟知的容器类，也是基于泛型实现的。这样才实现了一个容器类，适用于各种各样的数据类型。 通过泛型，使得类、接口、方法能够适用于非常广泛的数据类型，使得具体的代码能够和操作的具体的数据类型不再强行绑定到一起。同一套代码能够适用于多种数据类型。从而达到复用代码、降低耦合度、提高代码的可读性的目的。 优点 避免类型转换 // 未使用泛型 List list = new ArrayList(); list.add(\"hello\"); String s = (String) list.get(0); // 使用泛型 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"hello\"); String s = list.get(0); // 不需要进行类型转换 编译时强类型检测 泛型要求在声明时指定实际数据类型，Java 编译器在编译时会对泛型代码做强类型检查，并在代码违反类型安全时发出告警。早发现，早治理，把隐患扼杀于摇篮，在编译时发现并修复错误所付出的代价远比在运行时小。 泛型编程可实现通用算法 通过使用泛型，可以实现通用算法，这些算法可以处理不同类型的集合，可以自定义，并且类型安全且易于阅读。 泛型类型泛型类型是被参数化的类或接口 泛型类class name&lt;T1, T2, ... Tn&gt;{} 一般将泛型中的类名称为原型，而将 &lt;&gt; 指定的参数称为类型参数。 单类型参数（T）public class SingleInfo&lt;T&gt; { private T value; public T getValue() { return value; } public void setValue(T value) { this.value = value; } @Override public String toString() { return \"SingleInfo{\" + \"value=\" + value + '}'; } } 多类型参数（K，V）public class MultiInfo&lt;K, V&gt; { private K key; private V value; public MultiInfo(K key, V value) { this.key = key; this.value = value; } @Override public String toString() { return \"MultiInfo{\" + \"key=\" + key + \", value=\" + value + '}'; } 泛型类的嵌套MultiInfo&lt;Integer, MultiInfo&lt;Integer, String&gt;&gt; multi = new MultiInfo&lt;&gt;(1, new MultiInfo&lt;&gt;(1,\"32\")); System.out.println(multi); // MultiInfo{key=1, value=MultiInfo{key=1, value=32}} 泛型接口public interface Content&lt;T&gt; { T text(); } 实现接口的子类型声明具体的类型public class ImplInterface implements MyInterface&lt;Integer&gt; { private int a = 100; public ImplInterface(int a) { this.a = a; } @Override public Integer getT() { return a; } } 实现接口的子类型不声明具体类型public class NoImplInterface&lt;T&gt; implements MyInterface&lt;T&gt; { private T text; public NoImplInterface(T text) { this.text = text; } @Override public T getT() { return text; } } 泛型方法泛型方法是引入其自己的类型参数的方法。泛型方法可以是普通方法、静态方法以及构造方法。 泛型方法语法形式如下： public &lt;T&gt; T func(T obj) {} // 类型变量放在修饰符 (这里是 public static ) 的后面 , 返回类型的前面 是否拥有泛型方法，与其所在的类是否是泛型没有关系。 public class GenericsMethodDemo01 { public static &lt;T&gt; void printClass(T obj) { System.out.println(obj.getClass().toString()); } public static void main(String[] args) { printClass(\"abc\"); printClass(10); } } // Output: // class java.lang.String // class java.lang.Integer 泛型方法中也可以使用可变参数列表 public class GenericVarargsMethodDemo { public static &lt;T&gt; List&lt;T&gt; makeList(T... args) { List&lt;T&gt; result = new ArrayList&lt;T&gt;(); Collections.addAll(result, args); return result; } public static void main(String[] args) { List&lt;String&gt; ls = makeList(\"A\"); System.out.println(ls); ls = makeList(\"A\", \"B\", \"C\"); System.out.println(ls); } } // Output: // [A] // [A, B, C] 原理上述的定义各种泛型参数具体什么类嘞，其实就是Object。对于Java文件，在被使用之前需要经过编译、加载到JVM中两个阶段。编译阶段，编译器会把Java文件转换为.class文件。对于泛型，在编译阶段就会将泛型代码转换为普通的非泛型代码。使用javap也无法直接看到，因为在字节码里面也是看不到泛型的，因为已经被擦除了。将类型参数擦除之后，会使用Object进行替代以及必要的强制类型转换。然后Java虚拟机在执行过程中，已经不知道泛型的事情了，在其眼里就是普通的类。 类型擦除==Java中的泛型基本上都是在编译器这个层次来实现的。== Java 语言引入泛型是为了在编译时提供更严格的类型检查，并支持泛型编程。不同于 C++ 的模板机制，Java 泛型是使用类型擦除来实现的，使用泛型时，任何具体的类型信息都被擦除了。 ==Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况== 类型擦除做了以下工作： 把泛型中的所有类型参数替换为 Object，如果指定类型边界，则使用类型边界来替换。因此，生成的字节码仅包含普通的类，接口和方法。 擦除出现的类型声明，即去掉 &lt;&gt; 的内容。比如 T get() 方法声明就变成了 Object get() ；List 就变成了 List。如有必要，插入类型转换以保持类型安全。 生成桥接方法以保留扩展泛型类型中的多态性。类型擦除确保不为参数化类型创建新类；因此，泛型不会产生运行时开销。 示例： public class GenericsErasureTypeDemo { public static void main(String[] args) { List&lt;Object&gt; list1 = new ArrayList&lt;Object&gt;(); List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); System.out.println(list1.getClass()); System.out.println(list2.getClass()); } } // Output: // class java.util.ArrayList // class java.util.ArrayList 泛型和继承泛型不能用于显式地引用运行时类型的操作之中，例如：转型、instanceof 操作和 new 表达式。因为所有关于参数的类型信息都丢失了。 泛型无法向上转型 向上转型是指用子类实例去初始化父类，这是面向对象中多态的重要表现。 这是因为，泛型类并没有自己独有的 Class 类对象。比如：并不存在 List.class 或是 List.class，Java 编译器会将二者都视为 List.class。 类型边界有时您可能希望限制可在参数化类型中用作类型参数的类型。类型边界可以对泛型的类型参数设置限制条件。例如，对数字进行操作的方法可能只想接受 Number 或其子类的实例。 要声明有界类型参数，请列出类型参数的名称，然后是 extends 关键字，后跟其限制类或接口。 类型边界的语法形式如下： &lt;T extends XXX&gt; 类型通配符类型通配符一般是使用 ? 代替具体的类型参数。例如 List 在逻辑上是 List ，List 等所有 List&lt;具体类型实参&gt; 的父类 上界通配符可以使用上界通配符来缩小类型参数的类型范围。 它的语法形式为：&lt;? extends Number&gt; public class GenericsUpperBoundedWildcardDemo { public static double sumOfList(List&lt;? extends Number&gt; list) { double s = 0.0; for (Number n : list) { s += n.doubleValue(); } return s; } public static void main(String[] args) { List&lt;Integer&gt; li = Arrays.asList(1, 2, 3); System.out.println(\"sum = \" + sumOfList(li)); } } // Output: // sum = 6.0 下界通配符下界通配符将未知类型限制为该类型的特定类型或超类类型。 🔔 注意：上界通配符和下界通配符不能同时使用。 它的语法形式为：&lt;? super Number&gt; public class GenericsLowerBoundedWildcardDemo { public static void addNumbers(List&lt;? super Integer&gt; list) { for (int i = 1; i &lt;= 5; i++) { list.add(i); } } public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); addNumbers(list); System.out.println(Arrays.deepToString(list.toArray())); } } // Output: // [1, 2, 3, 4, 5] 无界通配符无界通配符有两种应用场景： 可以使用 Object 类中提供的功能来实现的方法。 使用不依赖于类型参数的泛型类中的方法。 通配符和向上转型泛型不能向上转型。但是，我们可以通过使用通配符来向上转型。 public class GenericsWildcardDemo { public static void main(String[] args) { List&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); List&lt;Number&gt; numList = intList; // Error List&lt;? extends Integer&gt; intList2 = new ArrayList&lt;&gt;(); List&lt;? extends Number&gt; numList2 = intList2; // OK } } 泛型约束Restrictions on Generics 泛型实践泛型命名泛型一些约定俗成的命名： E - Element K - Key N - Number T - Type V - Value S,U,V etc. - 2nd, 3rd, 4th types","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://winniekun.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Spring的bean注入方式","slug":"spring/Spring的bean注入方式","date":"2019-02-14T11:52:23.000Z","updated":"2020-08-30T04:50:22.252Z","comments":true,"path":"Spring的bean注入方式/","link":"","permalink":"https://winniekun.github.io/Spring%E7%9A%84bean%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/","excerpt":"Bean的依赖注入方式","text":"Bean的依赖注入方式 spring-bean.jpg Bean配置信息定义了Bean的实现及依赖关系，Spring容器根据各种形式的Bean配置信息在容器内部建立Bean定义注册表，然后根据注册表加载、实例化Bean，并建立Bean和Bean的依赖关系，最后将这些准备就绪的Bean放到Bean缓存池中，以供外层的应用程序进行调用。 Bean的注入方式有两种： XML中配置 构造方法注入 属性注入 工厂方法注入 使用注解的方式注入 XML中的配置依赖注入构造方法注入public class UserServiceImpl implements UserService { private UserDao userDao; // 利用构造方法注入 public UserServiceImpl(UserDao userDao){ this.userDao = userDao; } // //利用set进行动态实现值的注入 // public void setUserDao(UserDao userDao) { // this.userDao = userDao; // } public void getUser() { userDao.getUser(); } } bean.xml配置&lt;bean id=\"userImpl\" class=\"com.wkk.dao.impl.UserDaoImpl\"/&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;bean id=\"mysqlImpl\" class=\"com.wkk.dao.impl.UserDaoMysqlImpl\"/&gt; &lt;bean id=\"userServiceImpl\" class=\"com.wkk.service.impl.UserServiceImpl\"&gt; &lt;!--&lt;property name=\"userDao\" ref=\"mysqlImpl\"/&gt;--&gt; &lt;constructor-arg ref=\"mysqlImpl\"/&gt; &lt;/bean&gt; 属性注入(setter方法)public class UserServiceImpl implements UserService { private UserDao userDao; // 利用set进行动态实现值的注入 public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void getUser() { // System.out.println(\"UserService实现类: 对用户数据的逻辑操作(用户角度)\"); userDao.getUser(); } } bean.xml配置&lt;bean id=\"userImpl\" class=\"com.wkk.dao.impl.UserDaoImpl\"/&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;bean id=\"mysqlImpl\" class=\"com.wkk.dao.impl.UserDaoMysqlImpl\"/&gt; &lt;bean id=\"userServiceImpl\" class=\"com.wkk.service.impl.UserServiceImpl\"&gt; &lt;property name=\"userDao\" ref=\"mysqlImpl\"/&gt; &lt;/bean&gt; 工厂方式注入不写了，文档上没遇到， 然后平时感觉也没怎么遇到过。后面遇到再写 使用注解方式注入使用@Autowired自动注入@Component public class UserService { @Autowired @Qualifier(\"userDaoImpl2\") private UserDao userDao; public void say(){ userDao.say(); } } @Component public class UserDaoImpl1 implements UserDao { public void say() { System.out.println(\"这是UserDao的第一种实现方式\"); } } @Component public class UserDaoImpl2 implements UserDao { public void say() { System.out.println(\"这是UserDao的第二种实现方式\"); } } 测试@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = JavaConfig.class) public class UserServiceTest { @Autowired UserService userService; @Test public void say() { Assert.assertNotNull(userService); } } @Autowired不仅能对属性进行注解，还可以对方法、构造函数等。@Autowired类似与xml中使用构造方法注入或属性注入 &lt;property name=\"userDao\" ref=\"mysqlImpl\"/&gt; or &lt;constructor-arg ref=\"mysqlImpl\"/&gt; 如果使用了@Autowired或者Resource等，就不需要在定义Bean时使用属性注入和构造方法注入了。意思就是使用注解，可以省略繁杂的xml的配置。 @Autowired注解在setter方法上和属性注入的区别就是： setter方法注入是setter方法+bean.xml配置，@Autowired方式省去了bean.xml的配置 References Spring官方文档","categories":[{"name":"spring","slug":"spring","permalink":"https://winniekun.github.io/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://winniekun.github.io/tags/spring/"}]},{"title":"Spring中bean的几种装配方式总结","slug":"spring/Spring中bean的几种装配方式总结","date":"2019-01-14T11:50:54.000Z","updated":"2020-08-30T04:50:22.252Z","comments":true,"path":"Spring中bean的几种装配方式总结/","link":"","permalink":"https://winniekun.github.io/Spring%E4%B8%ADbean%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A3%85%E9%85%8D%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/","excerpt":"Bean的装配","text":"Bean的装配 装配: 创建应用对象之间的协作关系的行为， 也是DI的本质 Java装配（显式）XML装配（显式）自动化装配（隐式）从以下两个角度来实现自动化装配 组件扫描 Spring会自动发现应用上下文中所创建的bean 自动装配 Spring会自动满足bean之间的依赖使用@Component注解，告诉Spring需要为此类创建bean， 因为Spring默认是不开启组件扫描的，所以需要编写一个配置文件，启用组件扫描（@ComponentScan） 组件扫描组件扫描的bean命名Spring会根据类名指定ID（类名首字母小写）同时也可通过@Component(xxx)设置ID。 组件扫描的基础包默认会把使用@ComponentScan的包作为基础包，可以使用@ComponentScan(xxx)设置对应的基础包当将所有的配置文件统一放在同一个包里面的时候，需要指定基础包 如果，所有的对象都是独立的，彼此之间没有任何依赖，那么只需要组件扫描即可。但大多数情况下，很多对象都会依赖其他对象才能完成任务，所以就需要用到自动装配 自动装配自动装配就是让Spring自动满足bean依赖的一种方法。满足依赖的过程中，会在spring上下文中寻找某个bean需求的其他bean。 @Autowired@Autowired将当前bean依赖的bean注入进来，注入方式可以有构造器注入，也可以是setter注入，看@Autowired注解在哪儿。这样就可以省去在xml中的装配 References Spring实战第四版","categories":[{"name":"spring","slug":"spring","permalink":"https://winniekun.github.io/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://winniekun.github.io/tags/spring/"}]},{"title":"2019年书单【年终汇总】","slug":"碎碎念/2019年书单【年终汇总】","date":"2018-12-31T16:00:00.000Z","updated":"2020-08-30T04:50:22.257Z","comments":true,"path":"2019年书单【年终汇总】/","link":"","permalink":"https://winniekun.github.io/2019%E5%B9%B4%E4%B9%A6%E5%8D%95%E3%80%90%E5%B9%B4%E7%BB%88%E6%B1%87%E6%80%BB%E3%80%91/","excerpt":"我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 摘自鶸道场 趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。","text":"我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 摘自鶸道场 趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。 书籍相关 统计学习方法 算法新解 Python3学习笔记 Python编程导论 Fluent Python Flask Web开发实战入门、进阶与原理解析 黑客与画家 Vue.js实战 MySQL必知必会 编程珠玑 只能说是神书了，太多的算法书都或多或少的引用上面的例子 面向机器学习的特征工程 目前还没看完，因为觉得特征工程自己没有系统的弄过，所以打算好好看看 Fluent Python 原先觉得可以跳着看，看自己有欠缺的地方，然后开始看的时候，发现，哦～ 原来还有其他地方也是欠缺的，所以最后还是乖乖从章节的初始部分看 Java并发编程 目前看了两章 算法 把无向图看完了 Effective Java 感觉这种类型的书，没有看没看完一说，每次看都有新的理解，入门时开始看，哦～ 原来是这样， 最近再看，哦！原来是这样 电影、电视剧、综艺、纪录片 无双 我不是药神 灵能百分百II 紫罗兰的永恒花园 一拳超人II 闻香识女人 应该是我目前感触最深的一部了 驯龙高手III 结束了 精灵旅社III 也结束了，回想起来，这两部电影都是我从高中开始追的，现在都已经读研了。 hi，室友 王彦霖是真的逗，不知道是节目效果还是啥，宋小宝那一期是真的神奇，感觉基本的待客之道都没有 向往的生活III 一直是当美食篇来看的 破冰行动 暴雪将至 害怕成为这样的 沙赞 好尼玛智障啊 复联IV 铁人走的时候，心里还是哽了一下，还有我最喜欢的寡姐也走了。 最好的我们(电影版) 没啥好评价的，感觉和二熊写的不太一样了 哪吒之魔童降世 挺好看的 就是剧情太中规中矩了 沉默的证人 好差劲啊 西行记 属于那种看多了会腻的 使徒行者II 怎么这两天看的港片质量都这么差 还不及第一部的一半… 寄生虫 今年的戛纳电影最火的金棕榈电影 有很多的隐喻，可惜的是自己是跳着看的，错过了很多的细节 真的很好看 人生一串II 一如既往的好看 恶人传 最近迷上了马东锡的电影 看着真的很爽 红辣椒 转化的很棒 海上钢琴师 罗小黑战记 很好看，终于更新了 这个和哪吒的区别就是，看哪吒的时候，知道后面会发生啥，但是还是乐意去看， 这个是不确定后面会发生啥，想让它一直播，不要停 烈火英雄 很主旋律，但也很感人 诛仙I 正常的商业电影吧 鬼灭之刃 很好看，好好看 多罗罗 最长一枪 中国机长 敬畏 全职高手 大电影 不评价了， 就这样吧， 好坏参半，但是坏占大多数 少年的你 不知道为啥会有喷的,我觉得很棒哇 刺客伍六七II 不知道为啥,感觉没有第一季那么好看 镇魂街 漫画 我和我的祖国 主旋律还是适合在影院看,有氛围 中国机长 欧豪很靓哇 坏家伙们I 因马东锡在影视中打过僵尸, 打过坏人, 所以被称为神马东锡…. 坏家伙们II 他人即地狱 很阴森 囚犯医生 就是爽, 看着 秘密森林 反转真的是太大了 被告人 好看 爱吃拉面的小泉同学 很好吃 差馆 词穷，没有写不出来， 反正就是感慨很多 叶问IV 又是一个十年， 这个系列也结束了， 突然发现好多从初高中追的局都结束了， 时间真是个神奇的东西 镇魂街II 画风更好了？？ 感觉崩了 一人之下I、II 心中的国番第二","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"书单","slug":"书单","permalink":"https://winniekun.github.io/tags/%E4%B9%A6%E5%8D%95/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://winniekun.github.io/categories/Linux/"},{"name":"spring","slug":"spring","permalink":"https://winniekun.github.io/categories/spring/"},{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"vim","slug":"vim","permalink":"https://winniekun.github.io/categories/vim/"},{"name":"shell","slug":"shell","permalink":"https://winniekun.github.io/categories/shell/"},{"name":"分布式","slug":"分布式","permalink":"https://winniekun.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"操作系统","slug":"操作系统","permalink":"https://winniekun.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"dubbo","slug":"dubbo","permalink":"https://winniekun.github.io/categories/dubbo/"},{"name":"kafka","slug":"kafka","permalink":"https://winniekun.github.io/categories/kafka/"},{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"},{"name":"中间件","slug":"中间件","permalink":"https://winniekun.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"leetcode","slug":"leetcode","permalink":"https://winniekun.github.io/categories/leetcode/"},{"name":"网络","slug":"网络","permalink":"https://winniekun.github.io/categories/%E7%BD%91%E7%BB%9C/"},{"name":"排序","slug":"排序","permalink":"https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"},{"name":"concurrency","slug":"concurrency","permalink":"https://winniekun.github.io/categories/concurrency/"},{"name":"代码质量","slug":"代码质量","permalink":"https://winniekun.github.io/categories/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"},{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"},{"name":"算法","slug":"算法","permalink":"https://winniekun.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"设计模式","slug":"设计模式","permalink":"https://winniekun.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://winniekun.github.io/categories/%E5%89%91%E6%8C%87offer/"},{"name":"配置","slug":"配置","permalink":"https://winniekun.github.io/categories/%E9%85%8D%E7%BD%AE/"},{"name":"数据结构","slug":"数据结构","permalink":"https://winniekun.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"mysql","slug":"mysql","permalink":"https://winniekun.github.io/categories/mysql/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://winniekun.github.io/tags/Linux/"},{"name":"security","slug":"security","permalink":"https://winniekun.github.io/tags/security/"},{"name":"杂谈","slug":"杂谈","permalink":"https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"},{"name":"书单","slug":"书单","permalink":"https://winniekun.github.io/tags/%E4%B9%A6%E5%8D%95/"},{"name":"效率工具","slug":"效率工具","permalink":"https://winniekun.github.io/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"},{"name":"锁","slug":"锁","permalink":"https://winniekun.github.io/tags/%E9%94%81/"},{"name":"基础","slug":"基础","permalink":"https://winniekun.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"rpc","slug":"rpc","permalink":"https://winniekun.github.io/tags/rpc/"},{"name":"配置","slug":"配置","permalink":"https://winniekun.github.io/tags/%E9%85%8D%E7%BD%AE/"},{"name":"内存管理","slug":"内存管理","permalink":"https://winniekun.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"jdk","slug":"jdk","permalink":"https://winniekun.github.io/tags/jdk/"},{"name":"kafka","slug":"kafka","permalink":"https://winniekun.github.io/tags/kafka/"},{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"lang","slug":"lang","permalink":"https://winniekun.github.io/tags/lang/"},{"name":"双指针","slug":"双指针","permalink":"https://winniekun.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"Queue","slug":"Queue","permalink":"https://winniekun.github.io/tags/Queue/"},{"name":"应用层","slug":"应用层","permalink":"https://winniekun.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"},{"name":"ioc","slug":"ioc","permalink":"https://winniekun.github.io/tags/ioc/"},{"name":"归并排序","slug":"归并排序","permalink":"https://winniekun.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"数学基础","slug":"数学基础","permalink":"https://winniekun.github.io/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"name":"SQL","slug":"SQL","permalink":"https://winniekun.github.io/tags/SQL/"},{"name":"多线程","slug":"多线程","permalink":"https://winniekun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"if-else优化","slug":"if-else优化","permalink":"https://winniekun.github.io/tags/if-else%E4%BC%98%E5%8C%96/"},{"name":"dfs","slug":"dfs","permalink":"https://winniekun.github.io/tags/dfs/"},{"name":"bfs","slug":"bfs","permalink":"https://winniekun.github.io/tags/bfs/"},{"name":"trie","slug":"trie","permalink":"https://winniekun.github.io/tags/trie/"},{"name":"http","slug":"http","permalink":"https://winniekun.github.io/tags/http/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://winniekun.github.io/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"java基础","slug":"java基础","permalink":"https://winniekun.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"面试36讲","slug":"面试36讲","permalink":"https://winniekun.github.io/tags/%E9%9D%A2%E8%AF%9536%E8%AE%B2/"},{"name":"List","slug":"List","permalink":"https://winniekun.github.io/tags/List/"},{"name":"JUC","slug":"JUC","permalink":"https://winniekun.github.io/tags/JUC/"},{"name":"动态规划","slug":"动态规划","permalink":"https://winniekun.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"单调栈","slug":"单调栈","permalink":"https://winniekun.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"并发","slug":"并发","permalink":"https://winniekun.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://winniekun.github.io/tags/%E5%89%91%E6%8C%87offer/"},{"name":"二分搜索","slug":"二分搜索","permalink":"https://winniekun.github.io/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"},{"name":"I/O","slug":"I-O","permalink":"https://winniekun.github.io/tags/I-O/"},{"name":"位运算","slug":"位运算","permalink":"https://winniekun.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"图论","slug":"图论","permalink":"https://winniekun.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"ip","slug":"ip","permalink":"https://winniekun.github.io/tags/ip/"},{"name":"tcp","slug":"tcp","permalink":"https://winniekun.github.io/tags/tcp/"},{"name":"命令行","slug":"命令行","permalink":"https://winniekun.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"选择","slug":"选择","permalink":"https://winniekun.github.io/tags/%E9%80%89%E6%8B%A9/"},{"name":"AVL树","slug":"AVL树","permalink":"https://winniekun.github.io/tags/AVL%E6%A0%91/"},{"name":"flag","slug":"flag","permalink":"https://winniekun.github.io/tags/flag/"},{"name":"Map","slug":"Map","permalink":"https://winniekun.github.io/tags/Map/"},{"name":"springboot","slug":"springboot","permalink":"https://winniekun.github.io/tags/springboot/"},{"name":"回溯","slug":"回溯","permalink":"https://winniekun.github.io/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"链表","slug":"链表","permalink":"https://winniekun.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"二叉树","slug":"二叉树","permalink":"https://winniekun.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"交换","slug":"交换","permalink":"https://winniekun.github.io/tags/%E4%BA%A4%E6%8D%A2/"},{"name":"BST","slug":"BST","permalink":"https://winniekun.github.io/tags/BST/"},{"name":"总结","slug":"总结","permalink":"https://winniekun.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"B树","slug":"B树","permalink":"https://winniekun.github.io/tags/B%E6%A0%91/"},{"name":"插入","slug":"插入","permalink":"https://winniekun.github.io/tags/%E6%8F%92%E5%85%A5/"},{"name":"spring","slug":"spring","permalink":"https://winniekun.github.io/tags/spring/"}]}