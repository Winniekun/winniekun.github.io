{"meta":{"title":"Wkkの笔记","subtitle":"好记性不如烂键盘","description":"Anything in life worth doing is worth overdoing. Moderation is for cowards. ","author":"weikunkun","url":"https://winniekun.github.io","root":"/"},"pages":[{"title":"About Me","date":"2021-05-19T09:47:58.000Z","updated":"2021-10-03T14:03:18.251Z","comments":true,"path":"about/index.html","permalink":"https://winniekun.github.io/about/index.html","excerpt":"","text":"NPE 😈"},{"title":"Categories","date":"2021-05-19T09:47:47.000Z","updated":"2021-05-19T10:27:14.252Z","comments":true,"path":"categories/index.html","permalink":"https://winniekun.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-05-19T09:47:52.000Z","updated":"2021-05-19T10:27:30.150Z","comments":true,"path":"tags/index.html","permalink":"https://winniekun.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"分布式锁的阐述以及实现","slug":"分布式/distributed-lock-manager","date":"2021-09-22T08:10:46.000Z","updated":"2021-09-22T14:46:23.802Z","comments":true,"path":"distributed-lock-manager/","link":"","permalink":"https://winniekun.github.io/distributed-lock-manager/","excerpt":"","text":"分布式锁阐述在搞明白分布式锁之前，先明白其由来。 谈到分布式锁自然也就能联想到分布式应用。 在将应用拆分为分布式应用之前，是单机系统，在单机系统中的并发场景为单进程多线程模式 采用加锁或者非阻塞同步或者无锁同步可以简单的实现同步操作 将应用拆分为分布式应用之后，并发场景变成了多进程+多线程的模式 业界常用的解决方案通常是借助于一个第三方组件并==利用它自身的排他性来达到多进程的互斥==。如： 基于DB的唯一索引 基于ZK的临时节点 基于Redis的NX EX参数 EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。 PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。 NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。 XX ：只在键已经存在时，才对键进行设置操作。 一个良好的分布式锁，要解决如下的几个核心的问题： 可用问题： 无论何时都要保证锁服务的可用性（这是系统正常执行锁操作的基础）。 死锁问题： 客户端一定可以获取锁，即使其他客户端获取锁之后，在释放锁之前宕机了。 脑裂问题： 集群同步时产生的数据不一致或者故障转移时，导致新的进程有可能拿到锁，但之前的进程以为自己还有锁，那么就出现两个进程拿到了同一个锁的问题。 可重入： 一个节点获取了锁之后，还可以再次获取整个锁资源。 MySQL实现分布式锁基于MySQL的方案，一般分为3类：基于表记录、乐观锁和悲观锁 基于表记录最直观的形式就是创建一张表，然后在表里面执行操作，获取锁时在记录中新增一条记录，释放锁的时候再把该记录删除即可。 DDL： CREATE TABLE `database_lock` ( `id` BIGINT NOT NULL AUTO_INCREMENT, `resource` int NOT NULL COMMENT '锁定的资源', `description` varchar(1024) NOT NULL DEFAULT \"\" COMMENT '描述', PRIMARY KEY (`id`), UNIQUE KEY `uiq_idx_resource` (`resource`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='数据库分布式锁表'; 因为添加了唯一索引，所以能够保证排他性，同一时间只有一个客户端获取到共享资源（报错：ERROR 1062 (23000): Duplicate entry ‘1’ for key ‘uiq_idx_resource’）。 获取锁： INSERT INTO database_lock(resource, description) VALUES (1, 'lock'); 释放锁： DELETE FROM database_lock WHERE resource = 1; 注意事项： 没有时效时间，如果客户端获取锁之后，宕机之后，或者其他释放锁操作失败，就会导致其他客户端无法获取锁 可以做一个定时任务去定时清理。 这种锁的可靠性依赖于数据库。建议设置备库，避免单点，进一步提高可靠性 这种锁是非阻塞的，因为插入数据失败之后会直接报错，想要获得锁就需要再次操作。如果需要阻塞式的，可以弄个for循环、while循环之类的，直至INSERT成功再返回 这种锁也是非可重入的，因为同一个线程在没有释放锁之前无法再次获得锁，因为数据库中已经存在同一份记录了。想要实现可重入锁，可以在数据库中添加一些字段，比如获得锁的主机信息、线程信息等，那么在再次获得锁的时候可以先查询数据，如果当前的主机信息和线程信息等能被查到的话，可以直接把锁分配给它。 基于乐观锁DDL： CREATE TABLE `optimistic_lock` ( `id` BIGINT NOT NULL AUTO_INCREMENT, `resource` int NOT NULL COMMENT '锁定的资源', `version` int NOT NULL COMMENT '版本信息', `created_at` datetime COMMENT '创建时间', `updated_at` datetime COMMENT '更新时间', `deleted_at` datetime COMMENT '删除时间', PRIMARY KEY (`id`), UNIQUE KEY `uiq_idx_resource` (`resource`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='数据库分布式锁表'; 在使用乐观锁之前要确保表中有相应的数据，比如： INSERT INTO optimistic_lock(resource, version, created_at, updated_at) VALUES(20, 1, CURTIME(), CURTIME()); 在单线程的情况中，流程如下： 获取资源： select resource from optimistic_lock where id = 1; 执行业务逻辑 更新资源：update optimistic_lock set resource = resource - 1 where id = 1 不过在多线程的情况下，可能会出现超减的问题。所以我们可以通过一个version或者时间戳来进行控制，类似CAS 获取资源：SELECT resource, version FROM optimistic_lock WHERE id = 1 执行业务逻辑 更新资源：UPDATE optimistic_lock SET resource = resource -1, version = version + 1 WHERE id = 1 AND version = oldVersion 虽然本身并没有利用到数据库自身的锁机制，不影响请求性能，但是，并发量大的时候，会导致大量的请求失败。同时因为都是作用在同一条记录上，在一些特殊场景，如大促、秒杀等活动开展的时候，大量的请求同时请求同一条记录的行锁，会对数据库产生很大的写压力。所以综合数据库乐观锁的优缺点，乐观锁比较适合并发量不高，并且写操作不频繁的场景 基于悲观锁除了可以通过增删操作数据库表中的记录以外，我们还可以借助数据库中自带的锁来实现分布式锁。在查询语句后面增加FOR UPDATE，数据库会在查询过程中给数据库表增加悲观锁，也称排他锁。当某条记录被加上悲观锁之后，其它线程也就无法再改行上增加悲观锁。 步骤如下： 获取资源 SELECT * FROM database_lock WHERE id = 1 FOR UPDATE 执行业务逻辑 释放锁 COMMIT 注意事项： 避免锁升级到表锁。所以需要明确能够走到索引。 在悲观锁中，每一次行数据的访问都是独占的，只有当正在访问该行数据的请求事务提交以后，其他请求才能依次访问该数据，否则将阻塞等待锁的获取。悲观锁可以严格保证数据访问的安全。但是缺点也明显，即每次请求都会额外产生加锁的开销且未获取到锁的请求将会阻塞等待锁的获取，在高并发环境下，容易造成大量请求阻塞，影响系统可用性。另外，悲观锁使用不当还可能产生死锁的情况。 Redis实现分布式锁单机Redis实现分布式锁获取锁： SET resource_name my_random_value NX PX 30000 上面的命令如果执行成功，则客户端成功获取到了锁，接下来就可以访问共享资源了；而如果上面的命令执行失败，则说明获取锁失败。 SET命令阐述： resource_name 可以视为一个共享资源 my_random_value 通过客户端自己生成一个随机符号，作为唯一标志符，避免错误解锁问题 NX 若当前key已经存在，则不执行任何操作，若当前key不存在，执行命令，也就是set操作。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁（很好的排他性）。 PX 3000 表示这个锁有一个30秒的自动过期时间。当然，这里30秒只是一个例子，客户端可以选择合适的过期时间。 释放锁： if redis.call(\"get\",KEYS[1]) == ARGV[1] then return redis.call(\"del\",KEYS[1]) else return 0 end LUA命令阐述： 前面的my_random_value作为ARGV[1]传入，然后把resource_name作为KEY[1]传进来 单机Redis实例实现分布式锁的一些核心点： 锁必须要设置一个过期时间（锁的有效时间），避免客户端获取锁之后崩溃或者出现网络分割等问题导致的其无法和Redis实例继续通信，最后导致其他客户端都无法获取锁 获取锁操作要保证原子性 上述获取锁的语义分为两步骤： set 、设置过期时间 SETNX resource_name my_random_value EXPIRE resource_name 30 但分为两个命令的话，无法保证原子性操作（set之后，客户端宕机了，则会一直持有锁），上述的获取锁操作就是一个命令，也就具有原子性了。 my_random_value是必须的 通过my_random_value作为每个客户端的唯一标识符，可以有效的解决错误解锁的问题 客户端A获取锁，然后执行操作 客户端A在某个操作上阻塞了很久，锁的有效时间超过了，自动释放锁 客户端B成功获取锁，执行自己的业务 客户端A从阻塞中恢复，然后释放了客户端B的锁 释放锁要保证原子性 对于释放锁来说，共有三个步骤：查询、判断、删除，和获取锁同理，也要保证原子性。为了实现原子性操作，可以通过LUA脚本来做 if redis.call(\"get\", KEY[1]) == ARGV[1] then return redis.call(\"del\", KEY[1]) else return 0; end 如果无法保证原子性的话，会出现如下的情况 客户端A成功获取到了锁 客户端A对共享资源进行操作 客户端A执行结束，开始释放锁，先执行GET操作获取锁，然后进行比较客户端自身的随机值比较，符合预期 客户端A因为某些原因，发生了阻塞 超过了锁的使用时间，客户端B在锁被超时释放后，成功获取锁 客户端A从阻塞中恢复过来，执行最后一步，也就是DEL操作，结果错误释放了客户端B获取的锁。 分布式锁RedLock以上问题，在实现分布式锁时，稍加注意就能够很好的的解决，但是有一种情况很难解决，其是由failover问题导致的，具体如下： failover引起的问题 客户端1从Master中获取锁 Master宕机了，并且Master的数据还同步到Slave上 Slave升级为Master 客户端2从新的Master中获取到了对应同一个资源的锁 这样就导致了客户端A和客户端B同时获取了同一个资源的锁，这样就违背了分布式锁的语义了，锁的安全性被打破了。针对这个问题，antirez设计了Redlock算法。 获取锁步骤： 获取系统当前的时间（毫秒级别） 按照顺序依次向N个Redis实例执行获取锁操作 整体流程和基于单个Redis实例获取锁相同，包含有random_value和过期时间（PX 3000 也称为有效时间） 同时为了保证某个Redis实例宕机时，RedLock能够正常工作，对于每次获取锁操作，还要有一个超时时间，并且要远小于整个锁的有效时间。客户端在当前Redis实例获取锁失败（可能是宕机、可能时网络超时）的话，需要立即尝试在后续的Redis的实例上获取锁。 计算客户端获取锁的过程中，共消耗了多少时间。计算方式为：访问N个Redis实例之后的时间 - 第一步开始时的时间。同时保证 成功获取了 $N/2 + 1$个Redis实例上获取到了锁。那么认为获取锁成功， 否则视为失败。 获取锁成功，对应的锁的有效时间要重新计算。它等于最开始设置的有效时间减去获取锁消耗的时间。 获取锁失败，要求客户端要对所有的Redis实例进行释放锁操作（Lua脚本保证原子性）。 释放锁的步骤 客户端要对所有的Redis实例进行释放锁操作（Lua脚本保证原子性），不管这些节点当时在获取锁的时候成功与否。 ZooKeeper实现分布式锁 客户端创建一个znode节点，比如/lock，那么就意味着客户端获取锁成功了。其他客户端获取锁失败（znode已经存在） 持有锁的客户端业务逻辑执行完成之后，会删除znode，这样其他的客户端就接下来就能获取锁了 znode应该被创建成ephemeral（临时的）的。这是znode的一个特性，它保证如果创建znode的那个客户端崩溃了，那么相应的znode会被自动删除。这保证了锁一定会被释放。 那么问题来了，ZooKeeper是如何检测到客户端是否崩溃呢？实际上每个客户端和ZooKeeper的某个服务器都维护一个 Session，这个Session通过心跳检测来维持，如果ZooKeeper长时间获取不到客户端的心跳（Session的过期时间），那么就认为Session过期了，同时会该Session对应的ephemeral的znode都会自动删除。 设想如下的执行序列： 客户端1创建了znode节点/lock，获得了锁。 客户端1进入了长时间的GC pause。 客户端1连接到ZooKeeper的Session过期了。znode节点/lock被自动删除。 客户端2创建了znode节点/lock，从而获得了锁。 客户端1从GC pause中恢复过来，它仍然认为自己持有锁。 最后，客户端1和客户端2都认为自己持有了锁，冲突了。这与Martin在文章中描述的由于GC pause导致的分布式锁失效的情况类似。 看起来，用ZooKeeper实现的分布式锁也不一定就是安全的，该有的问题它还是有。但是，ZooKeeper作为一个专门为分布式应用提供方案的框架，它提供了一些非常好的特性，是Redis之类的方案所没有的。像前面提到的ephemeral类型的znode自动删除的功能就是一个例子。 还有一个很有用的特性是ZooKeeper的watch机制。这个机制可以这样来使用，比如当客户端试图创建/lock的时候，发现它已经存在了，这时候创建失败，但客户端不一定就此对外宣告获取锁失败。客户端可以进入一种等待状态，等待当/lock节点被删除的时候，ZooKeeper通过watch机制通知它，这样它就可以继续完成创建操作（获取锁）。这可以让分布式锁在客户端用起来就像一个本地的锁一样：加锁失败就阻塞住，直到获取到锁为止。这样的特性Redlock就无法实现。 基于ZooKeeper的锁和基于Redis的锁相比在实现特性上有两个不同： 在正常情况下，客户端可以持有锁任意长的时间，这可以确保它做完所有需要的资源访问操作之后再释放锁。这避免了基于Redis的锁对于有效时间(lock validity time)到底设置多长的两难问题。实际上，基于ZooKeeper的锁是依靠Session（心跳）来维持锁的持有状态的，而Redis不支持Sesion。 基于ZooKeeper的锁支持在获取锁失败之后等待锁重新释放的事件。这让客户端对锁的使用更加灵活。 总结摘自张铁蕾的博客 按照锁的两种用途，如果仅是为了效率(efficiency)，那么你可以自己选择你喜欢的一种分布式锁的实现。当然，你需要清楚地知道它在安全性上有哪些不足，以及它会带来什么后果。而如果你是为了正确性(correctness)，那么请慎之又慎。我们在分布式锁的正确性上走得最远的地方，要数对于ZooKeeper分布式锁、单调递增的epoch number以及对分布式资源进行标记的分析了。请仔细审查相关的论证。 References 基于数据库实现的分布式锁 基于Redis的分布式锁到底安全吗 分布式系统中，如何回答锁的实现原理","categories":[{"name":"分布式","slug":"分布式","permalink":"https://winniekun.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"锁","slug":"锁","permalink":"https://winniekun.github.io/tags/%E9%94%81/"}]},{"title":"零拷贝技术的理解","slug":"操作系统/zero-copy","date":"2021-09-14T07:41:13.000Z","updated":"2021-09-14T11:32:28.465Z","comments":true,"path":"zero-copy/","link":"","permalink":"https://winniekun.github.io/zero-copy/","excerpt":"","text":"零拷贝的好处 减少或避免不必要的CPU数据拷贝，从而释放CPU去执行其他任务 零拷贝机制能减少用户空间和操作系统内核空间的上下文切换 减少内存的占用 DMA技术 DMA 在没有DMA技术之前，I/O的过程如上图所示： CPU 发出对应的指令给磁盘控制器，然后返回； 磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个中断； CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。 可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。 为了解决这一问题，中间层的思路就又出来了。后期引入DMA技术，在进行I/O处理的时候（设备和内存进行数据传输的时候），数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。 DMA 具体过程： 用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态； 操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务； DMA 进一步将 I/O 请求发送给磁盘； 磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满； DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务； 当 DMA 读取了足够多的数据，就会发送中断信号给 CPU； CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回； 传统的文件传输 文件传输 首先，期间共发生了 4 次用户态与内核态的上下文切换，因为发生了两次系统调用，一次是 read() ，一次是 write()，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。 上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。 其次，还发生了 4 次数据拷贝，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程： 第一次拷贝，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。 第二次拷贝，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。 第三次拷贝，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。 第四次拷贝，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。 优化思路减少上下文的切换首先， 对于I/O的处理，用户态是无权限的，只能切换到内核态进行处理，所以减少上下文的切换的一个思路就是：减少系统调用 减少拷贝的次数通过对上述的分析，我们知道传统的文件传输，涉及到了四次的copy过程。在一些场景中，我们知道其实数据是完全不必copy到用户空间的，因为应用程序一般不会对数据进行加工。 零拷贝mmap + write在前面我们知道，read() 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 mmap() 替换 read() 系统调用函数。 mmap + write 示意图 流程： 应用进程通过mmap后，DMA将磁盘文件放入内核缓冲区，然后用户程序和内核共享该缓冲区 然后用户程序调用write，将数据写入socket缓冲区，（内部而言，是cpu内核缓冲区的内容copy到socket缓冲区） 然后DMA将socket缓冲区放入到网卡缓冲区中 拷贝次数 从 4 -&gt; 3 上下文切换还是发生了4次 sendfile 通过减少系统调用，实现零copy技术 sendfile sendfile可以替代read和write两个系统调用，这样就可以减少一次系统调用，避免两次上下文切换。其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如上图所示。 但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（The Scatter-Gather Direct Memory Access）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程（只进行了 2 次数据拷贝）。 网卡DMA 第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里； 第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝； 这就是所谓的零拷贝（*Zero-copy*）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的 零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。 所以，总体来看，零拷贝技术可以把文件传输的性能提高至少一倍以上。 总结 使用mmap + write （4次上下文切换，上次文件拷贝） 减少一次文件copy 使用sendfile（2吃上下文切换，三次文件拷贝） 减少了2次上下文切换 减少一次文件copy 网卡支持SG-DMA（2次上下文切换， 两次文件拷贝（不需要CPU进行操作）） 减少了2次上下文切换 减少了2次文件拷贝 使用零拷贝技术的项目kafka使用零拷贝技术，消费者（consumer）从Kafka消费数据，Kafka从磁盘读数据然后发送到网络上去，数据一共发生了四次传输的过程。其中两次是 DMA 的传输，另外两次，则是通过 CPU 控制的传输。通过零拷贝技术，避免了文件的多余的copy次数，以及CPU的参与，进而能够更好的提升整体的性能，优化CPU的使用。 Java transferTopublic static void copyFileByChannel(File source, File dest) throws IOException { try (FileChannel sourceChannel = new FileInputStream(source) .getChannel(); FileChannel targetChannel = new FileOutputStream(dest).getChannel()) { for (long count = sourceChannel.size(); count &gt; 0; ) { long transferred = sourceChannel.transferTo( sourceChannel.position(), count, targetChannel); sourceChannel.position(sourceChannel.position() + transferred); count -= transferred; } } } references 原来 8 张图，就可以搞懂「零拷贝」了","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://winniekun.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://winniekun.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Dubbo和Spring、SpringBoot的结合简单Demo","slug":"rpc/dubbo-demo","date":"2021-09-05T11:45:28.000Z","updated":"2021-09-07T16:50:20.349Z","comments":true,"path":"dubbo-demo/","link":"","permalink":"https://winniekun.github.io/dubbo-demo/","excerpt":"","text":"序dubbo和Spring、SpringBoot的集合 环境 Spring （说白了就是两个进程的通信，然后将dubbo交由spring来管理，我们需要做的就是进行配置，然后按照文档硬编码） &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring.version&gt;5.3.4&lt;/spring.version&gt; &lt;dubbo.version&gt;2.7.8&lt;/dubbo.version&gt; &lt;curator.version&gt;4.2.0&lt;/curator.version&gt; &lt;zk.version&gt;3.5.8&lt;/zk.version&gt; &lt;/properties&gt; SpringBoot &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.wkk.dubbo&lt;/groupId&gt; &lt;artifactId&gt;provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;provider&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.wkk.dubbo&lt;/groupId&gt; &lt;artifactId&gt;api&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 和Spring的结合(未配置ZK) dubbo和spring的结合 pom.xml: &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.wkk&lt;/groupId&gt; &lt;artifactId&gt;spring-dubbo-demo&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;dubbo-provider&lt;/module&gt; &lt;module&gt;dubbo-consumer&lt;/module&gt; &lt;module&gt;dubbo-api&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring.version&gt;5.3.4&lt;/spring.version&gt; &lt;dubbo.version&gt;2.7.8&lt;/dubbo.version&gt; &lt;curator.version&gt;4.2.0&lt;/curator.version&gt; &lt;zk.version&gt;3.5.8&lt;/zk.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;${dubbo.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;${zk.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;${curator.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;${curator.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; API 公共接口，然后provider提供对该接口的实现，consumer对其发起调用 image-20210905233104405 package com.wkk.api; /** * @author weikunkun * @since 2021/9/5 */ public interface HelloApi { String hello(String name); } PROVIDER 负责对api的实现 dubbo-provider 配置&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. --&gt; &lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt; &lt;dubbo:application name=\"demo-provider\"/&gt; &lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt; &lt;!-- 声明对外暴露的接口 --&gt; &lt;dubbo:service registry=\"N/A\" interface=\"com.wkk.api.HelloApi\" ref=\"quickStartServiceApi\"/&gt; &lt;!--配置bean实例--&gt; &lt;bean id=\"quickStartServiceApi\" class=\"com.wkk.provider.api.HelloApiImpl\"/&gt; &lt;/beans&gt; 依赖&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;spring-dubbo-demo&lt;/artifactId&gt; &lt;groupId&gt;com.wkk&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;dubbo-provider&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.wkk&lt;/groupId&gt; &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 相关实现：API实现： package com.wkk.provider.api; import com.wkk.api.HelloApi; /** * @author weikunkun * @since 2021/9/5 */ public class HelloApiImpl implements HelloApi { public String hello(String name) { return \"this is dubbot quick starter, name = \" + name; } } 启动类： package com.wkk.provider; import org.springframework.context.support.ClassPathXmlApplicationContext; import java.io.IOException; /** * @author weikunkun * @since 2021/9/5 */ public class ProviderClient { public static void main(String[] args) throws IOException { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"dubbo-provider.xml\"); context.start(); System.in.read(); } } CONSUMER 负责调用对应的接口，为了方便起见，具体的调用直接在consumer中的启动类进行操作 dubbo-consumer 配置&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. --&gt; &lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://dubbo.apache.org/schema/dubbo\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt; &lt;dubbo:application name=\"consumer-of-helloworld-app\" /&gt; &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt; &lt;dubbo:reference id=\"demoService\" interface=\"com.wkk.api.HelloApi\" url=\"dubbo://xxxx:20880\"/&gt; &lt;/beans&gt; 依赖&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;spring-dubbo-demo&lt;/artifactId&gt; &lt;groupId&gt;com.wkk&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;dubbo-consumer&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.wkk&lt;/groupId&gt; &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 相关实现启动类 package com.wkk.consumer; import com.wkk.api.HelloApi; import org.springframework.context.support.ClassPathXmlApplicationContext; import java.util.Scanner; /** * @author weikunkun * @since 2021/9/5 */ public class ConsumerClient { public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"dubbo-consumer.xml\"); HelloApi demoService = (HelloApi) context.getBean(\"demoService\"); while (true) { Scanner sc = new Scanner(System.in); String str = sc.nextLine(); System.out.println(demoService.hello(str)); } } } 最终结果 成果展示 和SpringBoot的结合(未配置ZK) 整体和Spring结合一致 API 公共接口，然后provider提供对该接口的实现，consumer对其发起调用 api 接口的设计 package com.wkk.dubbo.api; /** * @author weikunkun * @since 2021/9/6 */ public interface HelloApi { String hello(String name); } PROVIDER配置dubbo: application: name: demo-provider registry: address: N/A protocol: name: dubbo port: 20880 依赖&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.wkk.dubbo&lt;/groupId&gt; &lt;artifactId&gt;provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;provider&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.wkk.dubbo&lt;/groupId&gt; &lt;artifactId&gt;api&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 相关实现package com.wkk.dubbo.provider.impl; import com.wkk.dubbo.api.HelloApi; import org.apache.dubbo.config.annotation.DubboService; import org.apache.dubbo.rpc.RpcContext; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; /** * @author weikunkun * @since 2021/9/6 */ @Component @DubboService(version = \"1.0.0\") public class HelloApiImpl implements HelloApi { private static final Logger logger = LoggerFactory.getLogger(HelloApiImpl.class); @Override public String hello(String name) { try { Thread.sleep(200); // logger.info(\"Hello \" + name + \", request from consumer: \" + RpcContext.getServerContext().getRemoteAddress()); return \"Hello \" + name + \", response from provider: \" + RpcContext.getServerContext().getLocalAddress(); } catch (InterruptedException e) { e.printStackTrace(); } return null; } } CONSUMER配置spring: application: name: dubbo-consumer 依赖&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.wkk.consumer&lt;/groupId&gt; &lt;artifactId&gt;consumer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;consumer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.wkk.dubbo&lt;/groupId&gt; &lt;artifactId&gt;api&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 相关实现DemoServiceComponent： 用于调用provider中对应的实现方法 package com.wkk.consumer.consumer.comp; import com.wkk.dubbo.api.HelloApi; import org.apache.dubbo.config.annotation.DubboReference; import org.springframework.stereotype.Component; /** * @author weikunkun * @since 2021/9/7 */ @Component public class DemoServiceComponent implements HelloApi { @DubboReference(version = \"1.0.0\", url = \"dubbo://xxxx:20880\") private HelloApi helloApi; @Override public String hello(String name) { return helloApi.hello(name); } } ConsumerApplication： 启动类，通过Scanner做了交互 package com.wkk.consumer.consumer; import com.wkk.dubbo.api.HelloApi; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ConfigurableApplicationContext; import java.util.Scanner; @SpringBootApplication public class ConsumerApplication { public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(ConsumerApplication.class, args); HelloApi demoService = (HelloApi) context.getBean(\"demoServiceComponent\"); Scanner sc = new Scanner(System.in); while (true) { String s = sc.nextLine(); System.out.println(demoService.hello(s)); } } } 最终结果 成果展示 源码链接源码","categories":[{"name":"dubbo","slug":"dubbo","permalink":"https://winniekun.github.io/categories/dubbo/"}],"tags":[{"name":"rpc","slug":"rpc","permalink":"https://winniekun.github.io/tags/rpc/"}]},{"title":"Kafka在Linux上的配置","slug":"配置/kafka-config","date":"2021-08-22T13:24:40.000Z","updated":"2021-08-22T14:35:22.469Z","comments":true,"path":"kafka-config/","link":"","permalink":"https://winniekun.github.io/kafka-config/","excerpt":"","text":"序Kafka简介Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个“按照分布式事务日志架构的大规模发布/订阅消息队列”，[3]这使它作为企业级基础设施来处理流式数据非常有价值。此外，Kafka可以通过Kafka Connect连接到外部系统（用于数据输入/输出），并提供了Kafka Streams——一个Java流式处理库)。 Kafka架构Kafka存储的消息来自任意多被称为“生产者”（Producer）的进程。数据从而可以被分配到不同的“分区”（Partition）、不同的“Topic”下。在一个分区内，这些消息被索引并连同时间戳存储在一起。其它被称为“消费者”（Consumer）的进程可以从分区查询消息。Kafka运行在一个由一台或多台服务器组成的集群上，并且分区可以跨集群结点分布。 Kafka高效地处理实时流式数据，可以实现与Storm、HBase和Spark的集成。作为聚类部署到多台服务器上，Kafka处理它所有的发布和订阅消息系统使用了四个API，即生产者API、消费者API、Stream API和Connector API。它能够传递大规模流式消息，自带容错功能，已经取代了一些传统消息系统，如JMS、AMQP等。 Kafka架构的主要术语包括Topic、Record和Broker。Topic由Record组成，Record持有不同的信息，而Broker则负责复制消息。Kafka有四个主要API： 生产者API：支持应用程序发布Record流。 消费者API：支持应用程序订阅Topic和处理Record流。 Stream API：将输入流转换为输出流，并产生结果。 Connector API：执行可重用的生产者和消费者API，可将Topic链接到现有应用程序。 环境依赖 JDK11 kafka_2.13-2.8.0.tgz 基础使用假设Kafka环境和Zookeeper环境都没有 1. 下载并解压&gt; tar -xzf kafka_2.13-2.8.0.tgz &gt; mv kafka_2.13-2.8.0.tgz /usr/local/kafka &gt; cd /usr/local/kafka 2. 启动服务 kafka的启动依赖于Java环境，所以在使用Kakfa之前，记得配置Java8+的环境 &gt; bin/zookeeper-server-start.sh config/zookeeper.properties 打开另一个命令终端启动kafka服务： ## 用于后台启动 &gt; bin/kafka-server-start.sh config/server.properties &amp; 一旦所有服务成功启动，那Kafka已经可以使用了。 3. 创建一个主题创建一个名为“test”的Topic，只有一个分区和一个备份： &gt; bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test 创建好之后，可以通过运行以下命令，查看已创建的topic信息： &gt; bin/kafka-topics.sh --describe --topic test --bootstrap-server localhost:9092 Topic:quickstart-events PartitionCount:1 ReplicationFactor:1 Configs: Topic: quickstart-events Partition: 0 Leader: 0 Replicas: 0 Isr: 0 4. 发送消息Kafka提供了一个命令行的工具，可以从输入文件或者命令行中读取消息并发送给Kafka集群。每一行是一条消息。 运行 producer（生产者）,然后在控制台输入几条消息到服务器。 &gt; bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test hello world what's your name 5. 消费消息Kafka也提供了一个消费消息的命令行工具，将存储的信息输出出来，新打开一个命令控制台，输入： &gt; bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning hello world what's your name 注意，若是在服务器开启kafka服务，然后本地消费生产的消息，需要在kafka中的 config/service.properties 中修改配置（注意开启服务器对应的端口） advertised.listeners=PLAINTEXT://your ip : your port 6. 使用 Kafka Connect 来 导入/导出 数据可能现有的系统中拥有大量的数据，如关系型数据库或传统的消息传递系统，以及许多已经使用这些系统的应用程序。Kafka Connect允许你不断地从外部系统提取数据到Kafka，反之亦然。用Kafka整合现有的系统是非常容易的。为了使这个过程更加容易，有数百个这样的连接器现成可用。 7. 使用Kafka Stream来处理数据一旦我们的数据存储在Kafka中，就可以用Kafka Streams客户端库来处理这些数据，该库适用于Java/Scala。它允许你实现自己的实时应用程序和微服务，其中输入和/或输出数据存储在Kafka主题中。Kafka Streams将在客户端编写和部署标准Java和Scala应用程序的简单性与Kafka服务器端集群技术的优势相结合，使这些应用程序具有可扩展性、弹性、容错性和分布式。该库支持精确的一次性处理、有状态操作和聚合、窗口化、连接、基于事件时间的处理等等。 一个初步的体验，实现一个流行的WordCount算法的： KStream&lt;String, String&gt; textLines = builder.stream(\"quickstart-events\"); KTable&lt;String, Long&gt; wordCounts = textLines .flatMapValues(line -&gt; Arrays.asList(line.toLowerCase().split(\" \"))) .groupBy((keyIgnored, word) -&gt; word) .count(); wordCounts.toStream().to(\"output-topic\", Produced.with(Serdes.String(), Serdes.Long())); 以系统服务方式启动kafka创建 /usr/lib/systemd/system/zookeeper.service 并写入 [Unit] Requires=network.target After=network.target [Service] Type=simple Environment=\"PATH=/opt/jdk-11.0.12/bin:/opt/jdk-11.0.12/jre/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\" LimitNOFILE=1048576 ExecStart=/usr/local/kafka/bin/zookeeper-server-start.sh /usr/local/kafka/config/zookeeper.properties ExecStop=/usr/local/kafka/bin/zookeeper-server-stop.sh Restart=Always [Install] WantedBy=multi-user.target 创建 /usr/lib/systemd/system/kafka.service 并写入 [Unit] Requires=zookeeper.service After=zookeeper.service [Service] Type=simple Environment=\"PATH=/opt/jdk-11.0.12/bin:/opt/jdk-11.0.12/jre/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\" LimitNOFILE=1048576 ExecStart=/usr/local/kafka/bin/kafka-server-start.sh /usr/local/kafka/config/server.properties ExecStop=/usr/local/kafka/bin/kafka-server-stop.sh Restart=Always [Install] WantedBy=multi-user.target 注意：示例的kafka安装地址在 /usr/local/kafka 因为系统服务不会直接读取我们配置在/etc/profile或者bash_profile中的环境变量，所以Environment一定要记得配置。 ## 查看当前环境变量 export $PATH 启动服务重载系统服务并启动 systemctl daemon-reload systemctl enable zookeeper &amp;&amp; systemctl enable kafka systemctl start zookeeper &amp;&amp; systemctl start kafka systemctl status zookeeper &amp;&amp; systemctl status kafka zookeeper kafka references 维基百科—-kafka Kafka教程","categories":[{"name":"kafka","slug":"kafka","permalink":"https://winniekun.github.io/categories/kafka/"}],"tags":[{"name":"配置","slug":"配置","permalink":"https://winniekun.github.io/tags/%E9%85%8D%E7%BD%AE/"}]},{"title":"虚拟内存概览","slug":"操作系统/virtual-memory","date":"2021-07-27T06:57:30.000Z","updated":"2021-08-09T10:11:43.891Z","comments":true,"path":"virtual-memory/","link":"","permalink":"https://winniekun.github.io/virtual-memory/","excerpt":"","text":"序 “Any problem in computer science can be solved by another layer of indirection. ——程序员的自我修养 物理寻址早期，CPU在处理某个进程的时候，处理的流程如下。 对于物理寻址而言，我们需要直接将程序全部装入到物理内存中，接下来运行期间，CPU在处理时，直接进行物理寻址。然后执行相关的读写命令。 对于物理内存而言，是不做任何访问限制的，所以直接操作进行物理寻址会导致一个问题是： 读写内存的安全性问题 不同的进程被分配到不同的物理内存中，运行期间导致进程A错误修改了进程B占用的物理内存，导致进程B出现问题 危害操作系统自身的安全。恶意的进程直接修改操作系统所占用的物理空间，导致系统崩溃 内存的利用率不高 一个系统中，不同的进程是共享CPU和物理内存资源的，如果有很多的进程需要很大的内存，那么就会导致这些进程所需的内存大小 &gt; 实际的物理内存，这样就会导致有些有些进程无法被执行。 所以，为了更加有效的管理内存并且少出错，现代的操作系统提供了一种对主存的抽象概念—-虚拟内存。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘和内核软件的完美交互 虚拟内存概念 虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。现代所有用于一般应用的操作系统都对普通的应用程序使用虚拟内存技术，老一些的操作系统，如DOS和1980年代的Windows，或者那些1960年代的大型机，一般都没有虚拟内存的功能——维基百科 引入序中所引用的话Any problem in computer science can be solved by another layer of indirection. 同理虚拟内存为进程&lt;---&gt;物理内存的中间层，它为进程隐藏了物理内存的概念，同时为其提供了更加简洁易用的接口，供其调用。同时还提供了一些更加复杂的功能。 能力一：高速缓存我们可以将虚拟内存看作是磁盘上的一片空间，当这片空间中的一部分访问比较频繁时，该部分数据会以页为单位被缓存到主存中以加速 CPU 访问数据的性能，虚拟内存利用空间较大的磁盘存储作为『内存』并使用主存储缓存进行加速，让进程认为操作系统的内存很大而且很快，然而区域很大的磁盘并不快，而很快的内存也并不大。 虚拟内存作为缓存 在虚拟内存中的虚拟页共分为三种类型： 未分配 没有被进程申请使用的，也就是空闲的虚拟内存， 不占用虚拟内存磁盘的任何空间 未缓存 仅仅加载到磁盘中的页 已缓存 已经加载到内存中的内存页（页框） 能力二：内存管理 简化链接和加载 简化内存共享 将不同的进程中的页表中某些页表项映射到相同的物理地址，即可实现内存的共享。 简化内存分配 独立的虚拟内存空间也会简化内存的分配过程，当用户程序向操作系统申请堆内存时，操作系统可以分配几个连续的虚拟页，但是这些虚拟页可以对应到物理内存中不连续的页中。 能力三：内存保护现代操作系统中，用户进程不应该被允许修改它的只读代码段，而且也不应该允许它读取或修改任何内核中的代码和数据结构，并且也不允许其读取或者修改其他进程的私有内存，以及修改和其他进程共享的虚拟页面。如果不对进程的内存访问进行限制，攻击者就能够访问和修改其他进程的私有内存，进而导致整个系统崩溃。 通过虚拟内存，我们为进程提供了独立的地址空间，同时这也让我们能够快速的区分不同进程的私有内存。同时我们通过虚拟内存到实际的物理内存的转化需要使用地址翻译机制，整体流程如下所示： 虚拟寻址方式 通过MMU，每次都会读取页表中的一个页表条目(PTE)，通过在这些页表条目(PTE)中添加一些标志位，就能够实现对一个虚拟页的访问控制权限。譬如： 带标志位的页表 应用程序如何如何使用和管理虚拟内存 [ ] TODO 总结虚拟内存的思想，整体来看就是：通过结合磁盘和内存各自的优势，利用中间层对资源进行更合理地调度，充分提高资源的利用率。并提供和谐以及统一的抽象。个人目前接触到的最直观的体现就是 JDK中集合类的设计与实现。其也可以算是数据和数据结构之间的中间层，结合其他的技术譬如泛型，为上层的数据提供了接口的同时，隐藏了内部数据结构的实现以及维护。 最后再总结下为什么需要虚拟内存： 虚拟内存可以结合磁盘和物理内存的优势为进程提供看起来速度足够快并且容量足够大的存储； 虚拟内存可以为进程提供独立的内存空间并引入多层的页表结构将虚拟内存翻译成物理内存，进程之间可以共享物理内存减少开销，也能简化程序的链接、装载以及内存分配过程； 虚拟内存可以控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性； references csapp 第九章 操作系统导论 内存虚拟化部分 为什么Linux需要虚拟内存 如何理解虚拟内存","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://winniekun.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"内存管理","slug":"内存管理","permalink":"https://winniekun.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"ConcurrentHashMap源码分析","slug":"源码/JDK/map/concurrenthashmap-analysis","date":"2021-07-19T10:40:55.000Z","updated":"2021-07-19T13:56:53.865Z","comments":true,"path":"concurrenthashmap-analysis/","link":"","permalink":"https://winniekun.github.io/concurrenthashmap-analysis/","excerpt":"","text":"序ConcurrentHashMap，可以理解成是HashMap的线程安全版本，同样的，内部使用也是（数组 + 链表 + 红黑树）的结构来存储元素。同时相比于同样提供线程安全的HashTable，效率等各方面都有所提升 概述 ConcurrentHashMap 阅读套路按照正常的逻辑， 首先基础的数据构造, 然后了解其构造方法， 之后了解常用的API(CRUD)操作即可。 [x] 增 [x] 删 [x] 改 [x] 查 类的属性// 和hashmap类似 transient volatile Node&lt;K,V&gt;[] table; // 用于并发情况下的扩容控制 private transient volatile Node&lt;K,V&gt;[] nextTable; // 并发安全控制 private transient volatile long baseCount; private transient volatile int sizeCtl; private transient volatile int transferIndex; private transient volatile int cellsBusy; private transient volatile CounterCell[] counterCells; // views private transient KeySetView&lt;K,V&gt; keySet; private transient ValuesView&lt;K,V&gt; values; private transient EntrySetView&lt;K,V&gt; entrySet; private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * The default initial table capacity. Must be a power of 2 * (i.e., at least 1) and at most MAXIMUM_CAPACITY. */ private static final int DEFAULT_CAPACITY = 16; /** * The largest possible (non-power of two) array size. * Needed by toArray and related methods. */ static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * The default concurrency level for this table. Unused but * defined for compatibility with previous versions of this class. */ private static final int DEFAULT_CONCURRENCY_LEVEL = 16; /** * The load factor for this table. Overrides of this value in * constructors affect only the initial table capacity. The * actual floating point value isn't normally used -- it is * simpler to use expressions such as {@code n - (n &gt;&gt;&gt; 2)} for * the associated resizing threshold. */ private static final float LOAD_FACTOR = 0.75f; /** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2, and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */ static final int TREEIFY_THRESHOLD = 8; /** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */ static final int UNTREEIFY_THRESHOLD = 6; /** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * The value should be at least 4 * TREEIFY_THRESHOLD to avoid * conflicts between resizing and treeification thresholds. */ static final int MIN_TREEIFY_CAPACITY = 64; /** * Minimum number of rebinnings per transfer step. Ranges are * subdivided to allow multiple resizer threads. This value * serves as a lower bound to avoid resizers encountering * excessive memory contention. The value should be at least * DEFAULT_CAPACITY. */ private static final int MIN_TRANSFER_STRIDE = 16; /** * The number of bits used for generation stamp in sizeCtl. * Must be at least 6 for 32bit arrays. */ private static int RESIZE_STAMP_BITS = 16; /** * The maximum number of threads that can help resize. * Must fit in 32 - RESIZE_STAMP_BITS bits. */ private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1; /** * The bit shift for recording size stamp in sizeCtl. */ private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS; /* * Encodings for Node hash fields. See above for explanation. */ static final int MOVED = -1; // hash for forwarding nodes static final int TREEBIN = -2; // hash for roots of trees static final int RESERVED = -3; // hash for transient reservations static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash /** Number of CPUS, to place bounds on some sizings */ static final int NCPU = Runtime.getRuntime().availableProcessors(); 构造方法public ConcurrentHashMap() { } public ConcurrentHashMap(int initialCapacity) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(); int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); this.sizeCtl = cap; } public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) { this.sizeCtl = DEFAULT_CAPACITY; putAll(m); } public ConcurrentHashMap(int initialCapacity, float loadFactor) { this(initialCapacity, loadFactor, 1); } public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (initialCapacity &lt; concurrencyLevel) // Use at least as many bins initialCapacity = concurrencyLevel; // as estimated threads long size = (long)(1.0 + (long)initialCapacity / loadFactor); int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)size); this.sizeCtl = cap; } 构造方法与HashMap对比可以发现，没有了HashMap中的threshold和loadFactor，而是改用了sizeCtl来控制，而且只存储了容量在里面，那么它是怎么用的呢？官方给出的解释如下： Table initialization and resizing control. When negative, the table is being initialized or resized: -1 for initialization, else -(1 + the number of active resizing threads). Otherwise, when table is null, holds the initial table size to use upon creation, or 0 for default. After initialization, holds the next element count value upon which to resize the table. -1 有线程正在初始化 -(1 + n) 有n个线程正在一起扩容 0 默认值， 后续在真正初始化的时候使用默认容量 &gt;0 初始化或扩容完成后下一次的扩容门槛 增public V put(K key, V value) { return putVal(key, value, false); } /** Implementation for put and putIfAbsent */ final V putVal(K key, V value, boolean onlyIfAbsent) { // key和value都不能为null if (key == null || value == null) throw new NullPointerException(); // 计算hash值 int hash = spread(key.hashCode()); // 要插入的元素所在桶的元素个数 int binCount = 0; // 死循环，结合CAS使用（如果CAS失败，则会重新取整个桶进行下面的流程） for (Node&lt;K,V&gt;[] tab = table;;) { Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) // 如果桶未初始化或者桶个数为0，则初始化桶 tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) { // 如果要插入的元素所在的桶还没有元素，则把这个元素插入到这个桶中 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) // 如果使用CAS插入元素时，发现已经有元素了，则进入下一次循环，重新操作 // 如果使用CAS插入元素成功，则break跳出循环，流程结束 break; // no lock when adding to empty bin } else if ((fh = f.hash) == MOVED) // 如果要插入的元素所在的桶的第一个元素的hash是MOVED，则当前线程帮忙一起迁移元素 tab = helpTransfer(tab, f); else { // 如果这个桶不为空且不在迁移元素，则锁住这个桶（分段锁） // 并查找要插入的元素是否在这个桶中 // 存在，则替换值（onlyIfAbsent=false） // 不存在，则插入到链表结尾或插入树中 V oldVal = null; synchronized (f) { // 再次检测第一个元素是否有变化，如果有变化则进入下一次循环，从头来过 if (tabAt(tab, i) == f) { // 如果第一个元素的hash值大于等于0（说明不是在迁移，也不是树） // 那就是桶中的元素使用的是链表方式存储 if (fh &gt;= 0) { // 桶中元素个数赋值为1 binCount = 1; // 遍历整个桶，每次结束binCount + 1 for (Node&lt;K,V&gt; e = f;; ++binCount) { K ek; // 在链表中找到了改元素，覆盖 并退出 if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } // 如果没有找到 则 直接在尾部插入改元素 Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) { pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; } } } // 树上找点 else if (f instanceof TreeBin) { Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } // 如果binCount不为0，说明成功插入了元素或者寻找到了元素 if (binCount != 0) { // 如果链表元素个数达到了8，则尝试树化 // 因为上面把元素插入到树中时，binCount只赋值了2，并没有计算整个树中元素的个数 // 所以不会重复树化 if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } // 成功插入元素，元素个数加1（是否要扩容在这个里面） addCount(1L, binCount); return null; } 流程和hashmap类似： 如果hash桶未初始化，则先初始化 如果当前位置无元素，则通过cas的方式放入元素 如果当前位置存在元素 是转移节点（正在扩容），则将当前线程一起加入到扩容中 不是转移节点，锁这个桶 如果为链表节点，进行在链表上查找该元素，找到？覆盖：执行插入操作 如果为树节点，在红黑树中查找该元素，找到？覆盖：执行插入操作 存在该元素时，返回旧value 不存在，整个map的元素+ 1，并检查是否需要扩容 因为是线程安全的操作，所以仔细看下在整个put阶段，采用了哪些手段保证线程安全。这个才是我们看CHM源码的关键 数组初始化时的线程安全措施private final Node&lt;K,V&gt;[] initTable() { Node&lt;K,V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) { // 小于 0 代表有线程正在初始化，释放当前 CPU 的调度权，重新发起锁的竞争 if ((sc = sizeCtl) &lt; 0) Thread.yield(); // lost initialization race; just spin // CAS 赋值保证当前只有一个线程在初始化， // -1 代表当前只有一个线程能初始化 // 保证了数组的初始化的安全性 else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { try { // 很有可能执行到这里的时候，table 已经不为空了，这里是双重 check // 如果把sizeCtl原子更新为-1成功，则当前线程进入初始化 // 如果原子更新失败则说明有其它线程先一步进入初始化了，则进入下一次循环 // 如果下一次循环时还没初始化完毕，则sizeCtl&lt;0进入上面if的逻辑让出CPU // 如果下一次循环更新完毕了，则table.length!=0，退出循环 if ((tab = table) == null || tab.length == 0) { // 进行初始化 int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(\"unchecked\") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = tab = nt; sc = n - (n &gt;&gt;&gt; 2); } } finally { sizeCtl = sc; } break; } } return tab; } 小总结 数组初始化时： 使用CAS锁控制只有一个线程初始化桶数组并且一定能初始化成功； 然后通过 CAS 设置 sizeCtl 变量的值，来保证同一时刻只能有一个线程对数组进行初始化，CAS 成功之后，还会再次判断当前数组 是否已经初始化完成，如果已经初始化完成，就不会继续再执行初始化 扩容门槛写死的是桶数组大小的0.75倍，桶数组大小即map的容量，也就是最多存储多少个元素。 通过自旋 + cas + double check 保障了数组初始化时的线程安全。 Java线程中的一些方法的区别（sleep、yield、wait、join）只有runnable到running时才会占用cpu时间片，其他都会出让cpu时间片。线程的资源有不少，整体来看可分为如下两类 CPU资源 锁资源 分析以上四个方法时，查看这两个共享资源是否释放，区分更加明显 sleep：Thread类的方法，必须带一个时间参数。会让当前线程休眠进入阻塞状态并释放CPU（阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段），提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁 可通过调用interrupt()方法来唤醒休眠线程。 yield：让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 ，并且yield()方法只能让同优先级的线程有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。 wait：Object类的方法(notify()、notifyAll() 也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁 join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。 在桶位置放入元素时的线程安全措施（4个措施）else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) { if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin } static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) { return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v); } 通过自旋死循环保证一定可以新增成功 1⃣️ 在新增之前，通过==for (Node[] tab = table;;)==这样的死循环来保证新增一定可以成功，一旦新增成功，就可以退出当前死循环，新增失败的话，会重复新增的步骤，直到新增成功为止。 当前hash桶是否有元素： 无元素 cas 新增 2⃣️ Java 这里的写法非常严谨，没有在判断槽点为空的情况下直接赋值，因为在判断槽点为空和赋 值的瞬间，很有可能槽点已经被其他线程赋值了，所以我们采用 CAS 算法，能够保证槽点为空 的情况下赋值成功，如果恰好槽点已经被其他线程赋值，当前 CAS 操作失败，会再次执行 for 自旋，再走槽点有值的 put 流程，这里就是自旋 + CAS 的结合。 有元素 锁住当前点 （synchronized）3⃣️ put 时，如果当前槽点有值，就是 key 的 hash 冲突的情况，此时槽点上可能是链表或红黑树， 我们通过锁住槽点，来保证同一时刻只会有一个线程能对槽点进行修改 红黑树旋转时， 锁住红黑树的根节点，保证同一时刻，当前红黑树只能被一个线程旋转 4⃣️ 扩容时的线程安全措施ConcurrentHashMap 的扩容时机和 HashMap 相同，都是在 put 方法的最后一步检查是否需要扩 容，如果需要则进行扩容，但两者扩容的过程完全不同，ConcurrentHashMap 扩容的方法叫做 transfer，从 put 方法的 addCount 方法进去，就能找到 transfer 方法 private final void addCount(long x, int check) { CounterCell[] as; long b, s; // 这里使用的思想跟LongAdder类是一模一样的（后面会讲） // 把数组的大小存储根据不同的线程存储到不同的段上（也是分段锁的思想） // 并且有一个baseCount，优先更新baseCount，如果失败了再更新不同线程对应的段 // 这样可以保证尽量小的减少冲突 // 先尝试把数量加到baseCount上，如果失败再加到分段的CounterCell上 if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) { CounterCell a; long v; int m; boolean uncontended = true; if (as == null || (m = as.length - 1) &lt; 0 || (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) { fullAddCount(x, uncontended); return; } if (check &lt;= 1) return; s = sumCount(); } if (check &gt;= 0) { Node&lt;K,V&gt;[] tab, nt; int n, sc; while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) { int rs = resizeStamp(n); if (sc &lt; 0) { if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); } else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); s = sumCount(); } } } // 真正触发扩容的方式 // 扩容主要分 2 步， // 1. 第一新建新的空数组， // 2. 第二移动拷贝每个元素到新数组中去 // tab:原数组，nextTab:新数组 private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) { // 老数组的长度 int n = tab.length, stride; if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range // 如果新数组为空，初始化，大小为原数组的两倍，n &lt;&lt; 1 if (nextTab == null) { // initiating try { @SuppressWarnings(\"unchecked\") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; nextTab = nt; } catch (Throwable ex) { // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; } nextTable = nextTab; transferIndex = n; } // 新的table长度 int nextn = nextTab.length; // 代表转移节点，如果原数组上是转移节点，说明该节点正在被扩容 (node的hash值为-1) ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); boolean advance = true; boolean finishing = false; // to ensure sweep before committing nextTab // 无限自旋，i 的值会从原数组的最大值开始，慢慢递减到 0 for (int i = 0, bound = 0;;) { Node&lt;K,V&gt; f; int fh; while (advance) { int nextIndex, nextBound; // 结束循环的标志 if (--i &gt;= bound || finishing) advance = false; // 已经拷贝完成 else if ((nextIndex = transferIndex) &lt;= 0) { i = -1; advance = false; } // 每次减少 i 的值 else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) { bound = nextBound; i = nextIndex - 1; advance = false; } } // if 任意条件满足说明拷贝结束了 if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) { int sc; // 拷贝结束，直接赋值，因为每次拷贝完一个节点，都在原数组上放转移节点，所以拷 贝完成的节点的数据一定不会再发生变化。 // 原数组发现是转移节点，是不会操作的，会一直等待转移节点消失之后在进行操作。 // 也就是说数组节点一旦被标记为转移节点，是不会再发生任何变动的，所以不会有任 何线程安全的问题 // 所以此处直接赋值，没有任何问题。 if (finishing) { nextTable = null; table = nextTab; sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); return; } if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) { if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) return; finishing = advance = true; i = n; // recheck before commit } } else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd); else if ((fh = f.hash) == MOVED) advance = true; // already processed else { // 进行节点的拷贝 synchronized (f) { if (tabAt(tab, i) == f) { Node&lt;K,V&gt; ln, hn; if (fh &gt;= 0) { int runBit = fh &amp; n; Node&lt;K,V&gt; lastRun = f; for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) { int b = p.hash &amp; n; if (b != runBit) { runBit = b; lastRun = p; } } if (runBit == 0) { ln = lastRun; hn = null; } else { hn = lastRun; ln = null; } // 桶内只有的单个数据， 直接拷贝，为链表，循环多次形成链表拷贝 for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) { int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); else hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); } // 在新数组位置上放置拷贝的值 setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); // 在老数组位置上放上 ForwardingNode 节点 // put 时，发现是 ForwardingNode 节点，就不会再动这个节点的数 setTabAt(tab, i, fwd); advance = true; } // 红黑树的拷贝 else if (f instanceof TreeBin) { TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null; TreeNode&lt;K,V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) { int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt; (h, e.key, e.val, null, null); if ((h &amp; n) == 0) { if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; } else { if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; } } ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; } } } } } } 小结transfer方法的主要思路： 首先需要把老数组的值全部拷贝到扩容之后的新数组上，先从数组的队尾开始拷贝 拷贝数组的槽点时，先把原数组槽点锁住，保证原数组槽点不能操作，成功拷贝到新数组时， 把原数组槽点赋值为转移节点 这时如果有新数据正好需要 put 到此槽点时，发现槽点为转移节点，就会一直等待，所以在 扩容完成之前，该槽点对应的数据是不会发生变化的 从数组的尾部拷贝到头部，每拷贝成功一次，就把原数组中的节点设置成转移节点; 直到所有数组数据都拷贝到新数组时，直接把新数组整个赋值给数组容器，拷贝完成。 通过在原数组上设置转移节点，put 时碰到转移节点时会等待扩容成 功之后才能 put 的策略，来保证了整个扩容过程中肯定是线程安全的，因为数组的槽点一旦被设 置成转移节点，在没有扩容完成之前，是无法进行操作的。 （1）新桶数组大小是旧桶数组的两倍； （2）迁移元素先从靠后的桶开始； （3）迁移完成的桶在里面放置一ForwardingNode类型的元素，标记该桶迁移完成； （4）迁移时根据hash&amp;n是否等于0把桶中元素分化成两个链表或树； （5）低位链表（树）存储在原来的位置； （6）高们链表（树）存储在原来的位置加n的位置； （7）迁移元素时会锁住当前桶，也是分段锁的思想； 改查删总结（1）ConcurrentHashMap是HashMap的线程安全版本； （2）ConcurrentHashMap采用（数组 + 链表 + 红黑树）的结构存储元素； （3）ConcurrentHashMap相比于同样线程安全的HashTable，效率要高很多； （4）ConcurrentHashMap采用的锁有 synchronized，CAS，自旋锁，分段锁，volatile等； （5）ConcurrentHashMap中没有threshold和loadFactor这两个字段，而是采用sizeCtl来控制； （6）sizeCtl = -1，表示正在进行初始化； （7）sizeCtl = 0，默认值，表示后续在真正初始化的时候使用默认容量； （8）sizeCtl &gt; 0，在初始化之前存储的是传入的容量，在初始化或扩容后存储的是下一次的扩容门槛； （9）sizeCtl = (resizeStamp &lt;&lt; 16) + (1 + nThreads)，表示正在进行扩容，高位存储扩容邮戳，低位存储扩容线程数加1； （10）更新操作时如果正在进行扩容，当前线程协助扩容； （11）更新操作会采用synchronized锁住当前桶的第一个元素，这是分段锁的思想； （12）整个扩容过程都是通过CAS控制sizeCtl这个字段来进行的，这很关键； （13）迁移完元素的桶会放置一个ForwardingNode节点，以标识该桶迁移完毕； （14）元素个数的存储也是采用的分段思想，类似于LongAdder的实现； （15）元素个数的更新会把不同的线程hash到不同的段上，减少资源争用； （16）元素个数的更新如果还是出现多个线程同时更新一个段，则会扩容段（CounterCell）； （17）获取元素个数是把所有的段（包括baseCount和CounterCell）相加起来得到的； （18）查询操作是不会加锁的，所以ConcurrentHashMap不是强一致性的； （19）ConcurrentHashMap中不能存储key或value为null的元素； 一些思想 cas + 自选 乐观锁的思想，减少线程上下文切换的时间 分段锁思想，减少同一时间 竞争锁带来的低效问题 CounterCell，分段存储元素，减少多线程同时更新一个字段带来的低效 多线程协同进行扩容","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"jdk","slug":"jdk","permalink":"https://winniekun.github.io/tags/jdk/"}]},{"title":"kafka-consumer-note","slug":"中间件/kafka-consumer-note","date":"2021-07-02T08:32:01.000Z","updated":"2021-08-28T05:45:49.455Z","comments":true,"path":"kafka-consumer-note/","link":"","permalink":"https://winniekun.github.io/kafka-consumer-note/","excerpt":"","text":"Mathjax$m_i = a ^ {21}$","categories":[{"name":"中间件","slug":"中间件","permalink":"https://winniekun.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"https://winniekun.github.io/tags/kafka/"}]},{"title":"ThreadLocal源码解读","slug":"源码/JDK/lang/threadlocal-analysis","date":"2021-05-27T13:21:59.000Z","updated":"2021-09-08T13:19:53.637Z","comments":true,"path":"threadlocal-analysis/","link":"","permalink":"https://winniekun.github.io/threadlocal-analysis/","excerpt":"","text":"序多线程共享可变数据时，涉及到线程见同步的问题，并不是所有的时候，都要用到共享数据，所以就需要线程封闭出场了。数据都被封闭在各自的线程之中，就不需要进行同步，这种通过将数据封闭在线程内而避免使用同步的技术称之为线程封闭。 适用场景 线程间数据隔离，各线程的 ThreadLocal 互不影响 方便同一个线程使用某一对象，避免不必要的参数传递 全链路追踪中的 traceId 或者流程引擎中上下文的传递一般采用 ThreadLocal Spring 事务管理器采用了 ThreadLocal Spring MVC 的 RequestContextHolder 的实现使用了 ThreadLocal Demopublic class ThreadLocalDemo { public static final ThreadLocal&lt;String&gt; THREAD_LOCAL = new ThreadLocal&lt;&gt;(); public static final ThreadLocal&lt;String&gt; THREAD_LOCAL_NEXT = new ThreadLocal&lt;&gt;(); @Test public void demo() { new ThreadLocalDemo().threadLocalTest(); } public void threadLocalTest() { THREAD_LOCAL.set(\"wkk\"); THREAD_LOCAL_NEXT.set(\"cjsq\"); String v = THREAD_LOCAL.get(); String v2 = THREAD_LOCAL_NEXT.get(); System.out.println(\"子线程 执行前， \" + Thread.currentThread().getName() + \"线程取到的值：\" + v + \" \" + v2); Thread child = new Thread(new Runnable() { @Override public void run() { String v = THREAD_LOCAL.get(); String v2 = THREAD_LOCAL_NEXT.get(); System.out.println(Thread.currentThread().getName() + \"线程取到的值：\" + v + v2); // 设置 threadLocal THREAD_LOCAL.set(\"hhh\"); THREAD_LOCAL_NEXT.set(\"cjpl\"); v = THREAD_LOCAL.get(); v2 = THREAD_LOCAL_NEXT.get(); System.out.println(\"重新设置之后，\" + Thread.currentThread().getName() + \"线程取到的值为：\" + v + \" \" + v2); System.out.println(Thread.currentThread().getName() + \"线程执行结束\"); } }, \"子线程\"); child.start(); try { child.join(); } catch (InterruptedException e) { e.printStackTrace(); } v = THREAD_LOCAL.get(); v2 = THREAD_LOCAL_NEXT.get(); System.out.println(\"子线程线程执行之后，\" + Thread.currentThread().getName() + \"线程取到的值：\" + v + \" \" + v2); } } 输出 子线程 执行前， main线程取到的值：wkk cjsq 子线程线程取到的值：nullnull 重新设置之后，子线程线程取到的值为：hhh cjpl 子线程线程执行结束 子线程线程执行之后，main线程取到的值：wkk cjsq 源码解读重要属性// Thread类 ThreadLocal.ThreadLocalMap threadLocals = null; // 当前threadlocal的hashcode // 用于用于计算该ThreadLocal在线程的threadlocals（map）中的索引位置 private final int threadLocalHashCode = nextHashCode(); // hash表的阈值，黄金分割比 private static final int HASH_INCREMENT = 0x61c88647; // 保证了在一台机器中每个 ThreadLocal 的 threadLocalHashCode 是唯一的 private static AtomicInteger nextHashCode = new AtomicInteger(); // 用于当前threadlocal的hashcode private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } // 初始话的操作 protected T initialValue() { return null; } // lambda的初始化实现 public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) { return new SuppliedThreadLocal&lt;&gt;(supplier); } HashCode散列成果验证可以通过和String的hashcode做个对比，然后验证其使用这种方式的hash结果如何 private static AtomicInteger nextHashCode = new AtomicInteger(); private static final int HASH_INCREMENT = 0x61c88647; private static final int SIZE = 32; private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } @Test public void test_idx() { int hashCode = 0; Set&lt;Integer&gt; setThreadLocal = new HashSet&lt;&gt;(); Set&lt;Integer&gt; setNormal = new HashSet&lt;&gt;(); for (int i = 0; i &lt; SIZE; i++) { hashCode = nextHashCode(); int threadLocalHashCode = hashCode &amp; (SIZE - 1); int normalHashCode = String.valueOf(i).hashCode() &amp; (SIZE - 1); setThreadLocal.add(threadLocalHashCode); setNormal.add(normalHashCode); System.out.println(i + \" ThreadLocal的散列：\" + threadLocalHashCode + \" 普通散列：\" + normalHashCode); } double threadLocalRate = setThreadLocal.size() / (double)SIZE * 100; double normalRate = setNormal.size() / (double)SIZE * 100; System.out.println(\"ThreadLocal的散列：\" + threadLocalRate + \"% \" + \" 普通散列：\" + normalRate + \"% \"); } // ThreadLocal的散列：100.0% 普通散列：68.75% 形象理解 ThreadLocal形象理解 如果类比为HashMap的话，我们可以将threadlocal类比为key，然后被封闭的数据类比为value。不过稍微不同的是，hashmap中将key和value做映射的操作是map.put(key, value)，而threadlocals中，将threadlocal和被封闭的数据做映射的操作是threadlocal.set(xxx)。 思路转换emmmm怎么说呢，就是我们使用普通map的时候，操作的是一个map，获取key的value时，直接通过map.get()即可。 但是我们使用threadlocal时，其本身是一个key，怎么获取对应的value呢？ 先获取map（每个线程独有的map，所以根据当前线程获取map） 然后通过map.get(key)获取value 返回value ThreadLocalMapstatic class ThreadLocalMap { /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as \"stale entries\" in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) { super(k); value = v; } } // 下面的成员变量和hashmap同理 // 初始化容量 private static final int INITIAL_CAPACITY = 16; // 存储ThreadLocal的键值对，长度为2的幂次 private Entry[] table; /** * The number of entries in the table. */ private int size = 0; /** * The next size value at which to resize. */ private int threshold; // Default to 0 } ThreadLocalMap就是一个map，和hashmap类似，不过有些机制不同。 hash冲突解决方式 ThreadLocalMap处理hash冲突的方式为线型探测 HashMap使用的是拉链法 ThreadLocal内存泄漏根据注释和代码，了解到了ThreadLocalMap内部的每个entry中，key设置为弱引用的原因，不过value还是正常的引用。这也就导致了如果ThreadLocal没有外部的强引用时，只要发生GC，就会被回收。这样ThreadMap中的key就变成了null，但是value被Entry引用，Entry被ThreadLocalMap引用，ThreadLocalMap被Thread引用，这也就说明了只要，线程不终止，value的值一直无法被回收，所以可能会出现内存泄漏的现象 为了避免这种情况，在需要使用threadlocal之后，需要我们手动remove掉。防止 ThreadLocalMap 中 Entry 一直保持对 value 的强引用，导致 value 不能被回收 removepublic void remove() { ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); } // 根据当前线程获取其map ThreadLocalMap getMap(Thread t) { return t.threadLocals; } // 因为使用的线型探测法 // 所以要采用线型探测法找到对应的位置 private void remove(ThreadLocal&lt;?&gt; key) { Entry[] tab = table; int len = tab.length; // 根据threadlocal获取其hashcode值 int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { if (e.get() == key) { e.clear(); expungeStaleEntry(i); return; } } } private static int nextIndex(int i, int len) { return ((i + 1 &lt; len) ? i + 1 : 0); } private int expungeStaleEntry(int staleSlot) { Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal&lt;?&gt; k = e.get(); if (k == null) { e.value = null; tab[i] = null; size--; } else { int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) { tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; } } } return i; } 通过当前线程获取该线程的map 然后调用map.remove方法 后续的代码分析不动了。。。 set/** * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the {@link #initialValue} * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */ public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } ThreadLocalMap getMap(Thread t) { return t.threadLocals; } set方法的作用是把我们想要存储的value给保存方法，只要流程是： 先获取当亲的线程 根据当前线程获取该线程的map 判断map是否为空 为空 创建map 不为空 在map中放入元素 set(ThreadLcoal&lt;?&gt; key, Object value)// 在map中存储键值对&lt;key, value&gt; private void set(ThreadLocal&lt;?&gt; key, Object value) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); // 遍历一段连续的元素，以查找匹配的 ThreadLocal 对象 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { // / 获取该哈希值处的ThreadLocal对象 ThreadLocal&lt;?&gt; k = e.get(); // 键值ThreadLocal匹配，直接更改map中的value if (k == key) { e.value = value; return; } // 若 key 是 null，说明 ThreadLocal 被清理了，直接替换掉 if (k == null) { replaceStaleEntry(key, value, i); return; } } // 直到遇见了空槽也没找到匹配的ThreadLocal对象，那么在此空槽处安排ThreadLocal对象和缓存的value tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); } 通过这两种set方式，就更加证明了思路的转换，我们在set时，都需要先获取当前线程获取map，然后再对整个map遍历然后放入value、或者直接放入key、value getpublic T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } return setInitialValue(); } // 根据threadlocal获取entry private Entry getEntry(ThreadLocal&lt;?&gt; key) { // 计算hashcode，然后获取对应的索引位置 int i = key.threadLocalHashCode &amp; (table.length - 1); // 根据索引位置获取对应的entry Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e); } private T setInitialValue() { T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; } 先获取当前线程 获取当前线程的map map != null 通过key直接获取对应entry 返回entry.value map == null 初始化map 总结threadlocal本质属于某种map的一个key值，只不过该值通过泛型实现，支持各种类型。和基础的map不同的是，可以直接通过key.set(value)实现key-value的映射。而这种特殊的map是属于Thread级别的成员变量，多个线程之间该变量互不影响，所以这也就是我们所说的线程本地存储地方。不过需要注意的是，该key是虚引用，需要注意内存泄露的问题，所以在使用过threadlocal之后，记得及时remove。内部的threadlocalmap和hashmap的实现机制类似，不过区别就是对于hash冲突的解决方式为线型探测 内存泄露问题什么是内存泄漏内存泄漏指的是，当某一个对象不再有用的时候，占用的内存却不能被回收，这就叫作内存泄漏。 因为通常情况下，如果一个对象不再有用，那么我们的垃圾回收器 GC，就应该把这部分内存给清理掉。这样的话，就可以让这部分内存后续重新分配到其他的地方去使用；否则，如果对象没有用，但一直不能被回收，这样的垃圾对象如果积累的越来越多，则会导致我们可用的内存越来越少，最后发生内存不够用的 OOM 错误。 下面我们来分析一下，在 ThreadLocal 中这样的内存泄漏是如何发生的。 Key 的泄漏分析了 ThreadLocal 的内部结构之后，知道了每一个 Thread 都有一个 ThreadLocal.ThreadLocalMap 这样的类型变量，该变量的名字叫作 threadLocals。线程在访问了 ThreadLocal 之后，都会在它的 ThreadLocalMap 里面的 Entry 中去维护该 ThreadLocal 变量与具体实例的映射。 我们可能会在业务代码中执行了 ThreadLocal instance = null 操作，想清理掉这个 ThreadLocal 实例，但是假设我们在 ThreadLocalMap 的 Entry 中强引用了 ThreadLocal 实例，那么，虽然在业务代码中把 ThreadLocal 实例置为了 null，但是在 Thread 类中依然有这个引用链的存在。 GC 在垃圾回收的时候会进行可达性分析，它会发现这个 ThreadLocal 对象依然是可达的，所以对于这个 ThreadLocal 对象不会进行垃圾回收，这样的话就造成了内存泄漏的情况。 references Java并发编程 面试官系统精讲Java源码及大厂真题 Java并发编程78讲 【细谈Java并发】谈谈ThreadLocal 一文搞懂 ThreadLocal 原理 为何每次用完 ThreadLocal 都要调用 remove()？——内存泄漏","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"lang","slug":"lang","permalink":"https://winniekun.github.io/tags/lang/"}]},{"title":"死磕双指针","slug":"LeetCode/stick-to-two-pointer","date":"2021-05-27T09:10:30.000Z","updated":"2021-05-27T09:10:30.816Z","comments":true,"path":"stick-to-two-pointer/","link":"","permalink":"https://winniekun.github.io/stick-to-two-pointer/","excerpt":"","text":"序双指针，一个看了脑子里就有画面的算法技巧，主要方式有： 快慢指针 譬如链表环系列问题 获取链表的第K个节点 应该也属于快慢指针吧 只不过是一个指针先移动一定步长，然后另一个两个指针再以同样的速度移动 头尾指针 适用于数组和字符串 根据使用场景，用于优化遍历的时间复杂度 滑动窗口 普通指针26. 删除有序数组中的重复项class Solution { public int removeDuplicates(int[] nums) { int i = 0; int N = nums.length; for (int j = 1; j &lt; N; j++) { if (nums[i] != nums[j]) { nums[++i] = nums[j]; } } return i + 1; } } // 通法 class Solution { public int removeDuplicates(int[] nums) { return process(nums, 1); } int process(int[] nums, int k) { int idx = 0; for (int x : nums) { if (idx &lt; k || nums[idx - k] != x) nums[idx++] = x; } return idx; } } 80. 删除有序数组中的重复项 IIpublic int removeDuplicates(int[] nums) { return process(nums, 2); } private int process(int[] nums, int k) { int idx = 0; for (int x : nums) { if (idx &lt; k || nums[idx - k] != x) { nums[idx++] = x; } } return idx; } 283. 移动零88. 合并两个有序数组归并排序的中的一个步骤 快慢指针环系列 141. 环形链表public boolean hasCycle(ListNode head) { if (head == null) { return false; } ListNode fast = head; ListNode slow = head; while (fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { return true; } } return false; } 142. 环形链表 II头尾指针可以理解为对整个数组的暴力搜索的优化，正常情况下，是得到所有的区间k的子数组，然后一次计算结果。双指针之后，可以在遍历的过程就的出结果，避免的重复的遍历，并且优化的了遍历的时间复杂度 11. 盛最多水的容器public int maxArea(int[] height) { // 双指针(头尾指针) int N = height.length; int left = 0; int right = N - 1; int area = 0; while (left &lt; right) { int hight = Math.min(height[left], height[right]); int innerArea = hight * (right - left); area = Math.max(area, innerArea); if (height[left] &lt; height[right]) { left++; } else { right--; } } return area; } 15. 三数之和public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { // 思路 // 核心思路：双指针 头尾指针 Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); int N = nums.length; for (int i = 0; i &lt; N - 2; i++) { int rst = -nums[i]; int left = i + 1; int right = N - 1; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } while (left &lt; right) { int cur = nums[left] + nums[right]; if (cur == rst) { res.add(new ArrayList&lt;&gt;(Arrays.asList(nums[i], nums[left], nums[right]))); // 处理后序重复的元素 while (left &lt; right &amp;&amp; nums[left + 1] == nums[left]) { left++; } while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) { right--; } left++; right--; } else if (cur &gt; rst) { right--; } else { left++; } } } return res; } 16. 最接近的三数之和和上述类似，不过不用考虑元素重复问题，但是需要考虑最近，所以使用一个变量，用于检测当前结果是否比之前更好。 public int threeSumClosest(int[] nums, int target) { int N = nums.length; Arrays.sort(nums); // 如何判断最近？ // min(closest, curDistance) int closest = Integer.MAX_VALUE; int res = nums[0] + nums[nums.length - 1] + nums[1]; for (int i = 0; i &lt; N - 2; i++) { int low = i + 1; int height = N - 1; while (low &lt; height) { int innerCur = nums[i] + nums[low] + nums[height]; if (innerCur &lt; target) { low++; } else if (innerCur &gt; target) { height--; } else { return target; } if (Math.abs(innerCur - target) &lt; closest) { closest = Math.abs(innerCur - target); res = innerCur; } } } return res; } 18. 四数之和同样的思路，不过可以做一些细节处理，提前退出循环。 public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) { List&lt;List&lt;Integer&gt;&gt; quadruplets = new ArrayList&lt;&gt;(); if (nums == null || nums.length &lt; 4) { return quadruplets; } Arrays.sort(nums); int length = nums.length; for (int i = 0; i &lt; length - 3; i++) { // 重复 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } // 不符合条件 if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) { break; } // 结果小 if (nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] &lt; target) { continue; } for (int j = i + 1; j &lt; length - 2; j++) { // 重复 if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) { continue; } // 不符合条件 if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) { break; } // 太小 if (nums[i] + nums[j] + nums[length - 2] + nums[length - 1] &lt; target) { continue; } int left = j + 1, right = length - 1; while (left &lt; right) { int sum = nums[i] + nums[j] + nums[left] + nums[right]; if (sum == target) { quadruplets.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right])); while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) { left++; } left++; while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) { right--; } right--; } else if (sum &lt; target) { left++; } else { right--; } } } } return quadruplets; } 259. 较小的三数之和public int threeSumSmaller(int[] nums, int target) { Arrays.sort(nums); int N = nums.length; int count = 0; for (int i = 0; i &lt; N - 2; i++) { int left = i + 1; int right = N - 1; while (left &lt; right) { int innerCur = nums[i] + nums[left] + nums[right]; if (innerCur &lt; target) { int innerCount = right - left; count += innerCount; left++; } else { right--; } } } return count; } 30. 串联所有单词的子串滑动窗口209. 长度最小的子数组public int minSubArrayLen(int target, int[] nums) { int N = nums.length; int left = 0; int right = 0; int ans = Integer.MAX_VALUE; int sum = 0; while (right &lt; N) { sum += nums[right]; while (left &lt;= right &amp;&amp; sum &gt;= target) { ans = Math.min(ans, right - left + 1); sum -= nums[left]; left++; } right++; } return ans == Integer.MAX_VALUE ? 0 : ans; } 713. 乘积小于K的子数组双指针（滑动窗口）：left 和 right指针开始时均指向 nums数组的开头。 right指针遍历 nums数组，每遍历一个元素就更新一次乘积，即 product = product * nums[right]： 若当前更新后的 product &lt; k，则直接统计当前窗口中的元素个数（这恰好就是当前子数组中符合条件的全部子集个数） 我们每次都统计以nums[right]为结尾符合条件的子数组个数 若更新后的 product &gt;= k，则此时需要缩小窗口的大小，即令当前 product 除以当前 left 指针指向的元素值，然后令 left指针右移一位，直到当前的 produc &lt; k 为止，然后统计当前窗口中的元素个数，即为此时符合条件的子数组的个数，继续令 right 指针右移。 如此反复，直到 right 指针指向 nums 数组的末尾为止。 public int numSubarrayProductLessThanK(int[] nums, int k) { // 滑动窗口 int N = nums.length; int left = 0; int sum = 1; int count = 0; for (int right = 0; right &lt; N; right++) { sum *= nums[right]; while (left &lt;= right &amp;&amp; sum &gt;= k) { sum /= nums[left]; left++; } count += right - left + 1; } return count; }","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://winniekun.github.io/categories/leetcode/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://winniekun.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"PriorityQueue源码解读","slug":"源码/JDK/queue/PriorityQueue-analysis","date":"2021-05-22T12:00:56.000Z","updated":"2021-05-23T12:10:46.393Z","comments":true,"path":"PriorityQueue-analysis/","link":"","permalink":"https://winniekun.github.io/PriorityQueue-analysis/","excerpt":"PriorityQueue源码解读","text":"PriorityQueue源码解读 优先队列, 顾名思义就是按照元素的优先级进行弹出等操作, 那么在JDK中使用何种数据结构来实现优先队列嘞, Let’s Go 依赖 PriorityQueue emmm, 感觉从依赖上来看, 和其他的集合类一样, 实现其对应的接口(Marker Interface的作用?) 基础在阅读基础的时候，我们需要先理解一下什么是堆，其数据结构是啥，有哪些存储方式。 堆的底层数据结构为完全二叉树 存储方式（既然是二叉树，那么其存储方式主要分为如下两种） 顺序存储结构 根节点下标为0 若节点p的下标为$i$，则左孩子$2\\cdot i$ 右孩子为$2 \\cdot i + 1$ 若节点p的下标为$i$，则父节点的下标为$\\lfloor i/2\\rfloor$ 链式存储结构 树的存储结构 由上述的顺序存储结构可知，堆是用物理上的线性表示逻辑上的非线性的数据结构 具体的关于堆的操作，如刚开始的建堆，以及插入元素，删除堆顶元素，迭代等操作，可自行百度。 属性// 默认初始化容量 private static final int DEFAULT_INITIAL_CAPACITY = 11; // 底层使用Object[]数组实现, 和ArrayList这些一样 transient Object[] queue; // non-private to simplify nested class access // 标记元素个数 private int size = 0; // 比较器, 说明其实例均是可比较的 private final Comparator&lt;? super E&gt; comparator; // 说明具有fast fail 机制 transient int modCount = 0; // non-private to simplify nested class access 因为底层使用的是数组，同时其本身是支持动态插入和删除的，所以同理，和ArrayList同理，扩容应该是其核心的地方。同时也要关注其是否生成新的数组对象。 像ArrayList、HashMap中都有一个属性叫 modCount，每次对集合的修改这个值都会加1，在遍历前记录这个值到 expectedModCount中，遍历中检查两者是否一致，如果出现不一致就说明有修改，则抛出ConcurrentModificationException异常。 构造函数PriorityQueue()public PriorityQueue() { this(DEFAULT_INITIAL_CAPACITY, null); } PriorityQueue(int initialCapacity)public PriorityQueue(int initialCapacity) { this(initialCapacity, null); } PriorityQueue(Comparator&lt;? super E&gt; comparator)public PriorityQueue(Comparator&lt;? super E&gt; comparator) { this(DEFAULT_INITIAL_CAPACITY, comparator); } PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator)public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) { // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator; } 还有几个构造函数主要是用于将原各种类型的数据放入PriorityQueue中 增(入队)在阅读这些方法的时候, 想起来自己手撕算法的时候, 经常会记混List, Stack, Queue, Map这些的添加删除操作的API… 下面罗列的是个人觉得不错的代表数据结构特性的添加/删除操作的API 数据结构 添加 删除 List/Set add() remove() Stack push() pop() Queue offer() poll() Map put() remove() 用于入队的操作有add和offer。 public boolean add(E e) { return offer(e); } public boolean offer(E e) { // 不支持null元素 if (e == null) throw new NullPointerException(); modCount++; int i = size; // 元素数量超过数组数量，引发扩容机制 if (i &gt;= queue.length) // 扩容机制先按下不表 grow(i + 1); // 元素数量+1 size = i + 1; // 如果还没有元素 // 直接插入到数组第一个位置 if (i == 0) queue[0] = e; else // 否则 插入到堆的最后一个元素 // 然后再调整堆 siftUp(i, e); return true; } 宏观上来看, offer()方法会先检测是否需要扩容, 之后再插入元素, 最后进行调整, 最后调用siftUp进行调整。 siftUp假设在数组queue的k位置插入元素key（小根堆） 不断的比较key和k的父节点e （$queue\\lfloor(k-1/2\\rfloor)$）的关系 若$key &lt; e$ ，则queue[k] = e, 同时k到达e的位置（parent） 若$key \\geq e$ 或者 $k$已经到达跟节点，则结束循环 $queue[k]==e$ private void siftUp(int k, E x) { // 判断比较策略 // 1. X自身实现了Comparable接口，则通过comparable进行比较 // 2. X自身未实现Comparable接口，通过自定义的外部比较器compartor比较 if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x); } @SuppressWarnings(\"unchecked\") private void siftUpComparable(int k, E x) { Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x; while (k &gt; 0) { int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (key.compareTo((E) e) &gt;= 0) break; queue[k] = e; k = parent; } queue[k] = key; } @SuppressWarnings(\"unchecked\") private void siftUpUsingComparator(int k, E x) { while (k &gt; 0) { int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (comparator.compare(x, (E) e) &gt;= 0) break; queue[k] = e; k = parent; } queue[k] = x; } 结论 不允许null元素 插入元素前，先检测数组长度是否够用，不够进行扩容（扩容机制后续详细阐述） 在尾部插入元素，之后不断调整 通过调整的过程，可以知道PrioriryQueue默认是小根堆 删(出队)出队有两个方法，poll()和remove()，实际上remove调用的还是poll。remove不存在的元素时会报错。 public E remove() { E x = poll(); if (x != null) return x; else throw new NoSuchElementException(); } public E poll() { if (size == 0) return null; int s = --size; modCount++; E result = (E) queue[0]; // 获取当前最后一个元素 // 并将最后一个位置置空 E x = (E) queue[s]; queue[s] = null; // 如果弹出元素后还有元素 if (s != 0) //将队列末元素移到队列首 // 再做自上而下的堆化 siftDown(0, x); return result; } siftDown自顶向下，选择小的节点，不断的比较、交换，直到： 下标越界 节点的值同时小于等于左孩子和右孩子 假设数组queue最后一个元素的值为key（小根堆），下标k从0开始，当k存在左孩子时，执行以下循环： 若k有右孩子，则比较左右孩子的值，然后选出小的孩子child 比较key和c=queue[child]的大小 若$key \\leq c$ 结束循环 若$key &gt; c$, 则$queue[k] = c, k = child$， 继续循环 $queue[k] = key$ private void siftDown(int k, E x) { // 和 siftUp一样的思路 if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x); } @SuppressWarnings(\"unchecked\") private void siftDownComparable(int k, E x) { // 因为删除是从堆顶开始删除，所以和siftUp相反 Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x; int half = size &gt;&gt;&gt; 1; // loop while a non-leaf while (k &lt; half) { int child = (k &lt;&lt; 1) + 1; // assume left child is least Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0) c = queue[child = right]; if (key.compareTo((E) c) &lt;= 0) break; queue[k] = c; k = child; } queue[k] = key; } @SuppressWarnings(\"unchecked\") private void siftDownUsingComparator(int k, E x) { int half = size &gt;&gt;&gt; 1; while (k &lt; half) { int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c; k = child; } queue[k] = x; } 将队列首元素弹出 将队列末元素移到队列首 自上而下堆化，一直往下与最小的子节点比较 如果比最小的子节点大，就交换位置，再继续与最小的子节点比较 如果比最小的子节点小，就不用交换位置了，堆化结束 获取队头元素public E peek() { return (size == 0) ? null : (E) queue[0]; } 获取第一个元素的值。 扩容策略private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) { int oldCapacity = queue.length; // Double size if small; else grow by 50% int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ? (oldCapacity + 2) : (oldCapacity &gt;&gt; 1)); // overflow-conscious code // 检查是否溢出 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); queue = Arrays.copyOf(queue, newCapacity); } private static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 原数组空间大小&lt;64时，默认扩容为原先的两倍再加2个。。。 原数组空间大小&gt;64时，扩容为原先的1.5倍 最大容量空间为Integer.MAX_VALUE 总结 PriorityQueue内部的数据结构是堆，堆使用的数据结构是完全二叉树，然后使用的是顺序存储结构（数组） PriorityQueue默认是小根堆 堆保证堆顶元素为当前的最值，然后严格遵守字节点的值大于（小于）父节点的值 堆的删除操作从堆顶进行删除，然后会将最后的一个元素移至堆顶，此时堆的结构被破坏，所以需要执行siftDown 堆的插入操作从堆尾进行插入，此时堆的结构被破坏，所以需要执行siftUp","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"Queue","slug":"Queue","permalink":"https://winniekun.github.io/tags/Queue/"}]},{"title":"https总结","slug":"网络/https-conclution","date":"2021-05-21T14:32:09.000Z","updated":"2021-10-14T13:12:47.807Z","comments":true,"path":"https-conclution/","link":"","permalink":"https://winniekun.github.io/https-conclution/","excerpt":"","text":"序引入一个新的概念的时候，必然先阐述其相关方面已有的实现有哪些缺点，新的概念解决了哪些缺点。所以～让我们看看HTTP有哪些却缺点 缺点： 明文传输，传输信息容易被窃听 —- 窃听风险 不验证通信方的身份，因此可能会遭遇伪装 —- 冒充风险 无法验证报问的完整性，所以通信的信息可能已遭篡改 —- 篡改风险 譬如强行植入的广告信息 而HTTPS的出现就正好解决了上述的三个问题。对于窃听风险使用加密措施解决，对于冒充风险使用证书认证解决，对于篡改风险使用完整性保护解决（信息摘要算法） HTTPS概述 https HTTPS其实就是http secure的意思。HTTP是应用层协议，位于HTTP协议之下是传输协议TCP。TCP负责传输，HTTP则定义了数据如何进行包装。所以HTTP传输给TCP什么样的数据包，其都会原样的发送个通讯方（仅仅将数据包分为了多个报报问段）。 HTTP —&gt; TCP （明文传输） 而HTTPS相对于HTTP有哪些不同呢？其实就是在HTTP和TCP中间加多了一层加密层TLS/SSL。 通俗的讲，TLS、SSL其实是类似的东西，SSL是个加密套件，负责对HTTP的数据进行加密。TLS是SSL的升级版。现在提到HTTPS，加密套件基本指的是TLS。 原先是应用层将数据直接给到TCP进行传输，现在改成应用层将数据给到TLS/SSL，将数据加密后，再给到TCP进行传输。如下图所示 https和http传输过程 所以HTTPS本身并不是应用层的一个新的协议，只是HTTP在和TCP进行交接的中间，又新增了一层SSL/TLS协议。所以HTTPS可以理解为披着SSL/TLS协议外壳的HTTP而已。 HTTPS的加密—-混合加密首先需要了解对称加密、非对称加密的区别。我们知道实际对通信加密的是SSL/TLS层。SSL/TLS采用是混合加密的机制，也就是对称加密和非对称加密的混合。使用非对称加密传输安全传输对称加密的密钥，之后使用对称加密的密钥进行通信从而提高整体的通讯效率。 接下来结合WireShark抓包详细阐述TLS的加密流程，TLS 是建立在 TCP 基础上的，因此必定需要先三次 TCP 握手建立 TCP 连接，然后再是建立 TLS。 Client Hello Client Hello 报文：客户端对加密算法的支持度不同，因此需要向服务端发送客户端支持的 加密套件（Cipher Suite） ，同时还要生成一个 随机数 同时保存在客户端和发送给服务 Server Hello ServerCertificate 报文：服务端收到 Client Hello 之后，向客户端发送 CA 认证的数字证书，用来鉴别服务端身份信息，同时还要生成一个 随机数 同时保存在服务端和发送给客户端 Server Hello Done 报文：表示服务端宣告第一阶段的客户端服务端握手协商结束 可选：Certificate Request 报文：必要情况下，要求客户端发送证书验证身份 可选：Server Key Exchange 报文：如果 CA 认证的数字证书提供的信息不够，服务端还可发送提供补充信息 Client Finish Client Key Exchange 报文：客户端收到 CA 数字证书并通过验证，然后通过 CA 公钥解密获取到 服务端公钥。Client Key Exchange 报文包括有一个随机数，这个随机数被称为 Pre-master key/secret；一个表示随后的信息使用双方协商好的加密方法和密钥发送的 通知 ；还有一个通过协商好的 HASH 算法对前面所有信息内容的 HASH 计算值，用来提供服务端校验。这些信息都通过服务端公钥加密传送给服务端 ExchangeCipherSpec 报文：该报文通知服务端，此后的通信都将使用协商好的加密算法计算对称密钥进行加密通信（也就是使用两个随机数以及第三个 Pre-master key/secret 随机数一起算出一个对称密钥 session key/secret） Finished 报文：该报文包括连接至此的所有报文的校验值，使用已经生成的对称加密密钥加密 可选：ClientCertificate 报文：如果服务端请求，客户端需要发送 CA 数字证书 可选：CertificateVerify 报文：服务端如果要求 CA 数字证书，那么需要通过 HASH 算法计算一个服务端发送来的信息摘要 Server Finish 服务端先私钥得出Pre-master key， 同样使用这三个随机数得出对称加密密钥。服务端最后对客户端发送过来的 Finished 报文使用服务端对称密钥进行解密校验。 ClientCipherSpec 报文：报文通知服务端，此后的通信都将使用协商好的加密算法计算对称密钥 session key/secret 进行加密通信 Finished 报文：标志 TLS 连接建立成功 TLS 握手成功此后通过对称密钥 session key/secret 加密通信 握手：证书下发，密钥协商（这个阶段都是明文的） 数据传输：这个阶段才是加密的，用的就是握手阶段协商出来的对称密钥 进行整理，如下图所示 image-20210521215733187 使用wireshark实战证明本地地址和LeetCode-CN的交互 wireshark抓包显示 具体的流程如TLS 1.2 的官方文档，RFC-5246，其中的section-7.3所示 image-20211014162146281 接下来，根据wireshark进行实际的验证 ClientHello阶段 客户端想服务端发送https请求链接，同时将自身支持的TLS版本，一个随机串Random，密码套件（非对称加密算法、对称加密算法、摘要算法）发送给服务端，同时返回的内容还有一些其他的信息，如compression_methods（压缩的算法）、extensions（扩展字段） ServerHello阶段 服务端根据客户端获发送的数据，选择一套密码套件，以及自身的证书发送给客户端 选择的密码套件阐述： TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 ECDHE_RSA： 密钥交换时采用的RSA非对称加密算法 AES_128_GCM：握手通讯后使用AES对称算法，密钥长度为128 SHA256：摘要算法使用的是SHA256 Server Certificate阶段 服务端发完上面的 ServerHello 后立即发这个包 整个证书内容展开来看如下： 其中subject展开整理如下： CountryName: CN printableString: Shanghai printableString: IT uTF8String: 领扣网络（上海）有限公司 printableString: leetcode-cn.com 还有一个很重要的内容 subjectPublicKeyInfo（证书的公钥信息）： 整体来看，证书共分为如下的内容： 执行了客户端 + 服务端的两个hello阶段，然后在发送一个Certificate包，用于传递证书，待客户端校验 Server Hello Done 阶段 标识着 serverHello 这个握手过程结束了 Client ClientKeyExchange 阶段 紧接着 ServerHelloDone 发送，用于协商出 premaster_secret，同之前的 ServerKeyExchange 配合使用的。 生成最终通信的对称加密秘钥master_secret 这一步不是抓包的信息，而是客户端和服务端此时都在自己端内所做的事情，非常关键。 就是计算出最终对称加密用的秘钥 master_secret，这也是整个花里胡哨的过程，最终且唯一的一个目的，并且两端算出来的结果肯定是一样的。 HTTPS 的目的，不就是双方协商出一个共同的对称加密秘钥么，怕被中间人拦截到，所以做的证书呀，非对称加密算法呀，秘钥协商算法等复杂的规定。 那 master_secret 是怎么计算出来的呢？ 还记不记得之前我们得到了三个随机数： 随机数 1（客户端随机数）：在 ClientHello 消息里，由客户端生成的随机数，是： f52870c0be8c82f46f6ae0c5ad1be08a550bda92416bafebe54b9923b0795150 随机数 2（服务端随机数）：在 ServerHello 消息里，由服务端生成的随机数，是： d763c799e2dea5f59fb9dc12a476598d9fc486e0f43d57148bd15f137793f77a 随机数 3（pre_master)：通过秘钥交换算法 ECDHE 计算出的，我们叫它 pre_master。 最终的对称加密秘钥 master_secret，就是根据这三个随机数共同计算出来的。 一旦双方协商出来了这个相同的对称秘钥，那就可以开始愉快地安全通信了，TLS 层的工作也就圆满完成。 所以可想而知，接下来的工作，就都是收尾工作了，因为秘钥已经协商好了。就可以开心的用协商的密钥进行加密通讯了，啦啦啦 Client ChangeCipherSpec阶段 秘钥改变通知，此时客户端已经生成了 master_secret，之后的消息将都通过 master secret 来加密 Encrypted Handshake Message 阶段 用于数据验证 Server ChangeCipherSpec阶段 也是秘钥改变通知，此时服务端也已经生成了 master_secret 了，后面的通信都用此值加密。 Server Finish阶段 同 Client Finish，服务器端发送握手结束通知，同时会带上前面所发内容的签名到客户端，保证前面通信数据的正确性。 HTTPS的认证—-数字证书了解了HTTPS加密通信的流程后，对于数据裸奔的疑虑应该基本打消了。然而，还有一个问题：如何确保证书时可信的？ 证书不可信可能有两种情况： 证书是伪造的：压根不是CA颁发的 证书被篡改过：比如将XX网站的公钥给替换了 数字证书是由权威的CA（Certificate Authority）机构给服务端进行颁发，CA机构通过服务端提供的相关信息生成证书，证书内容包含了持有人的相关信息，服务器的公钥，签署者签名信息（数字签名）等，最重要的是公钥在数字证书中。 数字签名和摘要算法的关系 明文 —&gt; hash运算 —&gt; 摘要 —&gt; 私钥加密 —&gt; 数字签名 数字证书是如何保证公钥来自请求的服务器？ 数字证书上由持有人的相关信息，通过这点可以确定其不是一个中间人 证书包含的内容： 一个证书中含有三个部分:证书内容，散列算法，加密密文，证书内容会被散列算法hash计算出摘要，然后使用CA机构提供的私钥进行RSA加密得到数组签名（加密密文）。 Support/typora-user-images/image-20210521221149447.png 证书伪造浏览器内置的CA的根证书包含了CA的公钥 证书颁发的机构是伪造的：浏览器不认识，直接认为是危险证书 证书颁发的机构是确实存在的，于是根据CA名，找到对应内置的CA根证书、CA的公钥。 用CA的公钥，对伪造的证书的摘要进行解密，发现解不了。认为是危险证书 证书篡改 根据证书的加密密文（数字签名）使用CA的公钥得到证书摘要A 根据证书内容使用摘要算法得到证书摘要B 对比摘要A和摘要B是否相同 HTTPS的完整性保护—-摘要算法 [ ] TODO 总结references 图解HTTP 趣谈协议—-极客时间 Why does the SSL/TLS handshake have a client and server random","categories":[{"name":"网络","slug":"网络","permalink":"https://winniekun.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"应用层","slug":"应用层","permalink":"https://winniekun.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"}]},{"title":"Spring IoC解读","slug":"spring/spring-ioc-analysis","date":"2021-05-21T01:24:20.000Z","updated":"2021-07-24T07:46:15.133Z","comments":true,"path":"spring-ioc-analysis/","link":"","permalink":"https://winniekun.github.io/spring-ioc-analysis/","excerpt":"","text":"序IoCIoC控制反转，意思就是将创建对象的控制权从我们自己硬编码来new一个对象反转到了第三方身上。IoC的主要实现方式是依赖注入，Spring中的依赖注入方式有：构造方法注入、settter注入、接口注入。 控制反转是一种思想 依赖注入是一种设计模式 IoC是一种可以帮助我们解耦各业务对象间依赖关系的对象绑定方式 IoC Service Provider虽然业务对象可以通过IoC方式声明相应的依赖，但是最终仍然需要通过某个角色或者服务将这些依赖的对象绑定到一起。而IoC Service Provider就对应IoC场景中的这一角色。IoC Service Provider在这里是一个抽象出来的概念，它可以指代任何将IoC场景中的业务对象绑定到一起的实现方式。它可以是一段代码，也可以是一组相关的类，甚至可以是比较通用的IoC框架或 者IoC容器实现。 职责 业务对象的构建管理 IoC中，业务对象无需关心所依赖注入的对象如何构建如何取得，但是这部分的工作还是需要有人来做的。所以IoC Service Provider需要将对象的构建逻辑从客户端对象那里抽离出来，一面这部分逻辑污染业务对象的实现。 客户端：代使用某个对象或者某种服务的对象。如果对象A需要引用对象B，那么A就是B的客户端对象，而不管A 处于Service层还是数据访问层。 业务对象之间的依赖绑定 最艰巨也是最重要的，这 是它的最终使命之所在。如果不能完成这个职责，那么，无论业务对象如何的“呼喊”，也不 会得到依赖对象的任何响应(最常见的倒是会收到一个NullPointerException)。IoC Service Provider通过结合之前构建和管理的所有业务对象，以及各个业务对象间可以识别的依赖关系，将这些对象所依赖的对象注入绑定，从而保证每个业务对象在使用的时候，可以处于就绪状 态。 Spring IoC容器 image-20210520140010820 Spring的IoC容器就是一个IoC Provider，但是其相比于IoC Provider的功能更加的丰富，除了业务对象的构建、依赖关系的绑定这种IoC Provider的基本功能，还新增了业务对象声明周期的管理，AOP支持等。同时Spring提供了两种容器类型:BeanFactory和ApplicationContext。 BeanFactory 基础类型IoC容器，提供完整的IoC服务支持。如果没有特殊指定，==默认采用延迟初始化策略(lazy-load)==。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的 IoC容器选择。 ApplicationContext 在BeanFactory的基础上构建，是相对比较高 级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。ApplicationContext所管理 的对象，在该类型容器启动之后，==默认全部初始化并绑定完成==。所以，相对于BeanFactory来 说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中， ApplicationContext类型的容器是比较合适的选择。 简单的式例Spring IoC容器的一些特性简介autowire自动注入，通过autowire，我们可以略去很多人工显示的配置bean的操作，被依赖的发现和注入都交给了Spring，同时其有几个类型可选择，比如byName、byType等。 FactoryBeanBeanFactory和FactoryBean傻傻分不清？虽然两者类似，但是功能不同。FactoryBean是一种工厂Bean，和普通的Bean不一样，FactoryBean是可以生产Bean的Bean。 depends-on当一个 bean 直接依赖另一个 bean，可以使用 &lt;ref/&gt; 标签进行配置。不过如某个 bean 并不直接依赖于其他 bean，但又需要其他 bean 先实例化好，这个时候就需要使用 depends-on 特性了。depends-on 特性比较简单，就不演示了。仅贴一下配置文件的内容，如下： 这里有两个简单的类，其中 Hello 需要 World 在其之前完成实例化。相关配置如下： &lt;bean id=\"hello\" class=\"xyz.coolblog.depnedson.Hello\" depends-on=\"world\"/&gt; &lt;bean id=\"world\" class=\"xyz.coolblog.depnedson.World\" /&gt; BeanPostProcessorBeanPostProcessor 是 bean 实例化时的后置处理器，包含两个方法，其源码如下： public interface BeanPostProcessor { // bean 初始化前的回调方法 Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; // bean 初始化后的回调方法 Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException; } BeanPostProcessor是Spring框架的一个扩展点，可以通过BeanPostProcessor接口，我们能够插手Bean的实例化过程，比如AOP就是在bean实例将切面逻辑织入bean实例中，AOP也是正是通过BeanPostProcessor和IoC容器建立了联系 示例@Slf4j public class LoggerBeanPostProcessor implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) { log.info(\"Before \" + beanName + \" Initialization\"); return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) { log.info(\"After \" + beanName + \" Initialization\"); return bean; } } 配置如下&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean class=\"com.titizz.simulation.toyspring.learninng.LoggerBeanPostProcessor\"/&gt; &lt;bean id=\"car\" class=\"com.titizz.simulation.toyspring.Car\"&gt; &lt;/bean&gt; &lt;/beans&gt; 测试如下@Test public void testBeanPostProcessor() { String xmlPath = \"test-spring.xml\"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); } image-20210502181644978 核心接口Resource以 Resource 接口为核心发散出的几个类，都是用于解决 IoC 容器中的内容从哪里来的问题，也就是 配置文件从哪里读取、配置文件如何读取 的问题。 类名 说明 Resource 接口，标识一个外部资源。通过 getInputStream() 方法 获取资源的输入流 。 UrlResource 实现 Resource 接口的资源类，通过 URL 获取资源。 ResourceLoader 资源加载类。通过 getResource(String) 方法获取一个 Resouce 对象，是 获取 Resouce 的主要途径 。 BeanDefinition功能：用于解决Bean的定义问题，包括Bean的名字，类型以及它的属性赋予了什么值或者引用。说白了也就是解决了在IoC容器中定义一个Bean，使得IoC容器可以根据这个定义来生成实例。 类名 说明 BeanDefinition 该类保存了 Bean 定义。包括 Bean 的 名字 String beanClassName、类型 Class beanClass、属性 PropertyValues propertyValues。根据其 类型 可以生成一个类实例，然后可以把 属性 注入进去。propertyValues 里面包含了一个个 PropertyValue 条目，每个条目都是键值对 String - Object，分别对应要生成实例的属性的名字与类型。在 Spring 的 XML 中的 property 中，键是 key ，值是 value 或者 ref。对于 value 只要直接注入属性就行了，但是 ref 要先进行解析。Object 如果是 BeanReference 类型，则说明其是一个引用，其中保存了引用的名字，需要用先进行解析，转化为对应的实际 Object。 BeanDefinitionReader 解析 BeanDefinition 的接口。通过 loadBeanDefinitions(String) 来从一个地址加载类定义。 AbstractBeanDefinitionReader 实现 BeanDefinitionReader 接口的抽象类（未具体实现 loadBeanDefinitions，而是规范了 BeanDefinitionReader 的基本结构）。内置一个 HashMap rigistry，用于保存 String - beanDefinition 的键值对。内置一个 ResourceLoader resourceLoader，用于保存类加载器。用意在于，使用时，只需要向其 loadBeanDefinitions() 传入一个资源地址，就可以自动调用其类加载器，并把解析到的 BeanDefinition 保存到 registry 中去。 XmlBeanDefinitionReader 具体实现了 loadBeanDefinitions() 方法，从 XML 文件中读取类定义。 BeanFactory ❓以 BeanFactory 接口为核心发散出的几个类，都是用于解决 IoC 容器在 已经获取 Bean 的定义的情况下，如何装配、获取 Bean 实例 的问题。 类名 说明 BeanFactory 接口，标识一个 IoC 容器。通过 getBean(String) 方法来 获取一个对象 AbstractBeanFactory BeanFactory 的一种抽象类实现，规范了 IoC 容器的基本结构，但是把生成 Bean 的具体实现方式留给子类实现。IoC 容器的结构：AbstractBeanFactory 维护一个 beanDefinitionMap 哈希表用于保存类的定义信息（BeanDefinition）。获取 Bean 时，如果 Bean 已经存在于容器中，则返回之，否则则调用 doCreateBean 方法装配一个 Bean。（所谓存在于容器中，是指容器可以通过 beanDefinitionMap 获取 BeanDefinition 进而通过其 getBean() 方法获取 Bean。） AutowireCapableBeanFactory 可以实现自动装配的 BeanFactory。在这个工厂中，实现了 doCreateBean 方法，该方法分三步：1，通过 BeanDefinition 中保存的类信息实例化一个对象；2，把对象保存在 BeanDefinition 中，以备下次获取；3，为其装配属性。装配属性时，通过 BeanDefinition 中维护的 PropertyValues 集合类，把 String - Value 键值对注入到 Bean 的属性中去。如果 Value 的类型是 BeanReference 则说明其是一个引用（对应于 XML 中的 ref），通过 getBean 对其进行获取，然后注入到属性中。 ApplicationContext以 ApplicationContext 接口为核心发散出的几个类，主要是对前面 Resouce 、 BeanFactory、BeanDefinition 进行了功能的封装，解决 根据地址获取 IoC 容器并使用 的问题。 类名 说明 ApplicationContext 标记接口，继承了 BeanFactory。通常，要实现一个 IoC 容器时，需要先通过 ResourceLoader 获取一个 Resource，其中包括了容器的配置、Bean 的定义信息。接着，使用 BeanDefinitionReader 读取该 Resource 中的 BeanDefinition 信息。最后，把 BeanDefinition 保存在 BeanFactory 中，容器配置完毕可以使用。注意到 BeanFactory 只实现了 Bean 的 装配、获取，并未说明 Bean 的 来源 也就是 BeanDefinition 是如何 加载 的。该接口把 BeanFactory 和 BeanDefinitionReader 结合在了一起。 AbstractApplicationContext ApplicationContext 的抽象实现，内部包含一个 BeanFactory 类。主要方法有 getBean() 和 refresh() 方法。getBean() 直接调用了内置 BeanFactory 的 getBean() 方法，refresh() 则用于实现 BeanFactory 的刷新，也就是告诉 BeanFactory 该使用哪个资源（Resource）加载类定义（BeanDefinition）信息，该方法留给子类实现，用以实现 从不同来源的不同类型的资源加载类定义 的效果。 ClassPathXmlApplicationContext 从类路径加载资源的具体实现类。内部通过 XmlBeanDefinitionReader 解析 UrlResourceLoader 读取到的 Resource，获取 BeanDefinition 信息，然后将其保存到内置的 BeanFactory 中。 对 ApplicatinoContext 的分层更为细致。AbstractApplicationContext 中为了实现 不同来源 的 不同类型 的资源加载类定义，把这两步分层实现。以“从类路径读取 XML 定义”为例，首先使用 AbstractXmlApplicationContext 来实现 不同类型 的资源解析，接着，通过 ClassPathXmlApplicationContext 来实现 不同来源 的资源解析。 战略观望 容器启动阶段使用Resource相关接口标识我们配置文件从哪里获取，然后使用BeanDefinitionReader对标识的文件进行解析，将分析后的信息编组为相应的BeanDefinition。最后将保存了每个Bean定义信息的BeanDefinition，注册到相应的BeanDefinitionRegistry，这样容器的启动就完成了。 启动阶段任务 Bean实例化阶段通过容器的启动阶段，现在所有的Bean定义的信息，都通过BeanDefiniton的方式注册到了BeanDefinitionRegistry中，当某个请求方通过容器的getBean方法明确的调用某个对象的时候，或者因为依赖关系容器需要隐式的调用getBean方法，就会出发第二阶段的活动。 bean的实例化过程 Spring容器将对其所管理的对象全部给予统一的生命周期管理，这些被管理的对象完全摆脱了原 来那种“new完后被使用，脱离作用域后即被回收”的命运 详细阐述最简单的IoC容器public class BeanFactory { // 说白了就是一个map private Map&lt;String, Object&gt; beanMap = new HashMap&lt;&gt;(); public void registerBean(String name, Object bean) { beanMap.put(name, bean); } public Object getBean(String name) { return beanMap.get(name); } } public class SimpleBeanContainerTest { @Test public void testGetBean() throws Exception { // 需要我们去手动new依赖对象，然后放入 BeanFactory beanFactory = new BeanFactory(); beanFactory.registerBean(\"helloService\", new HelloService()); HelloService helloService = (HelloService) beanFactory.getBean(\"helloService\"); assertThat(helloService).isNotNull(); assertThat(helloService.sayHello()).isEqualTo(\"hello\"); } class HelloService { public String sayHello() { System.out.println(\"hello\"); return \"hello\"; } } } BeanFactoryPostProcess和BeanPostProcessorBeanFactoryPostProcess和BeanPostProcessor是spring框架中具有重量级地位的两个接口，理解了这两个接口的作用，基本就理解spring的核心原理了 BeanFactoryPostProcessor是spring提供的容器拓展机制，允许我们在bean实例化之前修改bean的定义信息（BeanDedinition），其重要的实现类PropertyPlaceholderConfigurer和CustomEditorConfigurer PropertyPlaceholderConfigurer的作用是用properties文件的配置值替换xml文件中的占位符 CustomEditorConfigurer的作用是实现类型转换。 BeanPostProcessor也是spring提供的容器拓展机制，不同于BeanFactoryPostProcessor，BeanPostProcesssor在Bean实例化之后修改Bean或替换Bean。也是实现AOP的关键。 等等等。。。 整体流程图 整体流程图 BeanDefinitionReader读取Bean的相关配置信息，并将读取到的信息使用BeanDefinition表示，同时注册到BeanDefinitionRegistry中。 通过实现了BeanFactoryPostProcessor的类，自定义修改BeanDefinition中的信息 Bean的实例化 采用策略模式，策略化Bean的实例，共包含两种方式：cglib、反射 获取Bean的实例之后，根据BeanDefinition中的信息，填充Bean的属性、依赖 检测各种检测各种Aware接口，并放入Bean中 调用BeanPostProcessor接口的前置处理方法，处理符合要求的Bean实例 如果实现了InitializingBean接口，则处理对应的afterPropertiesSet()方法 如果定义init-method方法，处理对应的初始化方法 调用BeanPostProcessor接口的后置处理方法，处理符合要求的Bean实例 使用 判断Bean的Scope，如果是prototype，不再管理 如果是单例，如果实现了DisposableBean接口，则执行对应的destroy方法 如果定义了destory-method，则执行自定义的销毁方法 结束整理的还是很乱，虽然看的时候是都看了。。。 后面慢慢优化吧（涉及到以后==永远不会）😑 references spring揭秘 tiny-spring mini-spring tiny-spring分析 Spring IoC容器分析 Spring IOC 容器源码分析系列","categories":[{"name":"spring","slug":"spring","permalink":"https://winniekun.github.io/categories/spring/"}],"tags":[{"name":"ioc","slug":"ioc","permalink":"https://winniekun.github.io/tags/ioc/"}]},{"title":"归并排序","slug":"算法/排序/归并排序","date":"2021-04-30T13:35:01.000Z","updated":"2021-06-17T04:51:19.309Z","comments":true,"path":"归并排序/","link":"","permalink":"https://winniekun.github.io/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","excerpt":"","text":"归并排序步骤 先选择分界点 先递归排序 归并 合二为一 Support/typora-user-images/image-20210419120203122.png private static void mergeSort(int[] array, int l, int r) { if (l &gt;= r) { return; } int mid = (l + r) / 2; mergeSort(array, l, mid); mergeSort(array, mid+1, r); // 整合 int[] tmp = new int[r - l + 1]; // 临时数组, 用于临时存储 [l,r]区间内排好序的数据 int i = l, j = mid + 1, k = 0; // 两个指针 // 进行归并 while (i &lt;= mid &amp;&amp; j &lt;= r) { if (array[i] &lt;= array[j]) tmp[k++] = array[i++]; else tmp[k++] = array[j++]; } while (i &lt;= mid) tmp[k++] = array[i++]; while (j &lt;= r) tmp[k++] = array[j++]; // 进行赋值 for (i = l, j = 0; i &lt;= r; i++, j++) array[i] = tmp[j]; }","categories":[{"name":"排序","slug":"排序","permalink":"https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"归并排序","slug":"归并排序","permalink":"https://winniekun.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"}]},{"title":"死磕数学基础","slug":"LeetCode/stick-to-math","date":"2021-04-20T11:56:11.000Z","updated":"2021-05-16T16:42:07.999Z","comments":true,"path":"stick-to-math/","link":"","permalink":"https://winniekun.github.io/stick-to-math/","excerpt":"前言LeetCode死磕系列十二： 数学基础 说实话，其实都是刷题都是数学的实现，不过感觉有些题目更加偏向数学应用，譬如蓄水池，等概率抽样…。","text":"前言LeetCode死磕系列十二： 数学基础 说实话，其实都是刷题都是数学的实现，不过感觉有些题目更加偏向数学应用，譬如蓄水池，等概率抽样…。 题目470 用rand7()实现Rand10()从最基础的讲起如何做到均匀的生成随机数 从上述的文章可以得出： 已知: $randN()$可以==等概率==生成$[1, N]$范围的数字那么: $(randN()-1) \\times Y + randY()$可以==等概率==生成$[1, Y \\times N]$ 范围的数字 即：实现了$randNY()$ 以$[(rand9() - 1) \\times 7 + rand7()]$为例子 rand9()-1\\rand7 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 1 8 9 10 11 12 13 14 2 15 16 17 18 19 20 21 3 22 23 24 25 26 27 28 4 29 30 31 32 33 34 35 5 36 37 38 39 40 41 42 6 43 44 45 46 47 48 49 7 50 51 52 53 54 55 56 8 57 58 59 60 61 62 63 是不是很神奇，数学证明不会 那么想到通过rand4()来实现rand2()呢？这个就很简单了，已知rand4()会均匀产生[1,4]的随机数，通过取余，再加1就可以了。如下所示，结果也是等概率的。 rand4() % 2 + 1 = ? 1 % 2 + 1 = 2 2 % 2 + 1 = 1 3 % 2 + 1 = 2 4 % 2 + 1 = 1 事实上，只要rand_N()中N是2的倍数，就都可以用来实现rand2()，反之，若N不是2的倍数，则产生的结果不是等概率的。比如： rand6() % 2 + 1 = ? 1 % 2 + 1 = 2 2 % 2 + 1 = 1 3 % 2 + 1 = 2 4 % 2 + 1 = 1 5 % 2 + 1 = 2 6 % 2 + 1 = 1 rand5() % 2 + 1 = ? 1 % 2 + 1 = 2 2 % 2 + 1 = 1 3 % 2 + 1 = 2 4 % 2 + 1 = 1 5 % 2 + 1 = 2 通用一些的 如果需要实现$randX()$ 先实现$randN()$ $N$为$X$的倍数（$N&gt;X$） 再通过 $randN() \\% X + 1$即可 public int rand10() { // rand 49 while (true) { int num = (rand7() - 1) * 7 + rand7(); // rand49 if (num &lt;= 40) { // 使用拒绝采样，得到rand40 return num % 10 + 1; // rand10 } } } 优化 class Solution extends SolBase { // 上述拒绝了9个数字， // 优化之后，减少丢弃值，提高命中率 public int rand10() { while(true) { int a = rand7(); int b = rand7(); int num = (a-1)*7 + b; // rand 49 if(num &lt;= 40) return num % 10 + 1; // 拒绝采样 a = num - 40; // rand 9 b = rand7(); num = (a-1)*7 + b; // rand 63 if(num &lt;= 60) return num % 10 + 1; a = num - 60; // rand 3 b = rand7(); num = (a-1)*7 + b; // rand 21 if(num &lt;= 20) return num % 10 + 1; } } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"数学基础","slug":"数学基础","permalink":"https://winniekun.github.io/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"}]},{"title":"死磕SQL","slug":"LeetCode/stick-to-sql","date":"2021-04-20T11:56:11.000Z","updated":"2021-05-16T16:39:43.618Z","comments":true,"path":"stick-to-sql/","link":"","permalink":"https://winniekun.github.io/stick-to-sql/","excerpt":"前言LeetCode死磕系列十： SQL","text":"前言LeetCode死磕系列十： SQL 作为一个后端开发程序员，SQL功底还是很重要的！！！ 所以还是要练习。 还记得去年被字节面试的时候，连SQL都写不出来。。。 LeetCode SQL题目整理刷了LC上的top70之后，感觉考察最多的还是多表的联合查找，毕竟实际中也不会仅仅是单表的查询。 主要题型： TOP N 问题 排名问题 滑动窗口 自链接问题 题解TOP N问题176. 第二高的薪水思路： 使用limit 注意判空、去重 select ifnull ((select distinct Salary from Employee order by Salary desc limit 1, 1) , null) as SecondHighestSalary; 先使用max查询最高的薪水 max，之后再通过自查询，查询小于max的max 184. 部门工资最高的员工-- 思路： 寻找最大薪资的数据 -- join -- 1. 直接join group by 选取最大的即可 但是 无法保证最大的薪资不重复 失败 -- 2. 先通过员工信息 寻找最大的薪资+id 的数据A，然后再join 两张表，将A中对应的数据返回 -- 1. select d.Name as Department, e.Name as Employee, e.Salary as Salary from Employee e inner join Department d on e.DepartmentId = d.Id where (e.DepartmentId, e.Salary) in (select DepartmentId, max(Salary) from Employee group by DepartmentId); 177. 第N高的薪水LIMIT PAGE, OFFSET 跳过 PAGE * OFFSET条数据，接下来的offset条数据， 因为题目中未说明薪资是否不重复，所以还需要使用distinct去重 CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN set N:= N-1; RETURN ( # Write your MySQL query statement below. select distinct Salary from Employee order by Salary desc limit N,1 ); END 185. 部门工资前三高的所有员工select d.Name as Department, e2.Name as Employee, e2.Salary from Department d inner join ( select e.*, dense_rank() over(partition by DepartmentID Order by Salary DESC) as 'rank' from Employee e ) e2 on d.Id= e2.DepartmentID where e2.rank&lt;=3 order by Department AND Salary 排名问题178.分数排名select Score, dense_rank() over(order by Score desc) as `Rank` from Scores; 自链接问题603. 连续空余座位-- 几个朋友来到电影院的售票处，准备预约连续空余座位。 -- 你能利用表 cinema ，帮他们写一个查询语句，获取所有空余座位，并将它们按照 seat_id 排序后返回吗？ select distinct a.seat_id from cinema a join cinema b on abs(a.seat_id - b.seat_id) = 1 and a.free = true and b.free = true order by a.seat_id","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"SQL","slug":"SQL","permalink":"https://winniekun.github.io/tags/SQL/"}]},{"title":"死磕多线程","slug":"LeetCode/stick-to-multi-thread","date":"2021-04-14T11:56:11.000Z","updated":"2021-06-06T07:56:37.628Z","comments":true,"path":"stick-to-multi-thread/","link":"","permalink":"https://winniekun.github.io/stick-to-multi-thread/","excerpt":"前言LeetCode死磕系列十一： 多线程","text":"前言LeetCode死磕系列十一： 多线程 看那么多的面经，发现已经开始询问多线程的编程了。个人感觉多线程编程主要是理解，思想。是有固定的套路的，譬如：交替输出，有序的输出哇。深挖下去就是考察对线程通讯的使用，以及一些高阶用法。和哲学家就餐问题、生产者消费者问题、读写者问题差不多。 所以～～～ 我来开始熟悉并发操作了，毕竟光看不练假把式 LeetCode 多线程题目整理1114. 按序打印","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"多线程","slug":"多线程","permalink":"https://winniekun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"一行一行源码分析清楚AbstractQueuedSynchronizer","slug":"Java进阶/并发/一行一行源码分析清楚AbstractQueuedSynchronizer","date":"2021-03-30T12:14:20.000Z","updated":"2021-04-05T12:19:21.814Z","comments":true,"path":"一行一行源码分析清楚AbstractQueuedSynchronizer/","link":"","permalink":"https://winniekun.github.io/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9AAbstractQueuedSynchronizer/","excerpt":"在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础。 Google 一下 AbstractQueuedSynchronizer，我们可以找到很多关于 AQS 的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。 本文将从 ReentrantLock 的公平锁源码出发，分析下 AbstractQueuedSynchronizer 这个类是怎么工作的，希望能给大家提供一些简单的帮助。","text":"在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础。 Google 一下 AbstractQueuedSynchronizer，我们可以找到很多关于 AQS 的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。 本文将从 ReentrantLock 的公平锁源码出发，分析下 AbstractQueuedSynchronizer 这个类是怎么工作的，希望能给大家提供一些简单的帮助。 申明以下几点： 本文有点长，但还是挺简单，主要面向读者对象为并发编程的初学者，或者想要阅读 Java 并发包源码的开发者。对于新手来说，可能需要花好几个小时才能完全看懂，但是这时间肯定是值得的。 源码环境 JDK1.7（1.8没啥变化），看到不懂或有疑惑的部分，最好能自己打开源码看看。Doug Lea 大神的代码写得真心不错。 本文不分析共享模式，这样可以给读者减少很多负担，第三篇文章对共享模式进行了分析。而且也不分析 condition 部分，所以应该说很容易就可以看懂了。 本文大量使用我们平时用得最多的 ReentrantLock 的概念，本质上来说是不正确的，读者应该清楚，AQS 不仅仅用来实现可重入锁，只是希望读者可以用锁来联想 AQS 的使用场景，降低阅读压力。 ReentrantLock 的公平锁和非公平锁只有一点点区别，第二篇文章做了介绍。 评论区有读者反馈本文直接用代码说不友好，应该多配点流程图，这篇文章确实有这个问题。但是作为过来人，我想告诉大家，对于 AQS 来说，形式真的不重要，重要的是把细节说清楚。 AQS 结构先来看看 AQS 有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了，毕竟可以猜嘛！ // 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的 private transient volatile Node head; // 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表 private transient volatile Node tail; // 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁 // 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1 private volatile int state; // 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入 // reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁 // if (currentThread == getExclusiveOwnerThread()) {state++} private transient Thread exclusiveOwnerThread; //继承自AbstractOwnableSynchronizer 怎么样，看样子应该是很简单的吧，毕竟也就四个属性啊。 AbstractQueuedSynchronizer 的等待队列示意如下所示，注意了，之后分析过程中所说的 queue，也就是阻塞队列不包含 head，不包含 head，不包含 head。 aqs-0 等待队列中每个线程被包装成一个 Node 实例，数据结构是链表，一起看看源码吧： static final class Node { // 标识节点当前在共享模式下 static final Node SHARED = new Node(); // 标识节点当前在独占模式下 static final Node EXCLUSIVE = null; // ======== 下面的几个int常量是给waitStatus用的 =========== /** waitStatus value to indicate thread has cancelled */ // 代码此线程取消了争抢这个锁 static final int CANCELLED = 1; /** waitStatus value to indicate successor's thread needs unparking */ // 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒 static final int SIGNAL = -1; /** waitStatus value to indicate thread is waiting on condition */ // 本文不分析condition，所以略过吧，下一篇文章会介绍这个 static final int CONDITION = -2; /** * waitStatus value to indicate the next acquireShared should * unconditionally propagate */ // 同样的不分析，略过吧 static final int PROPAGATE = -3; // ===================================================== // 取值为上面的1、-1、-2、-3，或者0(以后会讲到) // 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待， // ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。 volatile int waitStatus; // 前驱节点的引用 volatile Node prev; // 后继节点的引用 volatile Node next; // 这个就是线程本尊 volatile Thread thread; } Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。 上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说 ReentrantLock 的公平锁。再次强调，我说的阻塞队列不包含 head 节点。 aqs-0 首先，我们先看下 ReentrantLock 的使用方式。 // 我用个web开发中的service概念吧 public class OrderService { // 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个 private static ReentrantLock reentrantLock = new ReentrantLock(true); public void createOrder() { // 比如我们同一时间，只允许一个线程创建订单 reentrantLock.lock(); // 通常，lock 之后紧跟着 try 语句 try { // 这块代码同一时间只能有一个线程进来(获取到锁的线程)， // 其他的线程在lock()方法上阻塞，等待获取到锁，再进来 // 执行代码... // 执行代码... // 执行代码... } finally { // 释放锁 reentrantLock.unlock(); } } } ReentrantLock 在内部用了内部类 Sync 来管理锁，所以真正的获取锁和释放锁是由 Sync 的实现类来控制的。 abstract static class Sync extends AbstractQueuedSynchronizer { } Sync 有两个实现，分别为 NonfairSync（非公平锁）和 FairSync（公平锁），我们看 FairSync 部分。 public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } 线程抢锁很多人肯定开始嫌弃上面废话太多了，下面跟着代码走，我就不废话了。 static final class FairSync extends Sync { private static final long serialVersionUID = -3000897897090466540L; // 争锁 final void lock() { acquire(1); } // 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力 // 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。 // 否则，acquireQueued方法会将线程压到队列中 public final void acquire(int arg) { // 此时 arg == 1 // 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试 // 因为有可能直接就成功了呢，也就不需要进队列排了， // 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的) if (!tryAcquire(arg) &amp;&amp; // tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) { selfInterrupt(); } } /** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. */ // 尝试直接获取锁，返回值是boolean，代表是否获取到锁 // 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取 protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); // state == 0 此时此刻没有线程持有锁 if (c == 0) { // 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到， // 看看有没有别人在队列中等了半天了 if (!hasQueuedPredecessors() &amp;&amp; // 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了， // 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_= // 因为刚刚还没人的，我判断过了 compareAndSetState(0, acquires)) { // 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁 setExclusiveOwnerThread(current); return true; } } // 会进入这个else if分支，说明是重入了，需要操作：state=state+1 // 这里不存在并发问题 else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc &lt; 0) throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; } // 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁 // 回到上面一个外层调用方法继续看: // if (!tryAcquire(arg) // &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // selfInterrupt(); return false; } // 假设tryAcquire(arg) 返回false，那么代码将执行： // acquireQueued(addWaiter(Node.EXCLUSIVE), arg)， // 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE) /** * Creates and enqueues node for current thread and given mode. * * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared * @return the new node */ // 此方法的作用是把线程包装成node，同时进入到队列中 // 参数mode此时是Node.EXCLUSIVE，代表独占模式 private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure // 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后 Node pred = tail; // tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧) if (pred != null) { // 将当前的队尾节点，设置为自己的前驱 node.prev = pred; // 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴 if (compareAndSetTail(pred, node)) { // 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连， // 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了 pred.next = node; // 线程入队了，可以返回了 return node; } } // 仔细看看上面的代码，如果会到这里， // 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队) // 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的 enq(node); return node; } /** * Inserts node into queue, initializing if necessary. See picture above. * @param node the node to insert * @return node's predecessor */ // 采用自旋的方式入队 // 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队， // 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的 private Node enq(final Node node) { for (;;) { Node t = tail; // 之前说过，队列为空也会进来这里 if (t == null) { // Must initialize // 初始化head节点 // 细心的读者会知道原来 head 和 tail 初始化的时候都是 null 的 // 还是一步CAS，你懂的，现在可能是很多线程同时进来呢 if (compareAndSetHead(new Node())) // 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了 // 这个时候有了head，但是tail还是null，设置一下， // 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了 // 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return // 所以，设置完了以后，继续for循环，下次就到下面的else分支了 tail = head; } else { // 下面几行，和上一个方法 addWaiter 是一样的， // 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排 node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } // 现在，又回到这段代码了 // if (!tryAcquire(arg) // &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // selfInterrupt(); // 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列 // 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话， // 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false // 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了 final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); // p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head // 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列 // 所以当前节点可以去试抢一下锁 // 这里我们说一下，为什么可以去试试： // 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node， // enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程 // 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试， // tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state if (p == head &amp;&amp; tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return interrupted; } // 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头， // 要么就是tryAcquire(arg)没有抢赢别人，继续往下看 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; } } finally { // 什么时候 failed 会为 true??? // tryAcquire() 方法抛异常的情况 if (failed) cancelAcquire(node); } } /** * Checks and updates status for a node that failed to acquire. * Returns true if thread should block. This is the main signal * control in all acquire loops. Requires that pred == node.prev * * @param pred node's predecessor holding status * @param node the node * @return {@code true} if thread should block */ // 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：\"当前线程没有抢到锁，是否需要挂起当前线程？\" // 第一个参数是前驱节点，第二个参数才是代表当前线程的节点 private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { int ws = pred.waitStatus; // 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true if (ws == Node.SIGNAL) /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; // 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。 // 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。 // 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点， // 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队， // 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的 if (ws &gt; 0) { /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do { node.prev = pred = pred.prev; } while (pred.waitStatus &gt; 0); pred.next = node; } else { /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ // 仔细想想，如果进入到这个分支意味着什么 // 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3 // 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0 // 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0 // 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1) compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } // 这个方法返回 false，那么会再走一次 for 循序， // 然后再次进来此方法，此时会从第一个分支返回 true return false; } // private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) // 这个方法结束根据返回值我们简单分析下： // 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒 // 我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了 // 如果返回false, 说明当前不需要被挂起，为什么呢？往后看 // 跳回到前面是这个方法 // if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; // parkAndCheckInterrupt()) // interrupted = true; // 1. 如果shouldParkAfterFailedAcquire(p, node)返回true， // 那么需要执行parkAndCheckInterrupt(): // 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的 // 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒======= private final boolean parkAndCheckInterrupt() { LockSupport.park(this); return Thread.interrupted(); } // 2. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况 // 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。 // 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程： // =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。 } 说到这里，也就明白了，多看几遍 final boolean acquireQueued(final Node node, int arg) 这个方法吧。自己推演下各个分支怎么走，哪种情况下会发生什么，走到哪里。 解锁操作最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被 LockSupport.park(this); 挂起停止，等待被唤醒。 // 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了 public void unlock() { sync.release(1); } public final boolean release(int arg) { // 往后看吧 if (tryRelease(arg)) { Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } // 回到ReentrantLock看tryRelease方法 protected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); // 是否完全释放锁 boolean free = false; // 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉 if (c == 0) { free = true; setExclusiveOwnerThread(null); } setState(c); return free; } /** * Wakes up node's successor, if one exists. * * @param node the node */ // 唤醒后继节点 // 从上面调用处知道，参数node是head头结点 private void unparkSuccessor(Node node) { /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; // 如果head节点当前waitStatus&lt;0, 将其修改为0 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ // 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1） // 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的 Node s = node.next; if (s == null || s.waitStatus &gt; 0) { s = null; // 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; } if (s != null) // 唤醒线程 LockSupport.unpark(s.thread); } 唤醒线程以后，被唤醒的线程将从以下代码中继续往前走： private final boolean parkAndCheckInterrupt() { LockSupport.park(this); // 刚刚线程被挂起在这里了 return Thread.interrupted(); } // 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了 好了，后面就不分析源码了，剩下的还有问题自己去仔细看看代码吧。 总结总结一下吧。 在并发环境下，加锁和解锁需要以下三个部件的协调： 锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。 线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。 阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现，感兴趣的读者可以参考这篇文章关于CLH的介绍，写得简单明了。 示例图解析下面属于回顾环节，用简单的示例来说一遍，如果上面的有些东西没看懂，这里还有一次帮助你理解的机会。 首先，第一个线程调用 reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回 true 了，结束。只是设置了 state=1，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，那世界就太太太平了，完全没有交集嘛，那我还要 AQS 干嘛。 如果线程 1 没有调用 unlock() 之前，线程 2 调用了 lock(), 想想会发生什么？ 线程 2 会初始化 head【new Node()】，同时线程 2 也会插入到阻塞队列并挂起 (注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环) private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // Must initialize if (compareAndSetHead(new Node())) tail = head; } else { node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } 首先，是线程 2 初始化 head 节点，此时 head==tail, waitStatus==0 aqs-1 然后线程 2 入队： aqs-2 同时我们也要看此时节点的 waitStatus，我们知道 head 节点是线程 2 初始化的，此时的 waitStatus 没有设置， java 默认会设置为 0，但是到 shouldParkAfterFailedAcquire 这个方法的时候，线程 2 会把前驱节点，也就是 head 的waitStatus设置为 -1。 那线程 2 节点此时的 waitStatus 是多少呢，由于没有设置，所以是 0； 如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 shouldParkAfterFailedAcquire 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。 aqs-3 这里可以简单说下 waitStatus 中 SIGNAL(-1) 状态的意思，Doug Lea 注释的是：代表后继节点需要被唤醒。也就是说这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着 “waitStatus代表后继节点的状态” 这种思路去看一遍源码。 （全文完）","categories":[{"name":"concurrency","slug":"concurrency","permalink":"https://winniekun.github.io/categories/concurrency/"}],"tags":[]},{"title":"2020年总结","slug":"碎碎念/2020年总结","date":"2021-01-02T16:11:11.000Z","updated":"2021-01-02T16:40:50.580Z","comments":true,"path":"2020年总结/","link":"","permalink":"https://winniekun.github.io/2020%E5%B9%B4%E6%80%BB%E7%BB%93/","excerpt":"啊","text":"啊 2020年到底还是结束了，感觉现在的自己也不喜欢做各种阶段性总结了，总感觉把自己的经历写出来是一种特别矫情的事情。相反，更想把这些经历仅供自己慢慢回味和感触。但是，时间久了，有些东西记得就不够客观了（虽然现在记忆的也不够观。。。） 所以，以后的每一年都还是做一次年终小结吧。 上半年因为疫情，上半年一直在家里呆着，每天的生活差不多如下 时间 干啥 上午 网课（挂机，干自己的事情） 下午 网课（挂机，干自己的事情） 晚上 和韩老师还有沈总打游戏 在上网课的3个月里，自己虽然课没好好上过，不过还是做了一些事情的： 剑指offer刷了3遍 LeetCode300大关完成 深入理解JVM虚拟机终于是看懂了 JDK源码（collection、juc）嗑了一遍 HashMap的设计是真的精妙 红黑树真的不是正常人写的来的 操作系统过了一遍 为啥要做这些事情嘞，主要还是想找实习，感觉在学校里面呆腻了，想出来看看（什么**想法）… 终于，在我的艰苦复习和准备之下，我心仪的字节还是把我拒绝了（今年只面了字节一家大厂），被打击到了之后，也就没再继续投递其他大厂。后面通过牛客上的内推，来到了蔚来汽车实习。 下半年从9月中旬起，开始我的实习生活，从刚开始的不适应，到后面的一脸懵逼，再到现在的勉强适应。让我认识到了自己技术上的不足，以及交流上的问题。所以基本每天回来都会主动去看每个节点的所负责的业务逻辑，涉及哪些技术栈，这些技术栈是怎么使用的，和我之前自己写着玩儿的有什么区别。自己也学会了在做任务的时候，先去看需求背景，再去看实现方案，然后脑子构建实现方式，最后再看是撸代码。遇到了自己解决不了的，有疑惑的地方，也渐渐的学会主动去请教同事了。最后，在距离实习结束还有两个月不到的时间里，希望能够拓宽自己的技术栈，精进自己的技术深度。主动去和同事交流，学习经验。","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"2021年书单【年汇总】","slug":"碎碎念/2021年书单【年汇总】","date":"2021-01-01T07:01:10.000Z","updated":"2021-10-14T06:34:49.619Z","comments":true,"path":"2021年书单【年汇总】/","link":"","permalink":"https://winniekun.github.io/2021%E5%B9%B4%E4%B9%A6%E5%8D%95%E3%80%90%E5%B9%B4%E6%B1%87%E6%80%BB%E3%80%91/","excerpt":"我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 摘自鶸道场 趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。","text":"我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 摘自鶸道场 趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。 书籍相关 程序员代码面试指南- IT名企算法与数据结构题目最优解 计划的是去年年底开始刷，然后计划赶不上变化 公司安排的1230的任务挺复杂的，还挺多，就没有开始搞 不过终于在31号，下定决心先把书买了，然后1号正式开刷 Linux/Unix系统编程手册 Redis的设计与实现 C++ Primer 转C++和Go了要 Go 程序涉及语言 设计模式的艺术 感觉代码写的怪怪的，不符合正常编码习惯 操作系统导论 我这渣渣英语能力 深入理解Java虚拟机：JVM高级特性与最佳实践 看来是成长了，研一上看的时候，完全看不懂 现在也是常看常新 CSAPP YYDS 深入理解Kafka：核心设计与实践原理 基础 + 经验总结类型，挺好 UNIX网络编程卷1 Spring揭秘 写的真的好 不愧是国内技术书里面少有的上9⭐的图书 MySQL技术内幕(InnoDB存储引擎) 精进MySQL必备 Java 编程的逻辑 很有条理，但是有些知识点自己有些先入为主的坏习惯，所以有些地方不太能赞同 TCP&amp;IP网络编程 我的第二本C入门书籍~ 论文电影、电视剧、综艺、纪录片 一点就通 合伙人2 ？？？ 温暖的抱抱 拆弹专家2 送你一朵小红花 赘婿 上头看的 哪吒重生 够朋克 你好李焕英 好看的 因为是男高所以很幸福 憨批一家人哇 罗小黑战绩 更新了，泪目 灵笼 剧情很有趣，批量生产刀子ing 荣耀乒乓 你是我的城池营垒 白敬亭真的是逗 然后B站上还关注了他的账号","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"书单","slug":"书单","permalink":"https://winniekun.github.io/tags/%E4%B9%A6%E5%8D%95/"}]},{"title":"if-else代码优化的几种方案","slug":"代码规范/if-else-code-optimization","date":"2020-11-02T11:46:42.000Z","updated":"2020-11-02T12:46:17.949Z","comments":true,"path":"if-else-code-optimization/","link":"","permalink":"https://winniekun.github.io/if-else-code-optimization/","excerpt":"前言代码中涉及到较为复杂的逻辑是，一般情况下会出现大量的if-else，虽然实现了整个功能，但是阅读起来比较耗时，并且维护的时候也十分的困难，同时只要有一个地方没有考虑清楚，修改起来就难免出现bug。最近在做公司某个节点的性能优化，就遇到了这个问题，然后在review的时候，同事和我讲了一些优化方案，以及默认的规范之后。自己重新修改之后，感觉很舒服，后续自己重新整理一下，所以就写了这篇博客。","text":"前言代码中涉及到较为复杂的逻辑是，一般情况下会出现大量的if-else，虽然实现了整个功能，但是阅读起来比较耗时，并且维护的时候也十分的困难，同时只要有一个地方没有考虑清楚，修改起来就难免出现bug。最近在做公司某个节点的性能优化，就遇到了这个问题，然后在review的时候，同事和我讲了一些优化方案，以及默认的规范之后。自己重新修改之后，感觉很舒服，后续自己重新整理一下，所以就写了这篇博客。 优化方案优化一：提前return，去除不必要的else如果if-else代码块包含return语句，可以考虑通过提前return，把多余else干掉，使代码更加优雅。 优化前if(condition){ // do something } else { // do other thing return; } 优化后if(!condition) { return; } // do something 优化二：使用三元运算优化前int price; if(condition){ price = 10; } else { price = 20; } 优化后int price = condition ? 10 : 20; 优化三：使用枚举优化前int orderStatus = getXXX(xxx); String OrderStatusDes; if(orderStatus == 0) { OrderStatusDes = \"订单未支付\"; }else if(OrderStatus == 1) { OrderStatusDes = \"订单已支付\"; }else if(OrderStatus == 2) { OrderStatusDes = \"已发货\"; } 优化后先定义一个枚举类型 public enum OrderStatusEnum { UN_PAID(0,\"订单未支付\"),PAIDED(1,\"订单已支付\"),SENDED(2,\"已发货\"),; private int index; private String desc; public int getIndex() { return index; } public String getDesc() { return desc; } OrderStatusEnum(int index, String desc){ this.index = index; this.desc =desc; } OrderStatusEnum ofCode(int orderStatus) { for (OrderStatusEnum temp : OrderStatusEnum.values()) { if (temp.getIndex() == orderStatus) { return temp; } } return null; } } 有了枚举之后，以上if-else逻辑分支，可以优化为一行代码 String OrderStatusDes = OrderStatusEnum.ofCode(orderStatus).getDesc(); 优化四：合并条件表达式如果有一系列条件返回一样的结果，可以将它们合并为一个条件表达式，让逻辑更加清晰。 优化前double getVipDiscount() { if(age&lt;18){ return 0.8; } if(\"深圳\".equals(city)){ return 0.8; } if(isStudent){ return 0.8; } //do somethig } 优化后double getVipDiscount(){ if(age&lt;18|| \"深圳\".equals(city)||isStudent){ return 0.8; } //doSomthing } 如果返回统一结果的条件过多，可以再编写一个方法，封装起来😄 优化五：使用Optional有时候if-else比较多，是因为非空判断导致的，这时候你可以使用Java9的Optional进行优化。 优化前String str = \"wkk\"; if (str != null) { System.out.println(str); } else { System.out.println(\"Null\"); } 优化后Optional&lt;String&gt; strOptional = Optional.ofNullable(\"wkk\"); strOptional.ifPresentOrElse(System.out::println, () -&gt; System.out.println(\"Null\")); Java8的Optional虽然没有这个方法，但是我们可以用Optional来优化非空的赋值操作 示例： 电池平台服役状态赋值：如果为null，赋值为0，否则为原来的值 batteryBasicInfoCollectDto.setFlowControlState(Optional.ofNullable(batteryInfo.getFlowControlState()).orElse(0)); 优化六：表驱动法优化前表驱动法，又称之为表驱动、表驱动方法。表驱动方法是一种使你可以在表中查找信息，而不必用很多的逻辑语句（if或Case）来把它们找出来的方法。以下的demo，把map抽象成表，在map中查找信息，而省去不必要的逻辑语句。 if (param.equals(value1)) { doAction1(someParams); } else if (param.equals(value2)) { doAction2(someParams); } else if (param.equals(value3)) { doAction3(someParams); } 优化后// 这里泛型是为方便演示，实际可替换为你需要的类型 Map&lt;?, Function&lt;?&gt; action&gt; actionMappings = new HashMap&lt;&gt;(); // 初始化 actionMappings.put(value1, (someParams) -&gt; { doAction1(someParams)}); actionMappings.put(value2, (someParams) -&gt; { doAction2(someParams)}); actionMappings.put(value3, (someParams) -&gt; { doAction3(someParams)}); // 省略多余逻辑语句 actionMappings.get(param).apply(someParams); 优化七：优化逻辑结构，让正常流程走主干优化前public double getAdjustedCapital(){ if(_capital &lt;= 0.0 ){ return 0.0; } if(_intRate &gt; 0 &amp;&amp; _duration &gt;0){ return (_income / _duration) *ADJ_FACTOR; } return 0.0; } 优化后 public double getAdjustedCapital(){ if(_capital &lt;= 0.0 ){ return 0.0; } if(_intRate &lt;= 0 || _duration &lt;= 0){ return 0.0; } return (_income / _duration) *ADJ_FACTOR; } 将条件反转使异常情况先退出，让正常流程维持在主干流程，可以让代码结构更加清晰。 优化八：策略模式+工厂方法消除if-else策略类定义：一个策略接口和一组实现这个接口的策略类。 特点：客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。 假设需求：根据不同勋章类型，处理相对应的勋章服务 优化前 String medalType = \"guest\"; if (\"guest\".equals(medalType)) { System.out.println(\"嘉宾勋章\"); } else if (\"vip\".equals(medalType)) { System.out.println(\"会员勋章\"); } else if (\"guard\".equals(medalType)) { System.out.println(\"展示守护勋章\"); } 优化后首先，我们把每个条件逻辑代码块，抽象成一个公共的接口，可以得出以下代码： //勋章接口 public interface IMedalService { void showMedal(); } 我们根据每个逻辑条件，定义相对应的策略实现类，可得以下代码： //守护勋章策略实现类 public class GuardMedalServiceImpl implements IMedalService { @Override public void showMedal() { System.out.println(\"展示守护勋章\"); } } //嘉宾勋章策略实现类 public class GuestMedalServiceImpl implements IMedalService { @Override public void showMedal() { System.out.println(\"嘉宾勋章\"); } } //VIP勋章策略实现类 public class VipMedalServiceImpl implements IMedalService { @Override public void showMedal() { System.out.println(\"会员勋章\"); } } 接下来，我们再定义策略工厂类，用来管理这些勋章实现策略类，如下： //勋章服务工产类 public class MedalServicesFactory { private static final Map&lt;String, IMedalService&gt; map = new HashMap&lt;&gt;(); static { map.put(\"guard\", new GuardMedalServiceImpl()); map.put(\"vip\", new VipMedalServiceImpl()); map.put(\"guest\", new GuestMedalServiceImpl()); } public static IMedalService getMedalService(String medalType) { return map.get(medalType); } } 使用了策略+工厂模式之后，代码变得简洁多了，如下： public class Test { public static void main(String[] args) { String medalType = \"guest\"; IMedalService medalService = MedalServicesFactory.getMedalService(medalType); medalService.showMedal(); } }","categories":[{"name":"代码质量","slug":"代码质量","permalink":"https://winniekun.github.io/categories/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"}],"tags":[{"name":"if-else优化","slug":"if-else优化","permalink":"https://winniekun.github.io/tags/if-else%E4%BC%98%E5%8C%96/"}]},{"title":"lombok介绍","slug":"工具/lombok-introduce","date":"2020-10-02T12:08:21.000Z","updated":"2020-10-04T14:34:01.269Z","comments":true,"path":"lombok-introduce/","link":"","permalink":"https://winniekun.github.io/lombok-introduce/","excerpt":"Lombok使用 Lombok是一款好用顺手的工具，值得去好好去熟练使用和深究。Lombok是一种Java™实用工具，可用来帮助开发人员消除Java的冗长代码，尤其是对于简单的Java对象（POJO）。它通过注释实现这一目的。通过在开发环境中实现Lombok，开发人员可以节省构建诸如hashCode()和equals()这样的方法以及以往用来分类各种accessor和mutator的大量时间。","text":"Lombok使用 Lombok是一款好用顺手的工具，值得去好好去熟练使用和深究。Lombok是一种Java™实用工具，可用来帮助开发人员消除Java的冗长代码，尤其是对于简单的Java对象（POJO）。它通过注释实现这一目的。通过在开发环境中实现Lombok，开发人员可以节省构建诸如hashCode()和equals()这样的方法以及以往用来分类各种accessor和mutator的大量时间。 使用步骤 导入Maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;${lomok.version}&lt;/version&gt; &lt;/dependency&gt; 在IDE中安装对应的插件（lombok plugin） 常用注解详解简化代码，增加可读性@Getter&amp;@Setter@Getter @Setter public class Person { private Integer id; private String name; private String age; } 通过@Getter和@Setter之后，其就类似于如下的代码： public class Persons { private Integer id; private String name; private String age; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } } @Data其等同于如下的几个注解，使用的频率最高 @Getter/@Setter @ToString @EqualsAndHashCode @RequiredArgsConstructor @Buider自动生成流式set写法，能够快速的设定Object值。但是需要注意的是，虽然该方法很好，但是因为大多数的框架都使用到了set方法进进行注入，所以在开发的时候，我们一般是将@Builder和@Data一起使用。 // 方便查看输出对象 @ToString @Builder public class Person { private Integer id; private String name; private String age; public static void main(String[] args) { Person person = Person.builder().age(\"11\").id(1).name(\"wkk\").build(); System.out.println(person); } } //Builder的使用等同于如下 public static class PersonBuilder { private Integer id; private String name; private String age; PersonBuilder() { } public Person.PersonBuilder id(Integer id) { this.id = id; return this; } public Person.PersonBuilder name(String name) { this.name = name; return this; } public Person.PersonBuilder age(String age) { this.age = age; return this; } public Person build() { return new Person(this.id, this.name, this.age); } public String toString() { return \"Person.PersonBuilder(id=\" + this.id + \", name=\" + this.name + \", age=\" + this.age + \")\"; } } 日志使用一般情况下，我们做日志处理，都会先生成一个Logger的静态常量，使用@Slf4j之后，我们就可以完全不用new一个该常量了。 public class Person{ private static final Logger logger = LoggerFactory.getLogger(Person.class); private Integer id; private String name; private String age; public static void main(String[] args){ logger.info(\"logger: {}\", \"aaaa\"); } } // Lombok实现 @Slf4j public class Person { private Integer id; private String name; private String age; public static void main(String[] args) { System.out.println(\"fsda\"); log.info(\"Person: {}\", \"fdsa\"); } } 流式对象的关闭","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://winniekun.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"2020实习前的总结","slug":"碎碎念/before-internship","date":"2020-09-06T11:11:50.000Z","updated":"2020-10-01T15:12:36.296Z","comments":true,"path":"before-internship/","link":"","permalink":"https://winniekun.github.io/before-internship/","excerpt":"前言2020年2月底，在自己确定要找实习的时候，开始和女朋友哭诉所害怕自己找不到实习，没有公司要我，我太菜了等等等。经过耗时半年的时间，终于确定下来的了实习地点和实习公司，感觉整个过程还挺好玩儿的，所以就记录下来吧。","text":"前言2020年2月底，在自己确定要找实习的时候，开始和女朋友哭诉所害怕自己找不到实习，没有公司要我，我太菜了等等等。经过耗时半年的时间，终于确定下来的了实习地点和实习公司，感觉整个过程还挺好玩儿的，所以就记录下来吧。 现在挺尴尬的，本来想着再实习之前把文章写好，但是后面有别的事情就没有来得及写，最后想写的时候，发现hexo出问题了。所以就一直拖到了国庆假期，抽了点时间改改，终于又能重新写blog了。 目前已经在NIO实习两周了，第一周还好，就是看看公司文档，然后按照需求完善了一个接口，后面老师安排我看几个节点的代码，然后修复sonarQube上检测出的Bug。第二周就开始忙碌了，刚好排期，分配了我还挺多的任务，希望能做的又好又棒。 放张我所在楼的前台，感觉还挺好看的（假期前一天走的晚，刚好没有多少人，顺手拍的😄）。 NIO 国庆假期人是真的多，虹桥车站爆满。不知道为什么，脑子里竟然是釜山行的画面… 虹桥火车站 总结面试真的并不可怕，大不了就是给面试官感觉你不行，在面试官面前尬聊一个小时，其他的真的没什么。面多了就感觉还挺好玩儿的（就是每次面试前还是会紧张好长时间）。面试期间，感觉有一些问题并没有标准的答案，所以可以使用和面试官讨论的形式阐述自己的观点。最后就是记得面试后做好复盘，这样不仅可以帮助自己查缺补漏，还能让自己能够更好的梳理知识点。","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"死磕图","slug":"LeetCode/stick-to-graph","date":"2020-08-20T00:59:56.000Z","updated":"2020-08-30T04:50:22.250Z","comments":true,"path":"stick-to-graph/","link":"","permalink":"https://winniekun.github.io/stick-to-graph/","excerpt":"前言LeetCode死磕系列九： 图 说实话图目前遇到的题目类型不多, 再加上今年图论课程上的一些算法, 只能说算是覆盖了图相关的一丢丢的内容😄 最近LeetCode每日一题, 遇到了较多的图遍历(深度遍历, 广度遍历)问题, 感觉是有迹可循的, 所以做一下整理吧.","text":"前言LeetCode死磕系列九： 图 说实话图目前遇到的题目类型不多, 再加上今年图论课程上的一些算法, 只能说算是覆盖了图相关的一丢丢的内容😄 最近LeetCode每日一题, 遇到了较多的图遍历(深度遍历, 广度遍历)问题, 感觉是有迹可循的, 所以做一下整理吧. 题目 130. 被围绕的区域 133. 克隆图 733. 图像渲染 529. 扫雷游戏 题解","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"dfs","slug":"dfs","permalink":"https://winniekun.github.io/tags/dfs/"},{"name":"bfs","slug":"bfs","permalink":"https://winniekun.github.io/tags/bfs/"}]},{"title":"ArrayDeque-analysis","slug":"源码/JDK/queue/ArrayDeque-analysis","date":"2020-07-08T07:27:56.000Z","updated":"2020-08-30T04:50:22.257Z","comments":true,"path":"ArrayDeque-analysis/","link":"","permalink":"https://winniekun.github.io/ArrayDeque-analysis/","excerpt":"依赖","text":"依赖 ArrayDeque依赖 实现了Deque接口, Serializable接口, Cloneable接口, 继承了AbstractCollection类, 同时可以看到的是Deque接口继承自Queue接口, 它是对Queue的一种增强. Deque 接口的实现类可以被当作 FIFO（队列）使用，也可以当作 LIFO（栈）来使用 Queue和DequeDeque是对Queue的增强, 我们可以先看下Queue的具体设计: public interface Queue&lt;E&gt; extends Collection&lt;E&gt; { // 添加 boolean add(E e); // 添加 不同的实现使用的添加方式不同 // list使用add // queue使用offer boolean offer(E e); // 删除 E remove(); // 弹出 E poll(); E element(); // 获取头部数据 E peek(); } Deque的设计 public interface Deque&lt;E&gt; extends Queue&lt;E&gt; { void addFirst(E e); void addLast(E e); boolean offerFirst(E e); boolean offerLast(E e); E removeFirst(); E removeLast(); E pollFirst(); E pollLast(); E getFirst(); E getLast(); E peekFirst(); E peekLast(); boolean removeFirstOccurrence(Object o); boolean removeLastOccurrence(Object o); boolean add(E e); boolean offer(E e); E remove(); E poll(); E element(); E peek(); // *** 栈 ***// void push(E e); E pop(); // *** Collection中的方法 *** boolean remove(Object o); boolean contains(Object o); public int size(); Iterator&lt;E&gt; iterator(); Iterator&lt;E&gt; descendingIterator(); } Deque中新增了以下几类方法： *First，表示从队列头操作元素； *Last，表示从队列尾操作元素； *push(e)，pop()，以栈的方式操作元素的方法； 其抽象的样子 字段&amp;属性// 底层使用数组存储元素 transient Object[] elements; // non-private to simplify nested class access // 队列头位置 transient int head; // 队列尾位置 transient int tail; // 最小初始容量 private static final int MIN_INITIAL_CAPACITY = 8; 使用数组存储元素, 默认的最小初始化容量为8, 同时有头尾两个标记位 构造函数// 默认构造函数数组容量为16 public ArrayDeque() { elements = new Object[16]; } // 指定初始容量构造函数 public ArrayDeque(int numElements) { allocateElements(numElements); } // 将集合c中的元素初始化到数组中 public ArrayDeque(Collection&lt;? extends E&gt; c) { allocateElements(c.size()); addAll(c); } // 初始化数组 private void allocateElements(int numElements) { elements = new Object[calculateSize(numElements)]; } // 和HashMap的类似, 求大于且最接近numelemnets的2的幂次且不小于8 private static int calculateSize(int numElements) { int initialCapacity = MIN_INITIAL_CAPACITY; if (numElements &gt;= initialCapacity) { initialCapacity = numElements; initialCapacity |= (initialCapacity &gt;&gt;&gt; 1); initialCapacity |= (initialCapacity &gt;&gt;&gt; 2); initialCapacity |= (initialCapacity &gt;&gt;&gt; 4); initialCapacity |= (initialCapacity &gt;&gt;&gt; 8); initialCapacity |= (initialCapacity &gt;&gt;&gt; 16); initialCapacity++; if (initialCapacity &lt; 0) // Too many elements, must back off initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements } return initialCapacity; } 通过构造方法，我们知道默认初始容量是16，最小容量是8。 入队头部入队public void addFirst(E e) { if (e == null) throw new NullPointerException(); // 将head指针减1并与数组长度减1取模 // 这是为了防止数组到头了边界溢出 // 如果到头了就从尾再向前 // 相当于循环利用数组 elements[head = (head - 1) &amp; (elements.length - 1)] = e; // 如果头尾挨在一起了，就扩容 // 扩容规则也很简单，直接两倍 if (head == tail) doubleCapacity(); } 扩容// 扩容为两倍 private void doubleCapacity() { assert head == tail; int p = head; int n = elements.length; int r = n - p; // number of elements to the right of p int newCapacity = n &lt;&lt; 1; if (newCapacity &lt; 0) throw new IllegalStateException(\"Sorry, deque too big\"); Object[] a = new Object[newCapacity]; // 将旧数组head之后的元素拷贝到新数组中 System.arraycopy(elements, p, a, 0, r); // 将旧数组下标0到head之间的元素拷贝到新数组中 System.arraycopy(elements, 0, a, r, p); // 赋值为新数组 elements = a; // head指向0，tail指向旧数组长度表示的位置 head = 0; tail = n; } 可视化 尾部入队public void addLast(E e) { if (e == null) throw new NullPointerException(); // 在尾指针的位置放入元素 // 可以看到tail指针指向的是队列最后一个元素的下一个位置 elements[tail] = e; // tail指针加1，如果到数组尾了就从头开始 if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity(); } 入队有两种方式，从队列头或者从队列尾； 如果容量不够了，直接扩大为两倍； 通过取模的方式让头尾指针在数组范围内循环； x &amp; (len - 1) = x % len，使用&amp;的方式更快(len=2的幂次等式成立)； 出队头部出队public E pollFirst() { int h = head; @SuppressWarnings(\"unchecked\") // 取队列头元素 E result = (E) elements[h]; // Element is null if deque empty if (result == null) return null; // 队头元素为空 elements[h] = null; // Must null out slot // 队头右移 head = (h + 1) &amp; (elements.length - 1); return result; } 尾部出队public E pollLast() { // 因为队尾标记的是最后一个为不为空的元素的后一位 int t = (tail - 1) &amp; (elements.length - 1); @SuppressWarnings(\"unchecked\") // 获取队尾元素 E result = (E) elements[t]; if (result == null) return null; // 队尾设置为空 elements[t] = null; // 重新设置tail tail = t; return result; } 以下是一次ArrayDeque的头部入队, 尾部出队的可视化操作 ArrayDeque&lt;Integer&gt; arrayDeque = new ArrayDeque&lt;&gt;(6); ArrayDequeUtil.getField(arrayDeque); for (int i = 1; i &lt;=10; i++) { arrayDeque.addFirst(i); ArrayDequeUtil.getField(arrayDeque); } arrayDeque.pollLast(); ArrayDequeUtil.getField(arrayDeque); 栈的实现入栈以下是Deque实现入栈的操作 public void push(E e) { addFirst(e); } public void addFirst(E e) { if (e == null) throw new NullPointerException(); elements[head = (head - 1) &amp; (elements.length - 1)] = e; if (head == tail) doubleCapacity(); } 最后, 其依赖的还是addFirst(), 也就是从头部添加元素 出栈以下是Deque实现出栈的操作 public E pop() { return removeFirst(); } public E removeFirst() { E x = pollFirst(); if (x == null) throw new NoSuchElementException(); return x; } 最后, 其依赖的还是pollFirst(), 也就是从头部删除元素, 也就是后入的元素先出 说白了实现栈的方式就是仅仅只操作队列头即可 总结&amp;面试小问题 什么是双端队列？ 双端队列是一种特殊的队列，它的两端都可以进出元素，故而得名双端队列 ArrayDeque是怎么实现双端队列的？ 底层为数组, 然后通过取模的方式构造一个循环数组, 出队入队是通过头尾指针循环利用数组实现的. ArrayDeque是线程安全的吗？ 不是线程安全 ArrayDeque的扩容机制？ ArrayDeque在容量不足时(head == tail)会出发扩容, 扩容为原先的两倍, 具体的扩容机制, 可以看上述可视化过程","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"Queue","slug":"Queue","permalink":"https://winniekun.github.io/tags/Queue/"}]},{"title":"trie","slug":"算法/trie","date":"2020-07-07T11:58:58.000Z","updated":"2020-08-30T04:50:22.259Z","comments":true,"path":"trie/","link":"","permalink":"https://winniekun.github.io/trie/","excerpt":"前缀树原理","text":"前缀树原理 Trie, 由Edward Fredkin提出, 来自英文单词retrieval, Trie也称为前缀树, 用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。 对于字符Trie而言, 如果使用二叉树那样的两个分支明显是不够的. 举个例子, 英语中一共有26个字母, 每个字母还区分大小写, 如果忽略大小写的话, 那么可以使用简单的限定分支(子树)个数为26. 如下图所示为一个字符串Trie Trie 一个保存了8个键的trie结构，”A”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn 这只是针对于不区分大小写的英语字母, 若是区分大小写, 同时还有标点等, 那么分之的数量会更加的庞大且不确定, 这是我们可以使用散列表来解决动态数量的分支. Trie的出现, 解决了散列表无法解决的字符串数集问题: 找到具有同一前缀的全部键值。 按词典序枚举字符串的数据集。 同时Trie由散列表的另一方面是: 随着数据量的增大, 散列表的查找效率可能会降低到$O(n)$, 与哈希表相比, Trie 树在存储多个具有相同前缀的键时可以使用较少的空间. 此时Trie只需要$O(m)$的时间复杂度，其中$m$为键长。 前缀树的实现Trie 树是一个有根的树，其结点具有以下字段：。 最多$R$个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母, 简单起见, 假定$R$为 26, 小写英语字母数量 布尔字段, 以指定节点是对应键的结尾还是只是键前缀. 节点构造在构造之前, 先展示包含三个单词”sea”,”sells”,”she”的 Trie的样子, 加深理解 class TrieNode { private TrieNode[] links; private boolean isEnd; private final int R = 26; public TrieNode() { links = new TrieNode[R]; } public boolean containsKey(char ch) { return links[ch - 'a'] != null; } public void put(char ch, TrieNode node) { links[ch - 'a'] = node; } public TrieNode get(char ch) { return links[ch - 'a']; } public void setEnd() { isEnd = true; } public boolean isEnd() { return isEnd; } } 插入/** * 插入 */ public void insert(String word) { // 从根节点开始, 根节点为空 TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) { char current = word.charAt(i); if (!node.containsKey(current)) { node.put(current, new TrieNode()); } node = node.get(current); } node.setEnd(); } 查找每个键在 trie 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始，。检查当前节点中与键字符对应的链接。有两种情况： 存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。 不存在链接。若已无键字符，且当前结点标记为 isEnd，则返回 true。否则有两种可能，均返回 false : 还有键字符剩余，但无法跟随 Trie 树的键路径，找不到键。 没有键字符剩余，但当前结点没有标记为 isEnd。也就是说，待查找键只是Trie树中另一个键的前缀。 private TrieNode searchPrefix(String word) { TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) { char current = word.charAt(i); if (node.containsKey(current)) { node = node.get(current); } else { return null; } } return node; } public boolean search(String word) { TrieNode node = searchPrefix(word); return node != null &amp;&amp; node.isEnd(); } /** * 是否存在输入前缀的字符 */ public boolean startsWith(String prefix) { TrieNode node = searchPrefix(prefix); return node != null; } 整体class Trie { private TrieNode root; /** * 初始化 */ public Trie() { root = new TrieNode(); } /** * 插入 */ public void insert(String word) { TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) { char current = word.charAt(i); if (!node.containsKey(current)) { node.put(current, new TrieNode()); } node = node.get(current); } node.setEnd(); } /** * 删除 */ public boolean search(String word) { TrieNode node = searchPrefix(word); return node != null &amp;&amp; node.isEnd(); } private TrieNode searchPrefix(String word) { TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) { char current = word.charAt(i); if (node.containsKey(current)) { node = node.get(current); } else { return null; } } return node; } /** * 是否存在输入前缀的字符 */ public boolean startsWith(String prefix) { TrieNode node = searchPrefix(prefix); return node != null; } class TrieNode { private TrieNode[] links; private boolean isEnd; private final int R = 26; public TrieNode() { links = new TrieNode[R]; } public boolean containsKey(char ch) { return links[ch - 'a'] != null; } public void put(char ch, TrieNode node) { links[ch - 'a'] = node; } public TrieNode get(char ch) { return links[ch - 'a']; } public void setEnd() { isEnd = true; } public boolean isEnd() { return isEnd; } } } 敏感词过滤的前缀树实现因为敏感词除了英文字母之外, 还有其他的字符, 所以使用散列表来实现, public class Trie{ // 根节点 private TrieNode rootNode = new TrieNode(); // 将一个敏感词添加到前缀树中 private void addKeyword(String keyword) { TrieNode tempNode = rootNode; for (int i = 0; i &lt; keyword.length(); i++) { char c = keyword.charAt(i); TrieNode subNode = tempNode.getSubNode(c); if(!tempNode.containsKey(c)){ tempNode.addSubNode(c, new TrieNode()); } tempNode = tempNode.getSubNode(c); } tempNode.setKeywordEnd(true); } // 前缀树 private class TrieNode { // 关键词结束标识 private boolean isKeywordEnd = false; // 子节点(key是下级字符,value是下级节点) private Map&lt;Character, TrieNode&gt; subNodes = new HashMap&lt;&gt;(); public boolean isKeywordEnd() { return isKeywordEnd; } public void setKeywordEnd(boolean keywordEnd) { isKeywordEnd = keywordEnd; } // 添加子节点 public void addSubNode(Character c, TrieNode node) { subNodes.put(c, node); } // 获取子节点 public TrieNode getSubNode(Character c) { return subNodes.get(c); } } } 实例讲解最终实现public class SensitiveFilter { // 替换符 private static final String REPLACEMENT = \"***\"; // 根节点 private TrieNode rootNode = new TrieNode(); // 加载敏感字符, 只加载一次 @PostConstruct public void init() { try ( InputStream is = this.getClass().getClassLoader().getResourceAsStream(\"sensitive-word.txt\"); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); ) { String keyword; while ((keyword = reader.readLine()) != null) { // 添加到前缀树 this.addKeyword(keyword); } } catch (IOException e) { logger.error(\"加载敏感词文件失败: \" + e.getMessage()); } } // 将一个敏感词添加到前缀树中 private void addKeyword(String keyword) { TrieNode tempNode = rootNode; for (int i = 0; i &lt; keyword.length(); i++) { char c = keyword.charAt(i); TrieNode subNode = tempNode.getSubNode(c); if(!tempNode.containsKey(c)){ tempNode.addSubNode(c, new TrieNode()); } tempNode = tempNode.getSubNode(c); } tempNode.setKeywordEnd(true); } /** * 过滤敏感词 * * @param text 待过滤的文本 * @return 过滤后的文本 */ public String filter(String text) { if (StringUtils.isBlank(text)) { return null; } // 指针1 TrieNode tempNode = rootNode; // 指针2 int begin = 0; // 指针3 int position = 0; // 结果 StringBuilder sb = new StringBuilder(); while (position &lt; text.length()) { char c = text.charAt(position); // 跳过符号 if (isSymbol(c)) { // 若指针1处于根节点,将此符号计入结果,让指针2向下走一步 if (tempNode == rootNode) { sb.append(c); begin++; } // 无论符号在开头或中间,指针3都向下走一步 position++; continue; } // 检查下级节点 tempNode = tempNode.getSubNode(c); if (tempNode == null) { // 以begin开头的字符串不是敏感词 sb.append(text.charAt(begin)); // 进入下一个位置 position = ++begin; // 重新指向根节点 tempNode = rootNode; } else if (tempNode.isKeywordEnd()) { // 发现敏感词,将begin~position字符串替换掉 sb.append(REPLACEMENT); // 进入下一个位置 begin = ++position; // 重新指向根节点 tempNode = rootNode; } else { // 检查下一个字符 position++; } } // 将最后一批字符计入结果 sb.append(text.substring(begin)); return sb.toString(); } // 判断是否为符号 private boolean isSymbol(Character c) { // 0x2E80~0x9FFF 是东亚文字范围 return !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (c &lt; 0x2E80 || c &gt; 0x9FFF); } // 前缀树 private class TrieNode { // 关键词结束标识 private boolean isKeywordEnd = false; // 子节点(key是下级字符,value是下级节点) private Map&lt;Character, TrieNode&gt; subNodes = new HashMap&lt;&gt;(); public boolean isKeywordEnd() { return isKeywordEnd; } public void setKeywordEnd(boolean keywordEnd) { isKeywordEnd = keywordEnd; } // 添加子节点 public void addSubNode(Character c, TrieNode node) { subNodes.put(c, node); } // 获取子节点 public TrieNode getSubNode(Character c) { return subNodes.get(c); } public boolean containsKey(Character c){ return subNodes.containsKey(c); } } } References 算法新解 实现 Trie (前缀树) 问答社区-敏感词过滤 基于前缀树图文详解敏感词过滤 Trie Tree 的实现 (适合初学者) 面试被虐 说说游戏中的敏感词过滤是如何实现的？","categories":[{"name":"算法","slug":"算法","permalink":"https://winniekun.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"trie","slug":"trie","permalink":"https://winniekun.github.io/tags/trie/"}]},{"title":"Cookie和Session","slug":"网络/Cookie-Session","date":"2020-07-06T01:36:34.000Z","updated":"2020-08-30T04:50:22.262Z","comments":true,"path":"Cookie-Session/","link":"","permalink":"https://winniekun.github.io/Cookie-Session/","excerpt":"前言","text":"前言 Session和Cookie的作用是为了保持访问用户与后端服务器的交互状态 CookieCookie的作用通俗来讲就是当一个用户通过HTTP请求访问服务器的时候, 服务器将一些Key/Value的键值对返回给客户端, 并且还可以给这些数据添加一些限制条件: 存活时间, 生效范围等, 在符合限制条件的情况下, 该用户再次发起请求, 数据将会被完整的返回给服务器. @RequestMapping(value = \"/cookie/set\", method = RequestMethod.GET) @ResponseBody public String setCookie(HttpServletResponse response){ // 生成cookie Cookie cookie = new Cookie(\"wkk\", CommunityUtil.generateUUID()); // 设置生效范围 cookie.setPath(\"/community/alpha\"); // 设置cookie的生效时间（默认存在内存中， 设置时间之后会存在硬盘中） cookie.setMaxAge(10); // 发送给客户端 response.addCookie(cookie); return \"set cookie\"; } Cookie W3C在设计Cookie的时候, 实际上考虑的是为了记录用户在一段时间的web应用的行为路径. 因为HTTP是无状态协议, 当用户访问完一次请求结束之后, 后端服务器无法知道下一次来访的是否还是上次访问的用户. 使用Cookies带来的优势: 短时间内, 如果与用户相关的数据频繁被访问, 可以为该数据添加缓存, 提高数据的访问性能 若是同一客户端发送的请求, 每次发出的请求都会包含第一次访问服务器之后, 服务器设置的信息, 这样服务器就可以根据Cookie来划分用户. Session虽然Cookie的出现可以让服务器识别每个客户的请求, 但是每次客户的访问都必须返回这些Cookie, 如果Cookie很多, 无疑是增加了客户端和服务端之间数据的传输量, 而Session的存在就是为了解决这个问题. Session 同一个客户端每次和服务端交互的时候, 不需要每次都传回所有的Cookie值, 而只要传回一个ID, 这个ID是客户端第一次访问服务器时生成的, 而且每个客户端是唯一的, 这样每个客户端就有了唯一的ID, 客户端只要返回ID即可, 这个ID就是名为JSSIONID的一个Cookie 安全问题虽然Cookie和Session都可以跟踪客户端的访问记录, 但是工作方式不同, Cookie是通过把所有要保存的数据通过HTTP的头部从客户端传递到服务度端, 然后又从服务端传到客户端, 所有的数据都存储到客户端的浏览器中, 这些Cookie数据可以直接访问到, 设置可以修改, 所以安全性受到很大的挑战 相比而言, Session的安全性高很多, 因为Session的数据存储在服务器里, 只是通过Cookie传递一个SessionID而已, 所以Session更适合存储用户隐私和重要的数据","categories":[{"name":"网络","slug":"网络","permalink":"https://winniekun.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"http","slug":"http","permalink":"https://winniekun.github.io/tags/http/"}]},{"title":"单例模式","slug":"设计模式/SingletonPattern","date":"2020-07-02T13:35:20.000Z","updated":"2021-03-31T11:22:40.128Z","comments":true,"path":"SingletonPattern/","link":"","permalink":"https://winniekun.github.io/SingletonPattern/","excerpt":"前言","text":"前言 “你知道茴香豆的‘茴’字有几种写法吗？” 纠结单例模式有几种写法有用吗? 有点用, 面试中经常选择其中一种或几种写法作为话头, 以此展开考察面试者的code style 以及其他相关的知识点. 但是过于纠结这些写法, 反而类似于”茴”字有几个写法… 思想, 思想, 思想. 重要事情说三遍 类加载顺序类加载(classLoader)机制一般遵从下面的加载顺序 如果类还没有被加载： 先执行父类的静态代码块和静态变量初始化，静态代码块和静态变量的执行顺序跟代码中出现的顺序有关。 执行子类的静态代码块和静态变量初始化。 执行父类的实例变量初始化 执行父类的构造函数 执行子类的实例变量初始化 执行子类的构造函数 同时，加载类的过程是线程私有的，别的线程无法进入。 如果类已经被加载： 静态代码块和静态变量不在重复执行，再创建类对象时，只执行与实例相关的变量初始化和构造方法。 static关键字一个类中如果有成员变量或者方法被static关键字修饰，那么该成员变量或方法将独立于该类的任何对象。它不依赖类特定的实例，被类的所有实例共享，只要这个类被加载，该成员变量或方法就可以通过类名去进行访问，它的作用用一句话来描述就是，不用创建对象就可以调用方法或者变量，这简直就是为单例模式的代码实现量身打造的。 饿汉模式public class Singleton { private static Singleton instance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return instance; } } 在类加载的时候就完成了实例化, 避免了多线程的同步问题. 当然缺点也是有的, 因为类加载时就实例化了, 没有达到Lazy Loading (懒加载) 的效果, 如果该实例没被使用, 内存就浪费了. 懒汉模式顾名思义, 就是初始化的时候, 不会主动的去创建实例, 而是在调用getInstance()的时候, 才会被动的去创建. public class Singleton { private static Singleton instance = null; private LazySingleton(){ } public static Singleton getInstance(){ if(instance == null){ instance = new Singleton(); } return instance; } } 在单线程的情况下, 没有任何问题, 但是因为其为线程不安全的, 在多线程的情况下, 譬如两个线程A, B都执行了getInstance()方法, 并且都执行到了第9行代码, 然后A因为其他原因, 休眠了一会儿, 待B创建了实例对象之后, A有创建了一个, 显然, 这是不符合单利模式的 解决1在getInstance()方法内部添加同步代码块, 或者直接将该方法改为同步方法 public class Singleton { private static Singleton instance = null; private LazySingleton(){ } public synchronized static Singleton getInstance(){ if(instance == null){ instance = new Singleton(); } return instance; } } 好处是写起来简单, 且绝对线程安全; 坏处是并发性能极差, 事实上完全退化到了串行. 单例只需要初始化一次, 但就算初始化以后, synchronized的锁也无法避开, 从而getInstance()完全变成了串行操作. 性能不敏感的场景建议使用。 解决2也就是臭名昭著的双重检验方法 public class Singleton { private static Singleton instance; // 双重锁检验 public static Singleton getInstance() { if (instance == null) { // 第7行 synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); // 第10行 } } } return instance; } } 由于指令重排序的问题, 可能会被重排序为如下: instance = new Singleton(); // 第10行 // 可以分解为以下三个步骤 1 memory=allocate();// 分配内存 相当于c的malloc 2 ctorInstanc(memory) //初始化对象 3 s=memory //设置s指向刚分配的地址 // 上述三个步骤可能会被重排序为 1-3-2，也就是： 1 memory=allocate();// 分配内存 相当于c的malloc 3 s=memory //设置s指向刚分配的地址 2 ctorInstanc(memory) //初始化对象 而一旦假设发生了这样的重排序，比如线程A在第10行执行了步骤1和步骤3，但是步骤2还没有执行完。这个时候另一个线程B执行到了第7行，它会判定instance不为空，然后直接返回了一个未初始化完成的instance！ 解决3public class Singleton { private static volatile Singleton instance; // 双重锁检验 public static Singleton getInstance() { if (instance == null) { // 第7行 synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); // 第10行 } } } return instance; } } 这样就保证了线程的安全 枚举模式// 枚举 // ThreadSafe public enum Singleton4 { SINGLETON; } 使用javap进行反编译得到如下结果 // 枚举 // ThreadSafe public class Singleton4 extends Enum&lt;Singleton4&gt; { ... public static final Singleton4 SINGLETON = new Singleton4(); ... } 可以看到, 其本质也还是饿汉模式 静态内部类实现/** * JVM在类的初始化阶段（class被加在后，且被线程使用之前）会执行类的初始化 * 执行类的初始化期间，JVM会去获取一个锁，锁会同步多个线程对同一个类的初始化 * @author weikunkun * @since 2021/3/20 */ public class InstanceFactory { private static class InstanceHolder { public static Object object = new Object(); } public static Object getInstance() { return InstanceHolder.object; } }","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://winniekun.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"创建型模式","slug":"创建型模式","permalink":"https://winniekun.github.io/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java中异常类体系","slug":"Java基础/面试36讲/Throwable","date":"2020-07-02T11:57:04.000Z","updated":"2021-07-21T02:46:30.041Z","comments":true,"path":"Throwable/","link":"","permalink":"https://winniekun.github.io/Throwable/","excerpt":"","text":"解答Exception和Error均继承自Trowable, 如下图所示: 依赖图 Throwablepublic Throwable() {...} public Throwable(String message) {...} public Throwable(String message, Throwable cause) {...} public Throwable(Throwable cause) {...} ... 通过构造函数，可以看出，核心的参数为两个： message 表示异常信息 cause 造成异常的异常（套娃行为！！！） 上层的异常通过底层的异常触发一层一层的抛上来 Exception、Error在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型, Exception和Error代表了对不同异常情况的分类 Exception: 程序正常运行的情况下, 可以预料的意外情况, 可以并且应该被捕获, 之后进行处理, 最后仍能程序继续正常运行 又可以被细分为可检查异常和不可检查异常 可检查异常: 编译期间出现的异常, 必须进行捕获处理 不可检查异常: 运行期间出现的异常, 譬如ArrayIndexOutOfBoundsException, NullPointerException之类 Error: 正常情况下, 不大可能出现的异常, 绝大多数Error的出现会导致程序崩溃, 不便于也不需要捕获, 譬如OutOfMemoryError之类, 都是Error的子类 粗略了解了上述的Exception和Error的关系和概述之后，再来个详细的图，加深理解 Java 异常大家族 有这么多的异常类型，主要还是为了能够更加准确的捕获异常，增加代码的可读性、可维护性。同时可以自定义异常，更加精确阐述异常原因。通常是继承Exception或者Exception中的某个子类。 异常处理try-catch最直接的解决方式就是出现异常，解决异常。 try { // doSomething(); } catch (Exception e) { // 1. 记录异常 log.error(\"something error\"); // 2. 执行异常的业务逻辑 doExcepptionHandler(); // 3. 也可以执行完异常逻辑之后，再抛出异常 throw e } finallytry { } catch (Exception e) { } finally { } 无论是否发生异常，都会执行。 也可以这样： try { } finally { } 不捕获出现的异常，异常继续向上传递。 总结对于异常的处理，总有一层代码需要为异常负责，可能是知道如何处理异常的代码，可能是面对用户的代码，可能是主程序。 有了异常机制后，程序的正确逻辑和异常逻辑可以相分离，异常情况可以集中处理，异常还可以向上传递，不需要每层方法都需要处理。","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://winniekun.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"面试36讲","slug":"面试36讲","permalink":"https://winniekun.github.io/tags/%E9%9D%A2%E8%AF%9536%E8%AE%B2/"}]},{"title":"Spring Bean的生命周期和作用域","slug":"Java基础/面试36讲/spring-bean-knowledge-point","date":"2020-07-01T12:38:31.000Z","updated":"2021-04-05T15:26:25.201Z","comments":true,"path":"spring-bean-knowledge-point/","link":"","permalink":"https://winniekun.github.io/spring-bean-knowledge-point/","excerpt":"Spring Bean的生命周期","text":"Spring Bean的生命周期 Spring的生命周期从总体上可以分为创建和销毁两个部分. 实例化Bean对象 设置Bean属性 若是通过各种Aware接口声明了依赖关系,则会注入 Bean 对容器基础设施层面的依赖 如果bean实现了BeanNameAware接口, 则将BeanId通过setBeanName注入Spring中. 如果bean实现了BeanFactoryAware接口, 则将BeanFactory容器实例通过setBeanFactory注入Spring中 如果bean实现了ApplicationContextAware接口, 则将bean所在的应用的上下文通过setApplicationContext注入Spring中 如果bean实现了BeanPostProcessor接口, 则调用前置初始化方法, postProcessorBeforeInitialization() 如果bean实现了InitializingBean接口, 则调用afterPropertiesSet()方法, 调用自身的初始化方法 如果bean实现了BeanPostProcessor接口, 则调用后置初始化方法, postProcessorAfterInitialization() bean已经准备就绪, 可以使用, 一直驻留在应用上下文中, 直到应用上下文被销毁 如果bean实现了DisposableBean接口, 则调用destroy()方法 调用自身的destroy方法 Spring Bean 的作用域Spring Bean 有五个作用域，其中最基础的为加粗的两种 singleton Spring的默认作用于, 为每个IOC容器创建唯一的Bean实例 prototype 针对每个getBean请求, 都会创建一个Bean实例 request 每次Http请求都会创建新的Bean, 仅适用于WebApplicationContext session 一个HttpSession定义一个Bean. 该作用于仅适用于WebApplicationContext globalSession 同一个全局Http Session 定义一个Bean. 该作用域同样仅适用于WebApplicationContext","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://winniekun.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"面试36讲","slug":"面试36讲","permalink":"https://winniekun.github.io/tags/%E9%9D%A2%E8%AF%9536%E8%AE%B2/"}]},{"title":"WeakHashMap源码解读","slug":"源码/JDK/map/weakhashmap-analysis","date":"2020-06-20T10:42:30.000Z","updated":"2020-08-30T04:50:22.256Z","comments":true,"path":"weakhashmap-analysis/","link":"","permalink":"https://winniekun.github.io/weakhashmap-analysis/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"LinkedHashMap源码解读","slug":"源码/JDK/map/linkedhashmap-analysis","date":"2020-06-20T10:38:04.000Z","updated":"2021-05-04T14:46:52.357Z","comments":true,"path":"linkedhashmap-analysis/","link":"","permalink":"https://winniekun.github.io/linkedhashmap-analysis/","excerpt":"LinkedHashMap源码解读","text":"LinkedHashMap源码解读 依赖 LinkedHashMap依赖 LinkedHashMap继承HashMap, 拥有HashMap的所有特性, 并且还额外增加了按一定顺序访问的功能 概述LinkedHashMap 继承自 HashMap，在 HashMap 基础上，通过维护一条双向链表，解决了 HashMap 不能随时保持遍历顺序和插入顺序一致的问题。除此之外，LinkedHashMap 对访问顺序也提供了相关支持。在一些场景下，该特性很有用，比如缓存。在实现上，LinkedHashMap 很多方法直接继承自 HashMap，仅为维护双向链表覆写了部分方法。 节点的构造static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; { Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) { super(hash, key, value, next); } } LinkedHashMap内部的Entry相较于Node节点多了两个before、after引用，用来维护LinkedHashMap内部元素的顺序(其内部使用双向链表)。这些还好理解，不过比较好奇的是，为什么HashMap内部的TreeNode节点反而继承的是Entry，而不是HashMap内部的Node TreeNode 继承 LinkedHashMap 的内部类 Entry 后，就具备了和其他 Entry 一起组成链表的能力。但是这里会有一个疑问。当我们使用 HashMap 时，TreeNode 并不需要具备组成链表能力。如果继承 LinkedHashMap 内部类 Entry ，TreeNode 就多了两个用不到的引用，这样做不是会浪费空间吗？简单说明一下这个问题（水平有限，不保证完全正确），这里这么做确实会浪费空间，但与 TreeNode 通过继承获取的组成链表的能力相比，这点浪费是值得的。在 HashMap 的设计思路注释中，有这样一段话： Because TreeNodes are about twice the size of regular nodes, weuse them only when bins contain enough nodes to warrant use(see TREEIFY_THRESHOLD). And when they become too small (due toremoval or resizing) they are converted back to plain bins. Inusages with well-distributed user hashCodes, tree bins arerarely used. TreeNode 对象的大小约是普通 Node 对象的2倍，我们仅在桶（bin）中包含足够多的节点时再使用。当桶中的节点数量变少时（取决于删除和扩容），TreeNode 会被转成 Node。当用户实现的 hashCode 方法具有良好分布性时，树类型的桶将会很少被使用。 通过上面的注释，我们可以了解到。一般情况下，只要 hashCode 的实现不糟糕，Node 组成的链表很少会被转成由 TreeNode 组成的红黑树。也就是说 TreeNode 使用的并不多，浪费那点空间是可接受的。假如 TreeNode 机制继承自 Node 类，那么它要想具备组成链表的能力，就需要 Node 去继承 LinkedHashMap 的内部类 Entry。这个时候就得不偿失了，浪费很多空间去获取不一定用得到的能力。 类的属性/** * The head (eldest) of the doubly linked list. */ transient LinkedHashMap.Entry&lt;K,V&gt; head; /** * The tail (youngest) of the doubly linked list. */ transient LinkedHashMap.Entry&lt;K,V&gt; tail; /** * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt; * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order. * * @serial */ final boolean accessOrder; 构造函数public LinkedHashMap() { super(); accessOrder = false; } public LinkedHashMap(int initialCapacity) { super(initialCapacity); accessOrder = false; } public LinkedHashMap(int initialCapacity, float loadFactor) { super(initialCapacity, loadFactor); accessOrder = false; } public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) { super(); accessOrder = false; putMapEntries(m, false); } public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) { super(initialCapacity, loadFactor); this.accessOrder = accessOrder; } 和HashMap的构造函数是类似的，不过可以通过入参accessOrder来判断内部维护什么顺序的双向链表。 增链表的建立过程是在插入键值对节点时开始的，初始情况下，让 LinkedHashMap 的 head 和 tail 引用同时指向新节点，链表就算建立起来了。随后不断有新节点插入，通过将新节点接在 tail 引用指向节点的后面，即可实现链表的更新。 因为LinkedHashMap继承了HashMap，其并未整体重写父类的put操作，而是直接使用父类的put操作，那么问题来了，LinkedHashMap 是怎么做到在未重写父类方法情况下，有使得内部的节点具有链表的能力呢？研读源码 putVal()public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { // 对应table数组 Node&lt;K,V&gt;[] tab; // 对应位置的 Node 节点 Node&lt;K,V&gt; p; // n table的长度 // 原tab中对应放入Node的位置 int n, i; // 如果 table 未初始化，或者容量为 0 ，则进行扩容 // (第一次见这种赋值和判断融合的操作，学到了学到了) if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 如果对应的位置的Node节点为空，则直接创建 Node 节点即可。 // (n-1)&amp;hash 获取所在table的位置 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { // 哈希冲突解决 // key 在 HashMap 对应的老节点 Node&lt;K,V&gt; e; K k; // hash相等 key相等 执行覆盖 if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 为红黑树的节点 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 为Node节点，则说明是链表，且不是覆盖操作。需要遍历查找 else { // 判断什么时候进行链表转红黑树，什么时候红黑树转链表 for (int binCount = 0; ; ++binCount) { // 如果链表遍历完了都没有找到相同key的元素，说明该key对应的元素不存在，则在链表 // 最后插入一个新节点 if ((e = p.next) == null) { // ===1⃣️核心点=== // newNode() p.next = newNode(hash, key, value, null); // 链表的长度如果数量达到 TREEIFY_THRESHOLD（8）时，则进行树化。 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } // 如果待插入的key在链表中找到了，则退出循环 if (e.hash == hash&amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } // 覆盖操作， 也就是相同的key的value进行覆盖 if (e != null) { // existing mapping for key V oldValue = e.value; // onlyIfAbsent进行判断是否需要覆盖oldValue if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 如果超过阀值，则进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } // LinkedHashMap中，重写了HashMap的`newNode()`方法 Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) { // 重写了newNode方法 // 使得返回的节点为Entry节点，具有before、next指针 LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p; } // 将最后新的节点加入到双向链表的尾部 private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) { LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else { p.before = last; last.after = p; } } 总结 整体来看，就是上述的方式，在整个putVal方法中，重写了newNode()方法，同时newNode方法中，LinkedHashMap还执行了自定义的linkedNodeLast()方法。 小知识点 通过阅读putVal方法，会发现还有三个after开头的方法 // Callbacks to allow LinkedHashMap post-actions // 回调方法，供LinekdHash执行一些后置处理 // 在hashmap中并未做出具体的实现 // 但是在linkedhashmap中做出了具体的实现 void afterNodeAccess(Node&lt;K,V&gt; p) { } void afterNodeInsertion(boolean evict) { } void afterNodeRemoval(Node&lt;K,V&gt; p) { } 删和插入操作一样，LinkedHashMap的删除操作也是直接调用父类的方法，不过父类的删除逻辑并不会修复LinkedHashMap内部维护的双向链表，这也不是父类删除方法的职责，所以LinkedHashMap是如何实现在删除过程中维护内部的双向链表的呢？上源码 removeNode(int hash, Object key, Object value,boolean matchValue, boolean movable)public boolean remove(Object key, Object value) { return removeNode(hash(key), key, value, true, true) != null; } final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { // 这些和增里面是差不多的 // tab：桶数组 p：待删除节点的前驱节点 n: 桶数组大小 index: 桶数组第i个位置 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null&amp;&amp;(n = tab.length)&gt;0 &amp;&amp;(p=tab[index=(n-1)&amp;hash])!= null) { // node为需要删除的节点 Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) { if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else { do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } // 找到对应的key进行remove核心 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); // 如果node == p，说明是链表头是待删除节点 else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; // 调用删除回调方法进行后续操作 afterNodeRemoval(node); return node; } } return null; } // LinkedHashMap中afterNodeRemoval具体实现 // 双向链表的正常删除操作 void afterNodeRemoval(Node&lt;K,V&gt; e) { // unlink LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b; } // linkedlist的删除操作 E unlink(Node&lt;E&gt; x) { // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; // 后继节点 final Node&lt;E&gt; prev = x.prev; // 前驱节点 // 删除的为第一个节点 if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } // 删除的为最后一个节点 if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } } 说白了就是双向链表的删除，具体删除逻辑和LinkedList是一样的，先确定当前节点的前驱、后继节点，之后先修改指向后断链防止整个链表断开，在此期间需要判断下要删除的节点是否为第一个节点、最后一个节点，防止爆NPE 总结删除的过程并不复杂，上面这么多代码其实就做了三件事： 根据 hash 定位到桶位置 遍历链表或调用红黑树相关的删除方法 从 LinkedHashMap 维护的双链表中移除要删除的节点 查因为LinkedHashMap内部有两种机制维护内部的双向链表（按照插入顺序、按照访问顺序）前面说了插入顺序的实现，接下来研究下访问顺序。默认情况下，LinkedHashMap 是按插入顺序维护链表。不过我们可以在初始化 LinkedHashMap，指定 accessOrder 参数为 true，即可让它按访问顺序维护链表。 插入顺序、访问顺序的区别插入顺序:是指LinkedHashMap在数据插入时的插入顺序 比如说1,2,3,4…数据依次从小到大插入 若按照插入顺序输出,输出结果就是1,2,3,4… 访问顺序:则是说同样按照插入1,2,3,4…从小到大有序的插入 1. 如果在插入后你随机访问了某个元素,那么那个元素则会排列到集合的最后一位 @Test public void insetAndVisitedOrder() { Map&lt;String, String&gt; map = orderMap(); System.out.println(map); System.out.println(\"=================\"); map.get(\"key-3\"); System.out.println(map); } public Map&lt;String, String&gt; orderMap() { Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(8, 0.75F, true); for (int i = 0; i &lt; 5; i++) { map.put(\"key-\" + i, \"value-\" + i); } return map; } // {key-0=value-0, key-1=value-1, key-2=value-2, key-3=value-3, key-4=value-4} // ================= // {key-0=value-0, key-1=value-1, key-2=value-2, key-4=value-4, key-3=value-3} 阐述完毕，接下来看下其内部如何维护这两种类型的访问顺序 get(Object key)public V get(Object key) { Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; // 如果 accessOrder 为 true，则调用 afterNodeAccess 将被访问节点移动到链表最后 if (accessOrder) afterNodeAccess(e); return e.value; } void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; // 不是尾部节点 if (accessOrder &amp;&amp; (last = tail) != e) { LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else { p.before = last; last.after = p; } tail = p; ++modCount; } } 整体的操作共为两步 删除当前节点所在的位置 将当前节点插入到双向链表的尾部 注意可能当前节点可能是head节点、tail节点 同理，因为是维护了访问的双向链表，所以在对外提供的API，包含有访问性质的，都会调用afterNodeAccess来维护该双向链表 如： get getOrDefault image-20210504201032288 应用LRU缓存操作 在阐述缓存实现之前，还有一个afterNodeInsertion没有讲解 void afterNodeInsertion(boolean evict) { // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) { K key = first.key; removeNode(hash(key), key, null, false, true); } } // 移除最近最少被访问条件之一，通过覆盖此方法可实现不同策略的缓存 protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) { return false; } 上面的源码的核心逻辑在一般情况下都不会被执行，所以之前并没有进行分析。上面的代码做的事情比较简单，就是通过一些条件，判断是否移除最近最少被访问的节点。看到这里，大家应该知道上面两个方法的用途了。当我们基于 LinkedHashMap 实现缓存时，通过覆写removeEldestEntry方法可以实现自定义策略的 LRU 缓存。比如我们可以根据节点数量判断是否移除最近最少被访问的节点，或者根据节点的存活时间判断是否移除该节点等 public class SimpleCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; { private static final int MAX_NODE_NUM = 100; private int limit; public SimpleCache() { this(MAX_NODE_NUM); } public SimpleCache(int limit) { super(limit, 0.75f, true); this.limit = limit; } public V save(K key, V val) { return put(key, val); } public V getOne(K key) { return get(key); } public boolean exists(K key) { return containsKey(key); } /** * 判断节点数是否超限 * @param eldest * @return 超限返回 true，否则返回 false */ @Override protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) { return size() &gt; limit; } } 总结 LinkedHashMap继承自HashMap，具有HashMap的所有特性 LinkedHashMap内部维护了一个双向链表，来维护节点直接的顺序 如果accessOrder为false，则可以按插入元素的顺序遍历元素 如果accessOrder为true， 则可以按访问元素的顺序遍历元素 LinkedHashMap的实现非常精妙，很多方法都是在HashMap中留的钩子（Hook），直接实现这些Hook就可以实现对应的功能了，并不需要再重写put()等方法 默认的LinkedHashMap并不会移除旧元素，如果需要移除旧元素，则需要重写removeEldestEntry()方法设定移除策略； LinkedHashMap可以用来实现LRU缓存淘汰策略； references LinkedHashMap源码详细分析（JDK1.8）","categories":[],"tags":[]},{"title":"CopyOnWriteArrayList源码解读","slug":"源码/JDK/list/copy-on-write-arraylist","date":"2020-06-19T11:18:54.000Z","updated":"2020-08-30T04:50:22.255Z","comments":true,"path":"copy-on-write-arraylist/","link":"","permalink":"https://winniekun.github.io/copy-on-write-arraylist/","excerpt":"CopyOnWriteArrayList源码解读","text":"CopyOnWriteArrayList源码解读 依赖 CopyOnWriteArrayList依赖 字段&amp;属性// 用于修改数组的时候加锁 final transient ReentrantLock lock = new ReentrantLock(); // 真正存储元素的地方 只能通过get set访问 // 使用volatile修饰 保证可见性(一个线程的修改 对其他线程可见) private transient volatile Object[] array; final Object[] getArray() { return array; } final void setArray(Object[] a) { array = a; } 构造方法// 创建空数组 public CopyOnWriteArrayList() { setArray(new Object[0]); } // public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) { Object[] elements; // 如果c也是CopyOnWriteArrayList类型 // 则直接将其的array拿来用, 属于浅拷贝 // c和新的CopyOnWriteArrayList共享同一个数组 if (c.getClass() == CopyOnWriteArrayList.class) elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray(); else { elements = c.toArray(); // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elements.getClass() != Object[].class) elements = Arrays.copyOf(elements, elements.length, Object[].class); } setArray(elements); } // 把toCopyIn的元素拷贝给当前list的数组。 public CopyOnWriteArrayList(E[] toCopyIn) { setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class)); } 增add(E e)// 添加一个元素在末尾 public boolean add(E e) { final ReentrantLock lock = this.lock; // 修改数组之前加锁 lock.lock(); try { Object[] elements = getArray(); int len = elements.length; // 将数组拷贝到新数组中, 新数组长度比旧数组长度多1 Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; // array指向新的数组 setArray(newElements); return true; } finally { // 释放锁 lock.unlock(); } } 总结在尾部添加一个元素步骤: 先加锁 获取元素数组 创建一个新的数组, 长度比原数组长度多1, 并把原数组的内容拷贝到新数组 在新数组末尾添加元素 把新数组赋值给当前对象的array属性，覆盖原数组 解锁 add(int index, E element)// 指定位置添加元素 public void add(int index, E element) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; // 判断添加位置是否合法 if (index &gt; len || index &lt; 0) throw new IndexOutOfBoundsException(\"Index: \"+index+ \", Size: \"+len); Object[] newElements; // 需要移动元素的个数 int numMoved = len - index; if (numMoved == 0) newElements = Arrays.copyOf(elements, len + 1); else { // 新数组的长度为元素组的长度+1 newElements = new Object[len + 1]; // 先将原数组index之前的元素复制到新数组 System.arraycopy(elements, 0, newElements, 0, index); // 再将原数组index之后的元素复制到新数组 System.arraycopy(elements, index, newElements, index + 1, numMoved); } // 新数组中index的位置赋值element newElements[index] = element; // array指向新的数组 setArray(newElements); } finally { // 解锁 lock.unlock(); } } 总结 执行步骤: 先加锁 判断位置是否合法 计算移动的位置, 若为0, 等同于在末尾添加元素 若是不为0, 则分步骤添加原数组元素到新数组, 先是index之前, 再是index之后, 最后是index 把新数组赋值给当前对象的array属性，覆盖原数组 解锁 为什么这里使用System.arraycopy(), 而不是copyOf() 因为新数组已经被初始化了, 直接将原数组中的元素复制过来即可, 若是使用copyOf()实现起来麻烦,而且需要创建两次新的数组, 还有局部temp数组, 总之, 怎么实现起来方便怎么来, 如前一个add(E e)方法, 直接使用copyOf()方法就能实现, 使用System.arraycopy()需要先初始化, 然后再复制, 反而麻烦了 addAll(Collection&lt;? extends E&gt; c)public boolean addAll(Collection&lt;? extends E&gt; c) { Object[] cs = (c.getClass() == CopyOnWriteArrayList.class) ? ((CopyOnWriteArrayList&lt;?&gt;)c).getArray() : c.toArray(); if (cs.length == 0) return false; final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; // 原数组长度为0 if (len == 0 &amp;&amp; cs.getClass() == Object[].class) setArray(cs); else { // 创建新数组, 长度为原数组长度 + c的元素个数 // 并将元素组的元素拷贝进去 Object[] newElements = Arrays.copyOf(elements, len + cs.length); // 将c的元素拷贝到新数组中, 从len位置开始 System.arraycopy(cs, 0, newElements, len, cs.length); setArray(newElements); } return true; } finally { lock.unlock(); } } addAll(int index, Collection&lt;? extends E&gt; c)同理 查get()就是简单的根据索引获取数组元素 public E get(int index) { return get(getArray(), index); } private E get(Object[] a, int index) { return (E) a[index]; } 删remove(int index)public E remove(int index) { final ReentrantLock lock = this.lock; // 加锁 lock.lock(); try { Object[] elements = getArray(); int len = elements.length; // 获取旧值 E oldValue = get(elements, index); // 移动元素个数 int numMoved = len - index - 1; // 如果删除的是最后一个元素, 直接拷贝出一个新的len-1的数组即可 if (numMoved == 0) setArray(Arrays.copyOf(elements, len - 1)); else { Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); } return oldValue; } finally { lock.unlock(); } } 总结 步骤: 加锁 获取原数组及长度 获取旧值 计算需要移动元素的个数 若是移动次数=0, 即删除末尾元素, 直接复制一个长度为原数组长度-1的数组, 将原数组len-1的元素放入即可 若是移动次数&gt;0, 则现将index前的元素复制到新数组(新数组确定长度为原长度-1), 然后复制index之后的元素 返回旧值 解锁 为什么移动元素个数的计算和add`方法不一样 因为添加元素到指定位置时, 原数组的对应位置上的元素a不删除, 移动的时候a也需要移动 删除的时候, 直接原数组对应位置的上的元素直接删除, 所以不需要移动 数组长度在之前的ArrayList, LinkedList 中 size都是成员变量, 在对数组做修改的时候, size执行++ 或—即可, 但是这里却不是 public int size() { return getArray().length; } 我们发现, 每次修改都是拷贝一份正好可以存储目标个数元素的数组，所以不需要size属性了，数组的长度就是集合的大小，而不像ArrayList数组的长度实际是要大于集合的大小的。 总结 使用可重入锁和volatile保证线程安全 写操作都需要加锁, 然后在此期间创建新的数组, 并在新数组中做修改, 之后再用新数组替原数组, 空间复杂度为$O(n)$ 读操作不需要加锁, 支持随机访问, 空间复杂度为$O(1)$ 采用读写分离思想(读写者问题), 但是写操作占用大量的内存空间, 适用于读多, 写少的情景 只能保证最终一致性, 不能保证实时一致性 面试相关问题 CopyOnWriteArrayList是怎么保证并发安全的？ CopyOnWriteArrayList的实现采用了什么思想？ CopyOnWriteArrayList是不是强一致性的？ CopyOnWriteArrayList适用于什么样的场景？ CopyOnWriteArrayList插入、删除、查询元素的时间复杂度各是多少？ CopyOnWriteArrayList为什么没有size属性？","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"List","slug":"List","permalink":"https://winniekun.github.io/tags/List/"},{"name":"JUC","slug":"JUC","permalink":"https://winniekun.github.io/tags/JUC/"}]},{"title":"死磕动态规划","slug":"LeetCode/stick-to-dynamic-programming","date":"2020-06-16T02:54:10.000Z","updated":"2021-06-28T04:46:20.223Z","comments":true,"path":"stick-to-dynamic-programming/","link":"","permalink":"https://winniekun.github.io/stick-to-dynamic-programming/","excerpt":"前言LeetCode死磕系列七： DP 终于轮到了DP, 怎么说类, 感觉自己写DP的题挺玄幻的, 状态好了, 能找出转移方程, 就能瞬间解决, 搞不好还能优化, 状态不好了, 只知道可以用DP, 也只是知道….","text":"前言LeetCode死磕系列七： DP 终于轮到了DP, 怎么说类, 感觉自己写DP的题挺玄幻的, 状态好了, 能找出转移方程, 就能瞬间解决, 搞不好还能优化, 状态不好了, 只知道可以用DP, 也只是知道…. 的确, 和网上的很多总结类似, 做到后面也感觉DP使用的数学知识就是数学归纳法, 然后还有自身的优化, 譬如大多数情况自底向上的DP往往要比自顶向下的DP实现起来简约且效率高, 也可使用滚动数组将高纬的dp数组降维. 两大特性 无后效行 一旦f(i,j)确定，就不用关心 “我们如何计算出f(i,j)”。 想要确定f(i,j)，只需要知道f(i-1,j)和f(i,j-1)的值，而至于它们 是如何算出来的，对当前或之后的任何子问题都没有影响。 过去不依赖将来，将来不影响过去 —- 智巅语录 最优子结构 f(i,j)的定义就已经蕴含了“最优”。 大问题的最优解可以由若干个小 问题的最优解推出。(max, min, sum…) DP能适用的问题:能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。 题目特点 计数 有多少种方式走到右下角 有多少种方法选出k个数使得和是sum 求最大值最小值 从左上角走到右下角路径的最大数字和 最长上升子序列长度 求存在性 取石子游戏，先手是否必胜 能不能选出k个数使得和是sum 主要类型I:时间序列模型给出一个序列（字符串、数组），其中每一个元素可以认为一天，并且今天的状态只取决于昨天的状态 套路 定义$dp[i][j]$： 表示第i-th轮的第j种状态（j=1,2,3,..k） 千方百计将$dp[i][j]$和前一轮的状态$dp[i-1][j]$产生关系（j=1,2,3,..k） 最后的结果就是$dp[last][j]$的某种操作（sum、max、min…） image-20210503140232767 II:时间序列加强版(子序列模型)给出一个序列（数组、字符串），其中每一个元素可以认为一天，但是今天的状态和之前的某一天相关，需要进行挑选 套路 定义$dp[i]$: 表示第i-th轮的状态，一般这个状体要求和元素i直接相关❓ 千方百计的将$dp[i]$与之前的状态$dp[i’]$产生关系（i=1,2,3..i-1）操作如（sum、max、min） $dp[i]$肯定不能与大于 i的轮次有任何关系，否 则违反了DP 的无后效性。 最终的结果为$dp[i]$中的某一个 III:双序列模型给出两个序列$S$和$T$ (数组、字符串)，对它们两个搞事情 编辑距离公式 套路： 定于$dp[i][j]$: 表示针对$S[1:i]$和$T[1:j]$的子问题的求解 千方百计将$dp[i][j]$往之前的状态去转移：$dp[i-1][j], dp[i][j-1], dp[i-1][j-1]$ 最终的结果为$dp[m][n]$ IV:第I类区间型DP给出一个序列（数组、字符串），明确要求分割成k个连续空间，要你计算这些区间的某个最优性质。 套路 状态定义：$dp[i][k]$表示针对$S[1:i]$分成k个区间，此时能够得到的最优解 搜寻最后一个区间的起始位置$j$，将$dp[i][k]$分割成$dp[j-1][k-1]$和$两个部分 最终的结果是$dp[N][K]$ image-20210503143245100 V:第II类区间型DP只给出一个序列S（数组、字符串），求一个针对这个序列的最优解 适合条件： 这个最优解对于序列的index而言，没有“无后效性”。即无法设计$dp[i]$使得 $dp[i]$仅依赖于$dp[j] (j&lt;i)$. 但是大区间的最优解，可以依赖小区间的最优解。 套路： 定义$dp[i][j]$:表示针对$s[i:j]$的子问题的求解。 千方百计将最大区间的$dp[i][j]$往小区间的$dp[i’][j’]$转移 第一层循环是区间大小；第二层循环是起始点 最终的结果是$dp[1][N]$ image-20210503144732050 VI:背包入门题目抽象：给出N件物品，每个物品可用不可用（若干种不同的用法）需要消耗一定的代价。要求以某个有上限C的代价来实现最大收益。（有时候反过来，要求以某个有下限的收益来实现 最小代价。） 套路： 定义$dp[i][j]$表示只从前i件物品的子集里面选择、代价为$j$的最大收益 j = 1、2、3、4…C 千方百计的将$dp[i][j]$往$dp[i-1][j’]$转移：考虑如何使用物品i，对代价/收益的影响 第一层建议循环物品 第二层建议循环容量/代价 最后的结果$max{dp[N][c]} | c \\in {1,2,..c}$ LeetCode&amp;Offer DP题目整理(按照上述的分类整理)牢记动归的步骤： 确定dp的数组和下标的含义 确定递归公式 dp数组的初始化 确定遍历顺序 列举dp数组 时间序列模型❌ 198. 打家劫舍 ✅ 213. 打家劫舍 II ✅ 337. 打家劫舍 III ✅ 121. 买卖股票的最佳时机 ✅ 122. 买卖股票的最佳时机 II✅ 123. 买卖股票的最佳时机 III✅ 188. 买卖股票的最佳时机 IV✅ 309. 最佳买卖股票时机含冷冻期 376. 摆动序列 487. 最大连续1的个数 II✅ 1186. 删除一次得到子数组最大和✅ 714. 买卖股票的最佳时机含手续费 剑指 Offer 63. 股票的最大利润 时间序列模型加强版(子序列问题)✅ 300. 最长递增子序列✅ 368. 最大整除子集✅ 双序列模型✅备注：设置dp空间是，看有效位从0还是1开始。 从1开始，是为了让dp转移方程更加具有适用性，能从最开始的字符串就能计算 从0开始，需要额外考虑初始化过程。行、列 题目： 72. 编辑距离 32. 最长有效括号 115. 不同的子序列 1143. 最长公共子序列 最长公共子串 字符串交错组成 区间序列模型 1278. 分割回文串 III 813. 最大平均值和的分组 区间序列模型加强版背包模型数组系列 70. 爬楼梯 746. 使用最小花费爬楼梯 72. 编辑距离 198. 打家劫舍 213. 打家劫舍 II 337. 打家劫舍 III 53. 最大子序和 322. 零钱兑换 518. 零钱兑换 II 120 三角形最小路径和 300 最长上升子序列 354. 俄罗斯套娃信封 64 最小路径和 174 地下城游戏 不同路径 不同路径II 题解时间序列模型❌198. 打家劫舍 ✅时间序列模型：其中每一个元素可以认为一天，并且今天的状态只取决于昨天的状态 定于状态$dp[i][j]$ 表示第i家，偷或不偷 $j\\in {0,1}, i \\in {N_i}$ 转移方程 $ dp[i][j]=\\left{ \\begin{array}{rcl} dp[i][0]= dp[i-1][1] + val[i] &amp;&amp; {偷}\\ dp[i][1]=Math.max(dp[i-1][0], dp[i-1][1]) &amp;&amp;{不偷}\\end{array} \\right. $ class Solution { public int rob(int[] nums) { // 0表示偷 // 1表示不偷 int[][] dp = new int[nums.length][2]; dp[0][0] = nums[0]; for (int i = 1; i &lt; nums.length; i++) { dp[i][0] = dp[i-1][1] + nums[i]; dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]); int temp = Math.max(dp[i][0], dp[i][1]); } int len = nums.length; return Math.max(dp[len-1][0], dp[len-1][1]); } } 一维解法 定义状态 $dp[i]$表到第i家能偷到的最高金额 寻找状态转移方程 $dp[0]=nums[0]$ : 目前只有一家, 所以对于小偷来说, 就偷这一家就是最高金额 $dp[1] = Math.max(nums[0], nums[1])$: 目前有两家, 对于小偷来说因为条件限制, 所以只能偷两家中金额最大的那家 $dp[2] = Math.max(dp[0]+nums[2], dp[1])$: 目前有三家, 对于小偷来说因为条件限制, 有两种可能 $dp[3] = Math.max(dp[2], dp[1]+nums[3])$ $dp[i] = Math.max(dp[i-1], dp[i-2]+nums[i])$ 确定边界值 $dp[0] = nums[0]$ $dp[1] = Math.max(nums[0], nums[1])$ public int rob(int[] nums) { // TODO 校验 int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(nums[1], nums[0]); for (int i = 2; i &lt; nums.length; i++) { dp[i] = Math.max(dp[i-1], nums[i] + dp[i-2]); } return dp[nums.length-1]; } 213. 打家劫舍 II ✅绕圈圈的打家劫舍，在循环数组中打家劫舍，思路是一样的，不过需要分类讨论了（注意数组的边界，可能会出现越界问题） Trick:首位和末位不能同时抢，这说明至少有一个不能抢。 考虑首位的房子我不抢，那么对于house[1]~house[last]就是一个基本的 House Robber问题。 考虑末位的房子我不抢，那么对于house[0]~house[last-1]就是一个基本的 House Robber问题。 class Solution { public int rob(int[] nums) { // 环形 // 1. 首位和末位不能同时抢 // 1.1 首位抢 array[1:N-1]; // 1.2 末位抢 array[2:N]; if (nums.length == 1) { return nums[0]; } int len = nums.length; int first = rob(nums, 0, len - 2); int last = rob(nums, 1, len - 1); return Math.max(first, last); } private int rob(int[] nums, int first, int last) { int len = last - first + 1; if (last == first) { return nums[first]; } int[][] dp = new int[len][2]; // 0 表示偷. dp[i][0] = dp[i-1][0] + val[i]; // 1 表示不偷 dp[i][1] = max(dp[i-1][0], dp[i-1][1]); dp[0][0] = nums[first]; for (int i = 1; i &lt; len; i++) { dp[i][0] = dp[i-1][1] + nums[first + i]; dp[i][1] = Math.max(dp[i-1][0], dp[i-1][1]); } return Math.max(dp[len - 1][0], dp[len - 1][1]); } } 一维解法 image-20210412181723948 不管是环形的还是正常的数组，数组的位置是不会改变的，所以不会因为偷了i家之后，i-1和i+1就成为邻居了，下次可以考虑在i-1和i+1偷了 public int rob(int[] nums) { // dp // 定义dp数组和下标含义 // dp[i] 到第i间房子后，能获取的最大金额 // dp[i] = Max(dp[i-1],dp[i-2] + nums[i]); // 按照分类 // 1. 小偷偷的房间不包含头尾 // 2. 小偷偷的房间包含头部 // 3. 小偷偷的房间包含尾部 // 1 包含在了2、3两种情况中了 if (nums == null || nums.length == 0) { return 0; } if (nums.length == 1) { return nums[0]; } int left = 0; int right = nums.length - 1; int first = rob(nums, 0, right - 1); int second = rob(nums, 1, right); return Math.max(first, second); } private int rob(int[] nums, int left, int right) { if (left == right) { return nums[left]; } int len = right - left + 1; int[] dp = new int[len]; dp[0] = nums[left]; dp[1] = Math.max(nums[left], nums[left + 1]); for (int i = 2; i &lt; len; i++) { dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i+left]); } return dp[len-1]; } 337. 打家劫舍 III ✅在树上偷。。。 使用后序遍历，已经包含了遍历，所以只需要确定后序面遍历，遍历过程中向上传递什么内容，按照时间序列模型定义，可以直接返回一个二维数组 $ arrayi[2]=\\left{ \\begin{array}{rcl}array_i[0]=array{left}[1] + array{right}[1] + root.val &amp;&amp; {偷}\\ array[1]=Max(array{left}[0], array{right}[1]) + Max(arry{right}[0], aray_{right}[1]) &amp;&amp;{不偷}\\end{array} \\right. $ class Solution { public int rob(TreeNode root) { if (root == null) { return 0; } int[] array = postOrer(root); return Math.max(array[0], array[1]); } private int[] postOrer(TreeNode root) { int[] array = new int[2]; if (root == null) { return array; } int[] left = postOrer(root.left); int[] right = postOrer(root.right); // int[] array = new int[2]; // 0 表示偷 max(left[1], right[1]) + root.val; // 1 表示不偷 // 向上传递整个array数组 // 偷当前节点 int first = root.val+left[1]+right[1]; // 不偷当前节点 int second = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); // ans = Math.max() array[0] = first; array[1] = second; return array; } } 121. 买卖股票的最佳时机✅买卖股票有约束，根据题目意思，有以下两个约束条件： 条件 1：你不能在买入股票前卖出股票； 条件 2：最多只允许完成一笔交易。 因此 当天是否持股 是一个很重要的因素，而当前是否持股和昨天是否持股有关系，所以也为时间序列模型 若是昨天不持股，今天持股，则和第一天持股一个道理，则当前的金额数量为$-V[i]$，最后我们只需要返回最后一天不持股的最大金额数量即可。 $ dp[i][2]=\\left{ \\begin{array}{rcl}dp[i][0]= Max(dp[i-1][0], -v[i]]) &amp;&amp; {持股}\\ dp[i][1]=Max(dp[i-1][0] + v[i], dp[i-1][1]) &amp;&amp;{不持股}\\end{array} \\right. $ class Solution { public int maxProfit(int[] prices) { int len = prices.length; if (len &lt; 2) { return 0; } // 可以理解为折线统计图，然后求上升最高的线段 // 不过这次使用动规 // 0 持股 -prices[i] // 1 不持股 +prices[i] int[][] dp = new int[len][2]; dp[0][0] = -prices[0]; // 第0天持股手上的现金 dp[0][1] = 0; //第0天不持股，手上的现金 for (int i = 1; i &lt; len; i++) { dp[i][0] = Math.max(dp[i-1][0], -prices[i]); dp[i][1] = Math.max(dp[i-1][0] + prices[i], dp[i-1][1]); } return dp[len - 1][1]; } } 附加一题剑指 Offer 63. 股票的最大利润，一摸一样。 122. 买卖股票的最佳时机 II ✅ 根据上述的转移方式，可以得到如下状态转换 $ dp[i][2]=\\left{ \\begin{array}{rcl}dp[i][0]= Max(dp[i-1][0], dp[i-1][1]-v[i]]) &amp;&amp; {持股}\\ dp[i][1]=Max(dp[i-1][0] + v[i], dp[i-1][1]) &amp;&amp;{不持股}\\end{array} \\right. $ class Solution { public int maxProfit(int[] prices) { // 动归 int len = prices.length; int[][] dp = new int[len][2]; // 初始化 // 0 表示 第i天持有股票 // 1 表示 第i不持有股票 dp[0][1] = 0; dp[0][0] = -prices[0]; for (int i = 1; i &lt; len; i++) { dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] - prices[i]); dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]); } return dp[len-1][1]; } } 714. 买卖股票的最佳时机含手续费✅和上述同理，需要添加手续费 class Solution { public int maxProfit(int[] prices, int fee) { int len = prices.length; // 0 : 持股（买入） // 1 : 不持股（售出） // dp 定义第i天持股/不持股 所得最多现金 int[][] dp = new int[len][2]; dp[0][0] = -prices[0]; for (int i = 1; i &lt; len; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]); dp[i][1] = Math.max(dp[i - 1][0] + prices[i] - fee, dp[i - 1][1]); } return Math.max(dp[len - 1][0], dp[len - 1][1]); } } 123. 买卖股票的最佳时机 III✅ image-20210503100324818 思路 最高持有两股，分为四种状态 $ dp[i][j]=\\left{ \\begin{array}{rcl} dp[i][0] = Max(dp[i-1][0], -val[i]) &amp;&amp; {第i天，持第有1股的最大利润}\\ dp[i][1]=Max(dp[i-1][1], dp[i-1][0] + val[i]) &amp;&amp; {第i天，售出第1股的最大收益} \\dp[i][2] = Max(dp[i-1][2], dp[i-1][1] - val[i] &amp;&amp; {第i天，持有第2股的最大收益} \\dp[i][3] = Max(dp[i-1][3], dp[i-1][2] + val[i]) &amp;&amp; {第i天，售出第2股的最大收益} \\end{array} \\right. $ 最后的结果为$Max{dp[N][i]} (i = 0, 1, 2, 3)$ class Solution { public int maxProfit(int[] prices) { int n = prices.length; long[][] dp = new long[n][4]; // 0 持有1股 // 1 售出1股 // 2 持有2股 // 3 售出2股 // 第0天 持有一股， 第0天不可能出现售出的现象，只有持有第一股的可能 dp[0][0] = -prices[0]; dp[0][2] = -prices[0]; for (int i = 1; i &lt; n; i++) { dp[i][0] = Math.max(dp[i-1][0], -prices[i]); dp[i][1] = Math.max(dp[i-1][0] + prices[i], dp[i-1][1]); dp[i][2] = Math.max(dp[i-1][1] - prices[i], dp[i-1][2]); dp[i][3] = Math.max(dp[i-1][2] + prices[i], dp[i-1][3]); } long res = 0; for(int i = 0; i &lt; 4; i++) { res = Math.max(res, dp[n-1][i]); } return (int)res; } } 188. 买卖股票的最佳时机 IV✅属于123题的抽象类型，k次买卖，则我们会出现2*k次的持有、售卖状态，然后我们假设偶数为持有股票，奇数为售卖股票 image-20210503202846471 class Solution { public int maxProfit(int k, int[] prices) { // 类比买卖股票III if (prices == null || prices.length == 0) { return 0; } int len = prices.length; int[][] dp = new int[len][2*k]; for (int i = 0; i &lt; 2 * k; i++) { if (i % 2 == 0) { dp[0][i] = -prices[0]; } } for (int i = 1; i &lt; len; i++) { for (int j = 0; j &lt; 2 * k ; j++) { if (j == 0) { dp[i][j] = Math.max(dp[i-1][0], -prices[i]); } else if (j % 2 == 0) { dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-1] - prices[i]); } else { dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-1] + prices[i]); } } } // return Arrays.stream(dp[n -1]).max().getAsInt(); int res = 0; for (int i = 0; i &lt; 2 * k; i++) { res = Math.max(dp[len-1][i], res); } return res; } } 309. 最佳买卖股票时机含冷冻期✅ image-20210625160741945 $ dp[i][j]=\\left{ \\begin{array}{rcl} dp[i][0] = Max(dp[i-1][0], dp[i - 1][1] - priece[i]]) &amp;&amp; {第i天，刚持有股票的最大利益}\\ dp[i][1]=Max(dp[i-1][1], dp[i-1][2]) &amp;&amp; {冷冻的最大收益} \\dp[i][2] = Max(dp[i-1][2], dp[i-1][0] + val[i] &amp;&amp; {这一轮已经清空股票的最大收益} \\end{array} \\right. $ class Solution { public int maxProfit(int[] prices) { int n = prices.length; if (n &lt; 2) { return 0; } //定义 前i天 不同状态的最大利润 int[][] dp = new int[n][3]; // 初始化 // 0 : 买入 // 1 : 冷冻 // 2 : 清空 dp[0][0] = -prices[0]; dp[0][1] = 0; dp[0][2] = 0; for (int i = 1; i &lt; n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][2]); dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][0] + prices[i]); } return Arrays.stream(dp[n - 1]).max().getAsInt(); } } 276. 栅栏涂色256. 粉刷房子265. 粉刷房子 II487. 最大连续1的个数 II✅ image-20210503235309983 class Solution { public int findMaxConsecutiveOnes(int[] nums) { int len = nums.length; // 以 当前元素为结尾，是否形式翻转权利的最长连续的1 int[][] dp = new int[len][2]; // 0 未翻转1 // 1 翻转1 dp[0][1] = 1; dp[0][0] = nums[0] == 1 ? 1 : 0; int ans = Math.max(dp[0][1], dp[0][0]); for (int i = 1; i &lt; len; i++) { if (nums[i] == 1) { dp[i][0] = dp[i-1][0] + 1; dp[i][1] = dp[i-1][1] + 1; } else { dp[i][1] = dp[i-1][0] + 1; dp[i][0] = 0; } ans = Math.max(ans, Math.max(dp[i][0], dp[i][1])); } return ans; } } 1186. 删除一次得到子数组最大和✅ image-20210503235251921 class Solution { public int maximumSum(int[] nums) { int len = nums.length; // 0 不删除 // 1 删除 int ans = nums[0]; int[][] dp = new int[len][2]; dp[0][0] = nums[0]; dp[0][1] = 0; for (int i = 1; i &lt; len; i++) { dp[i][0] = Math.max(dp[i-1][0]+nums[i], nums[i]); dp[i][1] = Math.max(dp[i-1][0], dp[i-1][1] + nums[i]); int temp = Math.max(dp[i][0], dp[i][1]); ans = Math.max(ans, temp); } return ans; } } 时间序列模型加强版（子序列模型）✅300. 最长递增子序列✅class Solution { public int lengthOfLIS(int[] nums) { int len = nums.length; if (len &lt; 2) { return len; } int[] dp = new int[len]; Arrays.fill(dp, 1); dp[0] = 1; int ans = 1; for (int i = 1; i &lt; len; i++) { for (int j = 0; j &lt; i; j++) { if (nums[i] &gt; nums[j]) { dp[i] = Math.max(dp[j] + 1, dp[i]); } } ans = Math.max(dp[i], ans); } return ans; } } 368. 最大整除子集✅class Solution { public List&lt;Integer&gt; largestDivisibleSubset(int[] nums) { int len = nums.length; // 第 1 步：动态规划找出最大子集的个数、最大子集中的最大整数 int[] dp = new int[len]; Arrays.sort(nums); Arrays.fill(dp, 1); int maxSize = 1; int maxVal = dp[0]; for (int i = 1; i &lt; len; i++) { for (int j = 0; j &lt; i; j++) { if (nums[i] % nums[j] == 0) { dp[i] = Math.max(dp[i], dp[j] + 1); } } if (dp[i] &gt; maxSize) { maxSize = dp[i]; maxVal = nums[i]; } } // 第 2 步：倒推获得最大子集 List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (maxSize == 1) { res.add(nums[0]); return res; } for (int i = len - 1; i &gt;= 0 &amp;&amp; maxSize &gt; 0; i--) { if (dp[i] == maxSize &amp;&amp; maxVal % nums[i] == 0) { res.add(nums[i]); maxVal = nums[i]; maxSize--; } } return res; } } 1105. 填充书架双序列模型✅区间序列模型做到现在，其实可以感觉到，对于区间序列模型，其实基本思想是和子序列模型是类似的，不过子序列模型是从前面的多种状态里面获取最优结果，而区间序列是依据前面多种状态+剩余的元素构成的结果 共同决定的最优结果。 1278. 分割回文串 III明确要求分割成K个连续区间 思路：（经典的区间序列DP） 首先需要预处理每个区间$[i, j]$变成回文所需修改的字符数量(直接暴力就能获得)， 计为$cost[i,j]$ 设$dp[i][j]$表示前$i$个字符，分为$j$段，最少所需要修改的字符数量，有效字符的下标从$1$开始 初始时$dp[i,j]$为$+\\infty$, $dp[0,0] = 0$ 转移时，枚举前一次的分割点$l \\in {0, i-1}$ 这次转移所产生的新的区间为$[l+1, i]$，$dp[i][j] = min(dp[l][j-1] + g(l+1, j))$。 最终的答案$dp[N][K]$ 复杂度分析 预处理需要$O(n^3)$ 动态规划需要$O(nk)$空间 总时间复杂度$O(n^3)$ public static int palindromePartition(String s, int _k) { int n = s.length(); s = \"#\" + s; int K = _k; int[][] dp = new int[n+1][K+1]; int[][] cost = new int[n+1][n+1]; // fill for (int[] temp : dp) { Arrays.fill(temp, 1000); } for (int i = 1; i &lt;= n; i++){ dp[i][1]=calc(s.substring(1, i+1)); } for (int i = 1; i &lt;= n; i++) { for (int j = i; j &lt;= n; j++) { cost[i][j] = cost[i][j] = calc(s.substring(i, j + 1)); } } dp[1][1] = 0; for (int i = 1; i &lt;= n; i++) { for (int k = 1; k &lt;= Math.min(i, K); k++) { for (int l = 0; l &lt;= i - 1; l++) { dp[i][k] = Math.min(dp[i][k], dp[l][k-1] + cost[l + 1][i]); } } } return dp[n][K]; } private static int calc(String t) { int a = 0; int left = 0; int right = t.length() - 1; while (left &lt; right) { if (t.charAt(left) != t.charAt(right)) { a++; } left++; right--; } return a; } 813. 最大平均值和的分组本题求“最大值”，一般可以朝DP的方向考虑。另外，题意里有明确的分成k个subarray的要求，大概率就是区间型DP。 套路: 定义$dp[i][k]$，表示将前$i$个元素分成$k$个subarray的最优解，这里表示前$i$个元素，构成$k$个组，得到的最大平均数的值。突破口就是针对最后一个元素$A[i]$，它必定是在当前的最后一个subarray。 考虑最后的区间的首元素$j$会在哪里？如果选定了这个位置$j$，那么$dp[i][k]$就分解为了两个子问题，一个是$dp[j-1][k-1]$，是以前已经解决的状态，另一个就是$s[j:i]$这段区间的平均值。两者相加就是$dp[i][k]$.我们搜索所有的$j$的位置，选择使$dp[i][k]$最大化的结果。 public static double largestSumOfAverages(int[] nums, int k) { if (nums == null || nums.length == 0) { return 0D; } int len = nums.length; // dp[i][j]: 前i个元素，划分为j组，获得的最大平均总值 double[][] dp = new double[len+1][k+1]; // 优化 获取前缀和 //存储前缀和 double[] prefixSum = getPrefixSum(nums); // int[] prefixSum = new int[len + 1]; // for(int i = 1; i &lt;= len; i++){ // prefixSum[i] = prefixSum[i - 1] + nums[i - 1]; // } for (int i = 1; i &lt;= len; i++) { // 元素 for (int j = 1; j &lt;= Math.min(i, k); j++) { // 组 if(j == 1){ //针对只有1个分组的情况 dp[i][j] = (double)prefixSum[i] / i; continue; } for (int l = 0; l &lt;= i - 1; l++) { dp[i][j] = Math.max(dp[i][j], dp[l][j-1] + (double)(prefixSum[i] - prefixSum[l]) / (i - l)); } } } return dp[len][k]; } private static double[] getPrefixSum(int[] nums) { int len = nums.length; double[] prefixSum = new double[len + 1]; for (int i = 1; i &lt;= len; i++) { prefixSum[i] = prefixSum[i-1] + nums[i-1]; } return prefixSum; } 区间序列模型加强版背包模型数组系列 70. 爬楼梯 定义状态: $dp[i]$ 代表到达第$i$阶台阶, 有多少种走法 寻找状态转移方程 $dp[1] = 1$: 到达第1阶台阶只有一种走法$[1]$ $dp[2] = 2$: 到达第2阶台阶有两种走法$[1,1], [2]$ $dp[3] = 3$: 到达第3阶台阶有三种走法$[1,1,1], [1,2], [2, 1]$ $dp[4] = 5$: 到达第4阶台阶有五种走法$[1,1,1,1], [1,1,2],[1,2,1],[2,2][2,1,1]$ 通过上述的推演, 可以归纳, $dp[i]=dp[i-1] + dp[i-2]$, 也就是到达第$i$阶的台阶共有两种可能方式, 第一种是通过第$i-1$阶再走1步, 第二种是通过第$i-2$阶再走2步, 同时到达第$i-1$阶的走法有$dp[i-1]$种, 到达第$i-2$阶的走法有$dp[i-2]$种, 则$dp[i] = dp[i-1] + dp[i-2]$ 确定边界值 刚才找状态转移方程的时候已经确定好了 $dp[1] = 1$ $dp[2] = 2$ 因为计算机中, 索引是从0开始的, 如果我们定义长度为n的数组, 则最后一个数组的索引为n-1(我们理解上的dp[n]也就是数组中的dp[n-1]), 则我们定义的边界值$dp[0] = 1$, $dp[1] = 2$, 同理, 若是想直接返回dp[n], 则我们就需要将索引为0的数组元素空出来, 也就是dp[0] = 0, dp[1] = 1, dp[2] = 2 public int climbStairsI(int n) { if(n &lt;= 2){ return n; } int[] dp = new int[n]; dp[0] = 1; dp[1] = 2; for(int i = 2; i&lt;n; i++){ dp[i] = dp[i-1] + dp[i-2]; } return dp[n-1]; } public int climbStairsII(int n) { if(n &lt;= 2){ return n; } int[] dp = new int[n+1]; dp[0] = 0; dp[1] = 1; dp[2] = 2; for(int i = 3; i&lt;=n; i++){ dp[i] = dp[i-1] + dp[i-2]; } return dp[n]; } 最后优化 因为我们上述的算法, 消耗了$O(n)$的空间, 同时我们能感觉到可以使用累加的方式进行计算, 而且也只需要返回最终结果, 中间结果我们没必要存储起来, 所以可以做加法运算 public int climbStairs(int n) { if(n &lt;= 2){ return n; } int a = 1; int b = 2; int temp; for(int i = 3; i&lt;=n; i++){ temp = a + b; a = b; b = temp; } return b; } 746. 使用最小花费爬楼梯$ f[i] = cost[i] + min(f[i+1], f[i+2])$ public int minCostClimbingStairs(int[] cost) { int f1 = 0, f2 = 0; for (int i = cost.length - 1; i &gt;= 0; --i) { int f0 = cost[i] + Math.min(f1, f2); f2 = f1; f1 = f0; } return Math.min(f1, f2); } 73. 编辑距离 定义状态: $dp[i][j]$ 表示A的前i个字符到B的前j个字符之间的编辑距离 寻找状态转移方程 我觉得二维的状态, 画在纸上更加的简单明了 $dp[0][j]$表示一个空字符串A到B的前j个字符之间的距离 $dp[i][0]$表示一个空字符串B到字符串A的前i个字符之间的距离 $d[i,j]=min(d[i-1,j]+1 、d[i,j-1]+1、d[i-1,j-1]+temp)$ 这三个当中的最小值 $str1[i] == str2[j]$，表示相同, 用temp记录它，为0。否则temp记为1 $dp[i-1][j]$ 表示增加操作 $dp[i][j-1]$表示删除操作 $dp[i-1][j-1] + temp$表示替换操作 边界值 $dp[i][0]$ $dp[0][j]$ public static int minDistance(String word1, String word2) { int m = word1.length(); int n = word2.length(); int[][] dp = new int[m+1][n+1]; dp[0][0] = 0; // 初始化dp for(int i = 1; i&lt;=m; i++){ dp[i][0] = dp[i-1][0] + 1; } for(int j = 1; j&lt;=n; j++){ dp[0][j] = dp[0][j-1] + 1; } int temp = 0; // 转移方程: dp[i][j] = Math.min(dp[i-1][j-1]+temp, // dp[i][j-1]+1, dp[i-1][j]+1); for(int i = 1; i&lt;=m; i++){ for(int j = 1; j&lt;=n; j++){ // 因为我们的数组这只有效位从1开始 // 所以标记当前遍历到的字符串的位置为i-1|j-1 if(word1.charAt(i-1) == word2.charAt(j-1)){ temp = 0; }else { temp = 1; } dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]) + 1, dp[i-1][j-1] + temp); } } return dp[m][n]; } 337. 打家劫舍 III在树上偷。。。 使用后序遍历，定义一个二维数组 dp[0] : 不偷当前节点的结果 $dp[0] = Math.max(left[0], left[1]) + Math.max(rigth[0] + right[1])$ dp[1]：偷当前节点的结果 $dp[1] = root.val + left[0] + right[0]$ public int rob(TreeNode root) { int[] res = postOrder(root); return Math.max(res[0], res[1]); } private int[] postOrder(TreeNode root) { if (root == null) { return new int[2]; } int[] left = postOrder(root.left); int[] right = postOrder(root.right); int[] res = new int[2]; // 不偷当前节点 int first = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); // 偷当前节点 int second = root.val+left[0]+right[0]; res[0] = first; res[1] = second; return res; } 53. 最大子序和322. 零钱兑换518. 零钱兑换 II120 三角形最小路径和300 最长上升子序列354. 俄罗斯套娃信封最后的思路和最长上升子序列一样，不过在此之之前需要整理好数据 /** * 354 俄罗斯套娃信封 * 思路： 详见程序员代码面试指南216页 * @author weikunkun * @since 2021/4/2 */ public class LC_354 { public int maxEnvelopes(int[][] envelopes) { // 思路 // 封装一个信封对象，然后按照信封的宽度进行排序 小-大 // 如果宽度相同，按照高度排序 大到小 // 之后 对 高度序列 求最长递增子序列即可 Envelope[] array = genEnvelope(envelopes); int[] heights = genHeightArray(array); int[] dp = new int[heights.length]; Arrays.fill(dp, 1); int maxNumber = 0; for (int i = 0; i &lt; heights.length; i++) { int cur = heights[i]; int j = 0; int max = 0; while (j &lt; i) { if (heights[j] &lt; cur) { max = Math.max(max, dp[j]); } j++; } dp[i] = max + 1; maxNumber = Math.max(dp[i], maxNumber); } return maxNumber; } private Envelope[] genEnvelope(int[][] envelopes) { Envelope[] array = new Envelope[envelopes.length]; int i = 0; for (int[] envelope : envelopes) { Envelope env = new Envelope(envelope[0], envelope[1]); array[i++] = env; } Arrays.sort(array, new EnvelopComparetor()); return array; } private int[] genHeightArray(Envelope[] array) { int[] heights = new int[array.length]; int i = 0; for (Envelope envelope : array) { heights[i++] = envelope.height; } return heights; } } // 构建一个信封对象 class Envelope { public int wight; public int height; public Envelope(int wight, int height) { this.wight = wight; this.height = height; } } class EnvelopComparetor implements Comparator&lt;Envelope&gt; { @Override public int compare(Envelope o1, Envelope o2) { return o1.wight != o2.wight ? o1.wight - o2.wight : o2.height - o1.height; } } 64 最小路径和174 地下城游戏从下至上，然后每次当前位置的血量，为 dp[i+1][j+1] - dungeon[i][j] public int calculateMinimumHP(int[][] dungeon) { int[][] dp = new int[dungeon.length][dungeon[0].length]; int rows = dungeon.length; int cols = dungeon[0].length; dp[rows-1][cols-1] = Math.max(1-dungeon[rows-1][cols-1], 1); for (int i = rows-2; i &gt;= 0; i--) { dp[i][cols-1] = Math.max(1, dp[i+1][cols-1] - dungeon[i][cols-1]); } for (int i = cols-2; i &gt;= 0; i--) { dp[rows-1][i] = Math.max(1, dp[rows - 1][i + 1] - dungeon[rows-1][i]); } for (int i = rows - 2; i &gt;= 0; i--) { for (int j = cols - 2; j &gt;= 0; j--) { int min = Math.min(dp[i+1][j], dp[i][j+1]); dp[i][j] = Math.max(1, min - dungeon[i][j]); } } return dp[0][0]; } 62. 不同路径public int uniquePaths(int m, int n) { int[][] dp = new int[m][n]; dp[0][0] = 1; for(int i = 1; i &lt; m; i++) { dp[i][0] = 1; } for (int i = 1; i &lt; n; i++) { dp[0][i] = 1; } for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m-1][n-1]; } 63. 不同路径IIpublic int uniquePathsWithObstacles(int[][] obstacleGrid) { if (null == obstacleGrid || obstacleGrid.length == 0 || null == obstacleGrid[0] || obstacleGrid[0].length == 0) { return 0; } int m = obstacleGrid.length; int n = obstacleGrid[0].length; if (obstacleGrid[0][0] == 1) { return 0; } int[][] dp = new int[m][n]; dp[0][0] = 1; for(int i = 1; i &lt; m; i++) { if (obstacleGrid[i][0] == 1) { dp[i][0] = 0; break; } else { dp[i][0] = 1; } } for (int i = 1; i &lt; n; i++) { if (obstacleGrid[0][i] == 1) { dp[0][i] = 0; break; } else { dp[0][i] = 1; } } for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { if (obstacleGrid[i][j] == 0) { dp[i][j] = dp[i-1][j] + dp[i][j-1]; } else { dp[i][j] = 0; } } } return dp[m-1][n-1]; } 字符串系列72. 编辑距离这个在数组部分已经讲解过了。 32. 最长有效括号 确定dp数组，和索引下标意义 $dp[i]$ 表示 以s[i]结尾的最长有效括号 确定递归公式 s[i]是'('，以它为结尾的子串，肯定不是有效括号子串——dp[i] = 0 s[i]是')'， 以它为结尾的子串，分类讨论 s[i-1] == '(' dp[i] = dp[i-2] + 1; s[i-1] == ')' s[i-1]的最长子串为dp[i-1], 所以减去得s[i-dp[i-1]-1] s[i-dp[i-1]-1]不存在或为')'，则s[i]找不到匹配，直接gg——dp[i]=0 s[i-dp[i-1]-1]是'('，与s[i]匹配，有效长度 = 2 + 跨过的dp[i-1]+ 前方的dp[i-dp[i-1]-2]。等一下，s[i-dp[i-1]-2]要存在才行！ s[i-dp[i-1]-2]存在，dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2s[i-dp[i-1]-2]不存在，dp[i] = dp[i-1] + 2 public int longestValidParentheses(String s) { int maxans = 0; int[] dp = new int[s.length()]; for (int i = 1; i &lt; s.length(); i++) { if (s.charAt(i) == ')') { if (s.charAt(i - 1) == '(') { dp[i] = (i &gt;= 2 ? dp[i - 2] : 0) + 2; } else if (i - dp[i - 1] &gt; 0 &amp;&amp; s.charAt(i - dp[i - 1] - 1) == '(') { dp[i] = dp[i - 1] + ((i - dp[i - 1]) &gt;= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2; } maxans = Math.max(maxans, dp[i]); } } return maxans; } 115. 不同的子序列这道题感觉和编辑距离公式的思路差不多，不过，没有那么复杂，只需要考虑减这一个步骤即可。 还是那一个例子来说吧： 输入：S=\"bagbagbag\", T=\"bag\" 输出：5 Support/typora-user-images/image-20200907231246178.png 定义状态 $dp[i][j]$ 表示为$T$的前$i$个字符可以由$S$的前$j$个字符组成最多的个数 寻找状态转移方程 $S[i] == T[j]$ 取$S[i]$，那么当前情况总数，应该和字符串$S$的前$i-1$个字符所构成的子序列中出现字符串$T$的前$j-1$个字符的情况总数相等。$dp[i][j] = dp[i-1][j-1]$ 不取$S[i]$,那么当前情况总数，应该和字符串$S$的前$i$个字符所构成的子序列中出现字符串$T$的前$j-1$个字符的情况总数相等。$dp[i][j] = dp[i][j-1]$那么$dp[i][j]$应等于这两种情况的和。$dp[i][j] = dp[i-1][j-1] + dp[i][j-1]$ $S[i] != T[j]$ 只有一种情况，和$S[i] == T[j]$的第二种情况是一样的，因为当前不相等，也就不能取（图中蓝色框）。 $dp[i][j] = dp[i][j-1]$ 状态转移方程 $ dp[i][j]=\\left{ \\begin{array}{rcl} dp[i][j] = dp[i-1][j-1] + dp[i][j-1] &amp; &amp; {S[i] == T[j]}\\ dp[i][j]=dp[i][j-1] &amp; &amp; {S[i] != T[j]} \\end{array} \\right. $ 确定边界值 $dp[0][j]=1$，此时表示为T==NULL，也就是空字符串T可以由非空的S组成的最多的个数，很明显为1。 $dp[i][0] = 0$，此时表示为S==NULL，也就是非空字符串T可以由空的字符串S组成的最多的个数，很明显为0。 public int numDistinct(String s, String t) { int m = s.length(); int n = t.length(); int[][] dp = new int[n + 1][m + 1]; dp[0][0] = 1; for (int i = 1; i &lt;= n; i++) { dp[i][0] = 0; } for (int i = 1; i &lt;= m; i++) { dp[0][i] = 1; } // 注意i和j和题解上的是相反的 for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if (t.charAt(i - 1) == s.charAt(j - 1)) { dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1]; } else { dp[i][j] = dp[i][j - 1]; } } } return dp[n][m]; } 1143. 最长公共子序列思路和编辑距离差不多，编辑距离返回最后的结果，这里需要遍历整个dp矩阵，返回最大。 /** * 首先定义好第一行和第一列 * 假设 行 text2 * 假设 列 text1 * 对于行： text1[0] 和text2[i]中任意一位置字符相同，则i-len位置为1 * 对于列： 同理 * 非首行和首列： 1. dp[i-1][j] dp[i][j-1] dp[i-1][j-1]+1 最大 * @param text1 * @param text2 * @return */ public int longestCommonSubsequence(String text1, String text2) { int[][] dp = new int[text1.length()][text2.length()]; int max = 0; // 初始化行 // 初始化列 // 遍历整个 int rows = dp.length; int cols = dp[0].length; dp[0][0] = text1.charAt(0) == text2.charAt(0) ? 1 : 0; for (int i = 1; i &lt; rows; i++) { dp[i][0] = Math.max(dp[i-1][0], text1.charAt(i) == text2.charAt(0) ? 1 : 0); max = Math.max(dp[i][0], max); } for (int i = 1; i &lt; cols; i++) { dp[0][i] = Math.max(dp[0][i-1], text1.charAt(0) == text2.charAt(i) ? 1 : 0); max = Math.max(dp[0][i], max); } for (int i = 1; i &lt; rows; i++) { for (int j = 1; j &lt; cols; j++) { dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); if (text2.charAt(j) == text1.charAt(i)) { dp[i][j] = Math.max(dp[i][j], dp[i-1][j-1] + 1); } max = Math.max(dp[i][j], max); } } return max; } 最长公共子串找到了和公共子串类似的数组，就拿着替代一下 image-20210413155100877 public int findLengthII(int[] nums1, int[] nums2) { int len1 = nums1.length; int len2 = nums2.length; int[][] dp = new int[len1][len2]; // // if nums1[i] == nums2[j] dp[i][j] = dp[i-1][j-1] + 1; // else dp[i][j] = 0; int max = 0; for (int i = 0; i &lt; len1; i++) { if (nums1[i] == nums2[0]) { dp[i][0] = 1; max = Math.max(max, dp[i][0]); } } for (int i = 0; i &lt; len2; i++) { if (nums2[i] == nums1[0]) { dp[0][i] = 1; max = Math.max(max, dp[0][i]); } } for (int i = 1; i &lt; len1; i++) { for (int j = 1; j &lt; len2; j++) { if (nums1[i] == nums2[j]) { dp[i][j] = dp[i-1][j-1] + 1; max = Math.max(dp[i][j], max); } } } return max; } 字符串交错组成class Solution { public boolean isInterleave(String s1, String s2, String s3) { int n = s1.length(), m = s2.length(), t = s3.length(); if (n + m != t) { return false; } boolean[][] f = new boolean[n + 1][m + 1]; f[0][0] = true; for (int i = 0; i &lt;= n; ++i) { for (int j = 0; j &lt;= m; ++j) { int p = i + j - 1; if (i &gt; 0) { f[i][j] = f[i][j] || (f[i - 1][j] &amp;&amp; s1.charAt(i - 1) == s3.charAt(p)); } if (j &gt; 0) { f[i][j] = f[i][j] || (f[i][j - 1] &amp;&amp; s2.charAt(j - 1) == s3.charAt(p)); } } } return f[n][m]; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://winniekun.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"}]},{"title":"死磕单调栈","slug":"LeetCode/stick-to-monotonicity-stack","date":"2020-06-14T11:56:11.000Z","updated":"2021-05-16T16:40:37.343Z","comments":true,"path":"stick-to-monotonicity-stack/","link":"","permalink":"https://winniekun.github.io/stick-to-monotonicity-stack/","excerpt":"","text":"单调栈前几天刷每日一题的时候, 遇到了一个很有趣的题, 刚开始自己直接暴力AC了, 然后优化的时候, 发现了单调栈这么个特殊的数据结构, 很有趣. 首先, 单调栈的作用范围不大, 只适合用来做一类题目—Next Greater Element 题目接雨水思路参考甜姨题解 public int trap(int[] height) { // 思路 维护一个最小栈 if (height == null || height.length == 0) { return 0; } int ans = 0; Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; height.length; i++) { while (!stack.isEmpty() &amp;&amp; height[stack.peek()] &lt; height[i]) { int curIdx = stack.pop(); while(!stack.isEmpty() &amp;&amp; height[stack.peek()] == height[curIdx]) { stack.pop(); } if (!stack.isEmpty()) { int left = stack.peek(); int len = i - left -1 ; int high = Math.min(height[i], height[left]) - height[curIdx]; ans += len * high; } } stack.push(i); } return ans; }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"单调栈","slug":"单调栈","permalink":"https://winniekun.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"排序算法总结","slug":"算法/排序/sorting-algorithms-summary","date":"2020-06-10T05:30:17.000Z","updated":"2021-06-30T16:47:34.280Z","comments":true,"path":"sorting-algorithms-summary/","link":"","permalink":"https://winniekun.github.io/sorting-algorithms-summary/","excerpt":"排序算法总结","text":"排序算法总结 常用排序算法 时间复杂度 空间复杂度 是否为稳定排序 是否为原地排序 直接插入排序 $O(n^2)$ $O(1)$ ✔ ✔ 折半插入排序 $ O(n^2)$ (只优化了比较的过程) $O(1)$ ✔ ✔ 希尔排序 和增量有关，最坏$O(n^2)$ $O(1)$ ❌ ✔ 冒泡排序 $O(n^2)$ $O(1)$ ✔ ✔ 快速排序 $O(nlog_2n)$ $O(log_2n)$ ❌ ✔ 简单选择排序 $O(n^2)$ $O(1)$ ❌ ✔ 堆排序 $O(nlog_2n)$ $O(1)$ ❌ ✔ 归并排序 $O(nlog_2n)$ $O(n)$ ✔ ❌ ==基数排序== $O(dn) d是位数$ $O(d)$ ✔ ❌ ==桶排序== $O(n+k)$ k为桶个数，n为元素数量 $O(n+k)$ ✔ ❌ References 严版数据结构 数据结构与算法之美","categories":[{"name":"排序","slug":"排序","permalink":"https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[]},{"title":"lock","slug":"Java进阶/并发/lock","date":"2020-05-30T02:26:14.000Z","updated":"2020-08-30T04:50:22.248Z","comments":true,"path":"lock/","link":"","permalink":"https://winniekun.github.io/lock/","excerpt":"简介","text":"简介 锁用来控制多个线程的同步访问共享资源, 一个锁可以防止多个线程同时访问共享资源(读写锁允许多个线程并发访问共享资源), 在Java中, 内置锁—-基于对象的锁 , 它一般是配合synchronized关键字使用的, 同时synchronized的一系列优化 , 衍生出了偏向锁 , 轻量级锁, 重量级锁. 同时在java.util.concurrent.locks包下, 还提供了几个关于锁的接口, 抽象类及具体是实现的锁. 他们的拥有更高的灵活性和更加强大的功能. 基础使用 Lock lock = new ReentraLock(); lock.lock(); try{ // 业务逻辑 }final{ // 释放锁 lock.unlock() } 锁的分类锁可以根据以下几种方式来进行分类. 当然还有其他类型的锁类型, 如: 公平锁, 非公平锁; 偏向锁, 轻量级锁, 重量级锁; 乐观锁, 悲观锁; 重入锁和非重入锁能否重新进入锁, 也就是说锁支持一个线程对资源重复加锁. synchronized关键字就是使用的重入锁。比如说，你在一个synchronized实例方法里面调用另一个本实例的synchronized实例方法，它可以重新进入这个锁，不会出现任何异常。 公平锁和非公平锁公平和非公平的通俗意义就是FIFO先来后到 , 对于一个锁来说, 先对锁请求的线程会先被满足, 后对锁发起请求的线程会后被满足, 其就是公平锁 一般情况下，非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况。所以要根据实际的需求来选择非公平锁和公平锁。 读写锁和排它锁synchronized用的锁和ReentrantLock 都是排它锁, 也就是同一时刻仅允许一个线程访问资源 读写锁允许同一时刻多个线程并发访问资源, 其内部维护了一个读锁和写锁 通过分离读锁和写锁，使得在“读多写少”的环境下，大大地提高了性能。(操作系统中的读写者问题) juc.locks包 locks包一览 接口: Lock ReadWriteLock ConditionLock获取锁和释放锁的方法声明 public interface Lock { void lock(); void unlock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; Condition newCondition(); } ReadWriteLock返回读锁和写锁 public interface ReadWriteLock { /** * Returns the lock used for reading. * * @return the lock used for reading */ Lock readLock(); /** * Returns the lock used for writing. * * @return the lock used for writing */ Lock writeLock(); } Condition感觉和Object类中的wait和notify/notifyAll机制很像, 不过更加高端吧 public interface Condition { void await() throws InterruptedException; boolean await(long time, TimeUnit unit) throws InterruptedException; long awaitNanos(long nanosTimeout) throws InterruptedException; void awaitUninterruptibly(); boolean awaitUntil(Date deadline) throws InterruptedException; void signal(); void signalAll(); } 看下两者的区别吧 对比项 Object监视器 Condition 前置条件 获取对象的锁 调用Lock.lock获取锁，调用Lock.newCondition获取Condition对象 调用方式 直接调用，比如object.notify() 直接调用，比如condition.await() 等待队列的个数 一个 多个 当前线程释放锁进入等待状态 支持 支持 当前线程释放锁进入等待状态，在等待状态中不中断 不支持 支持 当前线程释放锁并进入超时等待状态 支持 支持 当前线程释放锁并进入等待状态直到将来的某个时间 不支持 支持 唤醒等待队列中的一个线程 支持 支持 唤醒等待队列中的全部线程 支持 支持 抽象类: AQS AQLS AOSAQS之前已经细讲了, AQLS和AQS实现原理一样, 只不过 state类型改为了long AOS是AQS和AQLS的父类, 根据源码可以推测出, 其作用是表示锁和持有者(线程)的关系 AOS public abstract class AbstractOwnableSynchronizer implements java.io.Serializable { /** Use serial ID even though all fields transient. */ private static final long serialVersionUID = 3737899427754241961L; /** * Empty constructor for use by subclasses. */ protected AbstractOwnableSynchronizer() { } /** * 独占模式，锁的持有者 */ private transient Thread exclusiveOwnerThread; /** * 设置锁持有者 */ protected final void setExclusiveOwnerThread(Thread thread) { exclusiveOwnerThread = thread; } /** * 获取锁的持有线程 */ protected final Thread getExclusiveOwnerThread() { return exclusiveOwnerThread; } } 具体实现类ReentrantLock之前讲过的重入锁和非重入锁以及公平锁和非公平锁在ReentrantLock均涉及到了. 我们可以根据源码看下具体的实现方式 public class ReentrantLock implements Lock, java.io.Serializable { private static final long serialVersionUID = 7373984872572414699L; /** Synchronizer providing all implementation mechanics */ private final Sync sync; abstract static class Sync extends AbstractQueuedSynchronizer { // 具体实现 } /** * Sync object for non-fair locks */ static final class NonfairSync extends Sync { // 具体实现 } /** * Sync object for fair locks */ static final class FairSync extends Sync { // 具体实现 } public ReentrantLock() { sync = new NonfairSync(); } public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } // Lock接口的方法实现 ... // 自己一些逻辑 ... public final boolean isFair() { return sync instanceof FairSync; } } 从整体上看, ReentrantLock有一个抽象内部类Sync继承AQS, 用于实现自己的同步器, 同时有两个非抽象内部类NonfairSync和FairSync, 继承了Sync, 从字面意思来看, 就是公平同步器和非公平同步容器 这意味着, ReentrantLock支持公平锁和非公平锁, 在构造函数里面可以传入一个boolean类型的参数，来指定它是否是一个公平锁，默认情况下是非公平的。这个参数一旦实例化后就不能修改，只能通过isFair()方法来查看。 我们来看下非公平锁实现的实现, 走一遍流程: abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = -5179523762034025860L; abstract void lock(); // 非公平的获取资源 final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); // 资源可用 if (c == 0) { if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } // 若是当前线程已经获取了锁 可重入 else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; } return false; } // other method } 在实现非公平锁的同时, 通过增加了再次获取资源的处理逻辑实现了可重入锁: 判断当前线程是否为获取锁的线程 来判断操作是否成功, 如果是同一线程, 则同步状态值进行增加并返回true 表示获取同步成功. 那么同理, 释放锁在释放同步状态的时候, 减少同步状态值, 为0 则表示释放完全 protected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) { free = true; // 全部释放的话直接把独占线程设置为null setExclusiveOwnerThread(null); } setState(c); return free; } 非公平锁的实现, 就是后申请资源的线程和先申请资源的线程一样, 谁能通过compareAndSetState设置成功, 则开始执行任务. ReentrantReadWriteLock它与ReentrantLock的功能类似，同样是可重入的，支持非公平锁和公平锁。不同的是，它还支持”读写锁“。 // 内部结构 private final ReentrantReadWriteLock.ReadLock readerLock; private final ReentrantReadWriteLock.WriteLock writerLock; final Sync sync; abstract static class Sync extends AbstractQueuedSynchronizer { // 具体实现 } static final class NonfairSync extends Sync { // 具体实现 } static final class FairSync extends Sync { // 具体实现 } public static class ReadLock implements Lock, java.io.Serializable { private final Sync sync; protected ReadLock(ReentrantReadWriteLock lock) { sync = lock.sync; } // 具体实现 } public static class WriteLock implements Lock, java.io.Serializable { private final Sync sync; protected WriteLock(ReentrantReadWriteLock lock) { sync = lock.sync; } // 具体实现 } // 构造方法，初始化两个锁 public ReentrantReadWriteLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); readerLock = new ReadLock(this); writerLock = new WriteLock(this); } // 获取读锁和写锁的方法 public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; } public ReentrantReadWriteLock.ReadLock readLock() { return readerLock; } ReentrantReadWriteLock实现了读写锁，但它有一个小弊端，就是在“写”操作的时候，其它线程不能写也不能读。我们称这种现象为写饥饿. StampedLockStampedLock类是在Java 8 才发布的，也是Doug Lea大神所写，有人号称它为锁的性能之王。它没有实现Lock接口和ReadWriteLock接口，但它其实是实现了“读写锁”的功能，并且性能比ReentrantReadWriteLock更高。StampedLock还把读锁分为了“乐观读锁”和“悲观读锁”两种。 等有大段时间的时候, 再好好分析源码 References Java并发编程的艺术 深入浅出Java多线程","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://winniekun.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"锁","slug":"锁","permalink":"https://winniekun.github.io/tags/%E9%94%81/"}]},{"title":"cas","slug":"Java进阶/并发/cas","date":"2020-05-28T03:45:05.000Z","updated":"2021-03-30T11:24:56.012Z","comments":true,"path":"cas/","link":"","permalink":"https://winniekun.github.io/cas/","excerpt":"CAS概念","text":"CAS概念 CAS ，Compare And Swap ，即比较并交换。Doug Lea 大神在实现同步组件时，大量使用CAS 技术，鬼斧神工地实现了Java 多线程的并发操作。整个 AQS 同步组件、Atomic 原子类操作等等都是基 CAS 实现的，甚至 ConcurrentHashMap 在 JDK 1.8 的版本中，也调整为 CAS + synchronized 。可以说，CAS 是整个 J.U.C 的基石。 CAS 在CAS中，有这样三个值： V：要更新的变量(var) E：预期值(expected)/原值(old value) N：新值(new) 比较并交换的过程如下： 判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。 所以这里的预期值E本质上指的是“旧值”。 我们以一个简单的例子来解释这个过程： 如果有一个多个线程共享的变量i原本等于5，我现在在线程A中，想把它设置为新的值6; 我们使用CAS来做这个事情； 首先我们用i去与5对比，发现它等于5，说明没有被其它线程改过，那我就把它设置为新的值6，此次CAS成功，i的值被设置成了6； 如果不等于5，说明i被其它线程改过了（比如现在i的值为2），那么我就什么也不做，此次CAS失败，i的值仍然为2。 在这个例子中，i就是V，5就是E，6就是N。 那有没有可能我在判断了i为5之后，正准备更新它的新值的时候，被其它线程更改了i的值呢？ 不会的。因为CAS是一种原子操作，它是一种系统原语，是一条CPU的原子指令，从CPU层面保证它的原子性 当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。 CAS 的实现Java实现CAS的原理 - Unsafe类在Java中, 如果有一个方法是native的, 那么Java不负责实现它, 而是交由底层的JVM使用C或C++去实现. 在Java中有一个Unsafe类, 位于sun.misc包中, 里面是native方法, 其中有几个关于CAS的 public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5); public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6); J.U.C 下的 Atomic 类，都是通过 CAS 来实现的, 以AtomicInteger为例子, 阐述CAS的实现 AtomicInteger// setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); } catch (Exception ex) { throw new Error(ex); } } private volatile int value; Unsafe 是 CAS 的核心类，Java 无法直接访问底层操作系统，而是通过本地 native 方法来访问。不过尽管如此，JVM还是开了一个后门：Unsafe ，它提供了硬件级别的原子操作。 valueOffset 为变量值在内存中的偏移地址，Unsafe 就是通过偏移地址来得到数据的原值的。 value 当前值，使用 volatile 修饰，保证多线程环境下看见的是同一个。 // AtomicInterger类 public final int addAndGet(int delta) { return unsafe.getAndAddInt(this, valueOffset, delta) + delta; } // Unsafe(核心) CAS的具体实现 public final int getAndAddInt(Object var1, long var2, int var4) { int var5; do { // 放入do内, 时刻获取最新的期望值(期望值在多线程中会被其他的线程修改) var5 = this.getIntVolatile(var1, var2); } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; } // Unsafe // var1: 对象 // var2: 对象地址 // var4: 预期值 // var5: 新值 public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); CAS是无锁的基础，它允许更新失败。所以经常会与while循环搭配，在失败后不断去重试。 getAndInt()方法, 其返回的值是预期值(E), 也就是旧值, 新值(N)是var5+var4 这里使用的是do-while循环。这种循环不多见，它的目的是保证循环体内的语句至少会被执行一遍。这样才能保证return 的值v是我们期望的值。 The difference between do-while and while is that do-while evaluates its expression at the bottom of the loop instead of the top. Therefore, the statements within the do block are always executed at least once. Java Documents CAS实现原子操作的三大问题&amp;解决方案CAS 虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方面： 循环时间太长 只能保证一个共享变量原子操作 ABA 问题 循环时间过长 如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋 CAS 长时间地不成功，则会给 CPU 带来非常大的开销。在 J.U.C 中，有些地方就限制了 CAS 自旋的次数，例如： BlockingQueue 的 SynchronousQueue 。 只能保证一个共享变量原子操作 使用JDK 1.5开始就提供的AtomicReference类保证对象之间的原子性，把多个变量放到一个对象里面进行CAS操作； 使用锁。锁内的临界区代码可以保证只有当前线程能操作。 ABA问题所谓的ABA问题就是, 一个值原先是A, 然后改为B, 后面又改为A, 之后用CAS进行检测是检测不出来的. 但是实际上是更新了两次. 解决该问题通常是在变量前面追加版本号或者时间戳. 从JDK 1.5开始，JDK的atomic包里提供了一个类AtomicStampedReference类来解决ABA问题。 References 深入分析CAS CAS与原子操作","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://winniekun.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"剑指offer题解","slug":"LeetCode/coding-interviews","date":"2020-05-28T02:37:49.000Z","updated":"2021-07-05T05:19:16.366Z","comments":true,"path":"coding-interviews/","link":"","permalink":"https://winniekun.github.io/coding-interviews/","excerpt":"数据结构类题目","text":"数据结构类题目 Array 面试题3: 数组中重复的数字 面试题4: 二维数组中的查找 面试题11: 旋转数组中的最小数字 面试题21: 调整数组顺序使奇数位于偶数前面 面试题29: 顺时针打印矩阵 面试题39: 数组中出现次数操作一半的数字 面试题42: 连续子数组的最大和 面试题45: 把数组排成最小的数 面试题47: 礼物的最大值 面试题51: 数组中的逆序对 面试题53: 在排序数组中查找数字 面试题53-I: 在排序数组中查找数字I 面试题53-II: 0 ~ n-1 中缺失的数字 面试题56: 数组中数字出现的次数 面试题66: 构建乘积数组 LinkedList 面试题6：从尾到头打印链表 面试题18：删除链表的节点 面试题22：链表中倒数第k个结点 面试题23：链表中环的入口节点 面试题24：反转链表 面试题25：合并两个或k个有序链表 面试题35：复杂链表的复制 面试题36： 二叉搜索树与双向链表 面试题52：两个链表的第一个公共结点 面试题56：删除链表中重复的结点 Tree 面试题7：重建二叉树 面试题26：树的子结构 面试题27：二叉树的镜像 面试题28：对称的二叉树 面试题32-I：从上到下打印二叉树 面试题32-II：从上到下打印二叉树 II 面试题32-III：从上到下打印二叉树 III 面试题33：二叉搜索树的后序遍历序列 面试题34： 二叉树中和为某一值的路径 面试题36：二叉搜索树与双向链表 面试题37：序列化二叉树 面试题54：二叉搜索树的第k大节点 面试题55-I： 二叉树的深度 面试题55-II：平衡二叉树 面试题68-I：二叉搜索树的最近公共祖先 面试题68-II：二叉树的最近公共祖先 Stack &amp; Queue 面试题9：用两个栈实现队列 面试题9-I: 两个队列实现栈 面试题30：包含min函数的栈 面试题31：栈的压入、弹出序列 面试题58-I：翻转单词顺序 面试题59-I：滑动窗口的最大值 Heap 面试题29: 最小的k个数 面试题41: 数据流中的中位数 Hash Table 面试题3: 数组中重复的数字 图 面试题12: 矩阵中的路径 面试题13: 机器人的运动范围 具体算法类题目搜索算法 面试题4: 二维数组中的查找 面试题11: 旋转数组的最小数字 面试题39: 数组中出现次数超过一半的数字 动态规划 面试题10-I: 10- I. 斐波那契数列 面试题10-II: 10- II. 青蛙跳台阶问题 面试题19: 19. 正则表达式匹配 面试题42: 42. 连续子数组的最大和 面试题46: 46. 把数字翻译成字符串 面试题47: 47. 礼物的最大价值 面试题48: 48. 最长不含重复字符的子字符串 面试题49: 49. 丑数 面试题60: 60. n 个骰子的点数 面试题63: 63. 股票的最大利润 回溯 面试题12: 矩阵中的路径 面试题13: 机器人的运动范围 排序 面试题29: 最小的k个数 (堆排序) 面试题39: 数组中出现次数超过一半的数字 (快排序) 面试题51: 数组中的逆序对(归并排序) 位运算 面试题15: 二进制中1的个数 面试题56-I: 数组中数字出现的次数 面试题56-II: 数组中数字出现的次数 II 刷题记录面试题3-I：数组中重复的数字题目一：找出数组中的重复数字方法一: 排序之后 查找排序，之后遇到有重复的返回该数字即可 时间复杂度： O(nlogn) 空间复杂度：O(1) // 内置排序算法 public int findRepeatNumber(int[] arrays) { Arrays.sort(arrays); int t = 0; for (int i = 0; i &lt; arrays.length-1; i++) { if (arrays[i] == arrays[i + 1]) { t = arrays[i]; } } return t; } // 使用快排 public int findRepeatNumber(int[] nums) { quickSort(nums); for(int i = 1; i&lt;nums.length; i++){ if(nums[i] == nums[i-1]){ return nums[i]; } } return -1; } private void quickSort(int[] nums){ quickSort(nums, 0, nums.length-1); } private void quickSort(int[] nums, int low, int high){ if(low &gt; high){ return; } else{ int position = patition(nums, low, high); quickSort(nums, low, position-1); quickSort(nums, position+1, high); } } private int patition(int[] nums, int low, int high){ int position = nums[low]; while(low &lt; high){ while(low &lt; high &amp;&amp; nums[high] &gt;= position){ high--; } nums[low] = nums[high]; while(low &lt; high &amp;&amp; nums[low] &lt;= position){ low++; } nums[high] = nums[low]; } nums[low] = position; return low; } 方法二: 散列表 将所有的元素当做key存如散列表，value表示key出现的个数 public int findRepeatNumber(int[] nums) { int a = 0; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i : nums) { if (map.containsKey(i)) { Integer integer = map.get(i); integer += 1; a = i; } else { map.put(i, 0); } } return a; } 方法三: 位图 具体可参见编程珠玑或算法新解 面试题3-II：不修改数组，找出重复的数字二分查找287. 寻找重复数 public int findDuplicate(int[] nums) { int i = 0; int j = nums.length - 1; while( i &lt; j ){ // j = mid // 所以 mid = (i+j)/2 // 若果i = mid // 则 mid = (i + j + 1)/2 int mid = (i + j) /2; int count = 0; // 统计小于中值的数量 for(int num : nums){ if(num &lt;= mid){ count++; } } // 如果统计出的数量&gt;中值 // 重复的元素可定出现在i~mid区间, 所以mid+1~j区间就可以不用考虑了 if(count &gt; mid){ j = mid; }else { i = mid + 1; } } return i; } 面试题4：二维数组查找从左下角开始 public boolean findNumberIn2DArray(int[][] matrix, int target) { int m = matrix.length -1; int n = 0; while(m &gt;= 0 &amp;&amp; n&lt;=matrix[0].length-1){ if(matrix[m][n] &lt; target){ n++; }else if(matrix[m][n] &gt; target){ m--; } else { return true; } } return false; } 面试题5：替换空格public String replaceSpace(String s) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; s.length(); i++) { if(s.charAt(i) == ' '){ sb.append(\"%20\"); } else{ sb.append(s.charAt(i)); } } return sb.toString(); } 面试题6：从尾到头打印链表public int[] reversePrint(ListNode head) { // 使用栈 ListNode p = head; Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); while (p != null){ stack.push(p); p = p.next; } int[] res = new int[stack.size()]; int i = 0; while (!stack.isEmpty()){ res[i++] = stack.pop().val; } return res; } // 头插法重新构造链表 然后依次放入 public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) { ListNode dummy = new ListNode(-1); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(listNode != null){ ListNode temp = listNode.next; listNode.next = dummy.next; dummy.next = listNode; listNode = temp; } listNode = dummy.next; while(listNode != null){ list.add(listNode.val); listNode = listNode.next; } return list; } 面试题7： 重建二叉树public static TreeNode buildTree(int[] preorder, int[] inorder) { Map&lt;Integer, Integer&gt; inMap = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; inorder.length; i++) { inMap.put(inorder[i], i); } TreeNode root = buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, inMap); return root; } public static TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd, Map&lt;Integer, Integer&gt; inMap) { if (preStart &gt; preEnd) { return null; } TreeNode root = new TreeNode(preorder[preStart]); // 当前根节点所在中序遍历位置 int inRoot = inMap.get(root.val); // 该根节点左边子节点的个数 int numsLeft = inRoot - inStart; root.left = buildTree(preorder, preStart + 1, preStart + numsLeft, inorder, inStart, inRoot - 1, inMap); root.right = buildTree(preorder, preStart + numsLeft + 1 , preEnd, inorder, inRoot + 1, inEnd, inMap); return root; } 面试题8： 二叉树的下一个节点面试题9： 两个栈实现队列// 使用两个栈实现队列 Deque&lt;Integer&gt; A, B; public interview9() { A = new ArrayDeque&lt;&gt;(); B = new ArrayDeque&lt;&gt;(); } public void appendTail(int value) { A.push(value); } public int deleteHead() { if (!B.isEmpty()) { return B.removeLast(); } // 表明两个栈都为空了, 所以没有能返回的值了 if (A.isEmpty()) { return -1; } while (!A.isEmpty()) { B.addLast(A.removeLast()); } return B.removeLast(); } 面试题10： 斐波那契数列方法一：递归 方法二：DP 题目二：青蛙跳台阶题目三： 矩阵覆盖面试题11： 旋转数组中的最小数字二分查找, 注意元素会重复 public int minArray(int[] numbers) { int i = 0; int j = numbers.length -1; while(i &lt; j){ int mid = (i + j )/2; if(numbers[mid] &gt; numbers[j]){ i = mid + 1; }else if(numbers[mid] &lt; numbers[j]){ j = mid; }else { j -= 1; } } return numbers[i]; } 面试题12：矩阵中的路径public boolean exist(char[][] matrix, String str) { int n = matrix.length; int m = matrix[0].length; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (hasPathCore(matrix, str, 0, i, j)) { return true; } } } return false; } public boolean hasPathCore(char[][] matrix, String str, int start, int row, int col) { int n = matrix.length; int m = matrix[0].length; if (start == str.length()) { return true; } if (row &lt; 0 || row &gt;= n || col &lt; 0 || col &gt;= m || matrix[row][col] != str.charAt(start)) { return false; } char c = matrix[row][col]; matrix[row][col] = ' '; boolean result = hasPathCore(matrix, str, start + 1, row + 1, col) || hasPathCore(matrix, str, start + 1, row - 1, col) || hasPathCore(matrix, str, start + 1, row, col + 1) || hasPathCore(matrix, str, start + 1, row, col - 1); matrix[row][col] = c; return result; } 面试题13：机器人的运动范围private int count = 0; public int movingCount(int m, int n, int k) { boolean[][] vistied = new boolean[m][n]; visit(vistied, k, m, n, 0, 0); return count; } public void visit(boolean visited[][], int k , int m, int n, int i, int j){ if(i &lt;0 || i&gt;=m || j &lt; 0 || j&gt;= n || visited[i][j] || cal(i, j) &gt; k){ return; } visited[i][j] = true; count++; visit(visited, k, m, n, i+1, j); visit(visited, k, m, n, i-1, j); visit(visited, k, m, n, i, j+1); visit(visited, k, m, n, i, j -1); } private int cal(int i, int j) { int calI = calculate(i); int calJ = calculate(j); return calI + calJ; } private int calculate(int num){ int sum = 0; while (num != 0){ sum += (num%10); num /= 10; } return sum; } 面试题14：剪绳子动态规划 //理解不好 public int cuttingRope(int n) { if (n &lt;= 3) { return n - 1; } int a = n / 3; int b = n % 3; if (b == 0) { return (int) Math.pow(3, a); } else if (b == 1) { return (int) (Math.pow(3, a - 1) * 4); } return (int) Math.pow(3, a) * 2; } public int cuttingRopeII(int n) { int[] dp = new int[n+1]; if(n&lt;=1){ return 0; } if(n==2){ return 1; } if(n==3){ return 2; } dp[0] = 0; dp[1] = 1; dp[2] = 2; dp[3] = 3; int max = 0; int temp = 0; for(int i = 4; i&lt;=n; i++){ for(int k=1; k&lt;=i/2; k++){ temp = dp[k] * dp[i-k]; if(max &lt; temp){ max = temp; } } dp[i] = max; } return dp[n]; } 面试题15：二进制中1个个数public static int numberOf2(int n){ // n &amp; (n - 1) 会消除 n 中最后一位中的 1。 int res = 0; while (n != 0){ n &amp;= (n-1); res++; } return res; } 面试题16：数值的整数次方面试题17：打印从1到最大的n位整数public int[] printNumbers(int n ){ int nums = (int) Math.pow(10, n); int[] res = new int[nums-1]; for (int i = 0; i &lt; nums-1; i++) { res[i] = i+1; } return res; } 面试题18：删除链表的节点public static ListNode deleteNode(ListNode head, ListNode q) { ListNode dummy = new ListNode(-1); if (head == null) { return null; } dummy.next = head; ListNode pre = dummy; ListNode p = head; while (p != null) { if (p == q) { pre.next = p.next; p = pre.next; } else { pre = p; p = p.next; } } return dummy.next; } 面试题19：正则表达式匹配还没理好 面试题20：表示数值的字符串按照题目提示写就是了 .: .之前不能出现.和e e: e之前不能出现e, 且前一位必须是数字,且后面必须还要有数字 +/-: +/-只能出现在0位置或者e后面 public static boolean isNumber(String s) { if(s == null || s.length() == 0){ return false; } boolean res = true; boolean isNums = false; boolean isDot = false; boolean isE = false; String trim = s.trim(); for (int i = 0; i &lt; trim.length(); i++) { if (trim.charAt(i) &lt;= '9' &amp;&amp; trim.charAt(i) &gt;= '0') { isNums = true; } else if (trim.charAt(i) == 'e' || trim.charAt(i) == 'E') { if (!isNums || isE) { return false; } isE = true; // 防止出现12e的情况(不能表示数字) isNums = false; } else if (trim.charAt(i) == '.') { if (isE || isDot) { return false; } isDot = true; } else if (trim.charAt(i) == '+' || trim.charAt(i) == '-') { if (i != 0 &amp;&amp; trim.charAt(i - 1) != 'E' &amp;&amp; trim.charAt(i - 1) != 'e') { return false; } } else { return false; } } return isNums; } 面试题21：调整数组顺序使奇数位于偶数前面// 最直白的做法，依次遍历，然后遇到偶数的时候 // 后面的元素调前面，该元素放置末尾 public int[] exchange(int[] nums) { if (nums == null || nums.length &lt; 2) { return nums; } int left = 0; int right = nums.length - 1; int temp[] = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) { if ((nums[i] &amp; 1) == 0) {//偶数 temp[right--] = nums[i]; } else {//奇数 temp[left++] = nums[i]; } } return temp; } // 双指针方法 public static int[] exchangeII(int[] nums) { int p = 0; int q = nums.length - 1; while (p &lt; q) { while (p &lt; q &amp;&amp; nums[p] % 2 == 0) { if(nums[q] %2 == 1){ int temp = nums[p]; nums[p] = nums[q]; nums[q] = temp; p++; q--; }else if(nums[q] %2 == 0){ q--; } } while (p &lt; q &amp;&amp; nums[p]%2 == 1){ p++; } } return nums; } // 上面的逻辑 是基于正常交换逻辑 // 但是是依次处理， 可以先假设符合条件， 之后将不符合条件的一一处理 // 类似快排的枢轴处理 // 代码的可读性更高 public static int[] exchangeIII(int[] nums){ int pBegin = 0; int pRear = nums.length-1; while (pBegin &lt; pRear){ while (pBegin &lt; pRear &amp;&amp; nums[pBegin]%2 == 1){ pBegin ++; } while (pBegin &lt; pRear &amp;&amp; nums[pRear] %2 == 0){ pRear--; } if(pBegin &lt; pRear){ int temp = nums[pBegin]; nums[pBegin] = nums[pRear]; nums[pRear] = temp; } } return nums; } 面试题22：链表中倒数第K个节点// 遍历两次链表 public static ListNode getKthFromEnd(ListNode head, int k){ if(head==null){ return null; } int length = getLength(head); if(k&gt;length){ return null; } if(k==length){ return head; } ListNode preNode = getPreNode(head, length - k); return preNode.next; } private static ListNode getPreNode(ListNode head, int preK){ while (preK &gt; 1){ head = head.next; preK--; } return head; } private static int getLength(ListNode head){ int length = 0; while (head != null){ head = head.next; length ++; } return length; } // 双指针解决 public static ListNode getKthFromEndII(ListNode head, int k){ if(head == null || k==0){ return null; } ListNode fast = head; ListNode slow = head; while (k-1 &gt; 0){ fast = fast.next; k--; } while (fast.next != null){ fast = fast.next; slow = slow.next; } return slow; } 面试题23：链表中环的入口节点双指针之快慢指针 public ListNode meetingNode(ListNode head) { ListNode entry = null; if (head == null) { return entry; } ListNode fast = head; ListNode slow = head; while (fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { ListNode slowII = head; while (slow != slowII) { slowII = slowII.next; slow = slowII.next; } return slow; } } return null; } 面试题24：反转链表头插法 public static ListNode reverseList(ListNode head){ ListNode dummmy = new ListNode(-1); ListNode p = head; while (p != null){ ListNode temp = p.next; p.next = dummmy.next; dummmy.next = p; p = temp; } return dummmy.next; } 面试题25： 合并两个排序的链表// 尾插法 public ListNode mergeTwoLists(ListNode l1, ListNode l2){ ListNode dummy = new ListNode(-1); ListNode rear = dummy; while (l1!= null &amp;&amp; l2!= null){ if(l1.value &lt;= l2.value){ rear.next = l1; l1 = l1.next; }else { rear.next = l2; l2 = l2.next; } rear = rear.next; } if (l1 != null){ rear.next = l1; } if (l2!= null) { rear.next = l2; } return dummy.next; } 面试题26：树的子结构public boolean isSubStructure(TreeNode A, TreeNode B){ boolean res = false; if(A!=null &amp;&amp; B!=null){ if(A.val == B.val){ res = doesHaveTree2(A, B); }if(!res){ res = isSubStructure(A.left, B); }if(!res){ res = isSubStructure(A.right, B); } } return res; } private boolean doesHaveTree2(TreeNode A, TreeNode B){ if(B == null) { return true; } if(A == null){ return false; } if(A.val != B.val){ return false; } return doesHaveTree2(A.left, B.left) &amp;&amp; doesHaveTree2(A.right, B.right); } 面试题27：二叉树的镜像public TreeNode mirrorTree(TreeNode root) { if (root != null) { TreeNode temp = root.left; root.left = root.right; root.right = temp; mirrorTree(root.left); mirrorTree(root.right); } return root; } 面试题28：对称二叉树// 递归 public boolean isSymmetric(TreeNode root) { if (root == null) { return true; } return isSymmetric(root.left, root.right); } private boolean isSymmetric(TreeNode left, TreeNode right) { if (left == null &amp;&amp; right == null) { return true; } if ((left != null &amp;&amp; right == null) || (left == null &amp;&amp; right != null) || (left.value != right.value)){ return false; } return isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left); } 面试题29： 顺时针打印矩阵打印矩阵的顺序是 “从左向右、从上向下、从右向左、从下向上” 循环。基础点为（0,0） 流程 空值处理 初始化， 初始化 上下左右的四个边界t、 b、 l、r 循环打印 根据边界依次添加到res尾部 边界修改（内缩1） 边界是否相遇，若相遇则打印完毕 | 打印方向 | 根据边界打印 | 边界内缩 | 是否打印完毕 || :———: | :—————————: | :———: | :—————: || 从左到右 | 左边界：l，右边界: r | t+1 | 是否t+1&gt;b || 从上到下 | 上边界: t，下边界: b | r-1 | 是否r-1","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://winniekun.github.io/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://winniekun.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"Vector&Stack源码解读","slug":"源码/JDK/list/vector&stack-analysis","date":"2020-05-26T08:29:05.000Z","updated":"2020-08-30T04:50:22.255Z","comments":true,"path":"vector&stack-analysis/","link":"","permalink":"https://winniekun.github.io/vector&stack-analysis/","excerpt":"Vector源码解读","text":"Vector源码解读 Vector依赖 支持泛型, 继承了AbstractList类, 实现了List接口 RandomAccess用来表明其支持随机访问 Cloneable用来表明其支持拷贝 Serializable用来表明支持序列化 Vector的实现和ArrayLis基本类似, 底层使用的都是Object类型的数组, 只不过Vector在方法上添加了关键字synchronized, 实现了线程安全. 所以具体的实现就不一一展开来了, 但是其扩容机制大小和ArrayList的不容,其他的部分, 分析Stack源码的时候相关涉及会再分析下 构造函数Vector()// 无参构造 public Vector() { this(10); } Vector(int initialCapacity)// 指定初始化容量 public Vector(int initialCapacity) { this(initialCapacity, 0); } Vector(int initialCapacity, int capacityIncrement)// 即指定初始化容量又指定扩容大小 public Vector(int initialCapacity, int capacityIncrement) { super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement; } Vector(Collection&lt;? extends E&gt; c)// 构造包含指定collection元素的Vector public Vector(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); elementCount = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, elementCount, Object[].class); } 扩容机制private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); } 可以看到其扩容机制和ArrayList的不同, ArrayList的扩容是原容量的1.5倍, 但是Vector的扩容机制和capacityIncrement相关 capacityIncrement&gt;0 则 扩容容量为 capacityIncrement, 最后的容量为 oldCapacity + capacityIncrement capacityIncrement&lt;0 则 扩容容量为 oldCapacity , 最后的容量为 2倍oldCapacity 总结共四个构造函数, 默认的初始化数组容量为10, 扩容大小不是程序内部实现, 而是用户定义, 默认为原数组的两倍, 若是用户指定了扩容大小, 则扩容为指定的容量 Stack源码解读 Stack方法 empty()public boolean empty() { return size() == 0; } peek()public synchronized E peek() { int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); } peek()函数调用了父类Vector的 elementAt()方法 public synchronized E elementAt(int index) { if (index &gt;= elementCount) { throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" + elementCount); } return elementData(index); } elementData()函数和ArrayList中的一样 说白了就是返回数组中最后一位的元素 pop()public synchronized E pop() { E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; } pop()函数调用了父类Vector的 removeElementAt()方法 这个方法和ArrayList的remove(int index)是一样的, 只不过添加了synchronized关键字实现线程安全 public synchronized void removeElementAt(int index) { modCount++; if (index &gt;= elementCount) { throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" + elementCount); } else if (index &lt; 0) { throw new ArrayIndexOutOfBoundsException(index); } int j = elementCount - index - 1; if (j &gt; 0) { System.arraycopy(elementData, index + 1, elementData, index, j); } elementCount--; elementData[elementCount] = null; /* to let gc do its work */ } 移除最后一个元素, 基本上不会执行前面的判断分支, 会直接执行 elementCount--; elementData[elementCount] = null; /* to let gc do its work */ push()public E push(E item) { addElement(item); return item; } push()调用了addElement()方法, 该方法首先会确定elementCount是否大于现在数组的容量大小, 若大扩容, 否则直接添加 public synchronized void addElement(E obj) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj; } 然后在数组尾部添加元素. search()返回对应元素所在堆的位置 这个对于底层的数组而言, 是相反的, 所以从尾到头遍历元素,同时因为允许元素为空, 所以首先会先判断查询元素是否为空 感觉这些索引位置和数组第几个元素的问题很恼火, 两者始终差个1 public synchronized int search(Object o) { int i = lastIndexOf(o); // 逆序返回 if (i &gt;= 0) { return size() - i; } return -1; } // elementCount记录为数组中的元素个数 // 但是数组是从位置0开始 // 所以在数组中最后一个元素的位置为elementCount-1 public synchronized int lastIndexOf(Object o) { return lastIndexOf(o, elementCount-1); } public synchronized int lastIndexOf(Object o, int index) { if (index &gt;= elementCount) throw new IndexOutOfBoundsException(index + \" &gt;= \"+ elementCount); if (o == null) { for (int i = index; i &gt;= 0; i--) if (elementData[i]==null) return i; } else { for (int i = index; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; } return -1; } 总结Vector和ArrayList的异同:异: Vector通过在涉及到线程不安全的方法上添加synchronized关键字实现了线程安全,而ArrayList为线程不安全 Vector的扩容机制可由用户自定义, 若为定义则扩为原数组的两倍 ArrayList的扩容机制不能通过用户自定义, 正常情况扩容为原数组的1.5倍 同: 底层都是Object数组 remove方法都不会改变底层数组的大小 Stack继承Vector类, 所有是线程安全的, 同时底层也是Object数组, 入栈等同于在数组中依次添加元素, 出栈在数组中就是删除数组中最后的元素, 然后将最后的位置设置为空, 数组整体的大小是不会随着出栈而改变的.","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"List","slug":"List","permalink":"https://winniekun.github.io/tags/List/"}]},{"title":"死磕二分查找","slug":"LeetCode/stick-to-binary-search","date":"2020-05-23T06:21:39.000Z","updated":"2020-08-30T04:50:22.250Z","comments":true,"path":"stick-to-binary-search/","link":"","permalink":"https://winniekun.github.io/stick-to-binary-search/","excerpt":"前言LeetCode死磕系列六：二分查找","text":"前言LeetCode死磕系列六：二分查找 二分查找是计算机科学中最基本、最有用的算法之一，在基础算法的学习中是非常重要的。 二分查找的最基本问题是在有序数组里查找一个特定的元素 二分查找算法是典型的「减治思想」的应用，我们使用二分查找将待搜索的区间逐渐缩小，以达到「缩减问题规模」的目的； 掌握二分查找的两种思路： 思路 1：在循环体内部查找元素：while (left &lt;= right)； 思路 2：在循环体内部排除元素：while (left &lt; right)。 全部使用左闭右闭区间，不建议使用左闭右开区间，反而使得问题变得复杂； 应用1、在半有序（旋转有序或者是山脉）数组里查找元素； 2、确定一个有范围的整数； 3、需要查找的目标元素满足某个特定的性质。 模板一class Solution { public int search(int[] nums, int target) { // 特殊用例判断 int len = nums.length; if (len == 0) { return -1; } // 在 [left, right] 区间里查找 target int left = 0; int right = len - 1; while (left &lt;= right) { // 为了防止 left + right 整形溢出，写成如下形式 int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] &gt; target) { // 下一轮搜索区间：[left, mid - 1] right = mid - 1; } else { // 此时：nums[mid] &lt; target // 下一轮搜索区间：[mid + 1, right] left = mid + 1; } } return -1; } } lower_bound：查找第一个大于或等于 target 的数字； upper_bound：查找第一个大于 target 的数字。 这一类问题的描述经常让人觉得头晕，使用模板一，就需要考虑返回 left 还是 right。 如果使用模板二，由于退出循环以后一定有 left == right，就只需要单独判断 left或right 是否满足题意。 模板二public int search(int[] nums, int left, int right, int target) { while (left &lt; right) { // 选择中位数时下取整 int mid = left + (right - left) / 2; if (check(mid)) { // 下一轮搜索区间是 [mid + 1, right] left = mid + 1 } else { // 下一轮搜索区间是 [left, mid] right = mid } } // 退出循环的时候，程序只剩下一个元素没有看到。 // 视情况，是否需要单独判断 left（或者 right）这个下标的元素是否符合题意 } public int search(int[] nums, int left, int right, int target) { while (left &lt; right) { // 选择中位数时上取整 int mid = left + (right - left + 1) / 2; if (check(mid)) { // 下一轮搜索区间是 [left, mid - 1] right = mid - 1; } else { // 下一轮搜索区间是 [mid, right] left = mid; } } // 退出循环的时候，程序只剩下一个元素没有看到。 // 视情况，是否需要单独判断 left（或者 right）这个下标的元素是否符合题意 } 特征：while (left &lt; right)，这里使用严格小于 &lt; 表示的临界条件是：当区间里的元素只有 2 个时，依然可以执行循环体。换句话说，退出循环的时候一定有 left == right 成立，这一点在定位元素下标的时候极其有用； 在循环体中，先考虑 nums[mid] 在满足什么条件下不是目标元素，进而考虑两个区间 [left, mid - 1] 以及 [mid + 1, right] 里元素的性质，目的依然是确定下一轮搜索的区间； 根据边界情况，看取中间数的时候是否需要上取整(也就是mid 是否的计算是否需要加1) 注意事项： 先写分支，再决定中间数是否上取整； 在使用多了以后，就很容易记住，只要看到 left = mid ，它对应的取中位数的取法一定是 int mid = left + (right - left + 1) / 2;。 LeetCode 二分查找题目整理 704 二分查找 (基础,经典应用) 35 插入搜索位置 69 x的平方根 34 在排序数组中查找元素的第一个和最后一个位置(经典, 很好的模板) 题解704. 二分查找 关于写left = mid + 1;还是写right = mid - 1; 上感到困惑，一个行之有效的思考策略是： 永远去想下一轮目标元素应该在哪个区间里: 如果目标元素在区间 [left, mid - 1] 里，就需要设置设置 right = mid - 1； 如果目标元素在区间 [mid + 1, right] 里，就需要设置设置 left = mid + 1； 考虑不仔细是初学二分法容易出错的地方，这里切忌跳步，需要仔细想清楚每一行代码的含义； 循环可以继续的条件是 while (left &lt;= right)，特别地，当 left == right 即当待搜索区间里只有一个元素的时候，查找也必须进行下去； public int search(int[] nums, int target) { int i = 0; int j = nums.length - 1; while (i &lt;= j) { // 防止整型溢出 // int mid = i + (j-i)/2; int mid = (i+j)/2; if(nums[mid] == target){ return mid; }else if(nums[mid] &lt; target){ i = mid+1; }else if(nums[mid] &gt; target){ j = mid-1; } } return -1; } 35. 搜索插入位置使用上述的模板来的话,需要考虑是返回i, 还是j 使用模板二的话,不用考虑 // 模板一解法 public static int searchInsert(int[] nums, int target) { if(target &gt; nums[nums.length-1]){ return nums.length; } int low = 0; int high = nums.length - 1; while (low &lt;= high) { int mid = (low + high) / 2; if(target == nums[mid]){ return mid; }else if(nums[mid] &lt; target){ low = mid+1; }else { high = mid-1; } } return high; } // 模板二解法 public static int searchInsertII(int[] nums, int target) { int len = nums.length; if (len == 0) { return 0; } // 特判 if (nums[len - 1] &lt; target) { return len; } int left = 0; int right = len - 1; while (left &lt; right) { int mid = left + (right - left) / 2; // 严格小于 target 的元素一定不是解 if (nums[mid] &lt; target) { // 下一轮搜索区间是 [mid + 1, right] left = mid + 1; } else { right = mid; } } return left; } 69. x 的平方根public int mySqrt(int x) { if (x == 0) { return 0; } if (x == 1) { return 1; } int i = 1; int j = x / 2; while (i &lt; j) { int mid = (i + j + 1) / 2; // 大于一定无 if (mid &gt; x / mid){ // 下一轮搜索的区间是 [left, mid - 1] j = mid -1; }else { // 下一轮搜索的区间是 [mid, right] i = mid; } } return i; } 34. 在排序数组中查找元素的第一个和最后一个位置public int[] searchRange(int[] nums, int target) { int i = 0; int j = nums.length - 1; int first = findFirstPosition(nums, target); if(first == 1){ return new int[]{-1, -1}; } int secondPosition = findSecondPosition(nums, target); return new int[]{first, secondPosition}; } public int findFirstPosition(int[] nums, int target) { int i = 0; int j = nums.length - 1; while (i &lt; j) { int mid = (i + j) / 2; // 小于一定没有解 if (nums[mid] &lt; target) { i = mid + 1; } else { j = mid; } } if (nums[i] == target) { return i; } else { return -1; } } public int findSecondPosition(int[] nums, int target) { int i = 0; int j = nums.length - 1; while (i &lt; j){ int mid = (i + j + 1)/2; if(nums[mid] &gt; target){ j = mid-1; }else { i = mid; } } if (nums[i] == target){ return i; }else { return -1; } } 278. 第一个错误的版本若是中间位置的版本为false, 说明第一个错误版本在[mid+1, right]; public int firstBadVersion(int n) { int left = 1, right = n; while (left &lt; right) { int mid = left + (right - left) / 2; if (!isBadVersion(mid)) { left = mid + 1; } else { right = mid; } } return left; } References 二分查找算法 特别好用的二分查找法模板（第 2 版）","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"二分搜索","slug":"二分搜索","permalink":"https://winniekun.github.io/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"}]},{"title":"聊天室的BIO NIO实现","slug":"Java进阶/IO/chat-room","date":"2020-05-21T13:03:39.000Z","updated":"2020-08-30T04:50:22.244Z","comments":true,"path":"chat-room/","link":"","permalink":"https://winniekun.github.io/chat-room/","excerpt":"简易客户端-服务端","text":"简易客户端-服务端 服务端创建一个ServerSocket实例, 绑定对应的端口之后, 在while循环中阻塞等待客户端的请求, 客户端请求成功之后,创建一个输入流和一个输出流 再进行数据交互. 创建一个ServerSocket并绑定端口 阻塞等待客户端请求 链接之后, 交互数据 public static void main(String[] args) { final int DEFAULT_PORT = 8888; final String QUIET = \"quiet\"; ServerSocket server = null; try { server = new ServerSocket(DEFAULT_PORT); System.out.println(\"[启动服务器， 监听端口 \" + DEFAULT_PORT + \"]\"); while (true) { // 等待链接 Socket client = server.accept(); System.out.println(\"[客户端 \" + client.getPort() + \" 已经链接]\"); BufferedReader reader = new BufferedReader( new InputStreamReader(client.getInputStream())); BufferedWriter writer = new BufferedWriter( new OutputStreamWriter(client.getOutputStream())); // 读取客户端数据 String msg = null; while (((msg = reader.readLine()) != null)) { System.out.println(\"[客户端 \" + client.getPort() + \"发送数据 \" + msg + \"]\"); // 返回个客户端数据 writer.write(\"{ echo \" + msg + \"} \\n\"); writer.flush(); if(QUIET.equalsIgnoreCase(msg)){ break; } } } } catch (IOException e) { e.printStackTrace(); } finally { if (server != null) { try { server.close(); } catch (IOException e) { e.printStackTrace(); } } } } 客户端创建一个Socket实例(服务器地址, 端口), 之后将创建两个输入流(一个用于读取服务端发送的数据, 一个用于读取用户输入的数据), 一个输出流(将用户输入的数据发送个服务端) 创建Socket 链接服务器 和服务器交互 public static void main(String[] args) { final String DEFAULT_SERVER_HOST = \"localhost\"; final String QUIET = \"quiet\"; final int DEFAULT_SERVER_PORT = 8888; try ( Socket client = new Socket(DEFAULT_SERVER_HOST, DEFAULT_SERVER_PORT); // 创建IO流 BufferedReader reader = new BufferedReader( new InputStreamReader(client.getInputStream())); BufferedWriter writer = new BufferedWriter( new OutputStreamWriter(client.getOutputStream())); // 等待用户输入信息 BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in)); ) { while (true) { // 读取用户输入数据 String input = consoleReader.readLine(); // 发送给服务器 writer.write(input + \"\\n\"); writer.flush(); // 输出服务器返回数据 String accept = reader.readLine(); System.out.println(\"[服务器 发送数据 \" + accept + \"]\"); // 查看是否退出 if(QUIET.equalsIgnoreCase(input)){ break; } } } catch (IOException e) { e.printStackTrace(); } } 总结上述一个简单的聊天室程序完成,但是因为 server.accept() InputStream.read() OutputStream.write() 均存在阻塞问题, 当有新的客户端发起请求时,服务端需要执行完上一个请求之后,才能去执行这个请求.所有我们可以将阻塞的部分独立出来用一个新的线程执行这部分内容. 将用户的输入处理用一个新的线程处理 将服务端中的数据处理独立出来, 创建一个对应的线程来执行对应客户端的数据交互 优化1: 服务端为每个请求创建线程处理 服务端Constant用于存放一些静态常量 public interface Constant { /** * 默认端口 */ int DEFAULT_PORT = 8888; /** * IP地址 */ String DEFAULT_HOST = \"localhost\"; /** * 退出命令 */ String QUIT = \"quit\"; } Server和基础的版本有所不同的是, 服务端转发消息给客户端,是除了发送消息的那个客户端. public class ChatServer implements Constant { private ServerSocket server = null; private ExecutorService executor; private Map&lt;Integer, Writer&gt; connectionClients; public ChatServer() { this.connectionClients = new HashMap&lt;&gt;(); this.executor = Executors.newFixedThreadPool(10); } // 新增用户添加到map public synchronized void add(Socket socket) throws IOException { if (socket != null) { int port = socket.getPort(); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); connectionClients.put(port, writer); System.out.println(\"客户端 [\" + port + \"] 已经连接服务器\"); } } // 下线客户移除 public synchronized void removeClient(Socket socket) throws IOException { if (socket != null) { int port = socket.getPort(); if (connectionClients.containsKey(port)) { connectionClients.get(port).close(); } connectionClients.remove(port); System.out.println(\"客户端 [\" + port + \"]已经断开连接\"); } } // 转发消息 public synchronized void forwardMSG(Socket socket, String msg) throws IOException { // 转发给除去发送者的其他在线用户 for (Integer integer : connectionClients.keySet()) { if (!integer.equals(socket.getPort())) { Writer writer = connectionClients.get(integer); writer.write(msg); writer.flush(); } } } // 全部转发 public synchronized void forwardAllMSG(String msg) throws IOException { for (Integer integer : connectionClients.keySet()) { connectionClients.get(integer).write(msg); connectionClients.get(integer).flush(); } } public synchronized void close(){ if(server != null){ try { server.close(); System.out.println(\"关闭服务器\"); } catch (IOException e) { e.printStackTrace(); } } } public void start() { try { // 绑定监听端口 server = new ServerSocket(DEFAULT_PORT); System.out.println(\"[启动服务器， 监听端口 \" + DEFAULT_PORT + \"]\"); while (true) { // 等待客户端连接 Socket socket = server.accept(); // 创建新的线程, 用于处理客户端数据 new Thread(new ChatHandler(socket, this)).start(); //executor.execute(new ChatHandler(socket, this)); } } catch (IOException e) { e.printStackTrace(); }finally { close(); } } public static void main(String[] args) { ChatServer server = new ChatServer(); server.start(); } } ChatHandler用于处理和客户端交互的线程 public class ChatHandler implements Runnable, Constant { Socket client; ChatServer chatServer; public ChatHandler(Socket socket, ChatServer chatServer){ this.client = socket; this.chatServer = chatServer; } @Override public void run() { try { // 存储新上线用户 chatServer.add(client); BufferedReader reader = new BufferedReader(new InputStreamReader(client.getInputStream())); String msg = null; while ((msg = reader.readLine()) != null){ // 读入客户端的消息 String fwdMSG = \"客户端 [\" + client.getPort() + \"] 消息为 \" + msg + \"\\n\"; System.out.print(fwdMSG); // 读出转发给其他的客户端 chatServer.forwardMSG(client, fwdMSG); // 检测是否退出 if(QUIT.equalsIgnoreCase(msg)){ break; } } } catch (IOException e) { e.printStackTrace(); }finally { try { chatServer.removeClient(client); } catch (IOException e) { e.printStackTrace(); } } } } 客户端除了将数据发送给服务端以及接受服务端的数据,还需要一个接受用户产生的数据的线程 Clientpublic class ChatClient implements Constant { private Socket socket; private BufferedReader reader; private BufferedWriter writer; // 发送给服务器数据 public void send(String msg) throws IOException { if (!socket.isOutputShutdown()) { writer.write(msg + \"\\n\"); writer.flush(); } } // 接受服务器转发的信息 public String receive() throws IOException { String msg = null; if (!socket.isInputShutdown()) { msg = reader.readLine(); } return msg; } // 关闭 public void close() { if (writer != null) { try { System.out.println(\"客户端\" + socket.getLocalPort() + \"关闭\"); writer.close(); } catch (IOException e) { e.printStackTrace(); } } } // 准备退出 public boolean readyQuit(String s) { return s.equalsIgnoreCase(QUIT); } // 开始 public void start() { try { socket = new Socket(DEFAULT_HOST, DEFAULT_PORT); writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 等待用户输入信息 new Thread(new UserInputHandler(this)).start(); // 读取服务器数据 String msg = null; while ((msg = receive()) != null){ System.out.println(msg); } } catch (IOException e) { e.printStackTrace(); } finally { close(); } } public static void main(String[] args) { ChatClient chatClient = new ChatClient(); chatClient.start(); } } UserInputHandlerpublic class UserInputHandler implements Runnable, Constant { ChatClient chatClient; public UserInputHandler(ChatClient chatClient) { this.chatClient = chatClient; } @Override public void run() { try { // 等待用户输入 BufferedReader consoleReader = new BufferedReader( new InputStreamReader(System.in)); while (true) { // 获取用户输入数据 String input = consoleReader.readLine(); // 向服务器发送输入数据 chatClient.send(input); if(chatClient.readyQuit(input)){ break; } } } catch (IOException e) { e.printStackTrace(); } } } 总结该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈1:1的正比关系，Java中的线程也是比较宝贵的系统资源，线程数量快速膨胀后，系统的性能将急剧下降，随着访问量的继续增大，系统最终就死掉了。 优化2: 服务端使用线程池来处理客户端的请求为了改进这种一连接一线程的模型，我们可以使用线程池来管理这些线程，实现一个或多个线程处理多个客户端请求的模型（服务端的线程个数和客户端并发访问数呈M:N的关系，N可以远远大于M，但是底层还是使用的同步阻塞I/O），通常被称为“伪异步I/O模型“。伪异步I/O模型图： 和优化1绝大多数部分的代码是类似的,所以只展示服务端需要修改的部分 private ExecutorService executor; public void start() { try { // 绑定监听端口 server = new ServerSocket(DEFAULT_PORT); System.out.println(\"[启动服务器， 监听端口 \" + DEFAULT_PORT + \"]\"); while (true) { // 等待客户端连接 Socket socket = server.accept(); // 创建新的线程, 用于处理客户端数据 new Thread(new ChatHandler(socket, this)).start(); executor.execute(new ChatHandler(socket, this)); } } catch (IOException e) { e.printStackTrace(); }finally { close(); } } 优化3: NIO服务端public class ChatServer implements NioConstant { private ServerSocketChannel server; private Selector selector; // 读取 buffer private ByteBuffer rBuffer = ByteBuffer.allocate(BUFFER); // 写入 buffer private ByteBuffer wBuffer = ByteBuffer.allocate(BUFFER); private Charset charset = Charset.forName(\"UTF-8\"); // 自定义端口 private int port; public ChatServer(){ this(DEFAULT_PORT); } public ChatServer(int port){ this.port = port; } public void start(){ try { // 打开一个ServerSocket 的 Channel server = ServerSocketChannel.open(); // 设置非阻塞 server.configureBlocking(false); // 得到一个关于该ServerSocketChannel的ServerSocket、并且绑定端口 server.socket().bind(new InetSocketAddress(port)); // 打开Selector selector = Selector.open(); // 把ServerSocketChannel注册到Selector ， 设置监听事件为ACCEPT server.register(selector , SelectionKey.OP_ACCEPT); System.out.println(\"启动服务器，监听端口：\"+ port +\"...\"); while(true){ // 本身是阻塞式调用 selector.select(); // 触发事件集 Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); for(SelectionKey key : selectionKeys){ // 处理被触发的事件 handles(key); } // 处理完成后，手动清空 selectionKeys.clear(); } } catch (IOException e) { e.printStackTrace(); } finally{ close(selector); } } private boolean readyToQuit(String msg){ return QUIT.equalsIgnoreCase(msg); } private synchronized void close(Closeable closeable){ if(closeable != null){ try { closeable.close(); } catch (IOException e) { e.printStackTrace(); } } } private String receive(SocketChannel client) throws IOException { // 写模式 rBuffer.clear(); while((client.read(rBuffer)) &gt; 0); // 读模式 rBuffer.flip(); return String.valueOf(charset.decode(rBuffer)); } private void forwardMessage(SocketChannel client , String fwdMsg) throws IOException { for(SelectionKey key : selector.keys()){ Channel connectedClient = key.channel(); if(connectedClient instanceof ServerSocketChannel){ continue; } if(key.isValid() &amp;&amp; !client.equals(connectedClient)){ // 写模式 wBuffer.clear(); wBuffer.put(charset.encode(getClientName(client) +\":\"+fwdMsg)); // 读模式 wBuffer.flip(); while(wBuffer.hasRemaining()){ ((SocketChannel) connectedClient).write(wBuffer); } } } } private String getClientName(SocketChannel client){ return \"客户端[\"+client.socket().getPort()+\"]\"; } private void handles(SelectionKey key) throws IOException { // ACCEPT事件 - 和客户端建立了连接 if(key.isAcceptable()){ ServerSocketChannel server = (ServerSocketChannel) key.channel(); SocketChannel client = server.accept(); // 设置成非阻塞 client.configureBlocking(false); client.register(selector , SelectionKey.OP_READ); System.out.println(getClientName(client)+\"已连接\"); } // READ事件 - 客户端发送了消息 else if(key.isReadable()){ SocketChannel client = (SocketChannel) key.channel(); String fwdMsg = receive(client); if(fwdMsg.isEmpty()){ // 客户端异常 , 不再监听这个事件 key.cancel(); // 更新监听事件状态 selector.wakeup(); } else{ forwardMessage(client , fwdMsg); // 检查用户是否准备退出 if(readyToQuit(fwdMsg)){ key.cancel(); selector.wakeup(); System.out.println(getClientName(client)+\"已断开\"); } } } } public static void main(String[] args) { ChatServer server = new ChatServer(); server.start(); } } 客户端public class ChatClient implements NioConstant { private String host; private int port; private SocketChannel client; private ByteBuffer rBuffer = ByteBuffer.allocate(BUFFER); private ByteBuffer wBuffer = ByteBuffer.allocate(BUFFER); private Selector selector; private Charset charset = Charset.forName(\"UTF-8\"); public ChatClient(){ this(DEFAULT_HOST , DEFAULT_PORT); } public ChatClient(String host , int port){ this.host = host; this.port = port; } // 检查用户是否准备退出 public boolean readyQuit(String msg){ return QUIT.equalsIgnoreCase(msg); } public void close(Closeable closeable){ if(closeable != null){ try { closeable.close(); } catch (IOException e) { e.printStackTrace(); } } } public void start(){ try { selector = Selector.open(); client = SocketChannel.open(); // 设置非阻塞 client.configureBlocking(false); client.register(selector , SelectionKey.OP_CONNECT); client.connect(new InetSocketAddress(host , port)); while(true){ selector.select(); Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); for(SelectionKey key : selectionKeys){ handles(key); } } } catch (IOException e) { e.printStackTrace(); } catch (ClosedSelectorException e){ // 用户正常退出，产生的异常 } finally { close(selector); } } private void handles(SelectionKey key) throws IOException { // CONNECT事件 - 连接就绪事件 if(key.isConnectable()){ SocketChannel client = (SocketChannel) key.channel(); if(client.isConnectionPending()){ client.finishConnect(); // 处理用户的输入 new Thread(new UserInputHandler(this)).start(); } client.register(selector , SelectionKey.OP_READ); } // READ事件 - 服务器转发消息 else if(key.isReadable()){ SocketChannel client = (SocketChannel) key.channel(); String msg = receive(client); if(msg.isEmpty()){ // 服务器异常 close(selector); } else{ System.out.println(msg); } } } private String receive(SocketChannel client) throws IOException { // 写模式 rBuffer.clear(); while(client.read(rBuffer) &gt; 0); // 写模式 rBuffer.flip(); return String.valueOf(charset.decode(rBuffer)); } public void send(String msg) throws IOException { if(msg.isEmpty()){ return ; } // 写模式 wBuffer.clear(); wBuffer.put(charset.encode(msg)); wBuffer.flip(); while(wBuffer.hasRemaining()){ client.write(wBuffer); } // 检查用户是否准备退出 if(readyQuit(msg)){ close(selector); } } public static void main(String[] args) { ChatClient client = new ChatClient(); client.start(); } }","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"I/O","slug":"I-O","permalink":"https://winniekun.github.io/tags/I-O/"}]},{"title":"Java的几种文件拷贝方式","slug":"Java基础/面试36讲/copy-methods-of-java","date":"2020-05-14T03:18:51.000Z","updated":"2021-09-12T13:35:17.254Z","comments":true,"path":"copy-methods-of-java/","link":"","permalink":"https://winniekun.github.io/copy-methods-of-java/","excerpt":"前言","text":"前言 Java中文件的拷贝方式，大体上分为两个派系 stream的方式实现拷贝 NIO的方式实现拷贝 以下举例四个经典的拷贝方式的实现，尽管Java中有自己的Copy实现，还是想使用BIO或NIO实现下面的四个方式 四种拷贝方式无Buffer的输入输出流拷贝方式public class NoBufferStreamCopy implements FileCopyRunner { @Override public void copyFile(File source, File target) { try ( InputStream input = new FileInputStream(source); OutputStream output = new FileOutputStream(target); ) { int read; while ((read = input.read())!= -1){ output.write(read); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } @Override public String toString() { return \"NoBufferStreamCopy\"; } } 有Buffer的输入输出流拷贝方式public class BufferStreamCopy implements FileCopyRunner { @Override public void copyFile(File source, File target) { try ( InputStream input = new FileInputStream(source); OutputStream output = new FileOutputStream(target); ) { byte[] buffer = new byte[1024]; int leng; while ((leng = input.read(buffer)) != -1){ output.write(buffer, 0, leng); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } @Override public String toString() { return \"BufferStreamCopy\"; } } NIO基础的拷贝实现public class NioBufferCopy implements FileCopyRunner { @Override public void copyFile(File source, File target) { try ( FileChannel input = new FileInputStream(source).getChannel(); FileChannel output = new FileOutputStream(target).getChannel(); ) { ByteBuffer buffer = ByteBuffer.allocate(1024); while (input.read(buffer) != -1){ buffer.flip(); while (buffer.hasRemaining()) { output.write(buffer); } buffer.clear(); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } @Override public String toString() { return \"NioBufferCopy\"; } } NIO Transfer实现拷贝public class NioTransferCopy implements FileCopyRunner { @Override public void copyFile(File source, File target) { try ( FileChannel inputChannel = new FileInputStream(source).getChannel(); FileChannel ouputChannel = new FileOutputStream(target).getChannel(); ) { for (long count = inputChannel.size(); count &gt; 0;) { long transferTo = inputChannel.transferTo(inputChannel.position(), count, ouputChannel); count -= transferTo; } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } @Override public String toString() { return \"NioTransferCopy\"; } } 对比测试类public class FileCopyDemo { private static final int ROUNDS = 5; private static final File sourceBig = new File(\"/home/kongweikun/Downloads/test/ccc.txt\"); private static final File sourceMid = new File(\"/home/kongweikun/Downloads/test/bbb.txt\"); private static final File sourceSmal = new File(\"/home/kongweikun/Downloads/test/aaa.txt\"); private static final File target = new File(\"/home/kongweikun/Downloads/test/ddd.txt\"); public static void benchMark(FileCopyRunner test, File source, File target, String name) { long elapsed = 0L; for (int i = 0; i &lt; ROUNDS; i++) { long start = System.currentTimeMillis(); test.copyFile(source, target); elapsed = System.currentTimeMillis() - start; // 删除copy之后的文件 target.delete(); } System.out.println(test + name + \" : \" + elapsed / ROUNDS + \"毫秒\"); } public static void main(String[] args) { FileCopyRunner noBufferStreamCopy = new NoBufferStreamCopy(); FileCopyRunner bufferedStreamCopy = new BufferStreamCopy(); FileCopyRunner nioBufferCopy = new NioBufferCopy(); FileCopyRunner nioTransferCopy = new NioTransferCopy(); // 测试 1 System.out.println(\"-----------------------------------------\"); System.out.println(\"无Buffer的BIO\"); benchMark(noBufferStreamCopy, sourceBig, target, \"大文件\"); benchMark(noBufferStreamCopy, sourceMid, target, \"中等文件\"); benchMark(noBufferStreamCopy, sourceSmal, target, \"小文件\"); System.out.println(\"-----------------------------------------\"); System.out.println(\"有Buffer的BIO\"); benchMark(bufferedStreamCopy, sourceBig, target, \"大文件\"); benchMark(bufferedStreamCopy, sourceMid, target, \"中等文件\"); benchMark(bufferedStreamCopy, sourceSmal, target, \"小文件\"); // System.out.println(\"-----------------------------------------\"); System.out.println(\"NIO基础\"); benchMark(nioBufferCopy, sourceBig, target, \"大文件\"); benchMark(nioBufferCopy, sourceMid, target, \"中等文件\"); benchMark(noBufferStreamCopy, sourceSmal, target, \"小文件\"); System.out.println(\"-----------------------------------------\"); System.out.println(\"NIO的TransferTo\"); benchMark(nioTransferCopy, sourceBig, target, \"大文件\"); benchMark(nioTransferCopy, sourceMid, target, \"中等文件\"); benchMark(nioTransferCopy, sourceSmal, target, \"小文件\"); } } ----------------------------------------- 无Buffer的BIO NoBufferStreamCopy大文件 : 614毫秒 NoBufferStreamCopy中等文件 : 0毫秒 NoBufferStreamCopy小文件 : 0毫秒 ----------------------------------------- 有Buffer的BIO BufferStreamCopy大文件 : 1毫秒 BufferStreamCopy中等文件 : 0毫秒 BufferStreamCopy小文件 : 0毫秒 ----------------------------------------- NIO基础 NioBufferCopy大文件 : 1毫秒 NioBufferCopy中等文件 : 0毫秒 NoBufferStreamCopy小文件 : 0毫秒 ----------------------------------------- NIO的TransferTo NioTransferCopy大文件 : 0毫秒 NioTransferCopy中等文件 : 0毫秒 NioTransferCopy小文件 : 0毫秒 总结对于 Copy 的效率,这个其实与操作系统和配置等情况相关,总体上来说,NIOtransferTo/From 的方式可能更快,因为它更能利用现代操作系统底层机制,避免不必要拷贝和上下文切换。 不同的 copy 方式,底层机制有什么区别?这里涉及到了用户态空间和内核态空间,这是操作系统层面的基本概念,操作系统内核、硬件驱动等运行在内核态空间,具有相对高的特权.而用户态空间,则是给普通应用和服务使用. 当我们使用输入输出流的进行读写的时候,实际上经历了多次的上下文切换: 应用数据的读取: 首先内核态将数据从磁盘读取到内核缓存,再切换到用户态将数据从内核缓存读取到用户缓存 用户态-内核态 所以,这种方式会带来一定的额外开销,可能会降低 IO 效率。 但是NIO的transferTo的实现, 会涉及到零拷贝, 也就是数据传输并不会涉及到用户态,省去了上下文的切换和不必要的拷贝. transferTo的传输过程是:","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://winniekun.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"面试36讲","slug":"面试36讲","permalink":"https://winniekun.github.io/tags/%E9%9D%A2%E8%AF%9536%E8%AE%B2/"}]},{"title":"接口和抽象类的区别","slug":"Java基础/面试36讲/interface-Abstarct-diff","date":"2020-05-13T13:03:31.000Z","updated":"2020-08-30T04:50:22.244Z","comments":true,"path":"interface-Abstarct-diff/","link":"","permalink":"https://winniekun.github.io/interface-Abstarct-diff/","excerpt":"接口","text":"接口 接口是不是类，是对类的一组需求的描述，这些类要遵从接口描述的同一格式进行定义（其是对行为的抽象，是抽象方法的集合）。有两个方面的职责： 抽象方法的集合（主要） 声明某些东西（Mark Interface） 通过接口，可以达到API和实现的分离，譬如MVC中的dao层或service层，但是不能实例化，同时也不能包含任何非常量成员，所以，也隐含表明，任何的field都具有public static final的意义。同时对于方法来说，接口中要么是抽象方法，要么是静态方法。如Collection框架中root interface java.util.Collection 疑问1：为什么常量成员默认修饰为public static final 接口必须要具体类实现才有意义，所以必须是public。 接口中的属性对所有实现类只有一份，所以是static。 要使实现类为了向上转型成功，所以必须是final的。 疑问2：为什么方法要么是抽象方法，要么是静态方法 抽象方法和接口定义的方法，你可以理解为是一种协议或者规范。比如我们是行业的达人，需要定义车的规范，它能启动、跑起来、刹车和停止，这4项功能就是抽象方法。至于用什么引擎启动、跑地多快、怎么刹车，我们就不想管了，你爱怎么实现是你的事，但你必须实现我们定义好的抽象方法，否则你生产的就不是车子了。 以最常用的java.util.List为例，它的继承树及其庞大。但这些实现类和继承类，都有共同的方法，也就是List定义的方法，比如get/add/remove/size。这样就保证了后续子孙都是一个模样的，但有个性。 List list = new 实现类();list.add(obj);list.get(0);int size = list.size();// 这行代码不需要修改实现类可以是ArrayList，也可以是LinkedList，或者是线程安全的CopyOnWriteArrayList。爱换那个换那个，但第二行的代码不需要修改，因为它们都使用了List的规范。 1、接口是一种约束和规范，是一种更加更高级的抽象类，抽象类的方法必须是公开的，因为要给人继承和使用啊，不用public，别人怎么看得到，所以在接口实现时，定义的方法修饰符必须是public；因此子类在实现接口重写方法时的修饰符必须是public。2、另外再扩展一下，接口中没有变量（既然是约束和规范，怎么能够定义一个大家都可以改的东西呢？），只能是常量，接口中定义常量默认的修饰符为public static final。 抽象类类似于模板，但又不同，目的是提高代码的复用，其抽取了相关的Java类的共用方法，或共用的成员变量，通过继承的方法达到代码复用目的。譬如Collection框架中的各种AbstractXXX类。抽象类除了不能实例化，形式上和Java类没有太大区别。 总结接口： 只有常量 方法要么是抽象方法、要么是静态方法 不能被实例化 一个类可以实现多个接口 抽象类： 除了不能实例化，其他和普通类没太大区别 一个类只能继承一个抽象类（Java 不支持多继承） 核心区别 行为规范: 接口 通用功能: 抽象 在一些情况下存在特定场景,需要抽象出与具体实现、实例化无关的通用逻辑,或者纯调用关系的逻辑，这样的话，因为Java不支持多继承，就无法使用抽象类进行实现，常用的方法是实现由静态方法构成的工具类，比如java.util.Collections 接口的职责也不仅仅限于抽象方法的集合,其实有各种不同的实践。有一类没有任何方法的接口,通常叫作 Marker Interface,顾名思义,它的目的就是为了声明某些东西,比如我们熟知的 Cloneable、Serializable 等。这种用法,也存在于业界其他的 Java 产品代码中。 References Java核心卷I","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://winniekun.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"面试36讲","slug":"面试36讲","permalink":"https://winniekun.github.io/tags/%E9%9D%A2%E8%AF%9536%E8%AE%B2/"}]},{"title":"JDK源码分析计划","slug":"源码/jdk-source-analysis","date":"2020-05-13T05:40:58.000Z","updated":"2020-08-30T04:50:22.257Z","comments":true,"path":"jdk-source-analysis/","link":"","permalink":"https://winniekun.github.io/jdk-source-analysis/","excerpt":"前言","text":"前言 自己也断断续续的读了一些JDK的源码了，并且也写了总结，但是尴尬的是，该忘得还是忘了，所以打算系统的理理，然后没看完一个除了总结，再做个思维导图。阅读JDK的目的有三： 学好数据结构以及相关算法 毕竟是内功，该硬啃还是要硬啃 不希望自己到时候追悔莫及 能让自己的Java的理解和熟练度更上一层楼 莫问Python嘞，问就是爱过 面试 这也是没得办法，感觉目前面试不问个源码问题，都不像面试 顺带把LeetCode相关的算法刷一遍😄 总体进程 常用数据结构手撸一遍 算法第四版 数据结构与算法分析 阅读JDK源码，记录 参考其他大佬的总结，查缺补漏 相关LeetCode题目刷了 JDK 集合类 所有集合 太复杂, 然后去除JUC上的一些实现类, 再看一下 collection-map-不包含JUC中的类 CollectionListList中的元素是有序的, 可重复的, 主要的实现方式是动态数组和链表 List Java中提供的List的实现主要有ArrayList、LinkedList、CopyOnWriteArrayList，另外还有两个古老的类Vector和Stack。 java.util.LinkedList ✔ java.util.Vector ✔ java.util.Stack ✔ java.util.ArrayList✔ java.util.concurrent.CopyOnWriteArrayList ✔ Queue队列是遵循着一定原则的入队出队操作的集合, 先进先出, 一般来说在堆尾添加元素(入队), 在队头删除元素(出队), 但是也不一定, 不如优先队列的原则就不同 Java中提供的Queue的实现有: PriorityQueue、ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue、LinkedTransferQueue、DelayQueue、ConcurrentLinkedQueue。 java.util.PriorityQueue java.util.concurrent.ArrayBlockingQueue java.util.concurrent.LinkedBlockingQueue java.util.concurrent.SynchronousQueue java.util.concurrent.PriorityBlockingQueue java.util.concurrent.LinkedTransferQueue java.util.concurrent.DelayQueue java.util.concurrent.ConcurrentLinkedQueue DequeDeque是一种特殊的队列，它的两端都可以进出元素，故而得名双端队列（Double Ended Queue）。 Deque Java中提供的Deque的实现主要有ArrayDeque、LinkedBlockingDeque、ConcurrentLinkedDeque、LinkedList。 java.util.Deque java.util.ArrayDeque java.util.concurrent.ConcurrentDeque Set Set Java中提供的Set的实现主要有HashSet、LinkedHashSet、TreeSet、CopyOnWriteArraySet、ConcurrentSkipListSet。 java.util.HashSet java.util.TreeSet java.util.LinkedHashSet java.util.concurrent.CopyOnWriteArraySet java.util.concurrent.ConcurrentSkipListSet Map Map java中提供的Map的实现主要有HashMap、LinkedHashMap、WeakHashMap、TreeMap、ConcurrentHashMap、ConcurrentSkipListMap，另外还有两个比较古老的Map实现HashTable、Properties。 java.util.TreeMap ✔ java.util.WeakHashMap java.util.LinkedHashMap java.util.HashMap ✔ java.util.concurrent.ConcurrentHashMap java.util.concurrent.ConcurrentSkipListMap java.util.Hashtable java.util.Properties 集合类概述逛博客的时候，发现一张神图 java-collection-cheat-sheet Java Collections Framework Cheat Sheet 阅读套路大体上的阅读框架写好了，接下来就是细致的硬啃了，可以先从顶层的接口开始，然后是Abstact类，这样方便理解不同的具体的集合类必备的通用方法等，然后再看这些具体类对这些通用方法的具体实现。顺序还是老样子：增、删、改、查，然后是其他的细节部分。 References 【死磕 Java 集合】— 总结篇","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"}]},{"title":"网站部署实录","slug":"配置/网站部署实录","date":"2020-05-10T12:23:05.000Z","updated":"2021-04-08T12:46:31.070Z","comments":true,"path":"网站部署实录/","link":"","permalink":"https://winniekun.github.io/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2%E5%AE%9E%E5%BD%95/","excerpt":"前言最近一个星期在做论坛形式的web应用，逻辑越写越多，脑子也是越写越乱，也越要越感觉SpringBoot和Flask的思想上好像。今天终于撸完了所有的业务逻辑，以及测试。开始部署，以下，记录部署的整个过程。😄","text":"前言最近一个星期在做论坛形式的web应用，逻辑越写越多，脑子也是越写越乱，也越要越感觉SpringBoot和Flask的思想上好像。今天终于撸完了所有的业务逻辑，以及测试。开始部署，以下，记录部署的整个过程。😄 环境依赖 部署 项目中的环境依赖如上图所述，按照步骤来， 先ssh链接服务器， 之后配置Java环境、MySQL、Redis、Kafka、Maven。之后配置Tomcat、Nginx。服务器使用的是Ubuntu18.04LTS SSH因为，ssh长时间不操作就断开，所以还是需要进行配置下 服务器配置1、 连接SSH ssh root@ip 2、编辑sshd_config vim /etc/ssh/sshd_config 3、找到ClientAliveInterval，将前面的#去掉（懒得找的话，直接在最后添加即可） # 服务器每隔60秒会给客户端发送一次保活信息包给客户端，可以将这个值设置大一点 ClientAliveInterval 60 4、找到ClientAliveCountMax，将前面的#去掉（同理） # 服务器发出的请求如果客户端没有响应，则判断超时1次，这个参数是表示允许超时的次数。可以将这个值设置大一点。 ClientAliveCountMax 888 Java环境oracle官网下载JDK，个人使用的是JDK8。之后将下载好的JDK上传服务器，也可以直接服务器安装，个人想试试scp命令，而且自己系统也是Ubuntu的，所有依赖环境压缩上传即可，更加方便 scp filepath/filename username@ip:/targetfilepath 譬如，下载好的本地JDK在Downloads文件夹下，想传入服务器root用户根目录下的community目录下，方便同一管理，后续的文件都传入community目录下 scp /Downloads/jdk-8u251-linux-x64.tar.gz root@ip:/community 之后使用终端登录服务器，解压JDK，配置环境(/etc/profile) ssh root@ip -p xxx (如果更改ssh端口的话) vim /etc/profile （配置环境变量） profile的配置如下 ## java environment export JAVA_HOME=/community/jdk1.8.0_251 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 之后，激活 source /etc/profile 最后，使用命令java -version检测是否配置成功 java version \"1.8.0_251\" Java(TM) SE Runtime Environment (build 1.8.0_191-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode) MySQL官网下载，点击MySQL APT Repository下载即可 MySQL 之后同理，传入服务， scp mysq-apt-config_0.8.15-1_all.deb root@ip:/community 之后通过之前ssh链接服务器的终端，安装MySQL sudo dpkg -i mysq-apt-config_0.8.15-1_all.deb 期间有让选择MySQL的版本，个人选择的是5.7的，因为开发的时候用的是5.7。之后更新source.list，下载MySQL即可 sudo apt-get update sudo apt-get install mysql-server 等待片刻后，会弹出mysql一个小的配置程序界面，要求你输入下root用户的密码（输入2次）等等。安装成功之后，登录尝试下即可 mysql -u root -p ## 输出信息 Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 24 Server version: 5.7.30-0ubuntu0.18.04.1 (Ubuntu) Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql&gt; MySQL的卸载在Ubuntu18.04系统下彻底删除MySQL的方法 Redis在此之前安装 add-apt-respository sudo apt-get update sudo apt-get install software-properties-common 步骤 $ sudo add-apt-repository ppa:redislabs/redis $ sudo apt-get update $ sudo apt-get install redis KafkaKafka官网，个人下载的是 kafka_2.12-2.5.0.tgz，前缀2.12是支持的Scala版本，本机电脑安装的Scala版本是2.12 下载之后，直接上传即可， 没有特别需要配置的东西，个人更改了log的地址，因为是服务器， 所以需要长期的运行，可执行如下命令 # zookeeper bin/zookeeper-server-start.sh -daemon config/zookeeper.properties # kafka server nohup bin/kafka-server-start.sh config/server.properties 1&gt;/dev/null 2&gt;&amp;1 &amp; Maven[Maven 3.6.3](https://apache.website-solution.net/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz，因为墙的问题，所以自己配置了setting.xml里面的`localRepository`和`mirrors` &lt;localRepository&gt;/home/kongweikun/maven&lt;/localRepository&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;uk&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://uk.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;CN&lt;/id&gt; &lt;name&gt;OSChina Central&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;internal nexus repository&lt;/name&gt; &lt;url&gt;http://repo.maven.apache.org/maven2&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 同理，需要在/etc/profile中配置 ## maven export M2_HOME=/community/apache-maven-3.6.3 export PATH=${M2_HOME}/bin:$PATH 激活 Tomcattomcat 9.0.34，下载之后，上传服务器即可，之后解压，/etc/profile配置 ## tomcat export CATALINA_HOME=/community/apache-tomcat-9.0.34 export CLASSPATH=${CLASSPATH}:${CATALINA_HOME}/lib export PATH=${PATH}:${CATALINA_HOME}/bin 之后，终端运行startup.sh，过一会儿用浏览器访问IP:8080查看是否能访问，不能访问的话，检查8080端口是否开发 netstat -apn | grep 8080 # 观察8080端口是否开放 netstat -ntpl # 显示网络状态, 可查看8080端口状态 ps -ef | grep tomcat # 查看tomcat进程 Nginxsudo apt-get install nginx 安装之后，可将/etc/nginx/sites-available/的default文件删除，但记得做备份。 之后在/etc/nginx/nginx.conf中的http中添加如下部分即可 upstream myserver{ server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; } server { listen 80; server_name ip; location / { proxy_pass http://myserver; } } nginx命令sudo systemctl restart nginx # 重启nginx systemctl status nginx # 检测nginx状态 部署最后，所有的环境安装成功之后，就是最重要的应用程序部署了。因为，Tomcat默认启动的是其webapps下的ROOT应用。其内部的应用程序，在路由上添加对应的名字即可，但是，因为我们想直接将ip绑定到应用程序，不加前缀，所以可以用如下的方式解决： 将自己的应用打包为war包，命名为ROOT，替换为Tomcat自带的ROOT应用。将properties中的server.servlet.context-path = xxx 后面的xxx去除，然后应用中涉及到context-path的也修改 pom.xml &lt;!--打成war包--&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;build&gt; &lt;!--打包名字--&gt; &lt;finalName&gt;ROOT&lt;/finalName&gt; &lt;plugins&gt; xxx &lt;/plugins&gt; &lt;/build&gt; 编写CommunityServleInitializer，继承SpringBootServletInitializer public class CommunityServleInitializer extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { return builder.sources(CommunityApplication.class); } } 将自己的应用程序上传服务器，然后使用maven打包 mvn clean package -Dmaven.test.skip=true 之后将target下的ROOT.war移动到Tomcat下的webapps中即可， 然后startup.sh over 部署成功展示 看来，这几年用Ubuntu还是有成果的，最起码，服务器上部署应用不用再那么恼火了，可以快速部署了。","categories":[{"name":"配置","slug":"配置","permalink":"https://winniekun.github.io/categories/%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"配置","slug":"配置","permalink":"https://winniekun.github.io/tags/%E9%85%8D%E7%BD%AE/"}]},{"title":"死磕位运算","slug":"LeetCode/stick-to-bit-operation","date":"2020-04-26T10:40:01.000Z","updated":"2021-08-18T08:54:33.166Z","comments":true,"path":"stick-to-bit-operation/","link":"","permalink":"https://winniekun.github.io/stick-to-bit-operation/","excerpt":"前言LeetCode死磕系列五： 位运算 位运算，在性能上是超过加减乘除的，只不过，费些脑细胞。基础的与&amp; 或| 异或^ 运算，以及左移动、右移。","text":"前言LeetCode死磕系列五： 位运算 位运算，在性能上是超过加减乘除的，只不过，费些脑细胞。基础的与&amp; 或| 异或^ 运算，以及左移动、右移。 常用操作&amp;、| 、^、&gt;&gt;、&lt;&lt;、&gt;&gt;&gt;假设整数变量 A 的值为 60 和变量 B 的值为 13： 操作符 描述 例子 ＆ 如果相对应位都是1，则结果为1，否则为0 （A＆B），得到12，即0000 1100 \\ 如果相对应位都是 0，则结果为 0，否则为 1 （A \\ B）得到61，即 0011 1101 ^ 如果相对应位值相同，则结果为0，否则为1 （A ^ B）得到49，即 0011 0001 〜 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。 （〜A）得到-61，即1100 0011 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数。 A &lt;&lt; 2得到240，即 1111 0000 &gt;&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数。 A &gt;&gt; 2得到15即 1111 &gt;&gt;&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 A&gt;&gt;&gt;2得到15即0000 1111 异或 2 ^ 2 = 0; 与 0 &amp; 1 = 0； 1 &amp; 1 = 0； n &amp; (n-1)10000000； 01111111; &lt;----- binary ----&gt; n n n-1 n&amp;(n-1) -- ---- ---- ------- 0 0000 0111 0000 * 1 0001 0000 0000 * 2 0010 0001 0000 * 3 0011 0010 0010 4 0100 0011 0000 * 5 0101 0100 0100 6 0110 0101 0100 7 0111 0110 0110 8 1000 0111 0000 * 9 1001 1000 1000 10 1010 1001 1000 11 1011 1010 1010 12 1100 1011 1000 13 1101 1100 1100 14 1110 1101 1100 15 1111 1110 1110 可以看到，其第一个方式是用于判断是否为2的幂次，n&amp;(n-1)的结果为0的话，则为2的幂次。 从运算结果分析（以12为例）： 12二进制表示为：1100，减去1之后，为1011，可以发现，减去1之后，是将该数字的二进制的最右边的1改为0，n&amp;(n-1)之后的结果为1000，比较1100和1000，这个操作可以总结为：将当前数字二进制最右边的1去除。最右边的1左边部分不变。所以，也可可以用于统计数字的二进制中1的个数问题。 补码： ~x + 1 是 x的补码; 补码 1 + 11111111111111111 = 000000000000000000; 2 + 11111111111111110 = 000000000000000000 (s | 1&lt;&lt;k)s: 集合（二进制表示包含的元素） 集合元素$s = {1,4,6}$ 则 $s = 1010010{2} = 82{10}$ k: 元素 将元素k放入集合s中 举例说明 当前$s=82$, 此时$k=2$，将$k$放入集合$s$中 $(1&lt;&lt;k) = 4 = 100_{2}$ $(s | 1&lt;&lt; k) == 1010110{2} == 86{10}$ 神奇的操作，适用于压缩状态dp LeetCode &amp; 剑指offer 位运算题目整理 面试题15：二进制中1的个数 136 Single Number LeetCode 位运算题目整理面试题15：二进制中1的个数public static int numberOf(int n){ // n &amp; (n - 1) 会消除 n 中最后一位中的 1。 int res = 0; while (n != 0){ res++; n &amp;= (n-1); } return res; } 136 Single Number这题是去除数组中的重复元素（给的测试集是只有一个不重复的元素），用了异或运算， 思路： 相等的数相异或结果为0，0和任何数相异或结果为这个数本身。根据这个特点，可以先设置一个初始值为0，然后分别和数组中的每个元素相异或，最后保留的肯定为唯一一个不重复的值。 相等的元素相异或的值为0，不是特指相等的元素必须相连，也可以不相连。 public singleNumber(int[] nums){ int res = 0; for( int i : nums){ res ^= i; } return res; } References n &amp; (n-1) what does this expression do? duplicate","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"位运算","slug":"位运算","permalink":"https://winniekun.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"匈牙利算法实现","slug":"算法/实现-图论/匈牙利算法实现","date":"2020-04-22T02:07:40.000Z","updated":"2020-08-30T04:50:22.260Z","comments":true,"path":"匈牙利算法实现/","link":"","permalink":"https://winniekun.github.io/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/","excerpt":"TODO","text":"TODO 前言匈牙利算法记录，并且添加了几道实战题目 简介&amp;思路匈牙利算法是一种在多项式时间内求解任务分配问题的组合优化算法，并推动了后来的原始对偶方法。美国数学家哈罗德·库恩于1955年提出该算法。此算法之所以被称作匈牙利算法，是因为算法很大一部分是基于以前匈牙利数学家Dénes Kőnig和Jenő Egerváry的工作之上创建起来的。匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径(是指从M中没有用到的顶点)开始，并从M中没有用到的顶点结束的交替路径)，它是一种用增广路径求二分图最大匹配的算法。 概念：匹配&amp;最大匹配&amp;完美匹配 匹配： 一种边的集合，其中任意两条边没有公共顶点 最大匹配: 一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。 完美匹配： 如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。 交替路径&amp;增广路径 交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。 增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路。 思路&amp;实现该思路和主要为最佳匹配问题， 题目References 维基百科 Hungarian Algorithm","categories":[{"name":"算法","slug":"算法","permalink":"https://winniekun.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://winniekun.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Java实现生产者-消费者模型","slug":"Java进阶/并发/Java实现生产者-消费者模型","date":"2020-04-21T13:27:00.000Z","updated":"2020-08-30T04:50:22.246Z","comments":true,"path":"Java实现生产者-消费者模型/","link":"","permalink":"https://winniekun.github.io/Java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/","excerpt":"前言","text":"前言 最近在看线程池的实现原理，后面又看了源码，发现其内部是一个生产者-消费者模型，用户是提交的任务（task）是生产者，线程池中的线程（worker）是消费者。 然后感觉对生产者-消费者模型的实现，磕磕绊绊的，所以记录一下。下面会涉及多种生产者-消费者模型的实现，可以先抽象出关键的接口，并实现一些抽象类： 准备生产者消费者接口生产者接口public interface Producer { void produce() throws InterruptedException; } 消费者接口public interface Consumer { void consume() throws InterruptedException; } 生产者消费者抽象类生产者抽象类abstract class AbstractProducer implements Runnable, Producer { @Override public void run() { while (true){ try{ produce(); }catch (Exception e){ e.printStackTrace(); } } } } 消费者抽象类abstract class AbstractConsumer implements Consumer, Runnable { @Override public void run() { while (true){ try{ consume(); }catch (Exception e){ e.printStackTrace(); } } } } Model接口对应的实现生产者-消费者模型，不同的生产者-消费者实现模型都实现该接口， public interface Model { Runnable newRunnableConsumer(); Runnable newRunnableProducer(); } Task将Task作为生产和消费的基本单位 public class Task { private int no; public Task(int no){ this.no = no; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } } 实现一：BlockingQueueBlockingQueue的写法最简单。核心思想是，把并发和容量控制封装在缓冲区中。而BlockingQueue的性质天生满足这个要求。 package com.train.concurrent.procon; import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingDeque; import java.util.concurrent.atomic.AtomicInteger; /** * @Time: 2020/4/21下午8:54 * @Author: kongwiki * @Email: kongwiki@163.com */ public class BlockingQueueModel implements Model { private BlockingQueue&lt;Task&gt; queue; private final AtomicInteger increTaskNo = new AtomicInteger(0); public BlockingQueueModel(int cap){ this.queue = new LinkedBlockingDeque&lt;&gt;(cap); } @Override public Runnable newRunnableConsumer() { return new ConsumerImpl(); } @Override public Runnable newRunnableProducer() { return new ProducerImpl(); } private class ConsumerImpl extends AbstractConsumer implements Runnable, Consumer{ @Override public void consume() throws InterruptedException { Task task = queue.take(); Thread.sleep(500 + (long) (Math.random() * 500)); System.out.println(\"consume: \" + task.getNo()); } } private class ProducerImpl extends AbstractProducer implements Runnable, Producer{ @Override public void produce() throws InterruptedException { Thread.sleep((long) (500 + (Math.random()) * 1000)); Task task = new Task(increTaskNo.getAndIncrement()); System.out.println(\"produce: \" + task.getNo()); queue.put(task); } } public static void main(String[] args) { Model model = new BlockingQueueModel(3); for (int i = 0; i &lt; 2; i++) { new Thread(model.newRunnableConsumer()).start(); } for (int i = 0; i &lt; 5; i++) { new Thread(model.newRunnableProducer()).start(); } } } 实现二：wait&amp;notifypackage com.train.concurrent.procon; import java.util.LinkedList; import java.util.Queue; import java.util.concurrent.atomic.AtomicInteger; /** * @Time: 2020/4/22上午7:40 * @Author: kongwiki * @Email: kongwiki@163.com */ public class WaitNotifyModel implements Model { private int integer; private final Object buffer_lock = new Object(); private final Queue&lt;Task&gt; buffer = new LinkedList&lt;&gt;(); private int cap; public WaitNotifyModel(int cap){ this.cap = cap; } @Override public Runnable newRunnableConsumer() { return new ConsumerImpl(); } @Override public Runnable newRunnableProducer() { return new ProducerImpl(); } public class ProducerImpl extends AbstractProducer implements Runnable, Producer{ @Override public void produce() throws InterruptedException { Thread.sleep((long) (500 + (Math.random() * 1000))); synchronized (buffer_lock){ while (buffer.size() == cap){ buffer_lock.wait(); } Task task = new Task(integer++); buffer.add(task); System.out.println(\"produce: \" + task.getNo()); buffer_lock.notifyAll(); } } } public class ConsumerImpl extends AbstractConsumer implements Runnable, Consumer{ @Override public void consume() throws InterruptedException { synchronized (buffer_lock){ while (buffer.size() == 0){ buffer_lock.wait(); } Task task = buffer.poll(); assert task != null; Thread.sleep((long) (500 + (Math.random() * 1000))); System.out.println(\"consume: \" + task.getNo()); buffer_lock.notifyAll(); } } } public static void main(String[] args) { Model model = new WaitNotifyModel(3); for (int i = 0; i &lt; 3; i++) { new Thread(model.newRunnableConsumer()).start(); } for (int i = 0; i &lt; 5; i++) { new Thread(model.newRunnableProducer()).start(); } } } 实现三：lock &amp;&amp; conditionpackage com.train.concurrent.procon; import java.util.LinkedList; import java.util.Queue; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; /** * @Time: 2020/4/22上午8:01 * @Author: kongwiki * @Email: kongwiki@163.com */ public class LockConditionModel implements Model { private final Lock BUFFER_LOCK = new ReentrantLock(); private final Condition BUFFER_COND = BUFFER_LOCK.newCondition(); private int integer; private Queue&lt;Task&gt; buffer = new LinkedList&lt;&gt;(); private int cap; public LockConditionModel(int cap){ this.cap = cap; } @Override public Runnable newRunnableConsumer() { return new ConsumerImpl(); } @Override public Runnable newRunnableProducer() { return new ProducerImpl(); } public class ProducerImpl extends AbstractProducer implements Producer, Runnable{ @Override public void produce() throws InterruptedException { Thread.sleep((long) (500 + (Math.random() * 1000))); BUFFER_LOCK.lockInterruptibly(); try{ while (buffer.size() == cap){ BUFFER_COND.await(); } Task task = new Task(integer++); buffer.offer(task); System.out.println(\"produce: \"+ task.getNo()); BUFFER_COND.signalAll(); }catch (Exception e){ e.printStackTrace(); }finally { BUFFER_LOCK.unlock(); } } } public class ConsumerImpl extends AbstractConsumer implements Consumer, Runnable{ @Override public void consume() throws InterruptedException { BUFFER_LOCK.lockInterruptibly(); try{ while (buffer.size() == 0){ BUFFER_COND.await(); } Task task = buffer.poll(); assert task != null; System.out.println(\"consume: \" + task.getNo()); BUFFER_COND.signalAll(); }catch (Exception e){ e.printStackTrace(); }finally { BUFFER_LOCK.unlock(); } } } public static void main(String[] args) { Model model = new LockConditionModel(3); for (int i = 0; i &lt; 3; i++) { new Thread(model.newRunnableConsumer()).start(); } for (int i = 0; i &lt; 5; i++) { new Thread(model.newRunnableProducer()).start(); } } }","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://winniekun.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"线程池理解","slug":"Java进阶/并发/线程池理解","date":"2020-04-20T12:23:43.000Z","updated":"2021-04-25T07:50:26.859Z","comments":true,"path":"线程池理解/","link":"","permalink":"https://winniekun.github.io/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%90%86%E8%A7%A3/","excerpt":"线程池的概述","text":"线程池的概述 线程池的内部构建了一个生产者-消费者模型，将线程和任务进行解耦，从而能够良好的缓冲任务，复用线程。同时线程池的运行主要分成两个部分：任务管理、线程管理。 那么生产者-消费者模型体现在哪儿？任务管理可以视为生产者，线程管理视为消费者。任务进入线程池中，线程池会判断其后续的流程： 直接申请线程执行任务 任务缓冲进入阻塞队列，等待线程执行 拒绝该任务 以上属于任务管理，线程管理主要为根据任务请求进行线程的分配，线程执行完之后，继续获取新的任务执行，最后线程获取不到任务，到一定时间之后，该线程被回收。 在Java中，线程池的主要实现类为ThreadPoolExecutor，其实阅读其源码，就可以理解线程池中的所有的思想，以及如何实现。阅读套路：构造方法—-&gt;其他方法及属性。 四个构造方法：其共有四中构造方法，参数分别有5、6、6、7个 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) { ... } public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) { ... } public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) { ... } public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { ... } 必备的参数(5个) corePoolSize：线程池中核心线程的数量 可以形象理解为餐馆就餐中的餐桌，正常情况下的餐桌数量就是corePoolSize。 maximumPoolSize：线程池中线程总数最大值 同上的例子，比作为就餐时间，因为人流量多，老板从后厨新加几个餐桌之后的数量。 在线程池中，从某方面可以将线程分为核心线程和非核心线程，核心线程默认会一直存在在线程池中，即使什么也不干。核心线程数量就是corePoolSize，非核心线程，如果长时间限制的话，会被回收(这和餐桌的例子很契合哇😄)。最大线程总数（maximumPoolSize）= 核心线程数量（corePoolSize） + 非核心线程数量 keepAliveTime：非核心线闲置超时时长 非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程。 TimeUnit unit 枚举类型： 包含有纳秒、微妙、毫秒、秒、分、小时、天 BlockingQueue\\ workQueue：阻塞队列，用于维护等待执行的Runnable任务对象 常用的几个阻塞队列： LinkedBlockingQueue 链式阻塞队列，底层数据结构是链表，默认大小是Integer.MAX_VALUE，也可以指定大小。 ArrayBlockingQueue 数组阻塞队列，底层数据结构是数组，需要指定队列的大小。 SynchronousQueue 同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。 DelayQueue 延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。 非必备的核心参数(2个) ThreadFactory threadFactory 用于自定义线程池的名字、以及兜底的异常处理策略等 RejectedExecutionHandler handler 拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为 ： ThreadPoolExecutor.AbortPolicy：默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：丢弃新来的任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。 ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务。 使用线程池的主要原因有如下: 创建/销毁线程需要消耗系统资源，线程池可以复用已创建的线程。 控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因） 可以对线程做统一管理。 线程池的生命周期线程池本身有一个调度线程，这个线程就是用于管理布控整个线程池里的各种任务和事务，例如创建线程、销毁线程、任务队列管理、线程队列管理等等。所以线程池中也有自己的状态。通过源码了解到ThreadPoolExecutor类中通过volatile int 定义了runState变量表示线程池的状态。 // runState is stored in the high-order bits private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; private static final int STOP = 1 &lt;&lt; COUNT_BITS; private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 运行状态 状态描述 转换方法 RUNNING 能够接受新的任务，并且也能处理阻塞队列中的任务 线程池创建之后 SHUTDOWN 不再接收新提交的任务，清除一些空闲worker，会等待阻塞队列中存储的任务执行完成。 shutdown（） STOP 停止接受新的任务，中断所有线程（包括正在执行的），阻塞队列中为执行的任务全部抛弃，此时poosize = 0, 阻塞队列size = 0; shutdownNow() TIDYING 所有的任务已经终止，workerCount（有效线程数量）数量为0 TERMINATED terminated()方法执行后，进入该状态 任务的管理概述中已经提及，线程池内部就是一个生产者-消费者模型，任务管理视为生产者，线程管理视为消费者，所以接下来详细阐述任务管理和线程管理 任务的调度任务的调度，感觉和操作系统中处理机的调度类似，任务提交之后，进行判断 判断线程池的状态是否为RUNNING，如不执行了，拒绝接收该任务（线程池要保证在RUNNING状态下执行任务）。 如果workerCount &lt; corePoolSize, 创建并启动一个线程，执行该任务。 如果workerCount &gt;= corePoolSize &amp;&amp; 阻塞队列未满，将该任务添加到阻塞队列中。 如果workerCount &gt;=corePoolSize &amp;&amp; 阻塞队里已满&amp;&amp;workerCount &lt; maximumPoolSize，创建并启动一个线程，执行该任务 如果workerCount &gt;= maximumPoolSize &amp;&amp; 阻塞队列已满， 根据拒策略进行拒绝，默认使用是AbortPolicy，放弃任务并抛出异常。 任务调度流程图.png ThreadPoolExecutor中任务调度的实现 public void execute(Runnable command) { if (command == null) throw new NullPointerException(); // 获取线程池状态 int c = ctl.get(); // ② if (workerCountOf(c) &lt; corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } // ③ if (isRunning(c) &amp;&amp; workQueue.offer(command)) { int recheck = ctl.get(); // 3.1 如果isRunning返回false(状态检查)，则remove这个任务，然后执行拒绝策略。 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); // 3.2 线程池处于running状态，但是没有线程，则创建线程 else if (workerCountOf(recheck) == 0) addWorker(null, false); } // ④如果workerCount &gt;=corePoolSize &amp;&amp; 阻塞队里已满&amp;&amp;workerCount &lt; maximumPoolSize，创建并启 // 动一个线程，执行该任务 else if (!addWorker(command, false)) reject(command); } 任务的缓冲（BlockingQueue）这是线程池的关键，其等同于生产者-消费者中的缓冲区，在线程池中，核心是对任务和线程的管理，上述也讲过了核心就是任务和线程的解耦，解耦的方式就是添加缓冲区。在线程池中通过阻塞队列实现缓冲区，暂存任务，工作线程从阻塞队列中获取任务。 阻塞队列常用用于生产者-消费者场景，其除了支持存储任务的线程存储元素，获取任务的线程获取元素之外，还有两个附加的操作（自己编写生产者-消费者最麻烦的地方）： 当队列为空的时候，获取任务的线程会等待队列非空 当队列满的时候，存放任务的线程会等待队列可用。 这样之后，我们就可以只管往里面存、取就行，而不用担心多线程环境下存、取共享变量的线程安全问题。简而言之，阻塞队列（BlockQueue就是生产者存放元素的容器），其提供了四中不同插入、移除、检测元素的方法： 方法 抛出异常 返回特殊值 一直阻塞 超时退出 插入 add(e) offer() put(e) offer(e, time , unit) 移除 remove() poll() take() poll(time, unit) 检查 element() peek() BlockingQueue的实现类有如下的一些 ArrayBlockingQueue LinkedBlockingQueue DelayQueue PriorityBlockingQueue SynchronousQueue 后续会看相应的源码，并整理为博客。目前就不详细解释其区别。 任务的申请由任务的调度可以总结出，任务的执行有两种可能 任务直接由新创建的线程执行 复用线程从阻塞队列中获取任务，执行 第一种情况出现在线程初始创建的时候，以及出现峰值的时候。第二种是线程获取任务绝大多数的情况。这里可以顺便分析ThreadPoolExecutor是如何实现线程的复用的。 第二种的任务的申请使用的是线程池中的getTask的方法 private Runnable getTask() { boolean timedOut = false; // Did the last poll() time out? for (;;) { int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) { decrementWorkerCount(); return null; } int wc = workerCountOf(c); // Are workers subject to culling? // boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; // 如果运行线程数超过了最大线程数，但是缓存队列已经空了，这时递减worker数量 if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) { if (compareAndDecrementWorkerCount(c)) return null; continue; } try { Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; } catch (InterruptedException retry) { timedOut = false; } } } 任务的拒绝任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。 决绝策略在构造方法的时候，就已经讲解了，共四种： ThreadPoolExecutor.AbortPolicy：默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：丢弃新来的任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。 ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务。 线程的管理Worker线程线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。 private final class Worker extends AbstractQueuedSynchronizer implements Runnable{ ... } Worker继承了AbstractQueueSynchronnizer，实现了Runnable接口。 构造方法Worker(Runnable firstTask) { setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); } 通过ThreadFactory方法创建线程，firstTask可为空，为空的时候，也就对应线程去阻塞队列中去获取任务，若是不为空，对应的为直接执行任务。 run方法public void run() { runWorker(this); } Worker线程增加(涉及到线程的复用)Worker线程的增加是通过线程池中的addWorker()方法 上篇private boolean addWorker(Runnable firstTask, boolean core) { // 源码中的上半部分 retry: for (;;) { int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) { // 当前线程的总数 int wc = workerCountOf(c); if (wc &gt;= CAPACITY || // 1.如果core是ture,证明需要创建的线程为核心线程，则先判断当前线程是否大于核心线程 // 如果core是false,证明需要创建的是非核心线程，则先判断当前线程数是否大于总线程数 // 如果不小于，则返回false wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop } } 以上的部分用于判断线程数量是否超出阀值，超过了就返回为false 下篇boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try { // 创建worker对象 w = new Worker(firstTask); // 实例化thread对象 final Thread t = w.thread; if (t != null) { // 全局锁 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) { if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); // 加入到workers set中 workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; } } finally { mainLock.unlock(); } if (workerAdded) { // 启动线程 t.start(); workerStarted = true; } } } finally { if (! workerStarted) addWorkerFailed(w); } return workerStarted; 创建worker对象，并初始化一个Thread对象，然后启动这个线程对象。t.start()方法会调用Worker中的run方法，run方法又使用了runWorker()方法，也就是线程的任务执行 线程的任务执行runWorker()方法final void runWorker(Worker w) { Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); boolean completedAbruptly = true; try { // Worker执行firstTask或从workQueue中获取任务，如果getTask方法不返回null,循环不退出 while (task != null || (task = getTask()) != null) { w.lock(); if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try { beforeExecute(wt, task); Throwable thrown = null; try { // 执行任务 task.run(); } catch (RuntimeException x) { thrown = x; throw x; } catch (Error x) { thrown = x; throw x; } catch (Throwable x) { thrown = x; throw new Error(x); } finally { afterExecute(task, thrown); } } finally { task = null; w.completedTasks++; w.unlock(); } } completedAbruptly = false; } finally { processWorkerExit(w, completedAbruptly); } } 首先去执行创建这个worker时就有的任务，当执行完这个任务后，worker的生命周期并没有结束，在while循环中，worker会不断地调用getTask方法从阻塞队列中获取任务然后调用task.run()执行任务,从而达到复用线程的目的。只要getTask方法不返回null,此线程就不会退出。 常见的线程池Executors类中提供的几个静态方法来创建线程池。通过前面的ThreadPoolExecutor的构造方法，就可以明白这些线程池具体干啥的，很可惜，阻塞队列的具体实现还没有看，而且线程池的demo写的也不多，认识不深刻，所以就暂时先不写。 newCachedThreadPoolpublic static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); } newFixedThreadPoolpublic static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); } newSingleThreadExecutorpublic static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); } newScheduledThreadPoolpublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } //ScheduledThreadPoolExecutor(): public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue()); } Executor框架 ThreadExecutorUML.png References 线程池原理 深入理解线程池 —— Java线程池是如何诞生的 Java线程池实现原理及其在美团业务中的实践","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://winniekun.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"Java线程之间通信方式","slug":"Java进阶/并发/Java线程之间通信方式","date":"2020-04-19T08:49:54.000Z","updated":"2021-04-27T07:42:26.716Z","comments":true,"path":"Java线程之间通信方式/","link":"","permalink":"https://winniekun.github.io/Java%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/","excerpt":"线程通信","text":"线程通信 合理的使用Java多线程可以更好地利用服务器资源。一般来讲，线程内部有自己私有的线程上下文，互不干扰。但是当我们需要多个线程之间相互协作的时候，就需要我们掌握Java线程的通信方式。本文将介绍Java线程之间的几种通信原理。 锁同步机制使用synchronized public class lockSyn { static class ThreadA implements Runnable{ @Override public void run() { synchronized (this) { for (int i = 0; i &lt; 10; i++) { System.out.println(\"ThreadA \" + i); } } } } static class ThreadB implements Runnable{ @Override public void run() { synchronized (this) { for (int i = 0; i &lt; 10; i++) { System.out.println(\"ThreadB \" + i); } } } } public static void main(String[] args) throws InterruptedException { new Thread(new ThreadA()).start(); Thread.sleep(1000); new Thread(new ThreadB()).start(); } } 这段程序能够保证先执行线程A，之后再执行线程B。 等待/通知机制使用wait()/notify()机制 public class waitNotify { private static Object lock = new Object(); static class A implements Runnable{ @Override public void run() { synchronized (lock){ for (int i = 0; i &lt; 5; i++) { System.out.println(\"A:\" + i); lock.notify(); try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } lock.notify(); } } } static class B implements Runnable{ @Override public void run() { synchronized (lock){ for (int i = 0; i &lt; 5; i++) { System.out.println(\"B:\" + i); lock.notify(); try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } lock.notify(); } } } public static void main(String[] args) throws InterruptedException { new Thread(new A()).start(); Thread.sleep(1000); new Thread(new B()).start(); } } wait(): 会释放锁。 信号量机制使用volatile定义信号量(涉及JMM—-Java内存模型) public class semaphore { private static volatile int signal = 0; static class ThreadA implements Runnable{ @Override public void run() { while (signal &lt; 10){ if(signal % 2 == 0){ System.out.println(\"ThreadA: \" + signal); signal++; } } } } static class ThreadB implements Runnable{ @Override public void run() { while (signal &lt; 10){ if(signal % 2 == 1){ System.out.println(\"ThreadB: \"+ signal); signal++; } } } } public static void main(String[] args) throws InterruptedException { new Thread(new ThreadA()).start(); Thread.sleep(1000); new Thread(new ThreadB()).start(); } }","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://winniekun.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"TCP/IP通识","slug":"网络/TCP-IP通识","date":"2020-04-17T01:36:34.000Z","updated":"2020-08-30T04:50:22.262Z","comments":true,"path":"TCP-IP通识/","link":"","permalink":"https://winniekun.github.io/TCP-IP%E9%80%9A%E8%AF%86/","excerpt":"OSI参考模型","text":"OSI参考模型 序号 层 常用协议 应用 7 应用层 HTTP、SMTP、SSH 针对特定应用的协议 6 表示层 同上 设备固有数据格式和网路标准格式转化 5 会话层 同上 通信管理。负责建立和断开通信链接 4 传输层 TCP、UDP、UDP-Lite、SCTP、DCCP 管理两个节点之间的数据传输。 3 网络层 IP、ARP、IPv4、IPv6、ICMP 地址管理和路由器选择 2 数据链路层 以太网、无线LAN、PPP… 互联设备之间传送和识别数据帧（将0 、1序列划分为具有意义的数据帧传送给终端） 1 物理层 同上 0 、1数字信号 TCP/IP的具体意义从字面意思上说，TCP/IP指的就是TCP、IP两个协议。虽然有些情况下就是这两个协议，其实不然。在大多数情况下，它是利用IP进行通信时所必须用到的协议群的统称。譬如：IP或ICMP、TCP或UDP、TELNET或FTP、以及 HTTP都属于TCP/IP协议。TCP/IP泛指这些协议。有时也统称TCP/IP为网际协议族。 TCP/IP协议分层模型 序号 层 常用协议 5 应用层 HTTP、SMTP、SSH 4 传输层 TCP、UDP 3 网络层 IP、ICMP、ARP 2 数据链路层 PPP 1 物理层 OSI模型和TCP/IP模型的区别OSI: 注重通信协议必要的功能是什么 TCP/IP: 注重在计算机实上现协议应该开发哪种程序 一些协议之间的区别IP和ICMPIP协议: 能使得整个互联网都能收到数据的协议，使用IP地址作为主机的标识，将数据包发送给目标地址。但是其不具有重发机制，即使发送失败，也不会重发，所以是一种非可靠性传输协议。 ICMP: IP数据包发送途中出现异常而无法发送到目标地址，这时使用ICMP协议给发送者发送一个发送异常的通知 TCP和UDPTCP：面向连接的可靠性传输协议，其为了建立和断开链接，需要至少7次的发包收包（3次握手、4次分手） UDP：面向无连接的不可靠性传输协议，其不会关注目标是否真的接收到了数据包（多媒体领域） References 图解TCP/IP协议","categories":[{"name":"网络","slug":"网络","permalink":"https://winniekun.github.io/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"ip","slug":"ip","permalink":"https://winniekun.github.io/tags/ip/"},{"name":"tcp","slug":"tcp","permalink":"https://winniekun.github.io/tags/tcp/"}]},{"title":"矩阵树的定理","slug":"算法/实现-图论/矩阵树的实现","date":"2020-04-10T02:07:19.000Z","updated":"2020-08-30T04:50:22.260Z","comments":true,"path":"矩阵树的实现/","link":"","permalink":"https://winniekun.github.io/%E7%9F%A9%E9%98%B5%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"TODO","text":"TODO 前言矩阵树定理的理解，且代码实现。并且添加了几道实战题目 简介&amp;思路Kirchhoff 矩阵树定理（简称矩阵树定理）解决了一张图的生成树个数计数问题。 无向图设$G$是一个有n个顶点的无向图。定义度数矩阵$D(G)$为： $D{ii}(G) = \\mathrm{deg}(i), D{ij} = 0, i\\neq j$ G的邻接矩阵$A(G)$为： $A{ij}(G) = A{ij}(G)$ 定义 Laplace 矩阵（亦称 Kirchhoff 矩阵）$L$为： $L(G) = D(G) - A(G)$ $G$的所有不同的生成树的个数等于其Laplace矩阵（$L(G)$）的任何一个n-1主子式的绝对值，所谓 n-1 阶主子式,就是对于 r(1≤r≤n),将$G$的第 r 行、第 r 列同时去掉后得到的新矩阵$G_r$ 举例： 无向图$G$如下图所示 则$A(G)$表示为： $\\begin{matrix}0 &amp; 1 &amp; 1 &amp; 0\\\\ 1 &amp; 0 &amp; 1 &amp; 1\\\\ 1 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\\\end{matrix} $ $D(G)$表示为: $\\begin{matrix}2 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 3 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 2 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1\\\\\\end{matrix} $ $L(G)$表示为： $\\begin{matrix}2 &amp; -1 &amp; -1 &amp; 0\\\\ -1 &amp; 3 &amp; -1 &amp; -1\\\\ -1 &amp; -1 &amp; 2 &amp; 0\\\\0&amp;-1&amp;0&amp;1\\\\ \\end{matrix} $ 去除$r$ = 1之后得到主子式$G_r$的绝对值即为该图的生成树个数。 $G_r$ = $\\begin{matrix} 3 &amp; -1 &amp; -1 \\\\-1&amp;2&amp;0\\\\-1&amp;0&amp;1\\\\ \\end{matrix} $ 根据公式计算的 $|G_r|$ = 3 所以该图共有三种生成树。 生成树个数.png 是不是很神奇， 我也觉得很神奇，然后去看了证明，也很神奇😑 有向图同理同理 行列式的变换 交换两行/列位置，行列式取相反数 对一行/列乘以某数，行列式也乘以某数 用一行的倍数减去另一行，行列式的值不变 一个上三角行列式的值等于对角线的乘积 转置矩阵，行列式不变 ACM矩阵行列式计算 实现按照数学公式计算余子式的值的话，复杂度达到$O(N!)*N $ ，所以需要通过行列式的性质，进行基础的变换之后再计算。 题目 「HEOI2015」小 Z 的房间 「FJOI2007」轮状病毒 小Z的房间矩阵树定理的裸题，题目给定的限制为1≤n,m≤9 矩阵维度限制在了个位数，算法有待优化。 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; typedef long long LL; const int N = 100; const LL mod = 1e9; int n, m, ed; LL ans = 1; int h[N][N], vis[N]; LL f[N][N]; char s[N]; int main() { scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { scanf(\"%s\", s); for (int j = 0; j &lt; m; j++) if (s[j] == '.') h[i][j + 1] = 1; //记录下房间的位置 else vis[(i - 1) * m + j + 1] = 1; //重要！！为墙的行一定全为0！！ } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) if (h[i][j]) { //若为房间 ed = 0; //纪录度数矩阵 if (h[i][j - 1]) f[(i - 1) * m + j][(i - 1) * m + j - 1] = -1, ed++; //左 if (h[i][j + 1]) f[(i - 1) * m + j][(i - 1) * m + j + 1] = -1, ed++; //右 if (h[i - 1][j]) f[(i - 1) * m + j][(i - 2) * m + j] = -1, ed++; //上 if (h[i + 1][j]) f[(i - 1) * m + j][i * m + j] = -1, ed++; //下 f[(i - 1) * m + j][(i - 1) * m + j] = ed; //加上度数矩阵 } } n = n * m - 1; //删去最后一行最后一列，并计算行列式的大小 for (int i = 1; i &lt;= n; i++) if (!vis[i]) { //注意！ 非墙的才继续 for (int j = i + 1; j &lt;= n; j++) if (!vis[j]) //同上 while (f[j][i]) { //辗转相除 LL r = f[i][i] / f[j][i]; for (int k = 1; k &lt;= n; k++) f[i][k] = (f[i][k] - f[j][k] * r % mod + mod) % mod, swap(f[i][k], f[j][k]); ans = (mod - ans) % mod; //交换两行，答案取负 } if (f[i][i] == 0) { puts(\"0\"); return 0; } //若主对角线有0，则答案为0 ans = (ans * f[i][i] + mod) % mod; //计算答案 } printf(\"%lld\\n\", ans); } 一下是测试结果 矩阵树定理-小Z的房间.png 轮状病毒总结引用周东老师的结束语吧： 扎实的数学功底是解决问题的保证,创造性地联想是解决问题的灵魂。 References 生成树的计数及其应用 —- 周东","categories":[{"name":"算法","slug":"算法","permalink":"https://winniekun.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://winniekun.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"程序员的魔法---命令行","slug":"操作系统/linux/linux-command-lines","date":"2020-04-10T01:13:07.000Z","updated":"2020-08-30T04:50:22.253Z","comments":true,"path":"linux-command-lines/","link":"","permalink":"https://winniekun.github.io/linux-command-lines/","excerpt":"前言不知不觉已经使用Ubuntu四年了，算是一只老白了。命令行，感觉对于程序员来说，简直和魔法一样，输入一行命令，然后就能得到你想要的结果，极其的amazing。当然，也和魔法一样难以使用，因为要记住很多很多的内容。","text":"前言不知不觉已经使用Ubuntu四年了，算是一只老白了。命令行，感觉对于程序员来说，简直和魔法一样，输入一行命令，然后就能得到你想要的结果，极其的amazing。当然，也和魔法一样难以使用，因为要记住很多很多的内容。 常用操作自言自语 echo 在哪儿 pwd(Print Working Directory) 换个地方 cd (change directory) 瞅瞅 ls ls ls -l 显示当前目录下文件信息 ls -la 列出所有文件，包括以.开头的隐藏文件 ls -lh 做单位换算，将byte换算成K，M，G等. 寻求帮助 man（manual）、 xxx -h xxx —help 文件内容 打印文件内容 cat(concatenate and print files) cat a.txt 头和尾 head、tail head a.txt tail a.txt 交互浏览 less less a.txt 内容查找 / 、grep less | grep xxx (grep -n 显示行数) 单词统计 wc 管道和重定向 重定向: 改变输入输出设备 标准输入/ 输出: 控制台/键盘 / 屏幕 echo hello &gt; hello.txt hello 输入到hello.txt echo world &gt;&gt; hello.txt world 追加输入到hello.txt的下一行 再追加输入下一行仍然使用&gt;&gt; cat &lt; hello.txt 将hello.txt文件输出到控制台 管道: 建一个命令的标准输出作为下一个命令的标准输出 man less | grep sim 查看less的用户手册, 然后匹配出包含sim的行 man less | grep sim - n | grep That &gt; that.txt 查看less的用户手册, 然后匹配出包含sim的行, 之后将又包含that的行存入that.txt 文件权限(chmod)Change Mode改变文件权限, Owner - Group - Others chmod +x foo 增加可执行权限/ +w +r chmod -x foo 移除可执行权限/ -w -r chmod 740 foo 把foo的权限设置成740 Owner: 7 = 1 + 2 + 4 = 可执行 + 可写 +可读 Group: 4 = 4 = 可读 Others: 0 = 没有任何权限 常见: -rw-r—r—r 默认(644) -rwxr-xr-x 755 -rwxrwxrwx 777 文件基本操作 mv(移动文件 重命名 剪切+粘贴) mv 需要移动文件 /指定目录 (移动文件) mv hwllo.txt hello.txt (重命名) cp(复制文件 复制文件夹) cp a.txt a_copy.txt cp -r dir1 dir2 rm(删除文件 删除文件夹) rm a.txt (删除一个文件) rm a.txt b.txt c.txt(删除多个文件 也可使用 rm *.txt) rm -r dir (删除文件夹) yes: 不停输出 进程管理 top: 显示或者更新排序过的进程信息 默认按照CPU占用率排序(导致风扇很响的那个玩意儿) ps: 显示进程状态(Process Status) 默认显示当前用户有控制终端的进程 ps aux : 显示所有进程, 包括其他用户 ps aux | grep idea | wc -l : 查看idea起了多少进程 kill/killall: 杀进程 kill: 终止或者给进程信号 kill -singal_number/-singal_name PID kill PID kill -9/-KILL PID killall: 按照名字终止进程","categories":[{"name":"Linux","slug":"Linux","permalink":"https://winniekun.github.io/categories/Linux/"}],"tags":[{"name":"命令行","slug":"命令行","permalink":"https://winniekun.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"}]},{"title":"JavaIO的前世-BIO阻塞模型","slug":"Java进阶/IO/java-bio","date":"2020-04-08T02:50:53.000Z","updated":"2020-08-30T04:50:22.244Z","comments":true,"path":"java-bio/","link":"","permalink":"https://winniekun.github.io/java-bio/","excerpt":"流","text":"流 基础使用","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"I/O","slug":"I-O","permalink":"https://winniekun.github.io/tags/I-O/"}]},{"title":"JavaIO的今世-NIO","slug":"Java进阶/IO/java-nio","date":"2020-04-07T06:16:56.000Z","updated":"2020-08-30T04:50:22.245Z","comments":true,"path":"java-nio/","link":"","permalink":"https://winniekun.github.io/java-nio/","excerpt":"Java NIO新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。","text":"Java NIO新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。 BIO带来的挑战BIO(blocking-IO) 不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputStream 读取时都有可能会阻塞。一旦有线程阻塞将会失去 CPU 的使用权，这在当前的大规模访问量和有性能要求情况下是不能接受的。虽然当前的网络 I/O 有一些解决办法，如一个客户端一个处理线程，出现阻塞时只是一个线程阻塞而不会影响其它线程工作，还有为了减少系统线程的开销，采用线程池的办法来减少线程创建和回收的成本，但是有一些使用场景仍然是无法解决的。如当前一些需要大量 HTTP 长连接的情况，像淘宝现在使用的 Web 旺旺项目，服务端需要同时保持几百万的 HTTP 连接，但是并不是每时每刻这些连接都在传输数据，这种情况下不可能同时创建这么多线程来保持连接。即使线程的数量不是问题，仍然有一些问题还是无法避免的。如这种情况，我们想给某些客户端更高的服务优先级，很难通过设计线程的优先级来完成，另外一种情况是，我们需要让每个客户端的请求在服务端可能需要访问一些竞争资源，由于这些客户端是在不同线程中，因此需要同步，而往往要实现这些同步操作要远远比用单线程复杂很多。以上这些情况都说明，我们需要另外一种新的 I/O 操作方式。 NIO 简介NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel 、Selector、Buffer 等抽象。 NIO有两种解释：一种叫非阻塞IO（Non-blocking I/O），另一种叫新的IO（New I/O），其实是同一个概念。它是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。(只有Socket Channel 才能配置为非阻塞，而 FileChannel 不能， 为 FileChannel 配置非阻塞也没有意义) NIO是一种基于通道和缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存（区别于JVM的运行时数据区），然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的直接引用进行操作。这样能在一些场景显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 ChannelChannel是对 BIO 中的流的模拟，可以通过它读写数据(真正读写数据的是Buffer)，永远不会出现直接向Channel写入数据或者直接从Channel中读取数据的操作。 通道与流的不同之处在于： 流是单向的 - 一个流只能单纯的负责读或写。 通道是双向的 - 一个通道可以同时用于读写。 因为Channel是双向的，其能更好的反应底层操作系统的真实情况（如操作系统中的通道）。同时Channel包括以下类型(标粗的是常用的类型)： FileChannel：从文件中读写数据； DatagramChannel：通过 UDP 读写网络中数据； SocketChannel：通过 TCP 读写网络中数据； ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。 基本使用 从Channel进行读取数据 首先会创建一个Buffer，Channel将数据读入其中，之后在Bufer中读取数据 public static void read() throws IOException { FileInputStream fileInputStream = new FileInputStream(\"aaa.txt\"); FileChannel inputChannel = fileInputStream.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(1024); inputChannel.read(buffer); // 切换为读模式 buffer.flip(); while (buffer.hasRemaining()){ byte b = buffer.get(); System.out.println(\"Character: \" + (char)b); } buffer.clear(); fileInputStream.close(); } 向Channel写入数据 创建Buffer，填充数据。之后Channel去写出数据 public static void write() throws IOException { FileOutputStream fileOutputStream = new FileOutputStream(\"bbb.txt\"); FileChannel outChannel = fileOutputStream.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(1024); byte[] msg = \"hello i'm wkk\".getBytes(); buffer.put(msg); buffer.flip(); outChannel.write(buffer); fileOutputStream.close(); } Buffer A buffer is a linear, finite sequence of elements of a specific * primitive type. Aside from its content, the essential properties of a * buffer are its capacity, limit, and position: --- 摘自Buffer源码 Buffer本身就是一块内存，底层实现上，实际是一个数组。数据的读写均是通过Buffer实现。 public class NioBase { public static void main(String[] args) { // 初始化一个Buffer IntBuffer buffer = IntBuffer.allocate(1024); // 向Buffer中随机写入10个数字 for (int i = 0; i &lt; 10; i++) { int randomNumber = new SecureRandom().nextInt(20); buffer.put(randomNumber); } // 切换为读模式 buffer.flip(); while (buffer.hasRemaining()){ System.out.print(buffer.get() + \" \"); } } } Capacity、Position、Limit * &lt;p&gt; A buffer's &lt;i&gt;capacity&lt;/i&gt; is the number of elements it contains. The * capacity of a buffer is never negative and never changes. &lt;/p&gt; * * &lt;p&gt; A buffer's &lt;i&gt;limit&lt;/i&gt; is the index of the first element that should * not be read or written. A buffer's limit is never negative and is never * greater than its capacity. &lt;/p&gt; * * &lt;p&gt; A buffer's &lt;i&gt;position&lt;/i&gt; is the index of the next element to be * read or written. A buffer's position is never negative and is never * greater than its limit. &lt;/p&gt; 在NIO中，真正和数据打交道的是Buffer。可以将Buffer简单的理解为一组基本数据类型的元素列表，其通过以下的基本变量来保存这个数据的当前位置状态，共有四个索引（mark用于记录以下三个索引，所以没有记录）。 索引 说明 capacity 缓冲数组的总长度 position 下一个要操作的数据元素的位置 limit 缓冲区数组不可操作的下一个元素的位置， limit&lt;=capacity image demopublic static void main(String[] args) { // 创建缓冲区 ByteBuffer buffer = ByteBuffer.allocate(1024); //buffer中四个变量的值 System.out.println(\"初始时----&gt;limit----&gt;\" + buffer.limit()); System.out.println(\"初始时----&gt;capacity----&gt;\" + buffer.capacity()); System.out.println(\"初始时----&gt;position----&gt;\" + buffer.position()); System.out.println(\"初始时----&gt;mark----&gt;\" + buffer.mark()); System.out.println(\"--------------------------------\"); //初始时----&gt;limit----&gt;1024 //初始时----&gt;capacity----&gt;1024 //初始时----&gt;position----&gt;0 //初始时----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=0 lim=1024 cap=1024] String s = \"abcd\"; buffer.put(s.getBytes()); //buffer添加数据之后，四个变量的值 System.out.println(\"put完之后----&gt;limit----&gt;\" + buffer.limit()); System.out.println(\"put完之后----&gt;capacity----&gt;\" + buffer.capacity()); System.out.println(\"put完之后----&gt;position----&gt;\" + buffer.position()); System.out.println(\"put完之后----&gt;mark----&gt;\" + buffer.mark()); //put完之后----&gt;limit----&gt;1024 //put完之后----&gt;capacity----&gt;1024 //put完之后----&gt;position----&gt;4 //put完之后----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=4 lim=1024 cap=1024] buffer.flip(); System.out.println(\"-------------------------------------------\"); System.out.println(\"flip()之后----&gt;limit----&gt;\" + buffer.limit()); System.out.println(\"flip()之后----&gt;capacity----&gt;\" + buffer.capacity()); System.out.println(\"flip()之后----&gt;position----&gt;\" + buffer.position()); System.out.println(\"flip()之后----&gt;mark----&gt;\" + buffer.mark()); byte[] bytes = new byte[buffer.limit()]; buffer.get(bytes); System.out.println(new String(bytes, 0, bytes.length)); //flip()之后----&gt;limit----&gt;4 //flip()之后----&gt;capacity----&gt;1024 //flip()之后----&gt;position----&gt;0 //flip()之后----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=0 lim=4 cap=1024] //abc System.out.println(\"-------------------------------------------\"); System.out.println(\"读完之后----&gt;limit----&gt;\" + buffer.limit()); System.out.println(\"读完之后----&gt;capacity----&gt;\" + buffer.capacity()); System.out.println(\"读完之后----&gt;position----&gt;\" + buffer.position()); System.out.println(\"读完之后----&gt;mark----&gt;\" + buffer.mark()); //读完之后----&gt;limit----&gt;4 //读完之后----&gt;capacity----&gt;1024 //读完之后----&gt;position----&gt;3 //读完之后----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=3 lim=4 cap=1024] System.out.println(\"----------------清空缓冲区-------------\"); buffer.clear(); System.out.println(\"清空之后----&gt;limit----&gt;\" + buffer.limit()); System.out.println(\"清空之后----&gt;capacity----&gt;\" + buffer.capacity()); System.out.println(\"清空之后----&gt;position----&gt;\" + buffer.position()); System.out.println(\"清空之后----&gt;mark----&gt;\" + buffer.mark()); //清空之后----&gt;limit----&gt;1024 //清空之后----&gt;capacity----&gt;1024 //清空之后----&gt;position----&gt;0 //清空之后----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=0 lim=1024 cap=1024] } 关于这三种索引的实际关系，以及flip() clear()在下述Buffer的读写中会详细阐述 Buffer 类型Buffer实现了java的所有的基础数据类型 ByteBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer CharBuffer MappedByteBuffer 使用Buffer对象之前需要先进行分配，每个类型的Buffer类都可以使用静态方法allocate（）分配该Buffer的容量大小 读和写向Buffer中写入数据：有两种方式： 通过channel.read(buffer)写入数据 RandomAccessFile file = new RandomAccessFile(\"../../Downloads/aaa.txt\", \"rw\"); FileChannel inChannel = file.getChannel(); // 创建缓冲区 ByteBuffer buffer = ByteBuffer.allocate(1024); // 从channel中写入数据 int read = inChannel.read(buffer); 直接通过buffer.put()写入数据 // 创建缓冲区 ByteBuffer buffer = ByteBuffer.allocate(18); String s = \"abcd\"; buffer.put(s.getBytes()); flip()方法 使用该方法之后，position索引会指向0，limit索引会指向缓冲区数组不可操作的下一个元素的位置（也可表示为当前缓冲数组可读元素的长度） flip__方法索引变化.png 所以，flip()方法也可以理解为切换读模式，输入一定的元素之后，感觉需要读出数据，使用flip()方法，切换为读的模式。 从Buffer中读出数据同理，也有两种方式从Buffer中读出数据 channel.write(buffer) buffer.get() clear()方法，操作数据的索引重归初始状态，类似于数据被清空，可以理解为切换写模式 Selector用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。即用选择器，借助单一线程，就可对数量庞大的活动I/O通道实施监控和维护。其和单片机中的事件轮询是一个道理,可惜本科上单片机的时候,并没有好好听(对不起小邹邹) NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。 NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式 去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。 通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时， 就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。 因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件， 对于 IO 密集型的应用具有很好地性能。 应该注意的是，只有Socket的Channel 才能配置为非阻塞，而 FileChannel 不能， 为 FileChannel 配置非阻塞也没有意义。 使用Selector的优点: 使用更少的线程来处理任务, 相比更多的线程,避免了线程上下文的切换开销 可以将上图做更细致的绘制: NIO模型的服务器端如何实现非阻塞？服务器上所有Channel需要向Selector注册，而Selector则负责监视这些Channel的IO状态(观察者)，当其中任意一个或者多个Channel具有可用的IO操作时，该Selector的select()方法将会返回大于0的整数(表示该Selector上有多少个Channel具有可用的IO操作)，并提供了selectedKeys()方法来返回这些Channel对应的SelectionKey集合(一个SelectionKey对应一个就绪的通道)。正是通过Selector，使得服务器端只需要不断地调用Selector实例的select()，即可知道当前所有Channel是否有需要处理的IO操作。 步骤创建选择器Selector selector = Selector.open(); 绑定端口,通道注册到选择器// 绑定端口 ServerSocketChannel server = ServerSocketChannel.open(); server.configureBlocking(false); // 设置为非阻塞 ServerSocket socket = server.socket(); socket.bind(new InetSocketAddress(port)); // 将通道注册到该线程的选择器 server.register(selector, SelectionKey.OP_ACCEPT); 通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。 在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类： SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE 监听事件selector.select(); 使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。 获取可达事件// 可达事件 Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; iterator = selectionKeys.interator(); while(iterator.hasnext()){ SelectionKey key = iterator.next(); if(key.isAcceptable()){ // ... }else if(key.isReadable()){ //... } // remove已经处理的事件 iterator.remove(); } 事件循环因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。 while(true){ // 监听事件 selector.select(); // 获取可达事件 Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; iterator = selectionKeys.interator(); while(iterator.hasnext()){ SelectionKey key = iterator.next(); if(key.isAcceptable()){ // ... }else if(key.isReadable()){ //... } // remove已经处理的事件 iterator.remove(); } } 整合public void start(){ // 1. 创建选择器 Selector selector = Selector.open(); // 2. 绑定端口 通道注册到选择器 ServerSocketChannel serverChannel = ServerSocketChannel.open(); serverChannel.configureBlocking(false); ServerSocket socket = serverChannel.socket(); socket.bind(new InetSocketAddress(port)); // 通道注册到selector上 serverChannel.register(selector, SelectionKey.OP_ACCEPT); // 事件轮询 while(true){ // 3 监听事件 selector.select(); // 4 获取可达事件 Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator(); while(iterator.hasNext()){ SelectionKey key = itrator.next(); if (key.isAcceptable()) { ServerSocketChannel server = (ServerSocketChannel) key.channel(); // 服务器会为每个新连接创建一个 SocketChannel SocketChannel client = server.accept(); client.configureBlocking(false); // 这个新连接的channel主要用于从客户端读取数据 client.register(selector, SelectionKey.OP_READ); }else if(key.isReadable()){ SocketChannel client = (SocketChannel)key.channel(); // 数据的处理 ByteBuffer buffer = ByteBuffer.allocate(1024); buffer.clear(); while (channel.read(buffer) &gt; 0); buffer.flip(); channel.write(buffer); } iterator.remove(); } } } 应用创建一个简单的服务端 public static void main(String[] args) throws IOException { // 服务端监听5个端口 int[] ports = new int[5]; int base = 9000; for (int i = 0; i &lt; 5; i++) { ports[i] = base++; } // 创建选择器 Selector selector = Selector.open(); // 绑定端口 通道注册到选择器 for (int port : ports) { ServerSocketChannel server = ServerSocketChannel.open(); server.configureBlocking(false); ServerSocket socket = server.socket(); socket.bind(new InetSocketAddress(port)); server.register(selector, SelectionKey.OP_ACCEPT); System.out.println(\"监听端口: \" + port); } // 事件轮询 while (true) { // 监听事件 int num = selector.select(); System.out.println(\"numbers: \" + num); // 获取可达事件 Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); System.out.println(\"可达事件集有: \" + selectionKeys.size()); for (SelectionKey selectionKey : selectionKeys) { System.out.println(\"可达事件集类型有: \" + selectionKey); } // 事件处理 Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator(); while (iterator.hasNext()) { SelectionKey key = iterator.next(); if (key.isAcceptable()) { ServerSocketChannel server = (ServerSocketChannel) key.channel(); SocketChannel client = server.accept(); client.configureBlocking(false); client.register(selector, SelectionKey.OP_READ); System.out.println(\"获得客户端的链接\" + client); } else if (key.isReadable()) { SocketChannel channel = (SocketChannel) key.channel(); ByteBuffer buffer = ByteBuffer.allocate(1024); buffer.clear(); while (channel.read(buffer) &gt; 0); buffer.flip(); channel.write(buffer); System.out.println(\"读取: \" + buffer + \", 来自于\" + channel); } // 记得remove iterator.remove(); } } } References Java NIO IBM NIO 入门","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"I/O","slug":"I-O","permalink":"https://winniekun.github.io/tags/I-O/"}]},{"title":"堆排序","slug":"算法/排序/堆排序","date":"2020-04-03T13:35:01.000Z","updated":"2020-08-30T04:50:22.261Z","comments":true,"path":"堆排序/","link":"","permalink":"https://winniekun.github.io/%E5%A0%86%E6%8E%92%E5%BA%8F/","excerpt":"堆排序","text":"堆排序 堆排序在 top K 问题中使用比较频繁，并且经常被用来实现优先级队列。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 。 堆的定义如下： $L(i) \\leq L(2i)$ 且 $L(i) \\leq L(2i+1)$ (小根堆) $L(i) \\geq L(2i)$且 $L(i) \\geq L(2i+1)$ （大根堆） 大根堆示意图.png 堆排序的关键是构造初始堆，对初始序列建堆，就是一个反复筛选的过程，因为是近似于完全二叉树，所以从第$\\lfloor n/2 \\rfloor$为根的子树开始调整（对于大根堆，根节点的关键字和其左右子女中关键字相比较大的进行交换）之后依次对各个节点$\\lfloor n/2 \\rfloor -1 ～ 1$为根的子树进行筛选。 实例对关键字序列：53、17、 78、 9、 45、 65、 87 、32 构建大根堆 大根堆的构建.png 插入插入是从尾部插入(当前堆有n个元素，在第n+1位置中插入)，然后调整 删除删除是从根节点开始删除，删除之后再进行调整 Java代码实现public void buildMaxHeap(int[] nums) { int length = (nums.length - 1) / 2; // 从n/2开始构建初始堆 for (int i = length; i &gt;= 0; i--) { adjustDown(nums, i, nums.length-1); } } private void adjustDown(int[] nums, int k, int len) { nums[0] = nums[k]; // 以第k个节点为根的子树进行调整 for (int i = 2 * k; i &lt;= len; i *= 2) { // 寻找子树中的最值 if(i &lt; len &amp;&amp; nums[i] &lt; nums[i+1]){ i ++; } if(nums[0] &gt;= nums[i]){ break; } else { nums[k] = nums[i]; k = i; } } nums[k] = nums[0]; }","categories":[{"name":"排序","slug":"排序","permalink":"https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"选择","slug":"选择","permalink":"https://winniekun.github.io/tags/%E9%80%89%E6%8B%A9/"}]},{"title":"AVL树详解","slug":"数据结构/AVL树详解","date":"2020-03-28T02:23:42.000Z","updated":"2020-08-30T04:50:22.253Z","comments":true,"path":"AVL树详解/","link":"","permalink":"https://winniekun.github.io/AVL%E6%A0%91%E8%AF%A6%E8%A7%A3/","excerpt":"简介","text":"简介 AVL树的引入是因为BST在极端的情况下，会退化为链表，那么查找的时间从$O(logN)$ —-&gt; $O(N)$ AVL树是一种自平衡的二叉树，定义如下 BST 左、右子树高度差的绝对值不超过1(平衡因子Balance Factor)空树、左右子树都是AVL AVL树.png 插入&amp;旋转三节点单旋转左旋 AVL_左旋.png 右旋 AVL_右旋.png 三节点双旋转LR旋转 AVL_LR.png RL旋转同理 什么时候需要旋转插入关键字key后，节点p的平衡因子由原来的1或者-1，变成了2或者-2，则需要旋转；只考虑插入key到左子树left的情形，即平衡因子为2 情况1：key&lt;left.key, 即插入到left的左子树，需要进行单旋转，将节点p右旋 情况2：key&gt;left.key, 即插入到left的右子树，需要进行双旋转，先将left左旋，再将p右旋 插入到右子树right、平衡因子为-2，完全对称 情况1 AVL_插入_情况1.png 情况2 AVL_插入_情况2_1.png 删除类似插入，假设删除了p右子树的某个节点，引起了p的平衡因子d[p]=2，分析p的左子树left，三种情况如下： 情况1：left的平衡因子d[left]=1，将p右旋 情况2：left的平衡因子d[left]=0，将p右旋 情况3：left的平衡因子d[left]= -1，先左旋left，再右旋p 删除左子树，即d[p]= -2的情形，与d[p]=2对称 情况1 AVL_删除_情况1.png 情况2 AVL_删除_情况2.png 情况3 AVL_删除_情况3.png 面试排序数组（链表）转AVL108. Convert Sorted Array to Binary Search Tree109. Convert Sorted List to Binary Search Tree判断是否为平衡二叉树LeetCode 110. Balanced Binary Tree相关题目会持续添加 References TreeMapSourceAnalysis","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://winniekun.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"AVL树","slug":"AVL树","permalink":"https://winniekun.github.io/tags/AVL%E6%A0%91/"}]},{"title":"2020Flag集","slug":"碎碎念/2020Flag集","date":"2020-03-24T01:58:39.000Z","updated":"2021-05-08T15:45:33.268Z","comments":true,"path":"2020Flag集/","link":"","permalink":"https://winniekun.github.io/2020Flag%E9%9B%86/","excerpt":"前言最近刷题刷的特别丧，被LeetCode虐的体无完肤，然后又在不停地感慨，握草，这是人想出来的解法。瞬间感觉自己太low了。需要打点鸡血！！！","text":"前言最近刷题刷的特别丧，被LeetCode虐的体无完肤，然后又在不停地感慨，握草，这是人想出来的解法。瞬间感觉自己太low了。需要打点鸡血！！！ Flag们第一次flags🎏 LeetCode400题 ❌ 虽然已经进入千题时代，个人觉得把前400题刷完就已经很胖胖了 5月之前完成（平均下来，每天还要刷7-8题。。。。） 这个flag会不会插的太深了， 后面拔不掉！！！ LeetCode精刷250题 😕 Cspiration上看到的，不管其他的，但刷题，我觉得很棒 剑指offer 一刷 3月底刷完 第二次flags🎏 LeetCode400题 ✔ 实习期间刷题太累了，有点儿怀疑刷题的目的在哪儿了，并没有感觉到自己的编码能力有多少提高 现在只求不要成为斐波那契猿就很开心了 11月20号 LeetCode500题❌ 不想刷了，感觉太功利了，而且越刷感觉越效果不好 总是陷入自己熟练的内容。。。 第三次flags🎏 年前突破500大关❌","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"flag","slug":"flag","permalink":"https://winniekun.github.io/tags/flag/"}]},{"title":"图论-搜索策略","slug":"算法/实现-图论/图论-搜索策略","date":"2020-03-20T03:22:56.000Z","updated":"2020-08-30T04:50:22.260Z","comments":true,"path":"图论-搜索策略/","link":"","permalink":"https://winniekun.github.io/%E5%9B%BE%E8%AE%BA-%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5/","excerpt":"前言","text":"前言 以下算法的是实现，BFS、DFS是基于图的邻接表存储方式实现的， A*基于图的邻接矩阵存储 BFSBFS，广度优先遍历，其遍历的形式可以理解为树的层次遍历，直到找到对应的节点，然后停止。所以，可以通过一个队列来实现该算法。 图论-bfs.png package com.wkk.utils; import com.wkk.graph.LGraph; import org.omg.CORBA.INTERNAL; import java.util.LinkedList; import java.util.Queue; import java.util.Stack; /** * @Time: 20-3-20下午3:16 * @Author: kongwiki * @Email: kongwiki@163.com */ public class BFS { // 图使用邻接表进行存储 private boolean[] marked; private int[] edgeTo; private final int s; public BFS(LGraph graph, int s) { marked = new boolean[graph.V()]; edgeTo = new int[graph.V()]; this.s = s; bfs(graph, s); } private void bfs(LGraph graph, int s) { Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); queue.offer(s); marked[s] = true; while (!queue.isEmpty()){ Integer v = queue.poll(); for (Integer element : graph.adj(v)) { if(!marked[element]){ edgeTo[element] = v; marked[element] = true; queue.offer(element); } } } } // 判断是否存在路径 s ---&gt; v public boolean hasPathTo(int v){ return marked[v]; } // 存储s---&gt;v的路径 public Stack&lt;Integer&gt; pathTo(int v){ if (!hasPathTo(v)) {return null;} Stack&lt;Integer&gt; path = new Stack&lt;Integer&gt;(); for (int x = v; x != s; x = edgeTo[x]) { path.push(x); } path.push(s); return path; } } 总结BFS算法能够找到 s —-&gt; v路径中的最优解 DFS关于dfs， 其应用范围很广，譬如可以解决排列组合问题等等等。首先，会从开始节点朝某一个方向进发，直到遇到边界或者障碍物，才回溯。dfs算法需要一个栈进行从存储所扫描路径上的所有节点，递归其本身也是一个栈的使用， 所以完全可以使用递归实现DFS算法。 图论-dfs.png public class DFS { private boolean[] marked; private int count; public DFS(LGraph graph, int v){ marked = new boolean[graph.V()]; dfs(graph, v); } public void dfs(LGraph graph, int v){ marked[v] = true; count++; for (Integer w : graph.adj(v)) { if(!marked[w]){ dfs(graph, w); } } } public boolean marked(int w){ return marked[w]; } public int count(){ return count; } } 总结DFS算法存在问题有： 路径不可能是最优解 寻路时间比较长 A*官方定义A*搜索算法（A* search algorithm）是一种在图形平面上，有多个节点的路径，求出最低通过成本的算法。其应用非常的广，主要分为两大应用，第一就是游戏中的NPC的移动计算，第二就是地图导航的应用。简而言之，其就是一种寻路算法。 该算法综合了最良优先搜索和Dijkstra算法的优点：在进行启发式搜索提高算法效率的同时，可以保证找到一条最优路径（基于评估函数）。 Astar_progress_animation.gif A*算法的评估函数，其中$ g(n) $表示从起点到任意顶点n的实际距离，$h(n)$ 表示任意顶点$ n$ 到起点的估算距离。 $ f(n) = g(n) + h(n) $ 这个公式遵循以下特性： 如果$g(n)$为0，即只计算任意顶点$n$到目标的评估函数$h(n)$而不计算起点到顶点$n$的距离，则算法转化为使用贪心策略的最良优先搜索，速度最快，但可能得不出最优解； 如果$h(n)$不大于顶点$n$到目标顶点)的实际距离，则一定可以求出最优解，而且$h(n)$越小，需要计算的节点越多，算法效率越低，常见的评估函数有——欧几里得距离、曼哈顿距离、切比雪夫距离； 如果$ h(n) $为0，即只需求出起点到任意顶点的$ n $最短路径$ g(n) $，而不计算任何评估函数$ h(n) $，则转化为单源最短路径问题，即Dijkstra算法，此时需要计算最多的顶点； 以上的摘自维基百科，一些名词可能有些抽象，现做举例说明； 实例讲解 图论-A* 对于上图，从顶点s出发，均走了两步，分别到达了M1和M2，接下来应该选择哪条路线到达终点E，很明显，选择M1这条路， 因为从M1出发，到E的距离终于7步，比从M2出发到E的距离9步，要少。 回想刚才的思路，发现，我们不仅思考了从起始点到当前点的距离， 还考虑了当前点到终点的距离。这就是A*算法的核心。其相比于BFS算法，除了考虑中间某个点到出发点的距离以外，还考虑了这个点同目标点的距离。这就是A*算法比广度优先算法智能的地方。也就是所谓的启发式搜索。实例中的s 到M1的距离就是g(n), M1到E的距离就是h(n) 对于上述的公式， g(n)是已知的，但是h(n)是需要进行计算的。 对于h(n)的精确计算，可以按照刚才实例的方式，使用横向距离+纵向距离的方式进行计算（曼哈顿距离），理论上来说是可行的，但是遇到如下的问题，那么使用刚才的方式计算h(n)的精确值就是错误的了 图论-A-star1.png 因为有障碍物，M到E的就需要绕过这个障碍物。但是，我们完全没有必要计算h(n)的精确的值，只需要尽可能找那些f(n)=g(n)+h(n)小的点（其中h(n)是个估算值），当做我们的路径经过点，即使实际的h'(n)值可能和h(n)值不等也没关系，我们就当做一个参考（总比广度优先搜索好）。如果通过这个估算，能干掉很多明显很差的点，我们也就节省了很多不必要的花销。 比如，上图中， M点即使是绕路，也比M'点要强。在估算的时候，我们就可以将S左边的点基本上都抛弃掉，从而减少我们扩展的点数，节约计算的时间。 经过上述的分析，接下来就只需要解决如下的两个问题： 这个估算的函数h(M)怎么样去计算？ 曼哈顿距离 欧式距离 切比雪夫距离 … 对于不同的估算函数h(M)来讲，对于我们的搜索结果会有什么样的影响？ h'(n) = h(n) 也就是每次扩展的那个点我们都准确的知道，如果选他以后，我们的路径距离是多少，这样我们就不用乱选了，每次都选最小的那个，一路下去，肯定就是最优的解，而且基本不用扩展其他的点 h'(n) &lt; h(n) 我们到最后一定能找到一条最短路径(如果存在另外一条更短的评估路径，就会选择更小的那个)，但是有可能会经过很多无效的点。极端情况，当h==0的时候，最终的距离函数就变成： f(n)=g(n)+h(n) =&gt; f(n)=g(n)+0 =&gt; f(n)=g(n) 这也就是BFS算法。 h'(n) &gt; h(n) 有可能就很快找到一条通往目的地的路径，但是却不一定是最优的解。 总结A*算法最后留给我们的，就是在时间和距离上需要考虑的一个平衡。如果要求最短距离，则一定选择h小于等于实际距离；如果不一定求解最优解，而是要速度快，则可以选择h大于等于实际距离。 实现思路思路(如果有路径)采用结点与结点的父节点（前一个节点） 的关系从最终结点回溯到起点，得到路径。 定义$ f(n) = g(n) + h(n) $的实现 $g(n)$的实现方式： 计算方式有挺多种的，这里我们就用这种吧，假设每个结点代表一个正方形，横竖移动距离：斜移动距离=1 : 1.4（$\\sqrt(2)$），我们取个整数10和14吧，也就是说当前结点G值=父节点的G+（10或14）。 $ h(n)$的实现方式： 曼哈顿距离 图论-A-star实例.jpeg 每个方块代表一个节点， 方块中左下角为g(n) 方块中右下角为h(n) 方块中左上角为f(n) 辅助表：Open、Close列表在A算法中，需要使用两个辅助表来记录结点。 一个用于记录可被访问的结点，称为Open表；一个是记录已访问过的结点，称为Close表。 *这两个表决定了算法的结束：条件是最终结点在Close表中(找到路径)或Open表为空(找不到了路径)。 移动结点、相邻结点的处理每次从Open表中取出F值最小的结点出来（这里我们使用优先队列来处理比较好），作为当前结点；然后将当前结点的所有邻结点按照邻结点规则加入到Open表中；最后将当前结点放入Close表中，这里就是每次循环的执行内容。 邻结点规则： 当邻结点不在地图中，不加入Open表 当邻结点是障碍物，不加入Open表 当邻结点在Close表中，不加入Open表 当邻结点不在Open中，加入Open表，设该邻结点的父节点为当前结点 当邻结点在Open表中，我们需要做个比较:如果邻结点的G值&gt;当前结点的G值+当前结点到这个邻结点的代价（10或14），那么修改该邻结点的父节点为当前的结点(因为在Open表中的结点除了起点，都会有父节点)，修改G值=当前结点的G值+当前结点到这个邻结点的代价 如果邻结点的G值&lt;当前结点的G值+当前结点到这个邻结点的代价（10或14）, 如果没有一条路径可以通过使用当前格子得到改善，所以我们不做任何改变。 步骤 把起始格添加到开启列表。 重复如下的工作： a) 寻找开启列表中F值最低的格子。我们称它为当前格。 b) 把它切换到关闭列表。 c) 对相邻的8格中的每一个？ 如果它不可通过或者已经在关闭列表中，略过它。反之如下。 如果它不在开启列表中，把它添加进去。把当前格作为这一格的父节点。记录这一格的F,G,和H值。 如果它已经在开启列表中，用G值为参考检查新的路径是否更好。更低的G值意味着更好的路径。如果是这样，就把这一格的父节点改成当前格，并且重新计算这一格的G和F值。如果你保持你的开启列表按F值排序，改变之后你可能需要重新对开启列表排序。 d) 停止，当你 把目标格添加进了开启列表，这时候路径被找到，或者 没有找到目标格，开启列表已经空了。这时候，路径不存在。 保存路径。从目标格开始，沿着每一格的父节点移动直到回到起始格。这就是你的路径。 实现代码输入涉及数据结构： 代表地图二值二维数组(0表示可通路，1表示路障) int[][] maps = { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 }, { 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, }; 坐标类 public class Coord { /** * 坐标原点在左上角 所以y是高 x是宽 * y向下递增 x向右递增 * 将x和y封装成一个类 方便传参 * 重写equals方法比较坐标(x,y)是不是同一个。 */ public int x; public int y; public Coord(int x, int y) { this.x = x; this.y = y; } @Override public boolean equals(Object obj) { if (obj == null) { return false; } if (obj instanceof Coord) { Coord c = (Coord) obj; return x == c.x &amp;&amp; y == c.y; } return false; } } Node类 public class Node implements Comparable&lt;Node&gt; { // 坐标 public Coord coord; // 父结点 public Node parent; // G：是个准确的值，是起点到当前结点的代价 public int G; // H：是个估值，当前结点到目的结点的估计代价 public int H; public Node(int x, int y) { this.coord = new Coord(x, y); } public Node(Coord coord, Node parent, int g, int h) { this.coord = coord; this.parent = parent; G = g; H = h; } // 方便优先队列排序。 public int compareTo(Node o) { if (o == null) { return -1; } if (G + H &gt; o.G + o.H) { return 1; } else if (G + H &lt; o.G + o.H) { return -1; } return 0; } } A*算法输入的数据结构的封装 package com.wkk.a; /** * @Time: 20-3-21上午12:35 * @Author: kongwiki * @Email: kongwiki@163.com */ public class MapInfo { // 二维数组的地图 public int[][] maps; //地图的宽 public int width; // 地图的高 public int hight; // 起始结点 public Node start; // 最终结点 public Node end; public MapInfo(int[][] maps, int width, int hight, Node start, Node end) { this.maps = maps; this.width = width; this.hight = hight; this.start = start; this.end = end; } } 处理: 几个常量：二维数组中哪个值表示障碍物、二维数组中绘制路径的代表值、计算G值需要的横纵移动代价和斜移动代价。 // 障碍值 public final static int BAR = 1; // 路径 public final static int PATH = 2; // 横竖移动代价 public final static int DIRECT_VALUE = 10; // 斜移动代价 public final static int OBLIQUE_VALUE = 14; 定义两个辅助表：Open表和Close表。Open表的使用是需要取最小值，使用优先队列PriorityQueue，Close只是用来保存结点，没其他特殊用途，就用ArrayList。 // 优先队列(升序) Queue&lt;Node&gt; openList = new PriorityQueue&lt;Node&gt;() List&lt;Node&gt; closeList = new ArrayList&lt;Node&gt;(); 定义几个布尔判断方法：最终结点的判断、结点能否加入open表的判断、结点是否在Close表中的判断。 /** * 判断结点是否是最终结点 */ private boolean isEndNode(Coord end, Coord coord) { return coord != null &amp;&amp; end.equals(coord); } /** * 判断结点能否放入Open列表 */ private boolean canAddNodeToOpen(MapInfo mapInfo, int x, int y) { // 是否在地图中 if (x &lt; 0 || x &gt;= mapInfo.width || y &lt; 0 || y &gt;= mapInfo.hight) { return false; } // 判断是否是不可通过的结点 if (mapInfo.maps[y][x] == BAR) { return false; } // 判断结点是否存在close表 if (isCoordInClose(x, y)) { return false; } return true; } /** * 判断坐标是否在close表中 */ private boolean isCoordInClose(Coord coord) { return coord != null &amp;&amp; isCoordInClose(coord.x, coord.y); } /** * 判断坐标是否在close表中 */ private boolean isCoordInClose(int x, int y) { if (closeList.isEmpty()) { return false; } for (Node node : closeList) { if (node.coord.x == x &amp;&amp; node.coord.y == y) { return true; } } return false; } 回溯绘制路径 /** * 在二维数组中绘制路径 */ private void drawPath(int[][] maps, Node end) { if (end == null || maps == null) { return; } System.out.println(\"总代价：\" + end.G); while (end != null) { Coord c = end.coord; maps[c.y][c.x] = PATH; end = end.parent; } } 运行结果自定义Graph int[][] maps = { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 }, { 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 }, }; 开始节点为：（1,1） 结束节点为： （9， 5） 输出结果： 总代价：176 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 2 2 2 2 2 2 2 2 0 0 0 0 1 1 0 0 0 0 0 0 1 1 1 2 0 0 0 0 1 0 0 0 0 0 1 1 2 2 0 0 0 0 0 1 1 1 1 1 1 1 2 0 0 0 0 0 0 0 1 0 0 1 0 0 2 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 待优化int类型 —-&gt; 泛型 异常数据处理 References 算法第四版 A*搜索算法 路径规划之 A* 算法 寻路 A* Pathfinding 那个传说中的算法——A*算法 GraphTree","categories":[{"name":"算法","slug":"算法","permalink":"https://winniekun.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://winniekun.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"HashMap源码解读","slug":"源码/JDK/map/hashmap-analysis","date":"2020-03-12T13:02:49.000Z","updated":"2021-03-29T23:16:05.822Z","comments":true,"path":"hashmap-analysis/","link":"","permalink":"https://winniekun.github.io/hashmap-analysis/","excerpt":"HashMap 源码解读","text":"HashMap 源码解读 前言 hash HashMap相较于之前的ArrayList和LinkedList，其理解上还是稍微有一些难度，其底层的实现是散列表, 散列表对于哈希冲突的解决方式有如下两种(开放寻址法, 链表法)： 开放寻址法以下为一些常用的开放寻址法。 有线性探测法hash(key)+0、hash(key)+1、hash(key)+2… 二次探测（平方探测法）hash(key)+0, hash(key)+1^2, hash(key)+2^2….. 双重散列第一次根据hash()函数计算得到的存储位置已经被占用，再用第二个hash()函数计算 链表法对于不同的关键字可能会通过散列函数映射到同一个地址。为了避免发生分歧，将同样的哈希结果，但是不同关键字的元素，可以将它们存储在一个线性链表中。 HashMap中的解决哈希冲突的方式就是链表法 概述HashMap主要用来存放键值对, 其基于哈希表的Map接口实现, 是常用的Java集合之一.JDK1.8之前HashMap由数组+链表组成, 其使用的是数组进行存储, 之后使用链接法解决哈希冲突. JDK1.8之后HashMap在解决哈希冲突时, 与之前不同的是, 当链表长度大于阈值(默认是8), 将链表转化为红黑树, 避免过长的链表从而降低性能(过长的话, 就相当于使用的是链表存储的了,每次的查找都会导致O(n)的时间), 同时转化为红黑树的时候也会进行判断（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间 HashMap的源码中，充斥个各种位运算代替常规运算的地方，以提升效率： 与运算替代模运算。用 hash &amp; (table.length-1) 替代 hash % (table.length) 用if ((e.hash &amp; oldCap) == 0)判断扩容后，节点e处于低区还是高区。 形象理解: HashMap的底层为数组, 可以将其称之为哈希桶 每个桶里放的是链表. 其是线程不安全的允许key为null, value为null遍历时无序. HashMap 依赖 HashMap依赖 实现了Serializable接口 实现了Cloneable接口 实现了Map接口，并继承了AbstractMap类 阅读套路按照正常的逻辑， 首先基础的数据构造, 然后了解其构造方法， 之后了解常用的API(CRUD)操作即可。 [x] 增 [x] 删 [x] 改 [x] 查 从节点的构造开始HashMap整体的构造 HashMap存储结构 在添加元素的时候, 会先根据hash值计算出其应在的位置, 若是没有冲突, 则直接放入, 若是有冲突, 则将该元素以俩表的形式插入到链表尾部 若是链表的长度超过阀值(默认是8), 则将链表转化为红黑树, 提高效率 数组的查询为$O(1)$ , 链表的查询为$O(k)$, 红黑树的查询为$O(logk)$, $k$表示为桶中的元素的个数, 所以当元素很多的时候, 转化为红黑树能提高查询效率 单个节点的构造static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; // 哈希值 final K key; // key V value; // value Node&lt;K,V&gt; next; // 链表中该元素指向的下一个节点 // 单个节点包含的信息 Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + \"=\" + value; } // 哈希函数 // 一个节点的hash值是将key的哈希值和value的哈希值异或得到 public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } // 设置新的value 同时返回旧的value public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; } return false; } } 总结: 一个节点的hash值是将key的哈希值和value的哈希值异或得到 单个节点包含的信息有 key value hash值 next指针（指向下一个节点） 红黑树节点的构造static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; { TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; // 默认为红色， 原因为红黑树的性质四 TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) { super(hash, key, val, next); } 类的属性//初始容量为16 注释中说明了 必须为2的幂次 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 // 最大容量 2^30 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认负载因子0.75(若是构造函数中未说明) static final float DEFAULT_LOAD_FACTOR = 0.75f; // 桶中的节点数量大于8时转为红黑树 static final int TREEIFY_THRESHOLD = 8; // 桶中的节点数量小于6时 转为链表 static final int UNTREEIFY_THRESHOLD = 6; // 桶中结构转化为红黑树对应的table的最小大小 static final int MIN_TREEIFY_CAPACITY = 64; // 哈希桶 存放链表 总是2的倍数 transient Node&lt;K,V&gt;[] table; // 存放具体元素的集 transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; // 存放元素的个数，注意这个不等于数组的长度。 transient int size; // 每次扩容和更改map结构的计数器 transient int modCount; // threshold = 哈希桶.length * loadFactor; 当桶的使用数量操作该值, 进行扩容 int threshold; // 装载因子，用于计算哈希表元素数量的阈值。 final float loadFactor; 总结：最为重要的属性为： table、size、threshold、loadFactor 构造方法HashMap()public HashMap() { // 默认构造方法 将负载因子设置为默认值 0.75, 其他的属性均为默认 // 假设默认初始化空间大小为16, 则元素数量达到16*0.75=12时, 会进行扩容. this.loadFactor = DEFAULT_LOAD_FACTOR; } 这是一个默认构造器，潜在的问题是初始容量16太小了，可能中间需要不断扩容的问题，会影响插入的效率。 HashMap(int)public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } 用这种构造函数创建HashMap的对象，如果知道map要存放的元素个数，可以直接指定容量的大小， 减除不停的扩容，提高效率 内部调用下述的构造方法 HashMap(int , float)public HashMap(int initialCapacity, float loadFactor) { // 检查输入初始容量是否合法 if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); // MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 传入的初始化容量 &lt;=最大容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 检查输入加载因子是否合法 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } // 取与cap最近的且大于cap的2的次方值 static final int tableSizeFor(int cap) { int n = cap - 1; // 执行或运算 n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } 先是对初始化容量、装载因子的合理性检测，之后进行赋值，loadFactor: 自定义值， 默认为0.75，threshold: 取与cap最近的且大于cap的2的次方值 总结1. 为什么 threshold 要返回大于等于 initialCapacity 的最小 2 的 N 次方？ 计算元素table中的位置的时候，概述中有讲，使用的是hash &amp; (table.length-1) 而不是我们认为的 hash % table.length，而这两个方式在table.length是2的N次方的时候是等价的，从性能上而言，&amp;性能更好，所以，仅需要满足数组的容量n尽可能为2的N次方即可。 2. 为什么给的是初始化容量， 计算的却是阀值，而不是容量？ 1.8中， 将table的初始化放入了resize()中，并且在类属性中也注意到了没有capacity这个属性， 所以这里只能重新计算threshold，而resize()后面就会根据threshold来重新计算capacity，来进行 table数组的初始化，然后再重新按照装载因子计算threshold。 HashMap(Map&lt;?extends K, ?extends V&gt;)// 将已有map m里的所有元素加入当前的map中 public HashMap(Map&lt;? extends K, ? extends V&gt; m) { this.loadFactor = DEFAULT_LOAD_FACTOR; // 核心 批量添加到table中 putMapEntries(m, false); } putMapEntries(m, false)// 其实就是一个一个取出m中的元素调用putVal,一个个放入table中的过程。 final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) { int s = m.size(); if (s &gt; 0) { // ① table为空。说明还没初始化，适合在构造方法的情况 if (table == null) { // pre-size // +1.0F 的目的，是因为下面 (int) 直接取整，避免不够。 float ft = ((float)s / loadFactor) + 1.0F; // 修正，防止超出 int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 如果计算出来的 t 大于阀值，则计算新的阀值 if (t &gt; threshold) threshold = tableSizeFor(t); } // ② 如果 table 非空，说明已经初始化，需要不断扩容到阀值超过 s 的数量 else if (s &gt; threshold) resize(); // ③ 正常情况 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) { K key = e.getKey(); V value = e.getValue(); // 添加元素 putVal(hash(key), key, value, false, evict); } } } 整体的意思就是必须保证新的map的table容量够，如何保证？确保原map的元素数量小于新map的threshold。 构造方法总结 若是不知道需要创建的map的容量大小，使用默认构造方法 默认的容量大小为16 若是能确定map的容量大小，可使用第二种构造方法 threshold的值为最小的大于输入容量的2的指数 将原oldMap放入另一个newMap 若oldMap为空（没有元素） 若是oldMap不是新建的，其自身有一定容量 确保newMap能够容下oldMap， 不行进行扩容 增、改put(K key, V value)public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } hash(key) static final int hash(Object key) { int h; //为了使计算出的hash更分散 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } JDK1.8哈希计算， 取得key的hashcode后，高16位与整个Hash异或运算重新计算hash值 putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { // 对应table数组 Node&lt;K,V&gt;[] tab; // 对应位置的 Node 节点 Node&lt;K,V&gt; p; // n table的长度 // 原tab中对应放入Node的位置 int n, i; // 如果 table 未初始化，或者容量为 0 ，则进行扩容 // (第一次见这种赋值和判断融合的操作，学到了学到了) if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 如果对应的位置的Node节点为空，则直接创建 Node 节点即可。 // (n-1)&amp;hash 获取所在table的位置 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { // 哈希冲突解决 // key 在 HashMap 对应的老节点 Node&lt;K,V&gt; e; K k; // hash相等 key相等 执行覆盖 if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 为红黑树的节点 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 为Node节点，则说明是链表，且不是覆盖操作。需要遍历查找 else { // 判断什么时候进行链表转红黑树，什么时候红黑树转链表 for (int binCount = 0; ; ++binCount) { // 如果链表遍历完了都没有找到相同key的元素，说明该key对应的元素不存在，则在链表 // 最后插入一个新节点 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // 链表的长度如果数量达到 TREEIFY_THRESHOLD（8）时，则进行树化。 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } // 如果待插入的key在链表中找到了，则退出循环 if (e.hash == hash&amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } // 覆盖操作， 也就是相同的key的value进行覆盖 if (e != null) { // existing mapping for key V oldValue = e.value; // onlyIfAbsent进行判断是否需要覆盖oldValue if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 如果超过阀值，则进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } 总结一下图片为putVal方法的总体逻辑 hashmap_put.png 摘自 Hashmap源码解析 putAll(Map&lt;? extends K, ? extends V&gt; m)public void putAll(Map&lt;? extends K, ? extends V&gt; m) { this.putMapEntries(m, true); } putMapEntries在构造方法四中已经讲解了。 扩容机制resize()// 扩容方法 final Node&lt;K,V&gt;[] resize() { // oldTab 表示当前的哈希桶 Node&lt;K,V&gt;[] oldTab = table; // oldCap表示当前哈希桶的容量 length int oldCap = (oldTab == null) ? 0 : oldTab.length; // 当前哈希桶的阀值 int oldThr = threshold; // 初始化新的容量和阀值 int newCap, newThr = 0; // 1. 如果当前的容量不为空 if (oldCap &gt; 0) { // 如果当前的容量已经达到了上限 if (oldCap &gt;= MAXIMUM_CAPACITY) { // 阀值为2^32-1 threshold = Integer.MAX_VALUE; // 返回当前的哈希桶不再扩容 return oldTab; } // 否者新的容量为原先容量的两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)// 如果旧的容量大于等于默认的初始容量 16 // 新的阀值也为原先的两倍 newThr = oldThr &lt;&lt; 1; // double threshold } // 2. 如果当前表是空的，但是有阈值。代表是初始化时指定了容量、阈值的情况(上述的第三种构造方法) else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; // 新的容量为旧的阀值 // 3. 此处的判断用于初始化 else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } //如果新的阈值是0，对应的是 当前表是空的，但是有阈值的情况 if (newThr == 0) { //根据新表容量 和 加载因子 求出新的阈值 float ft = (float)newCap * loadFactor; // 进行越界修复 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } // 更新阀值 threshold = newThr; @SuppressWarnings({\"rawtypes\",\"unchecked\"}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; // 更新哈希桶的引用 table = newTab; // 如果以前的哈希桶有元素 // 以下执行将原哈希桶中的元素转入新的哈希桶中 if (oldTab != null) { // 遍历老的哈希桶 for (int j = 0; j &lt; oldCap; ++j) { // 取出当前的节点e Node&lt;K,V&gt; e; // 如果当前桶中有元素, 则将链表复制给e if ((e = oldTab[j]) != null) { // 将原哈希桶置空以便GC oldTab[j] = null; // 当前链表中只有一个元素, 没有发生哈希碰撞 if (e.next == null) //直接将这个元素放置在新的哈希桶里。 //注意这里取下标 是用 哈希值 与 桶的长度-1 。 //由于桶的长度是2的n次方，这么做其实是等于 一个模运算。但是效率更高 newTab[e.hash &amp; (newCap - 1)] = e; // 发生碰撞, 而且节点的个数超过8, 则转化为红黑树 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); //发生碰撞, 节点个数＜8 则进行处理, 依次放入新的哈希桶对应的下标位置 //因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下 //标,即low位， 或者扩容后的下标，即high位。 high位=low位+原哈希桶容量 else { // preserve order //低位链表的头结点、尾节点 Node&lt;K,V&gt; loHead = null, loTail = null; //高位链表的头结点、尾节点 Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; // 将同一桶中的元素根据(e.hash &amp; oldCap)是否为0进行分割，分成高位链表和低位 链表以完成rehash do { next = e.next; //这里又是一个利用位运算 代替常规运算的高效点： 利用哈希值与旧的容量， //可以得到哈希值取模后，是大于等于oldCap还是小于oldCap，等于0代表小于 //oldCap，应该存放在低位，否则存放在高位 if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 总结步骤: 如果使用的是默认构造方法, 则第一次插入元素的时候初始化为默认的容量16, 扩容阀值为12 如果使用的是非默认方法, 则第一次插入元素时初始化容量为扩容阀值, 扩容的阀值为初始化的时候, 扩容门槛在构造方法里等于传入容量向上最近的2的n次方 如果旧容量＞0, 则新容量为旧容量的2倍, 但不超过最大容量($2^{30}$), 新的扩容阀值为旧的扩容阀值2倍 创建新的容量桶 搬移元素，原链表分化成两个链表，低位链表存储在原来桶的位置，高位链表搬移到原来桶的位置加旧容量的位置 删remove(Object key)public V remove(Object key) { Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; } final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { // 这些和增里面是差不多的 // tab：桶数组 p：待删除节点的前驱节点 n: 桶数组大小 index: 桶数组第i个位置 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null&amp;&amp;(n = tab.length)&gt;0 &amp;&amp;(p=tab[index=(n-1)&amp;hash])!= null) { // node为需要删除的节点 Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) { if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else { do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } // 找到对应的key进行remove核心 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); // 如果node == p，说明是链表头是待删除节点 else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; } } return null; } 除去复杂的判断，也就是单链表删除指定的节点，共有两种情况： 1.删除的为头结点。2. 删除的为中间节点 remove(Object key, Object value)public boolean remove(Object key, Object value) { return removeNode(hash(key), key, value, true, true) != null; } 查get(Object key)public V get(Object key) { HashMap.Node e; return (e = this.getNode(hash(key), key)) == null ? null } // 根据key获取对应的节点 final HashMap.Node&lt;K, V&gt; getNode(int hash, Object key) { HashMap.Node[] tab; HashMap.Node first; int n; if ((tab = this.table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[n - 1 &amp; hash]) != null) { Object k; if (first.hash == hash &amp;&amp; ((k = first.key) == key || key != null &amp;&amp; key.equals(k))) { return first; } HashMap.Node e; if ((e = first.next) != null) { if (first instanceof HashMap.TreeNode) { return ((HashMap.TreeNode)first).getTreeNode(hash, key); } do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || key != null &amp;&amp; key.equals(k))) { return e; } } while((e = e.next) != null); } } return null; } 使用first.hash == hash &amp;&amp; ((k = first.key) == key || key != null &amp;&amp; key.equals(k))判断是否为同一个key(因为相同的hash可能并不是同一个key，因为先是使用(n - 1) &amp; hash寻找桶的位置，之后再依次查找key) Note负数的二进制表示: 取绝对值求二进制 获得原码 之后各个位取反获得反码 反码在最后一位＋1获得补码 补码极为负数的表示 &gt;&gt;&gt;和&gt;&gt;的区别 &gt;&gt;&gt;适合高位的运算低位运算两者无区别 hashCode与equals的深入理解&gt;&gt; hashCode 的常规协定是：在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，==前提是对象上 equals 比较中所用的信息没有被修改。==从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。==如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。==以下情况不是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） ==当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。== hashCode的存在主要是用于查找的快捷性,如HashTable, HashMap等. 用来在散列存储数据结构中确定对象的存储地址的. 若是两个对象相同,那么equals(java.lang.Object)方法为true, 那么两个对象的hashCode必须相同. 如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上一条. 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。 ==hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的== 底层数据结构分析一些操作符号解析 ^ 异或 &gt;&gt;&gt; 向右移动xxx位, 无视符号, 高位填0，不能左移 &gt;&gt; 同理右移xxx位, 能左移 总结&amp;面试相关问题 HashMap是一种散列表, 使用(数组+链表+红黑树)的结构 HashMap的默认初始容量为16, 默认装载因子为0.75, 且容量总是$2^n$ 正常情况下, 扩容为原来的两倍 桶的长度小于64 时, 不会进行树化 桶的长度大于64且链表长度大于8时, 进行树化 当单个桶中的元素小于6时, 进行反树化(转化为链表) 查询时间为$O(1)$ 添加时间$O(1)$ 1.判断key，根据key算出索引。2.根据索引获得索引位置所对应的键值对链表。3.遍历键值对链表，根据key找到对应的Entry键值对。4.拿到value。分析：以上四步要保证HashMap的时间复杂度O(1)，需要保证每一步都是O(1)，现在看起来就第三步对链表的循环的时间复杂度影响最大，链表查找的时间复杂度为O(n)，与链表长度有关。我们要保证那个链表长度为1，才可以说时间复杂度能满足O(1)。但这么说来只有那个hash算法尽量减少冲突，才能使链表长度尽可能短，理想状态为1。因此可以得出结论：HashMap的查找时间复杂度只有在最理想的情况下才会为O(1)， HashMap是非线程安全的 HashMap的线程不安全在哪儿 在JDK1.7之前的版本会出现死循环的问题 数据覆盖问题 A, B两个线程都需要put操作, 然后当A, B线程都获得了尾节点之后, A的时间片用完了, B开始执行尾插, 之后A再执行, 这时A获取的还是旧的尾部节点 , 所以就会导致数据被覆盖, B插入的数据丢失 解决线程安全问题: Collections.SynchronizedMap() Map&lt;String, Integer&gt; testMap = new HashMap&lt;&gt;(); ... // 转为线程安全的map Map&lt;String, Integer&gt; map = Collections.synchronizedMap(testMap); 使用ConcurrentHashMap references 数据结构与算法之美 Java-Guid jdk-source-analysis","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"Map","slug":"Map","permalink":"https://winniekun.github.io/tags/Map/"}]},{"title":"Ubuntu中MySQL5.7插入中文设置","slug":"配置/Ubuntu中MySQL5-7插入中文设置","date":"2020-03-11T09:44:55.000Z","updated":"2020-08-30T04:50:22.263Z","comments":true,"path":"Ubuntu中MySQL5-7插入中文设置/","link":"","permalink":"https://winniekun.github.io/Ubuntu%E4%B8%ADMySQL5-7%E6%8F%92%E5%85%A5%E4%B8%AD%E6%96%87%E8%AE%BE%E7%BD%AE/","excerpt":"前言其实关MySQL中插入中文,自己前年是设置过的,之后就一直没有管过,后来系统重装之后,重新安装配置各种环境之后,今天开始用MySQL的时候,才发现这个问题还没有解决,然后一时也想不起来怎么弄了,就重新网上搜索教程,最后想了下还是写一下配置过程吧,以后备用","text":"前言其实关MySQL中插入中文,自己前年是设置过的,之后就一直没有管过,后来系统重装之后,重新安装配置各种环境之后,今天开始用MySQL的时候,才发现这个问题还没有解决,然后一时也想不起来怎么弄了,就重新网上搜索教程,最后想了下还是写一下配置过程吧,以后备用 第一步cp /etc/mysql/mysql.conf.d/mysqld.cnf /etc/mysql/my.cnf 第二步修改/etc/mysql/my.cnf文件，找到[client]标记后在下方添加一行代码： default-character-set=utf8 如果找不到[client]标记，就直接在文件末尾插入： [client] default-character-set=utf8 第三步找到[mysqld]标记，在该标记下方添加两行 character-set-server=utf8 collation-server=utf8_general_ci 最后执行重启mysql命令：sudo service mysql restart 查看修改结果进入MySQL，之后输入如下命令 show variables like 'character%';","categories":[{"name":"mysql","slug":"mysql","permalink":"https://winniekun.github.io/categories/mysql/"}],"tags":[{"name":"配置","slug":"配置","permalink":"https://winniekun.github.io/tags/%E9%85%8D%E7%BD%AE/"}]},{"title":"个人博客事件","slug":"碎碎念/个人博客事件","date":"2020-03-11T09:10:30.000Z","updated":"2021-05-16T16:33:27.776Z","comments":true,"path":"个人博客事件/","link":"","permalink":"https://winniekun.github.io/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BA%8B%E4%BB%B6/","excerpt":"前言自己是从大二下开始写博客的，期间使用过很多的博客平台：Jekyll + GitHub Pages 、WordPress 、Typecho Hexo + GitHub Pages 自己也用Django 、Flask搭建过，博客的界面也改版了一次又一次，最后还是确定下来使用我目前这个了","text":"前言自己是从大二下开始写博客的，期间使用过很多的博客平台：Jekyll + GitHub Pages 、WordPress 、Typecho Hexo + GitHub Pages 自己也用Django 、Flask搭建过，博客的界面也改版了一次又一次，最后还是确定下来使用我目前这个了 就这样吧，我也不知道这次能坚持多久🙂 关于之前的内容全没了，点儿都不剩的全删了，有些文章删了的确是很可惜，谨记教训！！！自己强行又加了一个19年的书单，之前17年、18年的真的没法补了，记不住是几号写的了，也忘了都看了些啥子。","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"springboot---配置","slug":"spring/springboot/springboot-配置","date":"2020-03-11T03:06:54.000Z","updated":"2020-08-30T04:50:22.252Z","comments":true,"path":"springboot-配置/","link":"","permalink":"https://winniekun.github.io/springboot-%E9%85%8D%E7%BD%AE/","excerpt":"","text":"","categories":[{"name":"spring","slug":"spring","permalink":"https://winniekun.github.io/categories/spring/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://winniekun.github.io/tags/springboot/"}]},{"title":"红黑树","slug":"源码/JDK/map/rbtree-analysis","date":"2020-03-10T01:39:12.000Z","updated":"2020-08-30T04:50:22.256Z","comments":true,"path":"rbtree-analysis/","link":"","permalink":"https://winniekun.github.io/rbtree-analysis/","excerpt":"红黑树剖析","text":"红黑树剖析 BST部分二叉排序树、二叉搜索树性质： 定义的空树是BST 左子树所有节点的值均小于根节点的值 右子树所有节点的值均大于根节点的值 中序遍历序列为升序 实现二插排序树：节点定义、插入 节点： AVLEntry 字典：AVLMap int compara(K a, K b) 比较关键字a和b的大小 boolean isEmpty() 判断map是否为空 V put(K key, V value) 添加元素 迭代器 LeetCode173 binary search tree iterator 要点： 利用中序遍历 方案1： 递归添加进入线性集合， 迭代线性集合 方案2： 非递归， 使左路径节点压栈 AVL迭代器 属性stack ， 存储BST的节点 hasNext, 是否还有下一个节点 next 下一个节点的值 remove 线程安全问题 AVLMap继承Iterable， 并重写Iterator方法， 返回AVL迭代器即可 查找原理： 若是根节点的值小于key， 递归从右子树查找 若是根节点的值大于key， 递归从左子树查找 如是根节点等于key， 成功 若是子树为空， 失败 实现模拟TreeMap的代码结构， 实现以下方法 AVLEntry getEntry(K key) 私有方法 主要查找逻辑 boolean containsKey(K key) 是否能找到关键字 V get(K key) 根据关键字返回对应的value boolean containsValue(V value) 能够找到value 删除（重点）原理删除操作较为繁琐， 需要考虑断链的情况，以及删除之后， 还需满足BST的特性 共分为三种情况， 假设删除的节点为p， 父节点为f p为叶子节点， 直接删除 p的左子树（右子树）不为空，删除之后， 其左子树（右子树）填补p的空缺位置 p既有左子树又有右子树， 找到右子树的最小值节点M（左子树的最大值）将该值替换p的值，之后按照1、2两种情况删除M即可 实现 AVLEntry deleteEntry() 递归函数（主逻辑） V remote(K key) 删除关键字key 返回对应的value void levelOrder 辅助函数 层次遍历 用于输出观察 面试经典： 寻找最大最小节点 BST的前驱和 BST的前驱和后继节点前驱结点：节点val值小于该节点val值并且值最大的节点 后继节点：节点val值大于该节点val值并且值最小的节点 前驱节点（有父指针的情况） 若一个节点有左子树，那么该节点的前驱节点是其左子树中val值最大的节点（也就是左子树中所谓的rightMostNode） 若一个节点没有左子树，那么判断该节点和其父节点的关系2.1 若该节点是其父节点的右边孩子，那么该节点的前驱结点即为其父节点。2.2 若该节点是其父节点的左边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的右边孩子，那么Q就是该节点的后继节点 后继节点（有父指针的情况） 若一个节点有右子树，那么该节点的后继节点是其右子树中val值最小的节点（也就是右子树中所谓的leftMostNode） 若一个节点没有右子树，那么判断该节点和其父节点的关系2.1 若该节点是其父节点的左边孩子，那么该节点的后继结点即为其父节点2.2 若该节点是其父节点的右边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的左边孩子，那么Q就是该节点的后继节点 LIntCode 448 Inorder Successor in BST p为最大节点， 返回null p有右子树 p没有右子树 进行二叉查找， 并压栈， 之后弹栈 AVL定义BST和TreeMap的效率对比 情况 BST TreeMap 升序序列（降序序列） Slow OK 随机序列 OK OK AVL是一种自平衡的二叉树 BST 左右子树的高度差绝对值&lt;1 空树、左右子树都是AVL 旋转与插入旋转 右旋 右旋 先左旋再右旋 左旋 同理 什么时候需要旋转 插入关键字key后，节点p的平衡因子由原来的1或者-1，变成了2或者-2，则需要旋转；只考虑插入key到左子树left的情形，即平衡因子为2 情况1：key&lt;left.key, 即插入到left的左子树，需要进行单旋转，将节点p右旋 情况2：key&gt;left.key, 即插入到left的右子树，需要进行双旋转，先将left左旋，再将p右旋插入到右子树right 平衡因子为-2，完全对称 对于检测是否平衡并旋转的调整过程自顶向下OR自底向上 对于BST的插入， 是自顶向下的，AVL的插入和BST的插入是一样的也是自顶向下 在检测节点p是否平衡之前，必须先保证左右子树已经平衡 子问题成立 —-&gt; 总问题成立 ： ==自底向上== 有parent指针， 直接向上回溯 无parent指针， 后续遍历、递归 无parent指针， 栈实现非递归 LeetCode110. Balanced Binary Tree 插入代码实现 AVLEnrty增加height属性，表示树的高度 ==&gt; 平衡因子可以实时计算 单旋转：右旋rotateRight、左旋rotateLeft 双旋转：先左后右firstLeftThenRight、先右后左firstRightThenLeft 辅助栈stack，将插入时候所经过的路径压栈 插入调整函数fixAfterInsertion 辅助函数checkBalance，断言AVL树的平衡性，检测算法的正确性 算法改进&amp;&amp;时间复杂度分析弹栈的时候，一旦发现某个节点并未改变，则停止弹栈 指针回溯次数：最坏为O(logN)最好为O(log1) , 平均为O(logN) 旋转次数： 无需旋转、单旋转、双旋转、不会超过两次 时间复杂度： BST插入O(logN)+指针回溯O(logN) + 旋转O(1) = O(logN) 空间复杂度： 有parent指针为O(1) 无parent指针为O(logN) 面试经典：排序数组转化为AVL和RBTtreeMap中buildFromSorted实现功能类似 删除原理类似插入，假设删除了p右子树的某个节点，引起了p的平衡因子d[p]=2，分析p的左子树left，三种情况如下： left的平衡因子d[left]=1，将p右旋 left的平衡因子d[left]=0，将p右旋 left的平衡因子d[left]= -1，先左旋left，再右旋p 删除左子树，即d[p]= -2的情形，与d[p]=2对称 实现 fixAfterDeletion：调整某个节点p deleteEntry直接调用fixAfterDeletion 红黑树红黑树定义 任意节点要么是红色，要么是黑色 根节点为黑色 所有的叶子节点为黑色（叶子节点为空） 如果一个节点为红色，那么它的两个子节点都为黑色 任意节点从它出发， 到所有叶子节点的路径上包含相同数量的黑色节点 简称为黑高（BlackHeight、BH） 由此衍生出的性质： 任意一颗以黑色节点为根的子树也必定是一颗红黑树 左（右）子树的高度最多是右（左）子树的两倍 其必定是一个BST 红黑树在JDK源码中的实现(TreeMap中的fixAfterInsertion和fixAfterDeletion)： 插入操作==自底向上== RBT中的插入调整： fixAfterInsersion: cast1、case2、case3 RBT中的删除调整：fixAfterDeletion: case1、case2、case3、case4 插入原则 若插入的为黑色的节点，违法性质5 只能插入红色节点，可能违反性质4，继续调整 from 插入正确性证明 是否会引起左右子树的BH不一致 有无继续破坏性质4的可能 插入调整无需调整的情况为： X为根节点，将X由红染黑，简称rootOver 父节点P为黑色，BlackParentOver，简称bpOver while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) 需要调整的情况为： 仅仅需要考虑父节点P为红色的情形，由于性质4，爷爷节点G必定为黑色，分为三种情况：case1: Y为红色，X可左可右；P、Y染黑，G染红，X回溯至Gcase2: Y为黑色，X为右孩子；左旋P，X指向P，转化为case3case3: Y为黑色，X为左孩子；P染黑，G染红，右旋G，结束结论：RBT的插入调整最多旋转2次 case1 条件P为红色，为G的左孩子， Y为红色， X可左可右， 处理方式： 将P、Y染黑， G然为红色，X回溯至G即可 条件简称： 红左父、红叔、红左右子 处理方式简称： 父叔变黑、爷变红，子变爷 if (parentOf(x) == leftOf(parentOf(parentOf(x)))) { Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) { setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); } } case2 条件： P为G的左孩子，Y为黑色，X为右孩子 处理方式：左旋P，X指向P，转化为case3 条件简称：红左父，黑叔，红右子 处理方式简称：左旋父、子变父、变为case3 else { if (x == rightOf(parentOf(x))) { x = parentOf(x); // X指向P rotateLeft(x); // 左旋P } case3 条件：P为G的左孩子，Y为黑色，X为左孩子 处理方式：P染黑，G染红，右旋G，结束 条件简称：红左父，黑叔，红左子 处理方式简称：父变黑、爷变红、右旋爷 setColor(parentOf(x), BLACK); // P染黑 setColor(parentOf(parentOf(x)), RED); // G 染红 rotateRight(parentOf(parentOf(x))); // 右旋G 当P为G的右孩子，同理 rightCase1：Y为红，X可左可右；P、Y变黑，G变红，X变GrightCase2：Y为黑，X为左孩子；右旋P，X变P，转case3rightCase3：Y为黑，X为右孩子；G变红，P变黑，左旋G 删除操作二插排序树的删除： 三种情况 AVL树的删除：两种情况 红黑树的删除： 四种情况 删除原则 删除的节点为红色，则直接删除，并不影响整体结果，需要注意防止断链 删除的节点为黑色，所在的BH—，需要进行调整 删除调整 from 删除正确性证明 是否违反性质五 X的BH只能保持或者不变，否者X要比S的BH要小 是否违反性质四 若谷违反了，继续染黑还是回溯 删除调整无需调整的情况 当前X为根节点，无论root为什么颜色，都将root染黑， rootOver 当前X为红色， 将X染黑， redOver while (x != root &amp;&amp; colorOf(x) == BLACK) 删除左孩子X 四种情况case1条件：S为红色隐含条件：由于性质4，P、LN、RN必定都为黑色处理方式：S染黑，P染红，左旋P，LN成为新的sib if (x == leftOf(parentOf(x))) { Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) { setColor(sib, BLACK); setColor(parentOf(x), RED); rotateLeft(parentOf(x)); sib = rightOf(parentOf(x)); } case2条件； case2-1条件：S、LN、RN均为黑色，P为黑色 case2-2条件：S、LN、RN均为黑色，P为红色 隐含条件：由于性质4，P、LN、RN必定都为黑色处理方式：S染黑，P染红，左旋P，LN成为新的sib处理方式相同：S染红，X回溯至P case3条件：S为黑色，LN为红色，RN为黑色处理方式：LN染黑、S染红，右旋S，S指向LN转化为case4-1、case4-2 case4S为黑色，LN随意，红RN；S变P的颜色，P和S染黑，左旋P Comparable和ComparatorComparableComparable简介Comparable是排序接口。 若一个类实现了Comparable接口，就意味着“该类支持排序”。 即然实现Comparable接口的类支持排序，假设现在存在“实现Comparable接口的类的对象的List列表(或数组)”，则该List列表(或数组)可以通过 Collections.sort（或 Arrays.sort）进行排序。 此外，“实现Comparable接口的类的对象”可以用作“有序映射(如TreeMap)”中的键或“有序集合(TreeSet)”中的元素，而不需要指定比较器。 Comparable 定义Comparable 接口仅仅只包括一个函数，它的定义如下： package java.lang; import java.util.*; public interface Comparable&lt;T&gt; { public int compareTo(T o); } 假设我们通过 x.compareTo(y) 来“比较x和y的大小”。若返回“负数”，意味着“x比y小”；返回“零”，意味着“x等于y”；返回“正数”，意味着“x大于y”。 ComparatorComparator简介Comparator 是比较器接口。 我们若需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)；那么，我们可以建立一个“该类的比较器”来进行排序。这个“比较器”只需要实现Comparator接口即可。 也就是说，我们可以通过“实现Comparator类来新建一个比较器”，然后通过该比较器对类进行排序。 Comparator定义Comparator 接口仅仅只包括两个个函数，它的定义如下： package java.util; public interface Comparator&lt;T&gt; { int compare(T o1, T o2); boolean equals(Object obj); } 总结相同 Comparable和Comparator都是用来实现对象的比较、排序 要想对象比较、排序，都需要实现Comparable或Comparator接口 Comparable和Comparator都是Java的接口 区别 Comparator位于java.util包下，而Comparable位于java.lang包下 Comparable接口的实现是在类的内部（如 String、Integer已经实现了Comparable接口，自己就可以完成比较大小操作），Comparator接口的实现是在类的外部（可以理解为一个是自已完成比较，一个是外部程序实现比较） 实现Comparable接口要重写compareTo方法, 在compareTo方法里面实现比较","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"Map","slug":"Map","permalink":"https://winniekun.github.io/tags/Map/"}]},{"title":"死磕回溯","slug":"LeetCode/stick-to-backtrack","date":"2020-02-25T14:18:18.000Z","updated":"2021-02-16T09:33:45.356Z","comments":true,"path":"stick-to-backtrack/","link":"","permalink":"https://winniekun.github.io/stick-to-backtrack/","excerpt":"前言LeetCode死磕系列四： 回溯","text":"前言LeetCode死磕系列四： 回溯 组合、排列 切割问题 子集问题 棋盘问题 回溯可抽象为树形结构（n叉树） for循环嵌套递归 优化： 剪枝操作 需要注意题目中一次的结果中元素能否重复，所有结果中，顺序不同，是否会造成一个新的结果。 LeetCode 回溯题目整理排列组合区分： 排列有序，相同元素不同顺序，则不同 组合无序，相同元素不同顺序，则相同(需要添加start索引) 77 combine 组合问题 78 Subsets 组合问题 46 Permutations 排列问题 47 PermutationsII 排列问题 36 Combination Sum 组合问题 40 Combination Sum II 组合问题 216 Combination Sum III 组合问题 90 Subsets II 组合问题 60 Permutation Sequence 和Permutations是一样的，只需要返回results中第k个值即可 二维问题 79 Word Search 经典的二维问题的回溯 剑指offer第12题 题解77 Combine78 Subsets组合问题 public static List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { List&lt;List&lt;Integer&gt;&gt; results = new LinkedList&lt;&gt;(); List&lt;Integer&gt; out = new LinkedList&lt;&gt;(); backtrack(nums, results, out, 0); return results; } private static void backtrack(int[] nums, List&lt;List&lt;Integer&gt;&gt; results, List&lt;Integer&gt; track, int start) { results.add(new LinkedList&lt;&gt;(track)); for (int i = start; i &lt; nums.length; i++) { track.add(nums[i]); backtrack(nums, results, track, i+1); track.remove(track.size()-1); } } 46 Permutations排列问题 private List&lt;List&lt;Integer&gt;&gt; results = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { int k = 3; List&lt;Integer&gt; out = new LinkedList&lt;&gt;(); backtrack(nums, out, k); return results; } private void backtrack(int[] nums, List&lt;Integer&gt; track, int k) if(track.size() == k){ results.add(new LinkedList&lt;&gt;(track)); } for (int i = 0; i &lt; nums.length; i++) { // 剔除重复值 if(track.contains(nums[i])){ continue; } track.add(nums[i]); backtrack(nums, track, k); track.remove(track.size()-1); } } 47 PermutationsII排列问题 private static List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); public static List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { Arrays.sort(nums); List&lt;Integer&gt; out = new ArrayList&lt;&gt;(); backtrack(nums, out, new boolean[nums.length]); return results; } private static void backtrack(int[] nums, List&lt;Integer&gt; out, boolean[] visit if (out.size() == nums.length) { results.add(new ArrayList&lt;&gt;(out)); return; } for (int i = 0; i &lt; nums.length; i++) { //重复元素只按顺序选择，若当前元素未被选择且前一元素与当前元素值相等也未被选择则跳过， // 这一可能情况与先选小序号后选大序号的相同元素相同 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; visited[i-1] &amp;&amp;!visited[i] || continue; } out.add(nums[i]); visited[i] = true; backtrack(nums, out, visited); out.remove(out.size() - 1); visited[i] = false; } } 36 Combination Sum组合问题 元素无重复项 可重复使用 private List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;List&lt;Integer&gt;&gt;(); private List&lt;Integer&gt; curren = new ArrayList&lt;Integer&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target){ Arrays.sort(candidates); if(candidates == null){ return results; } backtrack(0, candidates, target, curren); return results; } private void backtrack(int start, int[] candidates, int target, List&lt;Integer&gt; out){ if(target &lt; 0){ return; } if(target == 0){ results.add(new ArrayList&lt;&gt;(out)); } for (int i = start; i &lt; candidates.length; i++) { out.add(candidates[i]); backtrack(i, candidates, target-candidates[i], curren); out.remove(out.size()-1); } } 40 Combination Sum II组合问题 元素有重复项 不能重复选 // 有重复项 private List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { if (candidates == null) { return results; } Arrays.sort(candidates); List&lt;Integer&gt; out = new ArrayList&lt;&gt;(); backtrack(0, out, candidates, target); return results; } private void backtrack(int start, List&lt;Integer&gt; out, int[] candidates, int targe if(target &lt; 0){ return; } if(target == 0){ results.add(new ArrayList&lt;&gt;(out)); } for (int i = start; i &lt; candidates.length; i++) { if(candidates[i] == candidates[i-1] &amp;&amp; i&gt; start){ continue; } out.add(candidates[i]); backtrack(i+1, out, candidates, target-candidates[i]); out.remove(out.size()-1); } } 216 Combination Sum III组合问题 元素无重复项，但是候选集改变 private List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n){ List&lt;Integer&gt; out = new ArrayList&lt;&gt;(); backtrack(1, out, n, k); return results; } private void backtrack(int start, List&lt;Integer&gt; out, int n, int k) { if(out.size() == k &amp;&amp; n==0){ results.add(new ArrayList&lt;&gt;(out)); } for (int i = start; i &lt;= n; i++) { if(i&gt;=10){ continue; } out.add(i); backtrack(i+1, out, n-i, k); out.remove(out.size()-1); } } 90 Subsets II组合问题 元素有重复项 private List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;() public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) { if(nums == null){ return results; } Arrays.sort(nums); List&lt;Integer&gt; out = new ArrayList&lt;&gt;(); backtrack(nums, out, 0); return results; } private void backtrack(int[] nums, List&lt;Integer&gt; out, i results.add(new ArrayList&lt;&gt;(out)); for (int i = start; i &lt; nums.length; i++) { if(i&gt;start &amp;&amp; nums[i] == nums[i-1]){ continue; } out.add(nums[i]); backtrack(nums, out, i+1); out.remove(out.size()-1); } } 79 Word Search二维平面内判断是否包含有字符串，最基础的二维回溯问题. 和一维回溯问题不同的是，回溯函数去除了for循环，而是判断其相邻的四个格子： (row+1, col) (row-1, col) (row, col+1) (row, col-1) 调用回溯的方法使用了for循环，因为二维的每个位置都需要进行深度遍历。 回溯部分： 需要判断是否越界，越界的地方不走 终止条件： 当前的第i步，对应的字符刚好是word的第i个字符 public boolean exist(char[][] board, String word) { if (board.length == 0 || board[0].length == 0) { return false; } int m = board.length; int n = board[0].length; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (search(board, word, 0, i, j)) { return true; } } } return false; } private boolean search(char[][] board, String word, int start, int i, int j) { if (start == word.length()) { return true; } int m = board.length; int n = board[0].length; if (i &lt; 0 || j &lt; 0 || i &gt;= m || j &gt;= n || board[i][j] != word.charAt(start)) { return false; } char c = board[i][j]; board[i][j] = '#'; boolean res = search(board, word, start + 1, i + 1, j) || search(board, word, start + 1, i - 1, j) || search(board, word, start + 1, i, j + 1) || search(board, word, start + 1, i, j - 1); board[i][j] = c; return res; }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"回溯","slug":"回溯","permalink":"https://winniekun.github.io/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"死磕DFS","slug":"LeetCode/stick-to-DFS","date":"2020-02-23T11:59:12.000Z","updated":"2020-08-30T04:50:22.249Z","comments":true,"path":"stick-to-DFS/","link":"","permalink":"https://winniekun.github.io/stick-to-DFS/","excerpt":"前言LeetCode死磕系列三： DFS 刷了那么多题， 感觉DFS应用很广泛哇，遇到排列组合、搜索等问题，理解题意之后，直接无脑DFS都能行的通。","text":"前言LeetCode死磕系列三： DFS 刷了那么多题， 感觉DFS应用很广泛哇，遇到排列组合、搜索等问题，理解题意之后，直接无脑DFS都能行的通。 LeetCode DFS题目整理 200 Number of Islands 题解200 Number of Islands数陆地， 其中1表示陆地，0表示水 思路： 使用dfs, 从（0,0）开始，顺序下、上、右、左 每次访问到的陆地都改为水。这样就略去了标记为数组，减少空间 private static final int[][] DIRS = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; private static final char L = '1', W = '0'; public int numIslands(char[][] grid){ int count = 0; for (int i = 0; i &lt; grid.length; i++) { for (int j = 0; j &lt; grid[0].length; j++) { if (grid[i][j] == L) { count++; dfs(grid, i, j); } } } return count; } private void dfs(char[][] grid, int x, int y) { // 边界判断 if (x &lt; 0 || x &gt; grid.length-1 || y &lt; 0 || y &gt; grid[0].length-1) { return; } if(grid[x][y] == L){ grid[x][y] = W; for (int[] dir : DIRS) { dfs(grid, x+dir[0], y+dir[1]); } } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"dfs","slug":"dfs","permalink":"https://winniekun.github.io/tags/dfs/"}]},{"title":"死磕链表","slug":"LeetCode/stick-to-linkedlist","date":"2020-02-15T12:42:11.000Z","updated":"2021-07-02T04:06:00.749Z","comments":true,"path":"stick-to-linkedlist/","link":"","permalink":"https://winniekun.github.io/stick-to-linkedlist/","excerpt":"前言LeetCode死磕系列二： 链表","text":"前言LeetCode死磕系列二： 链表 链表作为基础的数据结构，将链表的操作掌握了，其他的相关结构与算法，理论上来说为题不大了。LeetCode中， 链表的操作是有迹可循的， 当然也可当场理解，然后画图，找解法（奈何我太笨，编码功底还不够），反正链表的所有操作都离不开基础的CRUD, 还需要注意的是，当涉及到头结点的操作的时候，最好设置一个dummy节点指向头结点，这样方便统一处理。 刷了LeetCode中所有链表有关的题目（34题免费题目）做了如下总结 CRUD增需要注意构造新链表时的头插法 和尾插法 头插法： 逆序 尾插法： 正序 删根据前驱删除 pre.next = pre.next.next; 根据当前节点删除 ListNode next = cur.next; cur.val = next.val; cur.next = next.next; 改查链表的常用操作 两两之间的交换 多节点的交换 反转 环 LeetCode 链表题目整理 2 Add Two Numbers 445 Add Two Numbers II 题解2. Add Two NumbersExample: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. 思路： 链表的反转序列代表一个整数，然后整数的相加之后，结果用个位--&gt;十位---&gt;百位的顺序表示。所以可以使用两个队列存储两个链表，然后开始依次弹出，进行相加，使用尾插法构造输出链表 public ListNode addTwoNumbers(ListNode l1, ListNode l2) { Queue&lt;ListNode&gt; queue1 = list2Queue(l1); Queue&lt;ListNode&gt; queue2 = list2Queue(l2); // 应题目要求 使用尾插发 ListNode dummy = new ListNode(-1); ListNode real = dummy; int carry = 0; while (!queue1.isEmpty() || !queue2.isEmpty()) { int p1 = queue1.isEmpty() ? 0 : queue1.poll().val; int p2 = queue2.isEmpty() ? 0 : queue2.poll().val; int sum = p1 + p2 + carry; int i = sum % 10; // 尾插法 ListNode cur = new ListNode(i); real.next = cur; real = cur; carry = sum / 10; } if (carry &gt; 0) { ListNode node = new ListNode(carry); real.next = node; real = node; } return dummy.next; } public Queue&lt;ListNode&gt; list2Queue(ListNode node) { Queue&lt;ListNode&gt; queue = new LinkedList&lt;&gt;(); while (node != null) { queue.offer(node); node = node.next; } return queue; } 445 Add Two Numbers II思路 链表代表一个整数，两整数相加之后，结果用最高位---&gt;....---&gt;十位---&gt;个位顺序表示。所以可以使用两个栈存储两个链表，然后开始依次弹出，进行相加，使用头插法构造输出链表。 public ListNode addTwoNumbersII(ListNode l1, ListNode l2) { if (l1 == null &amp;&amp; l2 == null) { return null; } Stack&lt;ListNode&gt; s1 = new Stack(); while(l1 != null) { s1.push(l1); l1 = l1.next; } Stack&lt;ListNode&gt; s2 = new Stack(); while(l2 != null) { s2.push(l2); l2 = l2.next; } int carry = 0; ListNode resNode = null; while (!s1.isEmpty() || !s2.isEmpty()) { int n1 = s1.isEmpty() ? 0 : s1.pop().val; int n2 = s2.isEmpty() ? 0 : s2.pop().val; int sum = n1 + n2 + carry; ListNode n = new ListNode(sum % 10); // 头插法 n.next = resNode; resNode = n; carry = sum / 10; } // 最高位 if (carry &gt; 0) { ListNode n = new ListNode(carry); n.next = resNode; resNode = n; } return resNode; } 链表表示整数，进行加法计算，这是两个链表的操作，没有涉及链表的增删改查，实现方式数组中的Add Two Numbers同理。但是需要注意题目要求，上述两个题目思路是一样的，但是需要注意题目说明，给定的链表是如何代表一个整数的，然后输出结果是如何表示的，（因为我们的算法是从个位开始计算的） 正序表示整数 &amp;&amp; 从个位依次输出使用栈存储，尾插法构造结果 逆序表示整数 &amp;&amp; 从最高位依次输出使用队列存储，头插法构造结果 19. Remove Nth Node From End of List查、删 倒数第n个节点删除 先获取第n个节点的前驱节点，然后按照前驱结点删除法删除即可 public static ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(-1); dummy.next = head; ListNode preNode = getPreNode(dummy, n); preNode.next = preNode.next.next; return head; } public static ListNode getPreNode(ListNode head, int n){ int count = 0; ListNode p = head; while (p != null){ count ++; p = p.next; } p = head; while ( count-n-1 &gt; 0){ p = p.next; count --; } return p; } // 也可以直接使用第二种删除方法 public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(-1); dummy.next = head; ListNode fast = dummy; ListNode slow = dummy; while(n &gt; 0){ fast = fast.next; n--; } while(fast.next != null){ fast = fast.next; slow = slow.next; } slow.next = slow.next.next; return dummy.next; } 21. Merge Two Sorted Lists增、查 public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(-1); ListNode real = dummy; while (l1 != null &amp;&amp; l2 != null){ if(l1.val &lt;= l2.val){ real.next = l1; l1 = l1.next; }else { real.next = l2; l2 = l2.next; } real= real.next; } if (l1 != null){ real.next = l1; } if (l2 != null) { real.next = l2; } return dummy.next; } 23. Merge k Sorted Lists增，查 方法一多链表之间按照递增顺序进行整合。（根据上一题的思路，先两两合并，最后合并成一个链表） public ListNode mergeKLists(ListNode[] lists) { if (lists == null) { return null; } int length = lists.length; while (length &gt; 1) { int k = (length + 1) / 2; for (int i = 0; i &lt; (length / 2); i++) { // mergeTwo为21题函数 lists[i] = mergeTwo(lists[i], lists[i+k]); } length = k; } return lists[0]; } 方法二使用小根堆 public ListNode mergeKLists(ListNode[] lists) { PriorityQueue&lt;ListNode&gt; heap = new PriorityQueue&lt;&gt;(new Comparator&lt;ListNode&gt;() { @Override public int compare(ListNode o1, ListNode o2) { return o1.val - o2.val; } }); // 尾插法 ListNode dummy = new ListNode(-1); ListNode real = dummy; for (ListNode node : lists) { if (node != null) { heap.offer(node); } } while (!heap.isEmpty()) { real.next = heap.poll(); real = real.next; if (real.next != null) { heap.offer(real.next); } } return dummy.next; } 24. Swap Nodes in Pairs改 两两交换， 两个节点的交换， 必然牵引到四个指针的改变 具体步骤见图： 链表.png public static ListNode swapPairs(ListNode head){ if(head == null){ return head; } ListNode dummy = new ListNode(-1); dummy.next = head; ListNode pre = dummy; while (head!=null &amp;&amp; head.next!=null){ ListNode temp = head.next; head.next = temp.next; temp.next = pre.next; pre.next = temp; pre = head; head = head.next; } return dummy.next; } 25. Reverse Nodes in k-Group思路和上一题一样。但是需要注意pre的cur 92. Reverse Linked List II和上述同理 public static ListNode reverseBetween(ListNode head, int m, int n) { if (head == null || n - m == 0) { return head; } ListNode dummy = new ListNode(-1); dummy.next = head; ListNode pre = dummy; for (int i = 0; i &lt; m-1; i++) { pre = pre.next; } ListNode cur = pre.next; for (int i = m; i &lt; n; i++) { ListNode temp = cur.next; cur.next = temp.next; temp.next = pre.next; pre.next = temp; } return dummy.next; } 206. Reverse Linked List头插法解决 public ListNode reverseList(ListNode head) { ListNode dummy = new ListNode(-1); while(head != null){ ListNode curr = head.next; head.next = dummy.next; dummy.next = head; head = curr; } return dummy.next; } 61. Rotate List查 快慢指针法，fast指针先走k步，之后slow和fast一起走，fast到链表尾部，然后将链表头尾相连。此时slow指向新的头结点的前驱节点，然后重新设置头指针，断开链表即可。 // 快慢指针 public static ListNode roateRightII(ListNode head, int k){ if(head == null){ return null; } int length = getLength(head); k %= length; ListNode endNode = getEndNode(head); ListNode fast = head, slow = head; while (k &gt; 0){ fast = fast.next; k--; } while (fast.next != null){ fast = fast.next; slow = slow.next; } // 构成环 fast.next = head; // 重新设置 head = slow.next; slow.next = null; return head; } 83. Remove Duplicates from Sorted List删 删除有重复的节点 使用前驱节点删除法，所以需要一个pre指针，和cur指针。 public ListNode deleteDuplicates(ListNode head) { ListNode pre = head; ListNode cur; while (pre.next != null){ cur = pre.next; // 因为是和cur的前驱比较， 所以不用判断cur.next!=null, 而是使用cur!=null while (cur!=null &amp;&amp; cur.val == pre.val){ cur = cur.next; } if(pre.next != cur){ pre.next = cur; } else { pre = pre.next; } } return head; } 82. Remove Duplicates from Sorted List II删 删光重复的节点 使用前驱节点删除法，所以需要一个pre指针，和cur指针。 可能存在头结点会变换, 所以设置一个空的头结点 public ListNode deleteDuplicates(ListNode head) { if (head == null) { return null; } ListNode dummy = new ListNode(-1); dummy.next = head; ListNode cur = null; ListNode pre = dummy; while (pre.next != null) { cur = pre.next; while (cur.next != null &amp;&amp; cur.next.val == cur.val) { cur = cur.next; } if(cur != pre.next){ pre.next = cur.next; } else { pre = pre.next; } } return dummy.next; } 86. Partition List109. Convert Sorted List to Binary Search Tree138. 复制带随机指针的链表class Solution { public Node copyRandomList(Node head) { if (head == null) { return head; } // key 旧。value 新 Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;(); Node newHead = new Node(head.val); Node oddHead = head; map.put(oddHead, newHead); Node nCur = newHead; Node oCur = head.next; while (oCur != null) { nCur.next = new Node(oCur.val); nCur = nCur.next; map.put(oCur, nCur); oCur = oCur.next; } oCur = head; nCur = newHead; while (oCur != null) { if (oCur.random != null) { // random ！！！！ Node ran = map.get(oCur.random); nCur.random = ran; } oCur = oCur.next; nCur = nCur.next; } return newHead; } } 141. Linked List Cycle142. Linked List Cycle II143. Reorder List147. Insertion Sort List148. Sort List160. Intersection of Two Linked Lists解法1：暴力求解 解法2： 构造环 203. 移除链表元素// 双指针 class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) { return head; } ListNode dummy = new ListNode(-1); dummy.next = head; ListNode pre = dummy; ListNode cur = head; while (cur != null) { if (cur.val != val) { pre = cur; cur = cur.next; } else { pre.next = cur.next; cur = pre.next; } } return dummy.next; } } 234. 回文链表class Solution { public boolean isPalindrome(ListNode head) { if (head == null) { return true; } Map&lt;Integer, ListNode&gt; map = new HashMap&lt;&gt;(); ListNode cur = head; int n = 0; while (cur != null) { map.put(n, cur); n++; cur = cur.next; } cur = head; for (int i = 0; i &lt; n / 2; i++) { System.out.println(cur.val); if (cur.val != map.get(n - i - 1).val) { return false; } cur = cur.next; } return true; } } 237. Delete Node in a Linked List328. 奇偶链表class Solution { public ListNode oddEvenList(ListNode head) { // 按照位置分奇偶 if (head == null) { return head; } ListNode odd = new ListNode(-1); ListNode even = new ListNode(-1); ListNode oddHead = odd; ListNode evenHead = even; int i = 1; while (head != null) { if (i % 2 == 1) { odd.next = head; odd = odd.next; } else { even.next = head; even = even.next; } head = head.next; i++; } // 断链 （注意注意注意） odd.next = evenHead.next; even.next = null; return oddHead.next; } } 369. Plus One Linked List379. Design Phone Directory426. Convert Binary Search Tree to Sorted Doubly Linked List430. Flatten a Multilevel Doubly Linked List445. Add Two Numbers II707. Design Linked List708. Insert into a Sorted Circular Linked List725. Split Linked List in Parts817. Linked List Components876. Middle of the Linked List1019. Next Greater Node In Linked List1171. Remove Zero Sum Consecutive Nodes from Linked List删 快慢指针 其实是和计算一个链表中是否存在和为n的子链表是一样的意思。 slow表示当前的元素，使用fast依次遍历其后续的元素，同时值相加，如果等于0，则slow.next = fast.next,如果fast遍历完了所有的元素了，没有等于0， 则slow移动到下一个元素 1290. Convert Binary Number in a Linked List to Integer查 1369. Linked List in Binary Tree","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"链表","slug":"链表","permalink":"https://winniekun.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"死磕二叉树","slug":"LeetCode/stick-to-binary-tree","date":"2020-02-15T12:40:45.000Z","updated":"2021-03-25T07:14:58.934Z","comments":true,"path":"stick-to-binary-tree/","link":"","permalink":"https://winniekun.github.io/stick-to-binary-tree/","excerpt":"前言LeetCode死磕系列一： 二叉树","text":"前言LeetCode死磕系列一： 二叉树 二叉树其自身就具有递归属性， 所以按道理，绝大多数题目用递归都是可以的 一般情况下:如果需要搜索整颗二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归 函数就需要返回值，因为遇到符合条件的路径了就要及时返回 常用操作 遍历 前序遍历 //递归前序遍历 public void preOrder(TreeNode root) { if (Objects.isNull(root)) { return; } // do something preOrder(root.left); preOrder(root.right); } //递归前序遍历 public void preOrder(TreeNode root) { } //非递归前序遍历 public void preOrderII(TreeNode root) { if (Objects.isNull(root)) { return; } Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); TreeNode p = root; while (!stack.isEmpty() || p != null) { while (p != null) { // do something stack.push(p); p = p.left; } if (!stack.isEmpty()) { p = stack.pop(); p = p.right; } } } 中序遍历 //递归中序遍历 public void inOrder(TreeNode root) { if (Objects.isNull(root)) { return; } inOrder(root.left); // do something inOrder(root.right); } //非递归中序遍历 public void inOrderII(TreeNode root) { if (Objects.isNull(root)) { return; } TreeNode p = root; Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); while (!stack.isEmpty() || p != null) { while (p != null) { stack.push(p); p = p.left; } if (!stack.isEmpty()) { p = stack.pop(); // do something p = p.right; } } } 后序遍历 //递归后序遍历 public void postOrder(TreeNode root) { if (Objects.isNull(root)) { return; } postOrder(root.left); postOrder(root.right); // do something } //非递归后序遍历 public void postOrderII(TreeNode root) { if (Objects.isNull(root)) { return; } Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); Deque&lt;TreeNode&gt; list = new ArrayDeque&lt;&gt;(); Deque&lt;TreeNode&gt; reverse = new ArrayDeque&lt;&gt;(); TreeNode p = root; stack.push(p); while (!stack.isEmpty()) { p = stack.pop(); list.push(p); if (p.right != null) { stack.push(p.left); } if (p.left != null) { stack.push(p.left); } } while (!list.isEmpty()) { reverse.add(list.pop()); } } 层次遍历 public void levelOrder(TreeNode root) { if (Objects.isNull(root)) { return; } Deque&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); TreeNode p = root; queue.offer(p); while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i &lt; size; i++) { p = queue.poll(); if (p.left != null) { queue.offer(p.left); } if (p.right != null) { queue.offer(p.right); } } } } 公共祖先 树转链表 重新构建二叉树 路径之和 深度和高度 求二叉树深度 和 二叉树高度的差异，求深度适合用前序遍历，而求高度适合用后序遍历 因为深度可以从上到下去查 所以需要前序遍历(根左右)，而高度只能从下到上去查，所以只能后序遍历(左右根) LeetCode&amp;剑指offer 二叉树题目整理 二叉树的前序遍历 二叉树的中序遍历 二叉树的后序遍历 二叉树的高度 二叉树的直径 二叉树的深度 二叉树的层次遍历 层次遍历能解决很多关于二叉树的问题，目前根据考研经验以及LeetCode刷题总结，其作用范围大概如下： 二叉树的深度 最大深度 一次正常的层次遍历 最小深度 第一次遇到当前节点为叶子节点时遍历结束 二叉树的宽度 最大宽度 最小宽度 以上两道题可以感觉出，层次遍历将二叉树定在了一个二维的坐标轴上，二叉树的层为一个方向，深度为一个方向。只要是和层和深度相关的内容都可以考虑试试层次遍历。以下的内容也都是在层和深度的基础上的一些小变化（最直白的简单题） 每一层的平均值、最大值、最小值等 二叉树的左视图、右视图 相关变种题目： 102.二叉树的层序遍历 107.二叉树的层次遍历II 199.二叉树的右视图 637.二叉树的层平均值 429.N叉树的层序遍历 515.在每个树行中找最大值 116.填充每个节点的下一个右侧节点指针 117.填充每个节点的下一个右侧节点指针II 104.二叉树的最大深度 解法不唯一，也可使用后序遍历解决。 111.二叉树的最小深度 和上一题一样的思路，但是条件不一样 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 222.完全二叉树的节点个数 路径问题 是否有满足和为sum的路径 求所有慢煮和为sum的路径 构造二叉树 给定一个数组，构造二叉树/构建平衡二叉树 根据前序中序、后序中序构建二叉树 二叉树的序列化 根据数组判断是否为二叉排序树 公共节点 题解二叉树的高度思路： 递归 辅助队列 二叉树的直径思路：感觉是二叉树的高度的延伸，思路是和二叉树的高度是类似的。 直径： 以当前节点为基础，然后依次获取当前节点的最大左子树深度L和右子树最大深度R，L+R=D即为结果，然后从每个节点的D中选取最大的即可 private int ans; public int diameterOfBinaryTree(TreeNode root) { if (Objects.isNull(root)) { return 0; } ans = 0; depth(root); return ans-1; } private int depth(TreeNode root) { if (Objects.isNull(root)) { return 0; } int left = depth(root.left); int right = depth(root.right); ans = Math.max(ans, left+right); return Math.max(left, right) + 1; } 二叉树的层次遍历102.二叉树的层序遍历层次遍历的基础模板题目 public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; out = new ArrayList&lt;&gt;(); if (Objects.isNull(root)) { return result; } Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); TreeNode p = root; queue.offer(p); while (!queue.isEmpty()) { int size = queue.size(); for(int i = 0; i &lt; size; i++) { p = queue.poll(); out.add(p.val); if (p.left != null) { queue.offer(p.left); } if (p.right != null) { queue.offer(p.right); } } result.add(out); out = new ArrayList&lt;&gt;(); } return result; } 107.二叉树的层次遍历II层次遍历的简单变形，根据list的特性，每次新增一层的结果的时，都在首位插入，即可完成逆序存储 public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; out = new ArrayList&lt;&gt;(); if (Objects.isNull(root)) { return result; } Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); TreeNode p = root; queue.offer(p); while (!queue.isEmpty()) { int size = queue.size(); for(int i = 0; i &lt; size; i++) { p = queue.poll(); out.add(p.val); if (p.left != null) { queue.offer(p.left); } if (p.right != null) { queue.offer(p.right); } } result.add(0, out); out = new ArrayList&lt;&gt;(); } return result; } 199.二叉树的右视图 二叉树层次遍历的简单变形。 思路： 每次遍历到当前层的最后一个非空节点的时候，存入到右视图的list中 public List&lt;Integer&gt; rightSideView(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (Objects.isNull(root)) { return result; } TreeNode p = root; Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(p); while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i &lt; size; i++) { p = queue.poll(); // 每一层的最后一个节点 if (i == size - 1) { result.add(p.val); } if (p.left != null) { queue.offer(p.left); } if (p.right != null) { queue.offer(p.right); } } } return result; } 637.二叉树的层平均值 二叉树层次遍历的简单变形。 思路： 求每一层的平均值 429.N叉树的层序遍历 515.在每个树行中找最大值116.填充每个节点的下一个右侧节点指针117.填充每个节点的下一个右侧节点指针II104.二叉树的最大深度思路1 广度遍历(层次遍历) public int maxDepth(TreeNode root) { if (Objects.isNull(root)) { return 0; } TreeNode p = root; Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(p); int count = 0; while (!queue.isEmpty()) { int size = queue.size(); count++; for (int i = 0; i &lt; size; i++) { p = queue.poll(); if (p.left != null) { queue.offer(p.left); } if (p.right != null) { queue.offer(p.right); } } } return count; } 思路2 深度遍历(后序遍历) public int maxDepth(TreeNode root) { if (Objects.isNull(root)) { return 0; } int left = maxDepthII(root.left); int right = maxDepthII(root.right); return Math.max(left, right) + 1; } 111.二叉树的最小深度最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 image-20210223220242873 /** * 深度遍历（后序） * @param root * @return */ public int minDepth(TreeNode root) { if (Objects.isNull(root)) { return 0; } int left = minDepth(root.left); int right = minDepth(root.right); if (root.left == null &amp;&amp; root.right != null) { return 1 + right; } else if (root.left != null &amp;&amp; root.right == null) { return 1 + left; } return Math.min(left, right) + 1; } /** * 广度遍历（层次） * @param root * @return */ public int minDepthII(TreeNode root) { int count = 0; if (Objects.isNull(root)) { return count; } Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); TreeNode p = root; queue.offer(p); while (!queue.isEmpty()) { int size = queue.size(); count++; for (int i = 0; i &lt; size; i++) { p = queue.poll(); if (p.left != null) { queue.offer(p.left); } if (p.right != null) { queue.offer(p.right); } if (p.left == null &amp;&amp; p.right == null) { return count; } } } return count; } 222.完全二叉树的节点个数references 代码随想录","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"}],"tags":[{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"二叉树","slug":"二叉树","permalink":"https://winniekun.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"LinkedList源码解读","slug":"源码/JDK/list/linkedlist-analysis","date":"2020-02-11T01:17:29.000Z","updated":"2020-08-30T04:50:22.255Z","comments":true,"path":"linkedlist-analysis/","link":"","permalink":"https://winniekun.github.io/linkedlist-analysis/","excerpt":"LinkedList源码解读概述LinkedList底层数据结构是链表，是实现了List接口和Deque接口的双端链表，其能够高效的实现插入删除操作, 而且也拥有了队列所拥有的特性。和ArrayList相比，因为其没有实现RandomAccess，是以下标进行访问元素， 所以对于元素访问不及ArrayList，随机访问元素慢。同时需要注意的是, LinkedList不是线程安全的，需要使用的别的方式实现线程安全。","text":"LinkedList源码解读概述LinkedList底层数据结构是链表，是实现了List接口和Deque接口的双端链表，其能够高效的实现插入删除操作, 而且也拥有了队列所拥有的特性。和ArrayList相比，因为其没有实现RandomAccess，是以下标进行访问元素， 所以对于元素访问不及ArrayList，随机访问元素慢。同时需要注意的是, LinkedList不是线程安全的，需要使用的别的方式实现线程安全。 依赖 image 阅读套路按照正常的逻辑，首先了解其构造方法， 之后了解常用的API(CRUD)操作即可。 [x] addAll(); [x] add(); [x] remove(); [x] get(); 从节点数据结构开始 image 按照正常的逻辑， 首先基础的数据构造, 然后了解其构造方法， 之后了解常用的API(CRUD)操作即可。 其实一个很明显的双向链表的数据结构。 构造函数 空的构造方法 public LinkedList() { } 用于构造一个空的链表。然后自行处理 含有参数的构造方法(用已有的集合创建链表) public LinkedList(Collection&lt;? extends E&gt; c) { this(); addAll(c); } 将已有的linkedlist添加到一个新的linkedlist中(尾插法，下文有提及)。其类似于copy() 增：add相关的方法可以看到， 初始化之后，使用无参的构造方法，返回的为一个空的链表，若是为含有参数的构造方法，会调用addAll()方法将一个链表的所有元素都拷贝到一个新的元素。 这个部分涉及了大量的双向链表的插入删除，可先理解了双向链表的操作（3、 4步骤的操作顺序在于采用的是哪个节点作为基础节点：也就是选择待插入位置的节点还是该节点的前驱节点，或者是两个都使用，若是两个都是用则3、 4无顺序先后）。 addAll() public boolean addAll(Collection&lt;? extends E&gt; c) { // 以size为插入下标，插入集合c中所有元素 return addAll(size, c); } public boolean addAll(int index, Collection&lt;? extends E&gt; c) { // 判断当前的索引是否越界， 若是越界， checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; // pred: 插入位置对应的节点的前驱节点 // succ: 插入位置对应的节点 // 以下为双向链表的插入操作需要的预备工作 Node&lt;E&gt; pred, succ; if (index == size) { // 在链表的尾部插入节点需要的预备工作 succ = null; pred = last; } else { // 在链表中间插入节点需要的预备工作 // 1. 确定插入位置的节点 // 2. 确定插入位置的节点的前驱节点 succ = node(index); pred = succ.prev; } // 插入节点 可画图理解 for (Object o : a) { @SuppressWarnings(\"unchecked\") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; } if (succ == null) { last = pred; } else { pred.next = succ; succ.prev = pred; } size += numNew; modCount++; return true; } addAll()主要为就是依次的遍历已有集合的所有元素，然后依次进行插入(尾插法，保证插入的顺序不会和最后的顺序不变) 判断越界方法private void checkPositionIndex(int index) { if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } private boolean isPositionIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt;= size; } 直接在if后跑出异常，可直接跑出异常信息，并且可以根据自己定义信息跑出异常。 add(E e)public boolean add(E e) { linkLast(e); return true; } void linkLast(E e) { // 在链表尾部插入元素 final Node&lt;E&gt; l = last; // 定义一个新的节点l, 指向尾节点，方便后续插入 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);// 创建插入元素的节点 // 以下为插入操作，可画图理解 last = newNode; if (l == null) // 说明原链表为空，更新头节点 first = newNode; else // 原链表不为空， 在尾部进行插入操作 l.next = newNode; size++; modCount++; } add(int index, E element)public void add(int index, E element) { checkPositionIndex(index); // 链表尾部插入元素 if (index == size) linkLast(element); // 在链表的中间部分插入元素 else linkBefore(element, node(index)); } void linkLast(E e) { // 在链表尾部插入元素 final Node&lt;E&gt; l = last; // 定义一个新的节点l, 指向尾节点，方便后续插入 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);// 创建插入元素的节点 // 以下为插入操作，可画图理解 last = newNode; if (l == null) // 说明原链表为空，更新头节点 first = newNode; else // 原链表不为空， 在尾部进行插入操作 l.next = newNode; size++; modCount++; } void linkBefore(E e, Node&lt;E&gt; succ) { // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); // 一下为双端链表的插入操作 succ.prev = newNode; // 若是在第一个节点前插入， 则插入节点为第一个节点 if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; } Node&lt;E&gt; node(int index) { // assert isElementIndex(index); // 根据索引创建节点 // 此处会有判断，判断是在链表的前半段还是后半段 // 加快查找效率 if (index &lt; (size &gt;&gt; 1)) { Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; } else { Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; } } 小结 链表批量增加，是靠for循环遍历原数组，依次执行插入节点操作。对比ArrayList是通过System.arraycopy完成批量增加的 通过下标获取某个node 的时候，（add select），会根据index处于前半段还是后半段 进行一个折半，以提升查询效率 删： remove相关的方法remove() public E remove() { // 默认是从链表的头部开始删除元素 return removeFirst(); } public E removeFirst() { final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); } private E unlinkFirst(Node&lt;E&gt; f) { // assert f == first &amp;&amp; f != null; // 删除第一个节点 final E element = f.item; final Node&lt;E&gt; next = f.next; // 防止删除时导致的断链 f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element; } remove(int index)下图为双向链表的删除操作，仅做参考，具体的写法依据个人采用基础节点。 mage public E remove(int index) { // 判断是否越界 checkElementIndex(index); return unlink(node(index)); } private void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } private boolean isElementIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt; size; } E unlink(Node&lt;E&gt; x) { // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; // 后继节点 final Node&lt;E&gt; prev = x.prev; // 前驱节点 // 删除的为第一个节点 if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } // 删除的为最后一个节点 if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; modCount++; return element; } 判断越界方法其实是和增里面的判断是一样的 private void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } private boolean isElementIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt; size; } remove(Object o)public boolean remove(Object o) { if (o == null) { for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) { unlink(x); return true; } } } return false; } E unlink(Node&lt;E&gt; x) { // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; // 后继节点 final Node&lt;E&gt; prev = x.prev; // 前驱节点 // 删除的为第一个节点 if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } // 删除的为最后一个节点 if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; modCount++; return element; } 小结删也一定会修改modCount。 按下标删，也是先根据index找到Node，然后去链表上unlink掉这个Node。 按元素删，会先去遍历链表寻找是否有该Node，考虑到允许null值，所以会遍历两遍，然后再去unlink它。 改：set()相关的方法set(int index, E element) public E set(int index, E element) { checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal; //返回原先的值 } private void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } private boolean isElementIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt; size; } Node&lt;E&gt; node(int index) { // assert isElementIndex(index); // 根据索引创建节点 // 此处会有判断，判断是在链表的前半段还是后半段 // 加快查找效率 if (index &lt; (size &gt;&gt; 1)) { Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; } else { Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; } } 小结set()也是根据索引去寻找对应Node()，之后替换，但是不会修改modCount 查： get相关方法get(int index)public E get(int index) { checkElementIndex(index); return node(index).item; } Node&lt;E&gt; node(int index) { // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) { Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; } else { Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; } } 判断越界方法其实是和增里面的判断是一样的 private void checkElementIndex(int index) { if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } private boolean isElementIndex(int index) { return index &gt;= 0 &amp;&amp; index &lt; size; } 小结按照索引查找对应的节点，之前的增、删、改都用到了 总结LinkedList是双向链表 链表的批量添加(addAll())是转化为数组之后使用for-each进行添加，默认在链表尾部添加， 会修改modCount 根据index获取节点时，会根据index处于后半段还是前半段进行查找，提升查找速率 所有的CRUD中都有涉及根据index去寻找节点 LinkedList中还有很多的API没有写，只是简单的写了基础的CRUD reference JavaGuid—-LinkedList 面试必备：LinkedList源码解读(JDK8) 王道考研数据结构—-链表一章 考研的时候看的，各种花式插入删除整合骚操作。 大话数据结构","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"List","slug":"List","permalink":"https://winniekun.github.io/tags/List/"}]},{"title":"ArrayList源码解读","slug":"源码/JDK/list/arrayList-analysis","date":"2020-02-10T01:49:19.000Z","updated":"2020-08-30T04:50:22.254Z","comments":true,"path":"arrayList-analysis/","link":"","permalink":"https://winniekun.github.io/arrayList-analysis/","excerpt":"ArrayList 源码解读","text":"ArrayList 源码解读 依赖 ArrayList依赖 关于为什么ArrayList已经继承了AbstractList还要实现List接口, 可参考 Why does LinkedHashSet extend HashSet and implement Set StackOverflow解释 可能这样增加可读性吧, 接口的第二个功能一样 字段 /** * Default initial capacity. * 默认初始化容量 */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances * 空实例的共享数组实例 * 若是无参构造方法 使用 DEFAULTCAPACITY_EMPTY_ELEMENTDATA; * 若是含参构造方法 使用 EMPTY_ELEMENTDATA */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. * */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */ transient Object[] elementData; // non-private to simplify nested class access /** * The size of the ArrayList (the number of elements it contains). * * @serial */ private int size; /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit * 某些 VM 保留数组头部用于存储一些 header words */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 可以发现, elementData 和 size 两个变量在ArrayList的运行中会有很大的变动, 可以使用反射进行观察 构造函数ArrayList()/** * 构造函数1: 默认构造函数, * DEFAULTCAPACITY_EMPTY_ELEMENTDATA = 0, * 初始是一个空数组, 当添加一个元素的时候, 扩充为10(如何扩充为10, 详见下述) * 原因详见 transient Object[] elementData上的注释 */ public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } 也就是在创建对象的时候，并没有立刻初始化容器的大小，直到第一次调用 add()方法的时候，才进行确定。 ArrayList(int initialCapacity)/** * 构造函数2 带初始容量参数的构造函数, (用户自己定义容量) */ public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } 初始化容量大小为initialCapactiy ArrayList(Collection&lt;? extends E&gt; c)/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null * 构造包含指定collection元素的列表 这些元素利用该集合的迭代按顺序返回 * 如果指定的集合为null, 抛出 NullPointerException */ public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; } } 总结 常量EMPTY_ELEMENTDATA和DEFAULTCAPACITY_EMPTY_ELEMENTDATA是为了初始化elementData的。如果为无参构造函数，使用DEFAULTCAPACITY_EMPTY_ELEMENTDATA；如果为含参构造函数，使用EMPTY_ELEMENTDATA 以无参构造方法创建arraylist时, 实际上初始化的值是一个空数组. 添加第一个元素时 扩容为10 如果使用Collection实例初始化, 不为空将调用toArray()方法初始化elementData, 为空时初始化为空数组EMPTY_ELEMENTDATA 增add(E e)public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } 在调用 add()方法的时候，首先调用 ensureCapacityInternal()方法来确定是否还有容量来容纳新的值。size是表示数组的初始大小，默认为 0 。 ArrayList-add执行步骤 按照流程走一遍: 第一次调用的时候: 第一步, 因为还为添加成功元素, size = 0 , size + 1 = 1 第二步, 首先执行第三步, 传入两个参数elementData和minCapacity 第三步, 此时的elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATAT, 然后 minCapaciy==1, 返回DEFAULT_CAPACITY 第四步, 此时的minCapacity==10 , elementData.length = 0 所以执行if分支 第五步, oldCapacity==0 经计算newCapacity==0 然后newCapacity-minCapacity&lt;0, 所以newCapacity==10 之后进行数据的复制，这时，elementData的长度是 10.，第一个元素成功的添加到数组中。 第二次调用 第一步, 因为已经添加成功了一个元素, size = 1 , size + 1 = 2 第二步, 首先执行第三步, 传入两个参数elementData和minCapacity 第三步, 此时的elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATAT, 然后 minCapaciy==2, 不执行if分支, 返回 2 第四步, 此时的minCapacity==2 , elementData.length = 10 所以不执行执行if分支, 也就是无需扩容 反复添加直到添加第11个元素的时候, 再次出发第四步的grow, 进行扩容, 扩为原先的1.5倍. add(int index, E element)public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } 使用arraycopy方法, 可以看做将指定坐标位置以及右侧所有元素向后移动一位，腾出空间存放新元素。 addAll(Collection&lt;? extends E&gt; c)public boolean addAll(Collection&lt;? extends E&gt; c) { Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; } addAll(int index, Collection&lt;? extends E&gt; c)public boolean addAll(int index, Collection&lt;? extends E&gt; c) { rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; } 总结 共实现四中添加方法: 添加单个元素(默认在尾部添加) 在指定位置添加单个元素 添加一个集合(默认在末尾) 在指定位置添加一个集合 每次执行add操作时都会首先调用 ensureCapacityInternal()方法来确定是否还有容量来容纳新的值, 若是没有则进行扩容, 有则直接添加 删remove()方法用来从集合中删除一个元素，可以删除指定索引出的元素，也可以指定元素。 remove(Object o)public boolean remove(Object o) { if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } // 将index位置后的所有元素前移一位, 之后size-1 private void fastRemove(int index) { modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work } 流程走一遍 ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(\"a\"); arrayList.add(\"b\"); arrayList.add(\"c\"); arrayList.remove(\"a\"); 要删除a这个元素，把 a传入到 remove()这个方法，首先进行判断是否为null，因为 ArrayList可以存放 null，如果为 null 则用==判断元素是否相等，否则用 equals()方法进行判断。 然后循环遍历 elementData这个数组，size为数组元素个数，找到和 a相等的元素的索引，例子中 index = 0， 然后把 0 传入到 fastRemove()方法中，之后计算要移动的元素的个数： int numMoved = size - index -1; 例子中 numMoved = 3 - 0 -1 = 2，也就是一共要移动两个元素，然后把 a之后的两个元素往前移动，然后进行 size-1，把最后一个元素位置的值设置为 null。 这样即可在ArrayList中删除一个元素。 remove(int index)public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; } 总结没啥好总结的 查public E get(int index) { // 判断查询的位置是否符合要求 rangeCheck(index); return elementData(index); } private void rangeCheck(int index) { if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } E elementData(int index) { return (E) elementData[index]; } 没啥好说的, 就是正常数据的使用 附加hugeCapacity 方法 private static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 只有newCapacity &gt;MAX_ARRAY_SIZE 才回调用该方法, 方法中使用三元运算, 意思是若果minCapacity&gt; MAX_ARRAY_SIZE 则newCapacity的容量大小为Integer.MAX_VALUE也就是2**31次方, 若是minCapacity&lt; MAX_ARRAY_SIZE 则newCapacity的容量大小为Integer.MAX_VALUE-8 ensureCapacity用法Arraylist源码中有一个ensureCapacity方法 /*** * 如有必要，增加此 ArrayList 实例的容量， * 以确保它至少可以容纳由minimum capacity参数指定的元素数。 */ public void ensureCapacity(int minCapacity) { int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) { ensureExplicitCapacity(minCapacity); } } 该方法适用于添加大量的元素, 以减少上文的增量重新分配的次数 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); final int N = 10000000; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; N; i++) { list.add(i); } long endTime = System.currentTimeMillis(); System.out.println(\"使用ensureCapaticy方法之前: \"+ (endTime - startTime)); list = new ArrayList&lt;&gt;(); list.ensureCapacity(N); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; N; i++) { list.add(i); } endTime = System.currentTimeMillis(); System.out.println(\"使用ensureCapaticy方法之后: \"+ (endTime -startTime)); 使用ensureCapaticy方法之前: 3345 使用ensureCapaticy方法之后: 257 总结ArrayList集合底层是用一个 Object 数组来存放元素的，其可以存放 null 值，因为是使用数组来存放元素，所以在知道索引的情况下，进行元素的查找是很快的，但是也有缺点，如果数组的容量不能够存放新元素的时候，会进行数组的扩容，也就是把数组元素复制到一个容量更大的数组中，所以如果在经常进行元素添加和删除操作的情况下效率会比较低。还有一点，ArrayList不是线程安全的，要保证线程安全，可以使用 Vector代替。 System.arraycopy(src, srcPos, dest, destPos, length) 与 Arrays.copyOf(original, newLength)区别arraycopy()的参数 src:源数组; srcPos:源数组要复制的起始位置; dest:目的数组; destPos:目的数组放置的起始位置; length:复制的长度. 两者的区别在于，Arrays.copyOf()不仅仅只是拷贝数组中的元素，在拷贝元素时，会创建一个新的数组对象。而System.arrayCopy只拷贝已经存在数组元素, 是否创建新的数据对象,根据写法而定 //System.arraycopy,只拷贝已存在的数组元素 int[] src = {0, 1, 2}; int[] dest = new int[3]; System.arraycopy(src, 0, dest, 0, src.length); System.out.println(Arrays.toString(dest)); //[0, 1, 2] //Arrays.copyOf,会创建一个新的数组对象 int[] src = {0, 1, 2}; int[] dest = Arrays.copyOf(src, src.length); System.out.println(Arrays.toString(dest)); //[0, 1, 2] 实际上Arrays.copyOf方法的内部实现也是通过System.arraycopy方法实现，在Arrays类中有多个copyOf的重载方法，现以拷贝int[]为例： 1 public static int[] copyOf(int[] original, int newLength) { 2 int[] copy = new int[newLength]; 3 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); 4 return copy; 5 } References ArrayList源码 ArrayList源码分析","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"List","slug":"List","permalink":"https://winniekun.github.io/tags/List/"}]},{"title":"Volatile关键字内涵","slug":"Java进阶/并发/Volatile关键字内涵","date":"2020-01-18T04:35:26.000Z","updated":"2021-05-31T15:43:04.259Z","comments":true,"path":"Volatile关键字内涵/","link":"","permalink":"https://winniekun.github.io/Volatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%86%85%E6%B6%B5/","excerpt":"内涵与表象","text":"内涵与表象 volatile主要有一下的功能： 保证变量的内存可见性 内存可见性：通俗来说就是，线程A对一个volatile变量的修改，对于其它线程来说是可见的，即线程每次获取volatile变量的值都是最新的 禁止volatile变量与普通变量重排序 定义: Volatile是轻量级的synchronized。它在多处理器开发过程中保证的共享变量的可见性、有序性 使用volatile的使用场景但是使用volatile必须满足两个条件： 对变量的写操作不依赖当前值，如多线程下执行a++，是无法通过volatile保证结果准确性的 该变量没有包含在具有其它变量的不变式中(如下例子解释) public class NumberRange { private volatile int lower = 0; private volatile int upper = 10; public int getLower() { return lower; } public int getUpper() { return upper; } public void setLower(int value) { if (value &gt; upper) throw new IllegalArgumentException(...); lower = value; } public void setUpper(int value) { if (value &lt; lower) throw new IllegalArgumentException(...); upper = value; } } 若是有两个线程同时分别执行了setLower(8)和setUpper(5) 然后 均通过了判断, 则最后的范围从$[0, 10]$ 变为了 $[8, 5]$成为了一个无效的范围, 这样就出现了问题. 这种场景下就只能使用synchronized, 同一时间只允许getLower和getUpper方法中其中一个执行 状态标记量public class ServerHandler { private volatile isopen; public void run() { if (isopen) { //促销逻辑 } else { //正常逻辑 } } public void setIsopen(boolean isopen) { this.isopen = isopen } } 单例模式的double check单例模式的一种实现方式，但很多人会忽略volatile关键字，因为没有该关键字，程序也可以很好的运行，只不过代码的稳定性总不是100%，说不定在未来的某个时刻，隐藏的bug就出来了。 public class Singleton{ private volatile static Singleton instance; public static Singleton getInstance(){ if(instance == null){ sychronized(Singleton.class){ if(instance == null){ instance = new Singleton(); } } } return instance; } } 在JMM中, 有主内存和本地内存, 每个线程都有一个本地内存, 且共享主内存中的数据, 普通变量和volatile变量的区别如下: 普通变量进行读操作的时候, 首先会读取本地内存中的数据, 若是不存在, 则去主内存中拷贝一份在本地内存, 写操作只会写入到本地内存. 这样其他变量就不会读取变量的最新值 voaltile遍历进行读操作的时候, JMM会将本地内存的数据设置为无效, 要求线程从主内存读取数据, 写操作时, JMM会将工作内存中的数据刷新到主内存中. 这样其他遍历就能够读取变量的最新值 可见性、有序性实现原理可见性： volatile修饰的变量进行写操作转换成汇编语言，会添加Lock前缀的指令 lock前缀的指令在多核处理器的情况下，会引发以下的两个事情： 会将当前处理器缓存的数据，写回主内存 同时写回内存的操作，会使得其他处理器缓存的该内存地址的数据无效 多处理器下，为了确保多处理器的缓存是一致的，会去实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检测自己缓存的数据是否过期。如果发现缓存的内存地址被修改，会将自身缓存的内存地址置为无效，然后下次操作该数据的时候，重新从主存中将数据重新读取缓存 有序性禁止重排序JVM通过内存屏障来实现限制处理器的重排序。 什么是内存屏障？硬件层面，内存屏障分两种：读屏障（Load Barrier）和写屏障（Store Barrier）。内存屏障有两个作用： 阻止屏障两侧的指令重排序； 强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。 编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。编译器选择了一个比较保守的JMM内存屏障插入策略，这样可以保证在任何处理器平台，任何程序中都能得到正确的volatile内存语义。这个策略是： 在每个volatile写操作前插入一个StoreStore屏障； 在每个volatile写操作后插入一个StoreLoad屏障； 在每个volatile读操作后插入一个LoadLoad屏障； 在每个volatile读操作后再插入一个LoadStore屏障。 大概示意图是这个样子： 内存屏障 再介绍一下volatile与普通变量的重排序规则: 如果第一个操作是volatile读，那无论第二个操作是什么，都不能重排序； 如果第二个操作是volatile写，那无论第一个操作是什么，都不能重排序； 如果第一个操作是volatile写，第二个操作是volatile读，那不能重排序。 References Java并发编程的艺术 深入浅出Java多线程","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://winniekun.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"Synchronize关键字内涵","slug":"Java进阶/并发/Synchronize关键字内涵","date":"2020-01-18T04:35:12.000Z","updated":"2021-06-05T08:52:56.318Z","comments":true,"path":"Synchronize关键字内涵/","link":"","permalink":"https://winniekun.github.io/Synchronize%E5%85%B3%E9%94%AE%E5%AD%97%E5%86%85%E6%B6%B5/","excerpt":"内涵与表象","text":"内涵与表象 synchronized关键字的解释如下： Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。 根据定义，会考虑两个方面的问题： synchronized是如何保证在同一时刻最多只有一个线程执行该段代码 保证在同一时刻最多只有一个线程执行该段代码，这又带来什么意义 老司机级别的解释： Java中的synchronized，通过使用内置锁，来实现对共享变量的同步操作，进而解决了对共享变量操作的原子性、保证了其他线程对共享变量的可见性、有序性，从而确保了并发情况下的线程安全。 原子性synchronized关键字的一个作用就是确保了原子性。 譬如使用count++而言，原先其执行需要三个步骤： 读取count值 count+1 写入count 值 其包含了三个步骤，且每次的步骤都依赖于上一次的结果。所以不是原子性的 synchronized(this){ count++; } 使用如上的方式，就确保了原子性。因为原子操作是线程安全的，这其实也是我们经常使用synchronize来实现线程安全的原因。 如何实现的原子性？ 因为synchronized被编译之后，使用的是monitorenter和monitroexit两个字节码指令，而这两个字节码指令实质上是依赖于操作系统中的互斥锁（mutex lock）实现。通过互斥锁，保证了同一时刻，只有一个线程修改了该共享变量，所以确保了原子性 可见性、有序性synchronize的确保原子性，其实是从使用synchronize的线程的角度来讲的，而如果我们从其他线程的角度来看，那么synchronize则是实现了可见性、有序性。 可见性：一个线程修改了共享变量的值，其他线程能够立即得知这个修改 有序性： Java程序中的天然有序性是指：如果在本线程内观察，所有的操作都是有序的，如果在另一个线程中观察另一个线程，那么所有的操作都是无序的 前半句是指线程内表现为串行的语义（as-if-serial规则） 后半句是指指令重排和工作内存和主内存同步延迟导致的现象 synchronzied如何保证可见性： JMM规定：一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。 synchronzied如何保证有序性： 锁自身的作用来或者说JMM的规定：一个变量在同一时刻只允许一条线程对其进行lock操作 内置锁在Java中，每个对象都有一把锁，放置于对象头中，用于记录当前对象被哪个线程所持有。相对于实例数据，对象头属于额外开销，所以被设计的极小来提高效率。对象头中的markword更加体现了这一点，且是非结构化的，这样在不同的锁状态下，能够复用相同的bit位，markword中就有存储锁的信息的部分。 markword 我们知道在Java中Synchronized能够实现的线程的同步，synchronized被编译之后会生成monirotenter和monitorexit两个字节码指令，依赖这两个字节码指令实现线程同步。 Monirtor：可以理解为只能容纳一名客人的房间，而线程可以等比于客人。整个状态的流转可以理解为一个状态机，同一时刻只有一个线程处于Active状态。 monitor Every object has an intrinsic lock associated with it. —— The Java™ Tutorials 普通同步方法 锁的是当前实例对象 静态同步方法 锁的是该类的Class对象 同步代码块儿 锁的是括号内的对象 因为synchronized被编译之后，使用的是monitorenter和monitroexit两个字节码指令，而这两个字节码指令实质上是依赖于操作系统中的互斥锁（mutex lock）实现，同时Java线程可以理解为对操作系统中线程的映射，所以每当挂起/唤醒一个线程，都需要涉及到操作系统的内核态内容的切换。属于重量级操作，甚至是有可能切换的时间远远超过于线程本身的运行时间。但是从Java6开始，引入了偏向锁、轻量级锁、重量级锁的锁优化过程，进而优化了其性能。 无锁定义：不锁住资源，多个线程中有一个能修改资源成功，其他线程会重试，通过CAS实现 偏向锁定义：偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。 依据：在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。 当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。==在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。==引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。 ==偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。== 偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。 轻量锁定义： 当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。 虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。 如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁 重量锁互斥锁 可重入：public class Widget{ public synchronized void doSomething(){ ... } } public class LoggingWidget extends Widget { public synchronized void doSomething(){ sout(\"...\"); super.doSomething(); } } 如果没有可重入性，那么该代码会产生死锁。 可重入的定义： 若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。 —- 维基百科 从设计上讲，当一个线程请求一个由其他线程持有的对象锁时，该线程会阻塞。当线程请求自己持有的对象锁时，如果该线程是重入锁，请求就会成功，否则阻塞。 synchronized拥有强制原子性的内部锁机制，是一个可重入锁。因此，在一个线程使用synchronized方法时调用该对象另一个synchronized方法或调用父类的synchronized方法，即一个线程得到一个对象锁后再次请求该对象锁，是永远可以拿到锁的。 在Java内部，同一个线程调用自己类中其他synchronized方法/块时不会阻碍该线程的执行，同一个线程对同一个对象锁是可重入的，同一个线程可以获取同一把锁多次，也就是可以多次重入。原因是Java中线程获得对象锁的操作是以线程为单位的，而不是以调用为单位的。 总结 Java中每个对象都有一个内置锁。 synchronized使用对象自带的内置锁来进行加锁，从而保证在同一时刻最多只有一个线程执行代码。 所有的加锁行为，都可以带来三个个保障——原子性、可见性、有序性。其中，原子性是相对锁所在的线程的角度而言，而可见性、有序性则是相对其他线程而言。 锁的持有者是线程，而不是调用，这也是锁的为什么是可重入的原因。 References Java并发编程实战 深入浅出Java多线程 Java多线程：synchronized的可重入性","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://winniekun.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"在IDEA中搭建JDK1.8阅读环境","slug":"配置/在IDEA中搭建JDK1-8阅读环境","date":"2020-01-15T12:27:15.000Z","updated":"2020-08-30T04:50:22.263Z","comments":true,"path":"在IDEA中搭建JDK1-8阅读环境/","link":"","permalink":"https://winniekun.github.io/%E5%9C%A8IDEA%E4%B8%AD%E6%90%AD%E5%BB%BAJDK1-8%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83/","excerpt":"前言自己从去年12月份开始看JDK上的部分源码，之前因为是懒，觉得看源码嘛，看嘛，突出看。直接就是阅读源码，然后每个代码逻辑都是靠自己推测， 还有理解， 并没有看输出， 现在才发现在IDEA中File | Settings | Build, Execution, Deployment | Debugger | Stepping中可以将Do not step into the classes即可，当然，若是想直接在源码中添加注释，需要进行一些配置。","text":"前言自己从去年12月份开始看JDK上的部分源码，之前因为是懒，觉得看源码嘛，看嘛，突出看。直接就是阅读源码，然后每个代码逻辑都是靠自己推测， 还有理解， 并没有看输出， 现在才发现在IDEA中File | Settings | Build, Execution, Deployment | Debugger | Stepping中可以将Do not step into the classes即可，当然，若是想直接在源码中添加注释，需要进行一些配置。 JDK1.8在IDEA中搭建阅读环境第一步解压系统JDK所在路径中的sc.zip 到自定义的文件中，譬如src中的source jdk-项目结构.png 第二步导入到自己的源码工程文件中 第三步修改工程文件中SDKs的Sourcepath 将sc,zip替换成图一中sc.zip解压到的文件。javafx-src.zip不动。如下图： jdk-sdks.png References JDK1.8源码分析03之idea搭建源码阅读环境 idea中搭建jdk1.8源码阅读环境","categories":[{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"配置","slug":"配置","permalink":"https://winniekun.github.io/tags/%E9%85%8D%E7%BD%AE/"}]},{"title":"2020年书单【年终汇总】","slug":"碎碎念/2020年书单【年汇总】","date":"2019-12-31T16:00:01.000Z","updated":"2021-02-04T11:48:38.112Z","comments":true,"path":"2020年书单【年汇总】/","link":"","permalink":"https://winniekun.github.io/2020%E5%B9%B4%E4%B9%A6%E5%8D%95%E3%80%90%E5%B9%B4%E6%B1%87%E6%80%BB%E3%80%91/","excerpt":"我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 摘自鶸道场 趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。","text":"我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 摘自鶸道场 趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。 书籍相关 LaTeX快速入门与提高 剑指Offer Java并发编程的艺术 Java并发编程实战 图解密码学技术 Redis设计与实现 深入分析Java Web技术内幕 深入理解JVM虚拟机 记得刚买的时候，是真的完全看不懂 现在有一些知其然了 图解HTTP 面试的时候，网络太糟糕 Mysql必知必会 高性能MySQL Linux-UNIX系统编程手册（上册） Linux-UNIX系统编程手册（下册） Java 8函数式编程 太欺负人了，我咋就不知道用各种流和optional 论文 少数决：更安全的分布式一致性算法选举机制 欺诈游戏的应用？？？ 电影、电视剧、综艺、纪录片 黑镜 岬童夷 如实陈述 挺好看的 使徒行者 刚上映的时候看过了, 然后又重新看了一遍 这种兄弟情真的是很棒棒哇!!! 反转也有 四大名捕 I、IV 现在还记得当初的版权意识有多差，当初四大名捕I一上线，我晚上就搜到了高清资源 云飞丝路天 疫情宅家，和父母一起看的 致命弯道 I、II、III、IV 握草，一部比一部恶心，有点儿反胃 谤法 人体蜈蚣I、II 握草，太尼玛恶心了 致命弯道是物理攻击的话， 那么这个是灵魂攻击 握草，太恶心了 决胜法庭 和女朋友一起看的 钢琴家 一堵墙，隔绝了人性和人性；一堵墙，囚禁住所有的理性。 彗星来的那一夜 狼溪 发现最近的口味有些重啊！！！ 时空恋旅人 能穿越真好 享受当下 饥饿站台 和女朋友一起看的 法医秦明 第一部 图个乐呗 安家 不知道为啥， 看着挺过瘾的😄 一个下午加一个晚上刷完了 感觉后面烂尾了 夫妻的世界 哇，才发现原来男女主，都已经50多了 我靠， 当悬疑剧来看的 VIP 说真的，虽然我还没有进入职场 但是，感觉韩剧拍的职场剧才是真的职场剧 国内的总感觉是在玩儿 张娜拉还是那么漂亮 一人之下III 我靠，终于更新了 感觉打斗场面很棒棒 在我心里，国番第二，罗小黑永远第一！！！ 我靠，SB吧，有些人，因为一件衣服导致整改！！！ 怎么就有那么些人见不得别人好 大理寺日志 刚开始看，感觉很不错 庆余年 之前只是觉得很搞笑，没有看，但是这几天看了精彩剪辑，发现很好看。 感觉和宋大志是一个类型的。 38师机动队 马东锡!!! 38指韩国税金征收法 老师 好 哇, 悲情结局哇 活着 韩国的丧失拍的真好 雾山五行 ORZ !!! 灵笼 感觉哈，单纯的感觉，主体思想因该是和进击的巨人差不多 好看还是好看 元龙 修仙爽文 十面埋伏 在江湖和官府的这些恩怨纠葛中，登锋履刃、冲锋陷阵的永远都是无足轻重的小人物，在既是当权者又是施暴着统治的封建王朝中，连爱情和自由都无法获得的他们，更不会有揭竿而起，拯救苍生，悬壶济世的英雄战记。有的也只不过是“天地逍遥任我游”的最后一丝慰藉。 排球少年 暖 改编自莫言的小说《白狗秋千架》 对于爱情，年轻的我们都会迫不及待的用各种方式表达炽热和真心，承诺就是其中最轻易最有表现力的一种。 也希望能够清楚在每一份承诺的重量。 功夫梦 never say never 女王的棋局 围棋少年？？？江流儿？？？ 棋魂","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"书单","slug":"书单","permalink":"https://winniekun.github.io/tags/%E4%B9%A6%E5%8D%95/"}]},{"title":"注解和反射","slug":"Java基础/注解和反射","date":"2019-12-10T10:51:29.000Z","updated":"2020-08-30T04:50:22.244Z","comments":true,"path":"注解和反射/","link":"","permalink":"https://winniekun.github.io/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/","excerpt":"注解这里主要涉及的是四个基础的元注解(meta-annotation) Java中的注解，有四个基本的元注解target Retention Documented Inherited 这四个元注解Documented和Inherited使用不多，主要为target retention两个注解","text":"注解这里主要涉及的是四个基础的元注解(meta-annotation) Java中的注解，有四个基本的元注解target Retention Documented Inherited 这四个元注解Documented和Inherited使用不多，主要为target retention两个注解 Target描述注解的使用范围(即被修饰的注解可以用在什么地方). public @interface Target { /** * Returns an array of the kinds of elements an annotation type * can be applied to. * @return an array of the kinds of elements an annotation type * can be applied to */ ElementType[] value(); } 使用的范围也就是ElementType[]中的枚举类型数据 public enum ElementType { /** Class, interface (including annotation type), or enum declaration */ TYPE, // 类、接口、枚举 /** Field declaration (includes enum constants) */ FIELD, // 成员变量 /** Method declaration */ METHOD, // 成员方法 /** Formal parameter declaration */ PARAMETER, // 方法参数 /** Constructor declaration */ CONSTRUCTOR, // 构造方法 /** Local variable declaration */ LOCAL_VARIABLE, // 局部变量 /** Annotation type declaration */ ANNOTATION_TYPE, // 注解类 /** Package declaration */ PACKAGE, // 包 /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, // 类型参数（泛型） /** * Use of a type * * @since 1.8 */ TYPE_USE } Retention描述注解保留的时间范围(即：被描述的注解在它所修饰的类中可以被保留到何时). Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略 public enum RetentionPolicy { // 源文件保留 SOURCE, // 编译期保留，默认值 CLASS, // 运行期保留，可通过反射去获取注解信息 RUNTIME } 反射正常方式: 引入需要的包类名称 —-&gt; 通过 new实例化 —-&gt; 获取实例化对象 反射: 实例化对象 —-&gt; getClass()方法 —-&gt; 得到完整的包类名称 通过反射， 使得Java具有类似动态语言的特性 反射所提供的功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的成员变量和方法 在运行时获取泛型信息 在运行时处理注解 生成动态代理 …… 反射优点和缺点优点: 可以动态创建和编译，有很大的灵活性 缺点: 慢于直接执行相同的操作 获取Class类的实例 已知某个类的实例 User user = new User(); Class&lt;? extends User&gt; aClass1 = user.getClass(); 已知具体的类 Class&lt;User&gt; aClass2 = User.class; 已知类的全名称 Class&lt;?&gt; aClass3 = Class.forName(\"com.xxx.xxx\"); 类的加载过程|—————————| |——————————| |————————————| | 类的加载 | ------&gt; | 类的链接 | -------&gt; | 类的初始化 | | Load | -----&gt; | Link | -------&gt; | Initialize | |—————————| |——————————| |————————————| 获取Class对象之后可以做写什么 创建类的对象 aClass.newInstance(); // 本质是调用了无参构造器 若是没有无参构造器，可以通过明确调用对应的构造器，然后将参数传递进去即可 aClass.getDeclaredConstrutor(Class...parameterTypes) 可以调用类中的方法 User user = (User) aClass.newInstance(); Method setName = aClass.getDeclaredMethod(\"setName\", String.class); // invoke: 激活 // (对象, \"方法的值\") setName.invoke(user, \"维坤坤\"); System.out.println(user.getName()); 操作类中的属性 //反射操作属性 User user3 = (User) aClass.newInstance(); Field name = aClass.getDeclaredField(\"name\"); // 不能操作私有属性 需要关闭安全检测 name.setAccessible(true); name.set(user3, \"孔维坤\"); System.out.println(user3.getName()); 注解和反射的实际应用编写一个注解，适用于成员方法，然后运行保留 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface AAAA { String value() default \"\"; } 通过反射获取注解中的内容 public class ReAno { @AAAA(\"我是方法注解\") public void say(int a){ System.out.println(\"wtf \" + a); } public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException { // 通过反射获取类 Class&lt;ReAno&gt; reAnoClass = ReAno.class; Method say = reAnoClass.getDeclaredMethod(\"say\", int.class); AAAA annotation = say.getAnnotation(AAAA.class); System.out.println(annotation.value()); // 输出: 我是方法注解 } } 总结通过反射获取注解的方式就是注解应用在什么范围， 就先通过反射获取对应的方法、或者成员变量，然后获取其注解即可。","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://winniekun.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"并发&I/O基本概念","slug":"Java进阶/并发/并发基本概念","date":"2019-12-06T03:13:58.000Z","updated":"2021-06-05T08:46:59.809Z","comments":true,"path":"并发基本概念/","link":"","permalink":"https://winniekun.github.io/%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"同步与异步","text":"同步与异步 同步进程和线程都是并发执行的，不同的进程之间，存在不同的相互制约关系。为了协调这种制约关系，引入了同步的概念。 举例说明：系统计算1+2×3。假设有两个进程进行计算该公式，一个是加法进程，一个是乘法进程。如果要计算正确，要先执行乘法进程，然后执行加法进程。但是因为系统的异步性（并发、虚拟、异步、共享），若是不加以制约，无法保证乘法进程在加法进程之前执行的。所以要制定一些机制去约束加法进程，让他在乘法进程完成之后运行。 同步同步也称为直接制约关系，是指一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。 互斥互斥也称为间接制约关系，当个一个进程进入临界区使用临界资源的时候，另一个进程必须等待，当占用临界资源的进程退出临界区之后，另一个进程才允许访问此临界资源 同时为了禁止两个进程同时进入临界区，同步机制因遵循一下的原则： 临界区：进程访问临界资源的代码，它同一时刻只能由一个进程执行，如java中的synchronized关键字在方法上，那临界区就是整个方法内部。而如果是使用synchronized代码块，那临界区就指的是代码块内部的区域。 空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程进入临界区 忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待 有限等待：对已经请求进入临界区的进程，应保证其在有限的时间进入临界区 让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程忙等。 经典同步问题生产者-消费者问题、读写者问题、哲学家就餐问题 异步异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。 举例说明：发短信，A发短信给B，发送给B即可，发送完之后，可以做其他的事情，短信来了，手机会提醒 阻塞与非阻塞阻塞和非阻塞是从CPU的消耗而言的。 阻塞：就是CPU停下来等待一个慢操作完成之后CPU再继续执行其他的事情 非阻塞： 在慢操作执行的时候，CPU会去执行其他的事情，等这个慢操作完成之后，CPU继续完成其后续事情 虽然表面上看非阻塞的方式可以明显的提高 CPU 的利用率，但是也带了另外一种后果就是系统的线程切换增加。增加的 CPU使用时间能不能补偿系统的切换成本需要好好评估。 以上两种概念的花式组合这里主要是和I/O相关 排列组合之后，共四种情况：同步阻塞、同步非阻塞、异步阻塞、异步非阻塞 组合方式 性能 同步阻塞 最常用的一种用法，使用也是最简单的，但是 I/O 性能一般很差，CPU 大部分在空闲状态。(BIO) 同步非阻塞 提升 I/O 性能的常用手段，就是将 I/O 的阻塞改成非阻塞方式，尤其在网络 I/O 是长连接，同时传输数据也不是很多的情况下，提升性能非常有效。这种方式通常能提升 I/O 性能，但是会增加 CPU 消耗，要考虑增加的 I/O 性能能不能补偿 CPU 的消耗，也就是系统的瓶颈是在 I/O 还是在 CPU 上。(NIO) 异步阻塞 这种方式在分布式数据库中经常用到，例如在网一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，而还有两至三份是备份记录会写到其它机器上，这些备份记录通常都是采用异步阻塞的方式写 I/O。异步阻塞对网络 I/O 能够提升效率，尤其像上面这种同时写多份相同数据的情况。 异步非阻塞 这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下使用，像集群之间的消息同步机制一般用这种 I/O 组合方式。如 Cassandra 的 Gossip 通信机制就是采用异步非阻塞的方式。它适合同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大，但是却非常频繁。这种网络 I/O 用这个方式性能能达到最高。(AIO) 虽然异步和非阻塞能够提升 I/O 的性能，但是也会带来一些额外的性能成本，例如会增加线程数量从而增加 CPU 的消耗，同时也会导致程序设计的复杂度上升。如果设计的不合理的话反而会导致性能下降。在实际设计时要根据应用场景综合评估一下。","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://winniekun.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"I/O","slug":"I-O","permalink":"https://winniekun.github.io/tags/I-O/"}]},{"title":"2019的最后100天","slug":"碎碎念/2019的最后100天","date":"2019-10-01T08:53:43.000Z","updated":"2020-08-30T04:50:22.258Z","comments":true,"path":"2019的最后100天/","link":"","permalink":"https://winniekun.github.io/2019%E7%9A%84%E6%9C%80%E5%90%8E100%E5%A4%A9/","excerpt":"前言时间过得可真快啊，去年的这个时候还在备考，刷各种题，现在已经在实验室做自己的事情了，又是最后的100天，希望自己在2019年的最后100天拼一拼，努力完成自己的任务。","text":"前言时间过得可真快啊，去年的这个时候还在备考，刷各种题，现在已经在实验室做自己的事情了，又是最后的100天，希望自己在2019年的最后100天拼一拼，努力完成自己的任务。 计划 Java基础 是的，我又开始看Java了，因为发现自己的对Python的理解貌似止步不前了， 那就换个语言好好学学，或许，会有更深刻的理解呢～～～ Spring大家族实现一个框架的demo Spring是一个微型框架… Flask源码解读 自己其实一直想把flask的源码理解了，但是苦于自己懒癌，以及看的时候经常会忘了自己该去看哪儿了。 自己阅读源码的方式还有很多问题 Python进阶 并发最起码要刷完吧，要不然白费了自己去年苦心整理的os了 迭代器、生成器、新特性 数据结构树和图 之前的都是理论上明白了， 现在需要去自己手动实现了，虽然去年不知道手写写废了多少支笔 LeetCode 100题 O(∩_∩)O哈哈哈~","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"冒泡排序","slug":"算法/排序/冒泡排序","date":"2019-09-30T14:47:49.000Z","updated":"2020-08-30T04:50:22.261Z","comments":true,"path":"冒泡排序/","link":"","permalink":"https://winniekun.github.io/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","excerpt":"冒泡排序","text":"冒泡排序 冒泡排序每次检查相邻两个元素，以升序为例， 如果前面的元素大于后面的元素，就将相邻两个元素交换。当没有相邻的元素需要交换时，排序就完成了。 时间复杂度：$O(n^2)$ 冒泡排序是稳定排序 伪代码$ \\begin{array}{ll} 1 &amp; \\textbf{Input. } \\text{An array } A \\text{ consisting of }n\\text{ elements.} \\newline 2 &amp; \\textbf{Output. } A\\text{ will be sorted in nondecreasing order stably.} \\newline 3 &amp; \\textbf{Method. } \\newline 4 &amp; flag\\gets True \\newline 5 &amp; \\textbf{while }flag\\newline 6 &amp; \\qquad flag\\gets False\\newline 7 &amp; \\qquad\\textbf{for }i\\gets1\\textbf{ to }n-1\\newline 8 &amp; \\qquad\\qquad\\textbf{if }A[i] &gt;A[i + 1]\\newline 9 &amp; \\qquad\\qquad\\qquad flag\\gets True\\newline 10 &amp; \\qquad\\qquad\\qquad \\text{Swap } A[i]\\text{ and }A[i + 1] \\end{array}$ Java实现public void bubbleSorted(int[] nums){ boolean flag = true; while(flag){ flag = false; for(int i = 0; i&lt; nums.length-1; i++){ if(nums[i] &gt; nums[i+1]){ int temp = nums[i]; nums[i] = nums[i+1]; nums[i+1] = temp; flag = true; } } } }","categories":[{"name":"排序","slug":"排序","permalink":"https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"交换","slug":"交换","permalink":"https://winniekun.github.io/tags/%E4%BA%A4%E6%8D%A2/"}]},{"title":"暑期生活","slug":"碎碎念/暑期生活","date":"2019-08-11T08:53:28.000Z","updated":"2020-09-06T11:13:23.491Z","comments":true,"path":"暑期生活/","link":"","permalink":"https://winniekun.github.io/%E6%9A%91%E6%9C%9F%E7%94%9F%E6%B4%BB/","excerpt":"前言今年暑假又提前结束了，还有很多想去做的事情还没有完成，譬如：整理笔记、出去旅游等。这次暑假应该是自己目前回老家最多次的一回了，而且也是自己第一次一个人回老家。挺好，路线熟悉之后，以后就能自己办事情了，不用再找别人代办了。","text":"前言今年暑假又提前结束了，还有很多想去做的事情还没有完成，譬如：整理笔记、出去旅游等。这次暑假应该是自己目前回老家最多次的一回了，而且也是自己第一次一个人回老家。挺好，路线熟悉之后，以后就能自己办事情了，不用再找别人代办了。 老家基本每年暑假老妈都会带着我和弟弟回老家一趟，之前很期待回老家，现在也没有那种每天倒计时回老家的那种期待感了，鬼知道什么情况。。。一直感觉老妈带我们回老家就两个目的：\\1. 多陪陪爷爷奶奶 外公外婆\\2. 体验生活，在老家种地真的不容易当然今年也不例外，因为自己大了，回去之后，肯定是要尽可能的多去帮帮家人做一些农活。而老弟，可能就是让他去体验生活吧，本来是带有教育目的的，但是感觉他玩儿的很开心哇。。。以下是他开心的体验生活的照片。 《暑期生活》 《暑期生活》 自己还记得和老弟一样大的时候，帮爷爷去掐棉花枝，免得棉花长得太高，从下午3点多一直干到6点多，那次把我累惨了，又累又渴，干完活之后，还要摘一袋西瓜回家，还好能骑三轮车，每个西瓜差不多就和这个那么大。不过我记得是圆的，现在种的细长的，一个个长得跟个冬瓜一样。。。 《暑期生活》 今年卸西瓜、装西瓜很累，真的累，特别累，因为天热，所以只能在凌晨5点多，或者下午5点多再下地去卸西瓜，当然也不是每次都这样，因为西瓜的价钱不稳定，所以当打听到西瓜的价钱涨了，就会立马下地卸瓜，装好之后拉去卖掉。记得有一次下午5点多卸，还下着小雨，后面刚卸完，就突然下来大暴雨。。。还好外婆及时送来了雨伞，要不然全部都要淋成落汤鸡。 杭州本科学校清人最后一天，就拎着行李回杭州了。虽然已经寄走了两大包东西了，但是我的大花箱还是塞得满满的，贼沉，早知道当初就不乱买那么多东西。 《暑期生活》 回杭州之后，天天在家待着，本来计划找个兼职做做的，结果都不要！都不要！都不要!!!很难受，不过自己的厨艺突然开窍了，可能是和沈总混久了的原因，反正基本每天晚饭都是我来做。图文不相关，就是单纯的想放个照片 《暑期生活》 西安革命尚未结束，同志仍需加油！！！ 《暑期生活》","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"快速排序","slug":"算法/排序/快速排序","date":"2019-08-02T01:20:14.000Z","updated":"2020-08-30T04:50:22.261Z","comments":true,"path":"快速排序/","link":"","permalink":"https://winniekun.github.io/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","excerpt":"简介","text":"简介 时间复杂度：$O(nlogn)$ 快速排序是不稳定算法 步骤分为三个过程： 将集合划分为两部分（保证大小关系即可，partition函数） 递归的在两个划分好的部分分别进行快排 不用合并，因为此时集合已经完全有序 Java实现public static void quickSort(int[] data, int low, int high) throws Exception { if(low == high){ return; } if(low &lt; high){ int partition = partition(data, data.length, low, high); quickSort(data, low, partition-1); quickSort(data, partition+1, high); } } private static int partition(int data[], int length, int low, int high) throws Exception { if(data == null || data.length&lt;= 0 || low &lt; 0 || high &gt;= length ){ throw new Exception(\"Invalid Parameters\"); } // 默认选择首位作为枢轴 int position = data[low]; while (low &lt; high){ while (low&lt; high &amp;&amp; data[high] &gt;= position){ high--; } data[low] = data[high]; while (low&lt;high &amp;&amp; data[low] &lt;= position){ low++; } data[high] = data[low]; } data[low] = position; return low; } References 快速排序 算法第四版","categories":[{"name":"排序","slug":"排序","permalink":"https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"交换","slug":"交换","permalink":"https://winniekun.github.io/tags/%E4%BA%A4%E6%8D%A2/"}]},{"title":"BST详解","slug":"数据结构/BST详解","date":"2019-07-28T02:24:44.000Z","updated":"2020-08-30T04:50:22.254Z","comments":true,"path":"BST详解/","link":"","permalink":"https://winniekun.github.io/BST%E8%AF%A6%E8%A7%A3/","excerpt":"简介","text":"简介 BST有很多的名字，如二叉排序树、二叉搜索树、Binary Sort Tree、Binary Search Tree、BST其具有如下性质： 定义空树是一个BST 左子树所有结点的值均小于根结点的值 右子树所有结点的值均大于根结点的值 左右子树都是BST(递归定义) 中序遍历序列为升序 查找假设查找关键字key 若根结点的关键字值等于key，成功 若key小于根结点的关键字，递归查找左子树 若key大于根结点的关键字，递归查找右子树 若子树为空，查找不成功 插入按照元素的大小进行查找，与查找类似。然后插入到对应的位置（插入到当前BST的叶子节点） 删除假设删除节点p，其父节点为f，分如下3种情况进行讨论： p是叶子节点，直接删除 p只有左子树left(右子树right)，直接用p.left(p.right)替换p p既有左子树left，又有右子树right，找到右子树的最小节点rightMin(找到left的最大节点leftMax)，用rightMin(leftMax)的值替换p的值，再根据以上两种情况删除rightMin(leftMax) P是叶子节点 bst_删除_情况1.png P只有左子树或右子树 bst_删除_情况2.png P既有左子树又有右子树 bst_删除_情况3.png 面试汇总给定一个BST的节点，寻找以当前节点为根节点的最值private static TreeNode getLastEntry(TreeNode node) { while (node.right != null) { node = node.right; } return node; } private static TreeNode getFirstEntry(TreeNode node) { while (node.left != null) { node = node.left; } return node; } 给定节点t，后继(前驱)节点 t为最值节点 无前驱或后继 当t有右子树 直接寻找其右子树最小节点（左子树最大节点）即可 t无右子树 向上回溯，找到第一个孩子是左子树孩子（右子树孩子）的父亲p 向上回溯，找到第一个关键字比孩子大（小）的父亲p（利用BST特性） LintCode448. Inorder Successor in BST使用指针代替路径栈，将空间复杂度降到O(1) 栈是自底向上寻找结果，指针为自顶向下寻找结果 public static TreeNode inorderSuccessor(TreeNode root, TreeNode p) { if (root == null) { return null; } // 情况0: 本身就是最值 if (getLastEntry(root) == p) { return null; } // 情况1: 有右子树 if (p.right != null) { return getFirstEntry(p.right); } // 情况2: 没有右子树 TreeNode parent = root; // temp指针代替栈 TreeNode temp = root; while (parent != null) { if (parent == p) { break; } else if (parent.val &gt; p.val) { temp = parent; parent = parent.left; } else { parent = parent.right; } } return temp; } private static TreeNode getLastEntry(TreeNode node) { while (node.right != null) { node = node.right; } return node; } private static TreeNode getFirstEntry(TreeNode node) { while (node.left != null) { node = node.left; } return node; } 相关题目会持续添加 References TreeMapSourceAnalysis","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://winniekun.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"BST","slug":"BST","permalink":"https://winniekun.github.io/tags/BST/"}]},{"title":"大四下学期总结---各奔东西","slug":"总结/大四下学期总结-各奔东西","date":"2019-07-26T08:53:13.000Z","updated":"2020-08-30T04:50:22.253Z","comments":true,"path":"大四下学期总结-各奔东西/","link":"","permalink":"https://winniekun.github.io/%E5%A4%A7%E5%9B%9B%E4%B8%8B%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93-%E5%90%84%E5%A5%94%E4%B8%9C%E8%A5%BF/","excerpt":"前言本科毕业了，然后例行的一学期一总结一直拖着没有写，其实自己也不知道该怎么去写，写些啥，然后就这么拖着拖到了7月底。","text":"前言本科毕业了，然后例行的一学期一总结一直拖着没有写，其实自己也不知道该怎么去写，写些啥，然后就这么拖着拖到了7月底。 干了些啥复试最后一学期如果按照到校的时间作为开学的第一天的话，那么我的开学时间有些早，然后就是慢慢悠悠的准备复试，关于考研的整个过程，个人不想再多写些啥子，总之，经历了就行。确定有书读之后，就直接去找了工作干了。工作实习工作是从4月中旬开始，期间因为公司统一使用的是Winidows系统，所以自己又换了个系统盘，然后一步一步按照公司的文档配置环境，完全是瞎子摸象，自己慢慢的去摸索，因为管的不是很严，所以在空余时间深化学习了git，尝试去看了flask的源码，本来计划干到6月份，5月初的时候，何老师开始催促我们要抓紧做毕设了，当初自己完全没有开始做，只是去了解了自己觉得需要用到的技术，后面发现事情开始多了起来，如果自己还不开始准备的话，就要延迟毕业了。然后果断和leader提出了辞职，开始一心准备自己的毕业设计。赶毕设整个毕设如果算全部都在做的时间的话，应该有个240个小时左右，主要是论文，现在还记得被论文支配恐惧，一共给何老师发了6个版本，第一个版本格式乱的没办法看，第二-四版本不停的按照要求改内容，第五版本，老师说她感觉论文写的太像一个文档，然后最后我又开始大改，期间还通宵了三次，终于在截止论文提交当天完成了要求。对于个人的毕业设计，我觉得自己核心的内容写的不是很好，反而Coookies池和IpProxy池做的很好答辩6月初开始的毕业答辩，具体几号忘了。我的号比较靠后，自己听了一些前面的同学的答辩，感觉一般，自己期间准备了下自己可能会被问到的问题，然后就和女朋友还有基友在那儿吹壳子了。以下为自己和沈总互拍的答辩照片 《大四下学期总结 --- 各奔东西》 《大四下学期总结 --- 各奔东西》 我现在还记得自己答辩完，台下一句话都没有，老师了等了近一分钟才开始问问题….. 可能是自己做的东西，我们那组答辩老师涉及的不多吧。最后问了几个比较鶸的问题散伙饭先是班级聚餐，在学校外面的烧烤店，感觉那次是我目前喝酒喝最多的一次了，但是还是没有醉(￣▽￣”)接下来是我和沈总一起请了何老师吃了一顿饭，虽然说是请，但是现在我还没有把饭前转给沈总(・ω・)，何老师还和我们说，我们答辩小组原定的争优答辩的那个同学弃权了，其他老师想让我去争优，然后何老师了解我毕设的具体情况，帮我拒绝了，真是虚惊一场呢。然后领毕业证的时候，全寝室一起吃了一顿火锅。最后，也就是22号那天吧，因为一些原因，自己23号才回杭，然后宿管大伯通知的是23前所有人要搬离寝室，和大伯说明情况之后，自己待在寝室亲眼看到了整个班级的同学一个一个走了，那个时候才感觉到原来本科真的毕业了。那天晚上整个人都不好了，全寝室楼出奇的安静，很渗人。 结尾时间真的挺快的，回想自己本科的生活，用一句话来概括的话应该就是享受生活、随时养老了，贼喜欢大二大三每次做项目发钱了，拉着沈总去正门享受生活，改善伙食的日子，虽然基本每次都是去吃火锅，然后吃完发誓下次坚决不再吃火锅。","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://winniekun.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"选择排序","slug":"算法/排序/选择排序","date":"2019-05-30T12:11:52.000Z","updated":"2020-08-30T04:50:22.261Z","comments":true,"path":"选择排序/","link":"","permalink":"https://winniekun.github.io/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","excerpt":"选择排序","text":"选择排序 每次找出第$i$小的元素（$Ai..n$中最小的元素），然后将这个元素和数组中第$i$个元素交换位置 时间复杂度： $O(n^2)$ 因为交换操作的存在，所以选择排序是不稳定排序 伪代码$ \\begin{array}{ll} 1 &amp; \\textbf{Input. } \\text{An array } A \\text{ consisting of }n\\text{ elements.} \\newline 2 &amp; \\textbf{Output. } A\\text{ will be sorted in nondecreasing order.} \\newline 3 &amp; \\textbf{Method. } \\newline 4 &amp; \\textbf{for } i\\gets 1\\textbf{ to }n-1 \\newline 5 &amp; \\qquad ith\\gets i\\newline 6 &amp; \\qquad \\textbf{for }j\\gets i+1\\textbf{ to }n\\newline 7 &amp; \\qquad\\qquad\\textbf{if }A[j] &lt; A[ith]\\newline 8 &amp; \\qquad\\qquad\\qquad ith\\gets j\\newline 9 &amp; \\qquad \\text{swap }A[i]\\text{ and }A[ith]\\newline \\end{array} $ Java实现public void selectionSort(int[] nums){ for(int i = 0; i&lt;nums.length; i++){ int ith = i; // 记录当前需要选取的第i个最小元素 for(int j = i+1; j&lt;nums.length; j++){ if(nums[j] &lt; nums[ith]){ ith = j; } } int temp = nums[i]; nums[i] = nums[ith]; nums[ith] = temp; } } over","categories":[{"name":"排序","slug":"排序","permalink":"https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"选择","slug":"选择","permalink":"https://winniekun.github.io/tags/%E9%80%89%E6%8B%A9/"}]},{"title":"B树系列","slug":"数据结构/B树系列","date":"2019-05-17T11:25:36.000Z","updated":"2020-08-30T04:50:22.254Z","comments":true,"path":"B树系列/","link":"","permalink":"https://winniekun.github.io/B%E6%A0%91%E7%B3%BB%E5%88%97/","excerpt":"B树共分为两个部分， 首先是B的性质、B树的建立、插入和删除，之后是B+树性质、以及相比于B树，区别在哪儿","text":"B树共分为两个部分， 首先是B的性质、B树的建立、插入和删除，之后是B+树性质、以及相比于B树，区别在哪儿 B树的性质B树又称为多路平衡查找树，B树中所有结点的孩子结点数的最大值称为B树的阶。通常使用m表示。 一颗m阶B树或为空，或为满足如下特性的m叉树。 树中每个节点至多有m颗子树（m-1关键字） 若是根节点不是终端节点，至少有两颗子树 除根以外的所有非叶子节点至少 $\\lceil m/2 \\rceil$ 颗子树（$\\lceil m/2 \\rceil $ -1 关键字） 所有的非叶子结点的结构如下： 所有叶子节点都出现在同一层次上，并且不带任何信息 b树示例.png B树的高度$ n$ : 关键字的个数 $h \\le log_\\lceil m/2 \\rceil ((n+1)/2) + 1 $ 具体的证明，百度。。。 B树的查找因为其是有序的，其和二叉搜索树的查找类似，只不过不同的是每个节点其有多个关键字的有序表，然后根据该节点的子树做多路分支决定。 基本步骤 在B树中找到节点 在节点内找到关键字 由于B树通常是存储在磁盘上的， 所有第一次是在磁盘上进行， 之后第二次在内存中运行，即在找到目标节点之后，将其储存内存之后， 然后使用顺序查找或者折半查找，查找等于K的关键字。 B树的插入、B树的删除可根据参考书和可视化网站进行理解 B树每个节点的关键字个数范围 $[\\lceil m/2 \\rceil -1 , m-1]$ 其中删除的操作共分为两种情况，并且这两种情况又有细分 删除关键字k为非终端节点（终端节点 != 叶子节点）其实和AVL的删除是如出一辙的 小于k的子树中关键字的个数 &gt; $\\lceil m/2 \\rceil -1$ 则找出k的前驱k’替代k， 再递归的删除k‘ 大于k的子树中关键字的个数 &gt; $\\lceil m/2 \\rceil -1$ 则找出k的后继k’替代k， 再递归的删除k’ k的左右子树的关键字个数 均为 $\\lceil m/2 \\rceil-1$ 则进行合并两个子树，然后删除k即可 删除关键字k为终端节点 如果k所在的节点关键字个数&gt; $\\lceil m/2 \\rceil -1$ 直接删除 k所在的节点关键字个数=$\\lceil m/2 \\rceil -1$ 兄弟够借 兄弟不够借 B+树B+树的性质B+树是应数据库的所需， 所出现的一种B树的变形 一颗m阶的B+树需满足下列条件 每个分支节点最多有m颗子树 非叶子的根节点至少有两颗子树，其他的分支节点至少有$\\lceil m/2 \\rceil $ 颗子树 节点的子树个数和关键字个数相等 所有叶子节点包含所有关键字及指向相应记录的指针，并且叶子节点将关键字按大小顺序排列，并且相邻叶节点按大小顺序相互链接起来 所有分支节点中仅包含它的各个子节点中关键字的最大值和指向该子树的指针 B+树结构示意图 B_树结构示意图.png B+树的性质II：才发现，原来各种资料上关于B+树的性质，不经相同….. 以下为维基百科的定义 和王道的定义区别不大，但是分支节点关键字个数比子树个数小1， 也就是和B的节点定义一样。 1）B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。 2）B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。 3） m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。 4）内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。 5）每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。 B+树结构示意图II下图为一个三阶B+树的示意图 B_树结构示意图.png B和B+区别 B+ trees don’t store data pointer in interior nodes, they are ONLY stored in leaf nodes. This is not optional as in B-Tree. This means that interior nodes can fit more keys on block of memory and thus fan out better. The leaf nodes of B+ trees are linked, so doing a linear scan of all keys will requires just one pass through all the leaf nodes. A B tree, on the other hand, would require a traversal of every level in the tree. This property can be utilized for efficient search as well, since data is stored only in leafs. B+内部节点不存储数据，只有叶子节点存储信息，B树没有，这也就意味着，B+树比B树的内部节点能存储更多的信息 B+树叶节点的数据是链接的，可做一次线性扫描获取所有的数据， 但是B树就需要遍历整个B树 查找、插入、删除B+和B树相同，但是对于查找而言，如果非叶子节点上关键字值等于给定值时，并不终止，而是继续查找，直到找到叶子节点上的该关键字为止。所以，B+树的查找，无论成功与否，每次都是一条从根节点到叶子节点的路径。 reference 王道数据结构 B+ tree B树和B+树的插入、删除图文详解 Memory locality &amp; the magic of B-Trees!","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://winniekun.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"B树","slug":"B树","permalink":"https://winniekun.github.io/tags/B%E6%A0%91/"}]},{"title":"大四上学期总结---慢煨慢炖","slug":"总结/大四上学期总结-慢煨慢炖","date":"2019-04-22T16:00:00.000Z","updated":"2020-08-30T04:50:22.253Z","comments":true,"path":"大四上学期总结-慢煨慢炖/","link":"","permalink":"https://winniekun.github.io/%E5%A4%A7%E5%9B%9B%E4%B8%8A%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93-%E6%85%A2%E7%85%A8%E6%85%A2%E7%82%96/","excerpt":"前言这学期都已经过半了，因为开学一直有事情，就一直拖到现在。","text":"前言这学期都已经过半了，因为开学一直有事情，就一直拖到现在。 总结 学习上上学期基本就是三点一线的生活，寝室 &lt;—-&gt; 图书馆 &lt;—-&gt; 食堂其实没有啥好总结的，感觉的话，自己的计算机基础的确是深化了，那几个月的确 很难受，周围的朋友实习的去实习了，保研的保研了，自己一直还没有确定下来。不过好处还是有的，自己深刻的体会到了团队的重要性，之前一直认为任何时候， 自己一个人终究好比过一堆人一起。不管是从效率上来讲还是从技术上来讲，但是 经过上学期的备考，感觉到了当大家共同为一个目标努力的时候，那种效率和自控 力是很高的。 技术上大概有进半年没有撸过代码吧，博客也没有更新过了，编码能力讲真是有一定的退步的，但是目前的感觉是比之之前的学习速度快了（在脑子保持清醒的情况下），自己现在不是很热衷于去了解和掌握一些框架的使用，反而对一些的算法的研究比较感兴趣了，虽然看的云里雾里的。自己在极客上买了数据结构与算法之美这个课程，觉得作者的理解很棒，并不是理论层面的，而是结合了真正的实际开发中的各个情况，希望自己有朝一日能有如此见解 生活上有时候选择比努力更重要没有什么所谓的happily ever after","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://winniekun.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"final、static、this、super关键字总结","slug":"Java基础/final、static、this、super关键字总结","date":"2019-04-10T01:47:33.000Z","updated":"2020-08-30T04:50:22.243Z","comments":true,"path":"final、static、this、super关键字总结/","link":"","permalink":"https://winniekun.github.io/final%E3%80%81static%E3%80%81this%E3%80%81super%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/","excerpt":"final static this super关键字总结final 关键字主要用于三个地方：类、方法、变量 类：用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。 方法： 方法锁定： 防止任何继承了类修改该方法 效率 变量： 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。","text":"final static this super关键字总结final 关键字主要用于三个地方：类、方法、变量 类：用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。 方法： 方法锁定： 防止任何继承了类修改该方法 效率 变量： 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 static 关键字主要为四个地方放： 修饰成员变量和成员方法， 静态代码块、静态内部类、静态导包 修饰静态成员变量和成员方法 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名() 静态代码块 静态代码块定义在类中方法外, ==静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.== 静态内部类 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着： 它的创建是不需要依赖外围类的创建。 它不能使用任何外围类的非static成员变量和方法。 静态导包 mport static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。 ```javaimport static com.train.keywords.Test.*; public class FinalForKnow { // final 用于 类 方法 变量 private static final String a = \"1123\"; public static void main(String[] args) { System.out.println(a); System.out.println(name); System.out.println(age); // 1123 // 维坤坤 // 0 } } public class Test { public static int age; public static String name = “维坤坤”; } ### this 关键字 引用类的当前实例 ### super 关键字 从子类访问父类的方法和变量 ```java public class Super { protected int number; protected showNumber() { System.out.println(\"number = \" + number); } } public class Sub extends Super { void bar() { super.number = 10; super.showNumber(); } } 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。 this、super不能用在static方法中。","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://winniekun.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"插入排序","slug":"算法/排序/插入排序","date":"2019-03-11T09:35:45.000Z","updated":"2020-08-30T04:50:22.261Z","comments":true,"path":"插入排序/","link":"","permalink":"https://winniekun.github.io/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","excerpt":"插入排序","text":"插入排序 前言插入排序的思想很直观，其在性能上不如一些分治的排序策略，例如快速排序，归并排序。插入排序是一种基于比较的排序算法。 算法思想其类似于打牌的抓牌环节，抓到牌后都会按照点数插入到合适的位置，核心思想是保证一个已排序区间，剩下的未排序区间依次与前面的已排序区间进行比较，插入到对应的位置。 插入有关于插入，若是序列是使用数组进行存储，则可以从右向左扫描已排序数组，因为这样可以在性能上有所优化。因为对于数组的插入，其不像链表一样，只需要断链，然后链接，其需要移动大量的元素，才能够进行插入，若是从左向右，譬如数组的长度为n，在位置i插入，则需要扫描i次，然后移动n-i+1次，最后插入数据。若是从右向左，最多需要i次扫描，然后可以边扫描边右移动 基本插入算法 复杂度:O(n^2) 比较次数（查找）: O(n^2) 移动次数（插入后导致的移动）: O(n^2)def insertSort(arraylist): arrayLen = len(arraylist) for i in range(1, arrayLen): current = arraylist[i] j = i - 1 while j &gt; 0 and arraylist[j] &lt; current: arraylist[j+1] = arraylist[j] j = j - 1 arraylist[j+1] = current return arraylist 优化一： 使用鶸二分查找因为已经确定了前面的排序区间是有序的，所以可以直接使用二分查找来确定插入的位置，这样查找的时间就得到了优化 复杂度: O(n^2) 比较次数: O(nlgn) 移动次数: O(n^2)```pythondef binarySearch(arraylist, key): low = 0 high = len(arraylist) while low &lt; high: mid = (log + hig)//2 if arraylist[mid] == key: return mid elif arraylist[mid] &gt; key: high = mid else: low = mid + 1 return low def insertSort(arraylist): arrayLen = len(arraylist) for i in range(1, arrayLen): current = arraylist[i] position = binarySearch(arraylist[:i], key) for i in range(i, position, -1): arraylist[i] = arraylist[i-1] arraylist[position] = current return arraylist ## 优化二： 为了优化而优化的链表 使用链表之后，改变其数据结构，可以优化插入的时间，由最初的O(n)优化到了O(1) + 复杂度: O(n^2) + 比较次数: O(n^2) + 移动次数: O(1) ```python def insert(arrayList, next, i): j = -1 # print(\"当前j为{}, next[j]={}，arrayList[next[j]]={} arrayList[i]={}\".format(j, next[j], arrayList[next[j]], arrayList[i])) while next[j] != -1 and arrayList[next[j]] &lt; arrayList[i]: j = next[j] # print(\"目前j={}\".format(j)) next[j], next[i] = i, next[j] # print(\"交换后的next[j]={}, next[i]={} \\n\".format(next[j], next[i])) def reorder(arrayList, next): i = -1 ys = [] while next[i] != -1: ys.append(arrayList[next[i]]) i = next[i] return ys def insertSortIII(arrayList): arrayLen = len(arrayList) next = [-1]*(arrayLen+1) for i in range(arrayLen): insert(arrayList, next, i) return reorder(arrayList, next) 优化三： 终极进化之二叉搜索树对于以上的优化，只能在插入和查找之中二选一的进行优化。单独提高其中一个仍会使插入算法保持在O(n^2)中，使用二分查找能够将查找次数降到最低—-O(lgN),对于插入，为了能实现常数时间的插入，必定需要改变其数据结构。二叉搜索树刚好满足以上的所有的需求，但是对于这个，应该不算是严格意义的插入排序了，应是更宽泛的定位—-基于比较的排序。 第一，其本身定义就支持二分查找。 同时查找到对应的值之后，即可插入，所以插入的时间为常数项O(1)。 对于其频繁的插入删除导致的性能降低，目前的排序涉及不多 总结 复杂度: O(nlgn) 移动次数: O(1) 比较次数 O(lgn) 实现首先将数据构造为二叉搜索树，之后再进行中序遍历即可。 class TreeNode: def __init__(self, data): self.data = data self.leftChild = None self.rightChild = None def insert(self, newData): \"\"\" 插入数据 # edage case: 若是value相同如何解决 Word天 :param newData: :return: \"\"\" if newData == self.data: return False elif newData &lt; self.data: if self.leftChild == None: self.leftChild = TreeNode(newData) else: self.leftChild.insert(newData) else: if self.rightChild == None: self.rightChild = TreeNode(newData) else: self.rightChild.insert(newData) # 以下的前中后遍历均为递归的遍历 def preOrder(self): \"\"\" 前序遍历 根左右 :return: \"\"\" print(self.data) if self.leftChild: self.leftChild.preOrder() else: self.rightChild.preOrder() def inOrder(self): \"\"\" 中序遍历 左根右 :return: \"\"\" if self.leftChild: self.leftChild.inOrder() print(self.data) if self.rightChild: self.rightChild.inOrder() References 算法新解 算法第四版","categories":[{"name":"排序","slug":"排序","permalink":"https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"插入","slug":"插入","permalink":"https://winniekun.github.io/tags/%E6%8F%92%E5%85%A5/"}]},{"title":"泛型","slug":"Java基础/泛型","date":"2019-03-10T23:53:55.000Z","updated":"2021-06-03T13:14:19.545Z","comments":true,"path":"泛型/","link":"","permalink":"https://winniekun.github.io/%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"序在Java中一直强调数据类型的概念，其自身有8种基础的数据类型，同时我们自定义的类，也可以理解为自定义的数据类型。我们熟知的容器类，也是基于泛型实现的。这样才实现了一个容器类，适用于各种各样的数据类型。 通过泛型，使得类、接口、方法能够适用于非常广泛的数据类型，使得具体的代码能够和操作的具体的数据类型不再强行绑定到一起。同一套代码能够适用于多种数据类型。从而达到复用代码、降低耦合度、提高代码的可读性的目的。 优点 避免类型转换 // 未使用泛型 List list = new ArrayList(); list.add(\"hello\"); String s = (String) list.get(0); // 使用泛型 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"hello\"); String s = list.get(0); // 不需要进行类型转换 编译时强类型检测 泛型要求在声明时指定实际数据类型，Java 编译器在编译时会对泛型代码做强类型检查，并在代码违反类型安全时发出告警。早发现，早治理，把隐患扼杀于摇篮，在编译时发现并修复错误所付出的代价远比在运行时小。 泛型编程可实现通用算法 通过使用泛型，可以实现通用算法，这些算法可以处理不同类型的集合，可以自定义，并且类型安全且易于阅读。 泛型类型泛型类型是被参数化的类或接口 泛型类class name&lt;T1, T2, ... Tn&gt;{} 一般将泛型中的类名称为原型，而将 &lt;&gt; 指定的参数称为类型参数。 单类型参数（T）public class SingleInfo&lt;T&gt; { private T value; public T getValue() { return value; } public void setValue(T value) { this.value = value; } @Override public String toString() { return \"SingleInfo{\" + \"value=\" + value + '}'; } } 多类型参数（K，V）public class MultiInfo&lt;K, V&gt; { private K key; private V value; public MultiInfo(K key, V value) { this.key = key; this.value = value; } @Override public String toString() { return \"MultiInfo{\" + \"key=\" + key + \", value=\" + value + '}'; } 泛型类的嵌套MultiInfo&lt;Integer, MultiInfo&lt;Integer, String&gt;&gt; multi = new MultiInfo&lt;&gt;(1, new MultiInfo&lt;&gt;(1,\"32\")); System.out.println(multi); // MultiInfo{key=1, value=MultiInfo{key=1, value=32}} 泛型接口public interface Content&lt;T&gt; { T text(); } 实现接口的子类型声明具体的类型public class ImplInterface implements MyInterface&lt;Integer&gt; { private int a = 100; public ImplInterface(int a) { this.a = a; } @Override public Integer getT() { return a; } } 实现接口的子类型不声明具体类型public class NoImplInterface&lt;T&gt; implements MyInterface&lt;T&gt; { private T text; public NoImplInterface(T text) { this.text = text; } @Override public T getT() { return text; } } 泛型方法泛型方法是引入其自己的类型参数的方法。泛型方法可以是普通方法、静态方法以及构造方法。 泛型方法语法形式如下： public &lt;T&gt; T func(T obj) {} // 类型变量放在修饰符 (这里是 public static ) 的后面 , 返回类型的前面 是否拥有泛型方法，与其所在的类是否是泛型没有关系。 public class GenericsMethodDemo01 { public static &lt;T&gt; void printClass(T obj) { System.out.println(obj.getClass().toString()); } public static void main(String[] args) { printClass(\"abc\"); printClass(10); } } // Output: // class java.lang.String // class java.lang.Integer 泛型方法中也可以使用可变参数列表 public class GenericVarargsMethodDemo { public static &lt;T&gt; List&lt;T&gt; makeList(T... args) { List&lt;T&gt; result = new ArrayList&lt;T&gt;(); Collections.addAll(result, args); return result; } public static void main(String[] args) { List&lt;String&gt; ls = makeList(\"A\"); System.out.println(ls); ls = makeList(\"A\", \"B\", \"C\"); System.out.println(ls); } } // Output: // [A] // [A, B, C] 原理上述的定义各种泛型参数具体什么类嘞，其实就是Object。对于Java文件，在被使用之前需要经过编译、加载到JVM中两个阶段。编译阶段，编译器会把Java文件转换为.class文件。对于泛型，在编译阶段就会将泛型代码转换为普通的非泛型代码。使用javap也无法直接看到，因为在字节码里面也是看不到泛型的，因为已经被擦除了。将类型参数擦除之后，会使用Object进行替代以及必要的强制类型转换。然后Java虚拟机在执行过程中，已经不知道泛型的事情了，在其眼里就是普通的类。 类型擦除==Java中的泛型基本上都是在编译器这个层次来实现的。== Java 语言引入泛型是为了在编译时提供更严格的类型检查，并支持泛型编程。不同于 C++ 的模板机制，Java 泛型是使用类型擦除来实现的，使用泛型时，任何具体的类型信息都被擦除了。 ==Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况== 类型擦除做了以下工作： 把泛型中的所有类型参数替换为 Object，如果指定类型边界，则使用类型边界来替换。因此，生成的字节码仅包含普通的类，接口和方法。 擦除出现的类型声明，即去掉 &lt;&gt; 的内容。比如 T get() 方法声明就变成了 Object get() ；List 就变成了 List。如有必要，插入类型转换以保持类型安全。 生成桥接方法以保留扩展泛型类型中的多态性。类型擦除确保不为参数化类型创建新类；因此，泛型不会产生运行时开销。 示例： public class GenericsErasureTypeDemo { public static void main(String[] args) { List&lt;Object&gt; list1 = new ArrayList&lt;Object&gt;(); List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); System.out.println(list1.getClass()); System.out.println(list2.getClass()); } } // Output: // class java.util.ArrayList // class java.util.ArrayList 泛型和继承泛型不能用于显式地引用运行时类型的操作之中，例如：转型、instanceof 操作和 new 表达式。因为所有关于参数的类型信息都丢失了。 泛型无法向上转型 向上转型是指用子类实例去初始化父类，这是面向对象中多态的重要表现。 这是因为，泛型类并没有自己独有的 Class 类对象。比如：并不存在 List.class 或是 List.class，Java 编译器会将二者都视为 List.class。 类型边界有时您可能希望限制可在参数化类型中用作类型参数的类型。类型边界可以对泛型的类型参数设置限制条件。例如，对数字进行操作的方法可能只想接受 Number 或其子类的实例。 要声明有界类型参数，请列出类型参数的名称，然后是 extends 关键字，后跟其限制类或接口。 类型边界的语法形式如下： &lt;T extends XXX&gt; 类型通配符类型通配符一般是使用 ? 代替具体的类型参数。例如 List 在逻辑上是 List ，List 等所有 List&lt;具体类型实参&gt; 的父类 上界通配符可以使用上界通配符来缩小类型参数的类型范围。 它的语法形式为：&lt;? extends Number&gt; public class GenericsUpperBoundedWildcardDemo { public static double sumOfList(List&lt;? extends Number&gt; list) { double s = 0.0; for (Number n : list) { s += n.doubleValue(); } return s; } public static void main(String[] args) { List&lt;Integer&gt; li = Arrays.asList(1, 2, 3); System.out.println(\"sum = \" + sumOfList(li)); } } // Output: // sum = 6.0 下界通配符下界通配符将未知类型限制为该类型的特定类型或超类类型。 🔔 注意：上界通配符和下界通配符不能同时使用。 它的语法形式为：&lt;? super Number&gt; public class GenericsLowerBoundedWildcardDemo { public static void addNumbers(List&lt;? super Integer&gt; list) { for (int i = 1; i &lt;= 5; i++) { list.add(i); } } public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); addNumbers(list); System.out.println(Arrays.deepToString(list.toArray())); } } // Output: // [1, 2, 3, 4, 5] 无界通配符无界通配符有两种应用场景： 可以使用 Object 类中提供的功能来实现的方法。 使用不依赖于类型参数的泛型类中的方法。 通配符和向上转型泛型不能向上转型。但是，我们可以通过使用通配符来向上转型。 public class GenericsWildcardDemo { public static void main(String[] args) { List&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); List&lt;Number&gt; numList = intList; // Error List&lt;? extends Integer&gt; intList2 = new ArrayList&lt;&gt;(); List&lt;? extends Number&gt; numList2 = intList2; // OK } } 泛型约束Restrictions on Generics 泛型实践泛型命名泛型一些约定俗成的命名： E - Element K - Key N - Number T - Type V - Value S,U,V etc. - 2nd, 3rd, 4th types","categories":[{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://winniekun.github.io/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Spring的bean注入方式","slug":"spring/Spring的bean注入方式","date":"2019-02-14T11:52:23.000Z","updated":"2020-08-30T04:50:22.252Z","comments":true,"path":"Spring的bean注入方式/","link":"","permalink":"https://winniekun.github.io/Spring%E7%9A%84bean%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/","excerpt":"Bean的依赖注入方式","text":"Bean的依赖注入方式 spring-bean.jpg Bean配置信息定义了Bean的实现及依赖关系，Spring容器根据各种形式的Bean配置信息在容器内部建立Bean定义注册表，然后根据注册表加载、实例化Bean，并建立Bean和Bean的依赖关系，最后将这些准备就绪的Bean放到Bean缓存池中，以供外层的应用程序进行调用。 Bean的注入方式有两种： XML中配置 构造方法注入 属性注入 工厂方法注入 使用注解的方式注入 XML中的配置依赖注入构造方法注入public class UserServiceImpl implements UserService { private UserDao userDao; // 利用构造方法注入 public UserServiceImpl(UserDao userDao){ this.userDao = userDao; } // //利用set进行动态实现值的注入 // public void setUserDao(UserDao userDao) { // this.userDao = userDao; // } public void getUser() { userDao.getUser(); } } bean.xml配置&lt;bean id=\"userImpl\" class=\"com.wkk.dao.impl.UserDaoImpl\"/&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;bean id=\"mysqlImpl\" class=\"com.wkk.dao.impl.UserDaoMysqlImpl\"/&gt; &lt;bean id=\"userServiceImpl\" class=\"com.wkk.service.impl.UserServiceImpl\"&gt; &lt;!--&lt;property name=\"userDao\" ref=\"mysqlImpl\"/&gt;--&gt; &lt;constructor-arg ref=\"mysqlImpl\"/&gt; &lt;/bean&gt; 属性注入(setter方法)public class UserServiceImpl implements UserService { private UserDao userDao; // 利用set进行动态实现值的注入 public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void getUser() { // System.out.println(\"UserService实现类: 对用户数据的逻辑操作(用户角度)\"); userDao.getUser(); } } bean.xml配置&lt;bean id=\"userImpl\" class=\"com.wkk.dao.impl.UserDaoImpl\"/&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;bean id=\"mysqlImpl\" class=\"com.wkk.dao.impl.UserDaoMysqlImpl\"/&gt; &lt;bean id=\"userServiceImpl\" class=\"com.wkk.service.impl.UserServiceImpl\"&gt; &lt;property name=\"userDao\" ref=\"mysqlImpl\"/&gt; &lt;/bean&gt; 工厂方式注入不写了，文档上没遇到， 然后平时感觉也没怎么遇到过。后面遇到再写 使用注解方式注入使用@Autowired自动注入@Component public class UserService { @Autowired @Qualifier(\"userDaoImpl2\") private UserDao userDao; public void say(){ userDao.say(); } } @Component public class UserDaoImpl1 implements UserDao { public void say() { System.out.println(\"这是UserDao的第一种实现方式\"); } } @Component public class UserDaoImpl2 implements UserDao { public void say() { System.out.println(\"这是UserDao的第二种实现方式\"); } } 测试@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = JavaConfig.class) public class UserServiceTest { @Autowired UserService userService; @Test public void say() { Assert.assertNotNull(userService); } } @Autowired不仅能对属性进行注解，还可以对方法、构造函数等。@Autowired类似与xml中使用构造方法注入或属性注入 &lt;property name=\"userDao\" ref=\"mysqlImpl\"/&gt; or &lt;constructor-arg ref=\"mysqlImpl\"/&gt; 如果使用了@Autowired或者Resource等，就不需要在定义Bean时使用属性注入和构造方法注入了。意思就是使用注解，可以省略繁杂的xml的配置。 @Autowired注解在setter方法上和属性注入的区别就是： setter方法注入是setter方法+bean.xml配置，@Autowired方式省去了bean.xml的配置 References Spring官方文档","categories":[{"name":"spring","slug":"spring","permalink":"https://winniekun.github.io/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://winniekun.github.io/tags/spring/"}]},{"title":"Spring中bean的几种装配方式总结","slug":"spring/Spring中bean的几种装配方式总结","date":"2019-01-14T11:50:54.000Z","updated":"2020-08-30T04:50:22.252Z","comments":true,"path":"Spring中bean的几种装配方式总结/","link":"","permalink":"https://winniekun.github.io/Spring%E4%B8%ADbean%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A3%85%E9%85%8D%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/","excerpt":"Bean的装配","text":"Bean的装配 装配: 创建应用对象之间的协作关系的行为， 也是DI的本质 Java装配（显式）XML装配（显式）自动化装配（隐式）从以下两个角度来实现自动化装配 组件扫描 Spring会自动发现应用上下文中所创建的bean 自动装配 Spring会自动满足bean之间的依赖使用@Component注解，告诉Spring需要为此类创建bean， 因为Spring默认是不开启组件扫描的，所以需要编写一个配置文件，启用组件扫描（@ComponentScan） 组件扫描组件扫描的bean命名Spring会根据类名指定ID（类名首字母小写）同时也可通过@Component(xxx)设置ID。 组件扫描的基础包默认会把使用@ComponentScan的包作为基础包，可以使用@ComponentScan(xxx)设置对应的基础包当将所有的配置文件统一放在同一个包里面的时候，需要指定基础包 如果，所有的对象都是独立的，彼此之间没有任何依赖，那么只需要组件扫描即可。但大多数情况下，很多对象都会依赖其他对象才能完成任务，所以就需要用到自动装配 自动装配自动装配就是让Spring自动满足bean依赖的一种方法。满足依赖的过程中，会在spring上下文中寻找某个bean需求的其他bean。 @Autowired@Autowired将当前bean依赖的bean注入进来，注入方式可以有构造器注入，也可以是setter注入，看@Autowired注解在哪儿。这样就可以省去在xml中的装配 References Spring实战第四版","categories":[{"name":"spring","slug":"spring","permalink":"https://winniekun.github.io/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://winniekun.github.io/tags/spring/"}]},{"title":"2019年书单【年终汇总】","slug":"碎碎念/2019年书单【年终汇总】","date":"2018-12-31T16:00:00.000Z","updated":"2020-08-30T04:50:22.257Z","comments":true,"path":"2019年书单【年终汇总】/","link":"","permalink":"https://winniekun.github.io/2019%E5%B9%B4%E4%B9%A6%E5%8D%95%E3%80%90%E5%B9%B4%E7%BB%88%E6%B1%87%E6%80%BB%E3%80%91/","excerpt":"我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 摘自鶸道场 趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。","text":"我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 摘自鶸道场 趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。 书籍相关 统计学习方法 算法新解 Python3学习笔记 Python编程导论 Fluent Python Flask Web开发实战入门、进阶与原理解析 黑客与画家 Vue.js实战 MySQL必知必会 编程珠玑 只能说是神书了，太多的算法书都或多或少的引用上面的例子 面向机器学习的特征工程 目前还没看完，因为觉得特征工程自己没有系统的弄过，所以打算好好看看 Fluent Python 原先觉得可以跳着看，看自己有欠缺的地方，然后开始看的时候，发现，哦～ 原来还有其他地方也是欠缺的，所以最后还是乖乖从章节的初始部分看 Java并发编程 目前看了两章 算法 把无向图看完了 Effective Java 感觉这种类型的书，没有看没看完一说，每次看都有新的理解，入门时开始看，哦～ 原来是这样， 最近再看，哦！原来是这样 电影、电视剧、综艺、纪录片 无双 我不是药神 灵能百分百II 紫罗兰的永恒花园 一拳超人II 闻香识女人 应该是我目前感触最深的一部了 驯龙高手III 结束了 精灵旅社III 也结束了，回想起来，这两部电影都是我从高中开始追的，现在都已经读研了。 hi，室友 王彦霖是真的逗，不知道是节目效果还是啥，宋小宝那一期是真的神奇，感觉基本的待客之道都没有 向往的生活III 一直是当美食篇来看的 破冰行动 暴雪将至 害怕成为这样的 沙赞 好尼玛智障啊 复联IV 铁人走的时候，心里还是哽了一下，还有我最喜欢的寡姐也走了。 最好的我们(电影版) 没啥好评价的，感觉和二熊写的不太一样了 哪吒之魔童降世 挺好看的 就是剧情太中规中矩了 沉默的证人 好差劲啊 西行记 属于那种看多了会腻的 使徒行者II 怎么这两天看的港片质量都这么差 还不及第一部的一半… 寄生虫 今年的戛纳电影最火的金棕榈电影 有很多的隐喻，可惜的是自己是跳着看的，错过了很多的细节 真的很好看 人生一串II 一如既往的好看 恶人传 最近迷上了马东锡的电影 看着真的很爽 红辣椒 转化的很棒 海上钢琴师 罗小黑战记 很好看，终于更新了 这个和哪吒的区别就是，看哪吒的时候，知道后面会发生啥，但是还是乐意去看， 这个是不确定后面会发生啥，想让它一直播，不要停 烈火英雄 很主旋律，但也很感人 诛仙I 正常的商业电影吧 鬼灭之刃 很好看，好好看 多罗罗 最长一枪 中国机长 敬畏 全职高手 大电影 不评价了， 就这样吧， 好坏参半，但是坏占大多数 少年的你 不知道为啥会有喷的,我觉得很棒哇 刺客伍六七II 不知道为啥,感觉没有第一季那么好看 镇魂街 漫画 我和我的祖国 主旋律还是适合在影院看,有氛围 中国机长 欧豪很靓哇 坏家伙们I 因马东锡在影视中打过僵尸, 打过坏人, 所以被称为神马东锡…. 坏家伙们II 他人即地狱 很阴森 囚犯医生 就是爽, 看着 秘密森林 反转真的是太大了 被告人 好看 爱吃拉面的小泉同学 很好吃 差馆 词穷，没有写不出来， 反正就是感慨很多 叶问IV 又是一个十年， 这个系列也结束了， 突然发现好多从初高中追的局都结束了， 时间真是个神奇的东西 镇魂街II 画风更好了？？ 感觉崩了 一人之下I、II 心中的国番第二","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"书单","slug":"书单","permalink":"https://winniekun.github.io/tags/%E4%B9%A6%E5%8D%95/"}]}],"categories":[{"name":"分布式","slug":"分布式","permalink":"https://winniekun.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"操作系统","slug":"操作系统","permalink":"https://winniekun.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"dubbo","slug":"dubbo","permalink":"https://winniekun.github.io/categories/dubbo/"},{"name":"kafka","slug":"kafka","permalink":"https://winniekun.github.io/categories/kafka/"},{"name":"源码","slug":"源码","permalink":"https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"},{"name":"中间件","slug":"中间件","permalink":"https://winniekun.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"leetcode","slug":"leetcode","permalink":"https://winniekun.github.io/categories/leetcode/"},{"name":"网络","slug":"网络","permalink":"https://winniekun.github.io/categories/%E7%BD%91%E7%BB%9C/"},{"name":"spring","slug":"spring","permalink":"https://winniekun.github.io/categories/spring/"},{"name":"排序","slug":"排序","permalink":"https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://winniekun.github.io/categories/LeetCode/"},{"name":"concurrency","slug":"concurrency","permalink":"https://winniekun.github.io/categories/concurrency/"},{"name":"碎碎念","slug":"碎碎念","permalink":"https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"代码质量","slug":"代码质量","permalink":"https://winniekun.github.io/categories/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"},{"name":"java","slug":"java","permalink":"https://winniekun.github.io/categories/java/"},{"name":"算法","slug":"算法","permalink":"https://winniekun.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"设计模式","slug":"设计模式","permalink":"https://winniekun.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://winniekun.github.io/categories/%E5%89%91%E6%8C%87offer/"},{"name":"配置","slug":"配置","permalink":"https://winniekun.github.io/categories/%E9%85%8D%E7%BD%AE/"},{"name":"Linux","slug":"Linux","permalink":"https://winniekun.github.io/categories/Linux/"},{"name":"数据结构","slug":"数据结构","permalink":"https://winniekun.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"mysql","slug":"mysql","permalink":"https://winniekun.github.io/categories/mysql/"}],"tags":[{"name":"锁","slug":"锁","permalink":"https://winniekun.github.io/tags/%E9%94%81/"},{"name":"基础","slug":"基础","permalink":"https://winniekun.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"rpc","slug":"rpc","permalink":"https://winniekun.github.io/tags/rpc/"},{"name":"配置","slug":"配置","permalink":"https://winniekun.github.io/tags/%E9%85%8D%E7%BD%AE/"},{"name":"内存管理","slug":"内存管理","permalink":"https://winniekun.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"jdk","slug":"jdk","permalink":"https://winniekun.github.io/tags/jdk/"},{"name":"kafka","slug":"kafka","permalink":"https://winniekun.github.io/tags/kafka/"},{"name":"JDK源码","slug":"JDK源码","permalink":"https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"},{"name":"lang","slug":"lang","permalink":"https://winniekun.github.io/tags/lang/"},{"name":"双指针","slug":"双指针","permalink":"https://winniekun.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"Queue","slug":"Queue","permalink":"https://winniekun.github.io/tags/Queue/"},{"name":"应用层","slug":"应用层","permalink":"https://winniekun.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"},{"name":"ioc","slug":"ioc","permalink":"https://winniekun.github.io/tags/ioc/"},{"name":"归并排序","slug":"归并排序","permalink":"https://winniekun.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"死磕系列","slug":"死磕系列","permalink":"https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"},{"name":"数学基础","slug":"数学基础","permalink":"https://winniekun.github.io/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"name":"SQL","slug":"SQL","permalink":"https://winniekun.github.io/tags/SQL/"},{"name":"多线程","slug":"多线程","permalink":"https://winniekun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"杂谈","slug":"杂谈","permalink":"https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"},{"name":"书单","slug":"书单","permalink":"https://winniekun.github.io/tags/%E4%B9%A6%E5%8D%95/"},{"name":"if-else优化","slug":"if-else优化","permalink":"https://winniekun.github.io/tags/if-else%E4%BC%98%E5%8C%96/"},{"name":"dfs","slug":"dfs","permalink":"https://winniekun.github.io/tags/dfs/"},{"name":"bfs","slug":"bfs","permalink":"https://winniekun.github.io/tags/bfs/"},{"name":"trie","slug":"trie","permalink":"https://winniekun.github.io/tags/trie/"},{"name":"http","slug":"http","permalink":"https://winniekun.github.io/tags/http/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://winniekun.github.io/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"java基础","slug":"java基础","permalink":"https://winniekun.github.io/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"面试36讲","slug":"面试36讲","permalink":"https://winniekun.github.io/tags/%E9%9D%A2%E8%AF%9536%E8%AE%B2/"},{"name":"List","slug":"List","permalink":"https://winniekun.github.io/tags/List/"},{"name":"JUC","slug":"JUC","permalink":"https://winniekun.github.io/tags/JUC/"},{"name":"动态规划","slug":"动态规划","permalink":"https://winniekun.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"单调栈","slug":"单调栈","permalink":"https://winniekun.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"并发","slug":"并发","permalink":"https://winniekun.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://winniekun.github.io/tags/%E5%89%91%E6%8C%87offer/"},{"name":"二分搜索","slug":"二分搜索","permalink":"https://winniekun.github.io/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"},{"name":"I/O","slug":"I-O","permalink":"https://winniekun.github.io/tags/I-O/"},{"name":"位运算","slug":"位运算","permalink":"https://winniekun.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"图论","slug":"图论","permalink":"https://winniekun.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"ip","slug":"ip","permalink":"https://winniekun.github.io/tags/ip/"},{"name":"tcp","slug":"tcp","permalink":"https://winniekun.github.io/tags/tcp/"},{"name":"命令行","slug":"命令行","permalink":"https://winniekun.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"选择","slug":"选择","permalink":"https://winniekun.github.io/tags/%E9%80%89%E6%8B%A9/"},{"name":"AVL树","slug":"AVL树","permalink":"https://winniekun.github.io/tags/AVL%E6%A0%91/"},{"name":"flag","slug":"flag","permalink":"https://winniekun.github.io/tags/flag/"},{"name":"Map","slug":"Map","permalink":"https://winniekun.github.io/tags/Map/"},{"name":"springboot","slug":"springboot","permalink":"https://winniekun.github.io/tags/springboot/"},{"name":"回溯","slug":"回溯","permalink":"https://winniekun.github.io/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"链表","slug":"链表","permalink":"https://winniekun.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"二叉树","slug":"二叉树","permalink":"https://winniekun.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"交换","slug":"交换","permalink":"https://winniekun.github.io/tags/%E4%BA%A4%E6%8D%A2/"},{"name":"BST","slug":"BST","permalink":"https://winniekun.github.io/tags/BST/"},{"name":"总结","slug":"总结","permalink":"https://winniekun.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"B树","slug":"B树","permalink":"https://winniekun.github.io/tags/B%E6%A0%91/"},{"name":"插入","slug":"插入","permalink":"https://winniekun.github.io/tags/%E6%8F%92%E5%85%A5/"},{"name":"spring","slug":"spring","permalink":"https://winniekun.github.io/tags/spring/"}]}