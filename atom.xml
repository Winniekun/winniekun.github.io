<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wkkの笔记</title>
  
  <subtitle>好记性不如烂键盘</subtitle>
  <link href="https://winniekun.github.io/atom.xml" rel="self"/>
  
  <link href="https://winniekun.github.io/"/>
  <updated>2021-09-14T11:32:28.465Z</updated>
  <id>https://winniekun.github.io/</id>
  
  <author>
    <name>weikunkun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>零拷贝技术的理解</title>
    <link href="https://winniekun.github.io/zero-copy/"/>
    <id>https://winniekun.github.io/zero-copy/</id>
    <published>2021-09-14T07:41:13.000Z</published>
    <updated>2021-09-14T11:32:28.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="零拷贝的好处"><a href="#零拷贝的好处" class="headerlink" title="零拷贝的好处"></a>零拷贝的好处</h2><blockquote><ul><li>减少或避免不必要的CPU数据拷贝，从而释放CPU去执行其他任务</li><li>零拷贝机制能减少用户空间和操作系统内核空间的上下文切换</li><li>减少内存的占用</li></ul></blockquote><h2 id="DMA技术"><a href="#DMA技术" class="headerlink" title="DMA技术"></a>DMA技术</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210913110850194.png" alt="DMA" title="">                </div>                <div class="image-caption">DMA</div>            </figure><p>在没有<code>DMA技术</code>之前，<code>I/O</code>的过程如上图所示：</p><ol><li>CPU 发出对应的指令给磁盘控制器，然后返回；</li><li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个<strong>中断</strong>；</li><li>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。</li></ol><blockquote><p>可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。</p></blockquote><p>为了解决这一问题，中间层的思路就又出来了。后期引入DMA技术，在进行<code>I/O</code>处理的时候（设备和内存进行数据传输的时候），<strong>数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210913112417717.png" alt="DMA" title="">                </div>                <div class="image-caption">DMA</div>            </figure><blockquote><p>具体过程：</p><ol><li>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li><li>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；</li><li>DMA 进一步将 I/O 请求发送给磁盘；</li><li>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li><li><strong>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务</strong>；</li><li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li><li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li></ol></blockquote><h2 id="传统的文件传输"><a href="#传统的文件传输" class="headerlink" title="传统的文件传输"></a>传统的文件传输</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210913110511570.png" alt="文件传输" title="">                </div>                <div class="image-caption">文件传输</div>            </figure><p>首先，期间共<strong>发生了 4 次用户态与内核态的上下文切换</strong>，因为发生了两次系统调用，一次是 <code>read()</code> ，一次是 <code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</p><p>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p><p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p><ul><li><em>第一次拷贝</em>，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li><li><em>第二次拷贝</em>，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li><li><em>第三次拷贝</em>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li><li><em>第四次拷贝</em>，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li></ul><h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><h3 id="减少上下文的切换"><a href="#减少上下文的切换" class="headerlink" title="减少上下文的切换"></a>减少上下文的切换</h3><p>首先， 对于<code>I/O</code>的处理，用户态是无权限的，只能切换到内核态进行处理，所以减少上下文的切换的一个思路就是：<code>减少系统调用</code></p><h3 id="减少拷贝的次数"><a href="#减少拷贝的次数" class="headerlink" title="减少拷贝的次数"></a>减少拷贝的次数</h3><p>通过对上述的分析，我们知道传统的文件传输，涉及到了四次的<code>copy</code>过程。在一些场景中，我们知道其实数据是完全不必copy到用户空间的，因为应用程序一般不会对数据进行加工。</p><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><h3 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a>mmap + write</h3><p>在前面我们知道，<code>read()</code> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <code>mmap()</code> 替换 <code>read()</code> 系统调用函数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210913114731106.png" alt="mmap + write 示意图" title="">                </div>                <div class="image-caption">mmap + write 示意图</div>            </figure><p>流程：</p><ol><li>应用进程通过<code>mmap</code>后，<code>DMA</code>将磁盘文件放入内核缓冲区，然后用户程序和内核共享该缓冲区</li><li>然后用户程序调用<code>write</code>，将数据写入<code>socket缓冲区</code>，（内部而言，是cpu内核缓冲区的内容copy到socket缓冲区）</li><li>然后DMA将<code>socket缓冲区</code>放入到网卡缓冲区中</li></ol><blockquote><p>拷贝次数 从 4  -&gt; 3 上下文切换还是发生了4次</p></blockquote><h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h3><blockquote><p>通过减少系统调用，实现零copy技术</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210913121323890.png" alt="sendfile" title="">                </div>                <div class="image-caption">sendfile</div>            </figure><p><code>sendfile</code>可以替代<code>read</code>和<code>write</code>两个系统调用，这样就可以减少一次系统调用，避免两次上下文切换。其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如上图所示。</p><p>但是这还不是真正的零拷贝技术，如果网卡支持 <code>SG-DMA（The Scatter-Gather Direct Memory Access）</code>技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程（只进行了 2 次数据拷贝）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210913123946592.png" alt="网卡DMA" title="">                </div>                <div class="image-caption">网卡DMA</div>            </figure><ul><li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li><li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li></ul><p>这就是所谓的<strong>零拷贝（*Zero-copy*）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的</strong></p><p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p><p>所以，总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上</strong>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>使用mmap + write （4次上下文切换，上次文件拷贝）<ul><li>减少一次文件copy</li></ul></li><li>使用sendfile（2吃上下文切换，三次文件拷贝）<ul><li>减少了2次上下文切换</li><li>减少一次文件copy</li></ul></li><li>网卡支持SG-DMA（2次上下文切换， 两次文件拷贝（不需要CPU进行操作））<ul><li>减少了2次上下文切换</li><li>减少了2次文件拷贝</li></ul></li></ol><h3 id="使用零拷贝技术的项目"><a href="#使用零拷贝技术的项目" class="headerlink" title="使用零拷贝技术的项目"></a>使用零拷贝技术的项目</h3><h4 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h4><p>使用零拷贝技术，<code>消费者（consumer）</code>从Kafka消费数据，Kafka从磁盘读数据然后发送到网络上去，数据一共发生了四次传输的过程。其中两次是 DMA 的传输，另外两次，则是通过 CPU 控制的传输。通过<code>零拷贝</code>技术，避免了文件的多余的copy次数，以及CPU的参与，进而能够更好的提升整体的性能，优化CPU的使用。</p><h4 id="Java-transferTo"><a href="#Java-transferTo" class="headerlink" title="Java transferTo"></a>Java transferTo</h4><pre><code class="lang-java">public static void copyFileByChannel(File source, File dest) throws        IOException {    try (FileChannel sourceChannel = new FileInputStream(source)            .getChannel();         FileChannel targetChannel = new FileOutputStream(dest).getChannel()) {        for (long count = sourceChannel.size(); count &gt; 0; ) {            long transferred = sourceChannel.transferTo(                    sourceChannel.position(), count, targetChannel);            sourceChannel.position(sourceChannel.position() + transferred);            count -= transferred;        }    }}</code></pre><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ol><li><a href="https://www.cnblogs.com/xiaolincoding/p/13719610.html" target="_blank" rel="noopener">原来 8 张图，就可以搞懂「零拷贝」了</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;零拷贝的好处&quot;&gt;&lt;a href=&quot;#零拷贝的好处&quot; class=&quot;headerlink&quot; title=&quot;零拷贝的好处&quot;&gt;&lt;/a&gt;零拷贝的好处&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;减少或避免不必要的CPU数据拷贝，从而释放CPU去执行其他任务&lt;/li</summary>
      
    
    
    
    <category term="操作系统" scheme="https://winniekun.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="基础" scheme="https://winniekun.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo和Spring、SpringBoot的结合简单Demo</title>
    <link href="https://winniekun.github.io/dubbo-demo/"/>
    <id>https://winniekun.github.io/dubbo-demo/</id>
    <published>2021-09-05T11:45:28.000Z</published>
    <updated>2021-09-07T16:50:20.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><code>dubbo</code>和<code>Spring</code>、<code>SpringBoot</code>的集合</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ol><li><p>Spring （说白了就是两个进程的通信，然后将dubbo交由spring来管理，我们需要做的就是进行配置，然后按照文档硬编码）</p><pre><code class="lang-xml">&lt;properties&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;spring.version&gt;5.3.4&lt;/spring.version&gt;    &lt;dubbo.version&gt;2.7.8&lt;/dubbo.version&gt;    &lt;curator.version&gt;4.2.0&lt;/curator.version&gt;    &lt;zk.version&gt;3.5.8&lt;/zk.version&gt;&lt;/properties&gt;</code></pre></li><li><p>SpringBoot</p><pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.5.4&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.wkk.dubbo&lt;/groupId&gt;    &lt;artifactId&gt;provider&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;provider&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;11&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo-spring-boot-starter --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;2.7.13&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.wkk.dubbo&lt;/groupId&gt;            &lt;artifactId&gt;api&lt;/artifactId&gt;            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre></li></ol><h2 id="和Spring的结合-未配置ZK"><a href="#和Spring的结合-未配置ZK" class="headerlink" title="和Spring的结合(未配置ZK)"></a>和Spring的结合(未配置ZK)</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210905192815964.png" alt="dubbo和spring的结合" title="">                </div>                <div class="image-caption">dubbo和spring的结合</div>            </figure><p><strong>pom.xml:</strong></p><pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.wkk&lt;/groupId&gt;    &lt;artifactId&gt;spring-dubbo-demo&lt;/artifactId&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;modules&gt;        &lt;module&gt;dubbo-provider&lt;/module&gt;        &lt;module&gt;dubbo-consumer&lt;/module&gt;        &lt;module&gt;dubbo-api&lt;/module&gt;    &lt;/modules&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;spring.version&gt;5.3.4&lt;/spring.version&gt;        &lt;dubbo.version&gt;2.7.8&lt;/dubbo.version&gt;        &lt;curator.version&gt;4.2.0&lt;/curator.version&gt;        &lt;zk.version&gt;3.5.8&lt;/zk.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;            &lt;version&gt;${dubbo.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;            &lt;version&gt;${zk.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;            &lt;version&gt;${curator.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;            &lt;version&gt;${curator.version}&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><blockquote><p> 公共接口，然后<code>provider</code>提供对该接口的实现，<code>consume</code>r对其发起调用</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210905233104405.png" alt="image-20210905233104405" title="">                </div>                <div class="image-caption">image-20210905233104405</div>            </figure><pre><code class="lang-java">package com.wkk.api;/** * @author weikunkun * @since 2021/9/5 */public interface HelloApi {    String hello(String name);}</code></pre><h3 id="PROVIDER"><a href="#PROVIDER" class="headerlink" title="PROVIDER"></a>PROVIDER</h3><blockquote><p> 负责对<code>api</code>的实现</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210905193330955.png" alt="dubbo-provider" title="">                </div>                <div class="image-caption">dubbo-provider</div>            </figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--  Licensed to the Apache Software Foundation (ASF) under one or more  contributor license agreements.  See the NOTICE file distributed with  this work for additional information regarding copyright ownership.  The ASF licenses this file to You under the Apache License, Version 2.0  (the "License"); you may not use this file except in compliance with  the License.  You may obtain a copy of the License at      http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software  distributed under the License is distributed on an "AS IS" BASIS,  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language governing permissions and  limitations under the License.  --&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"       xmlns="http://www.springframework.org/schema/beans"       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"&gt;    &lt;dubbo:application name="demo-provider"/&gt;    &lt;dubbo:protocol name="dubbo" port="20880"/&gt;    &lt;!--  声明对外暴露的接口 --&gt;    &lt;dubbo:service            registry="N/A"            interface="com.wkk.api.HelloApi"            ref="quickStartServiceApi"/&gt;    &lt;!--配置bean实例--&gt;    &lt;bean id="quickStartServiceApi" class="com.wkk.provider.api.HelloApiImpl"/&gt;&lt;/beans&gt;</code></pre><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;parent&gt;        &lt;artifactId&gt;spring-dubbo-demo&lt;/artifactId&gt;        &lt;groupId&gt;com.wkk&lt;/groupId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;dubbo-provider&lt;/artifactId&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.wkk&lt;/groupId&gt;            &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><h4 id="相关实现："><a href="#相关实现：" class="headerlink" title="相关实现："></a><strong>相关实现：</strong></h4><p><strong>API实现：</strong></p><pre><code class="lang-java">package com.wkk.provider.api;import com.wkk.api.HelloApi;/** * @author weikunkun * @since 2021/9/5 */public class HelloApiImpl implements HelloApi {    public String hello(String name) {        return "this is dubbot quick starter, name = " + name;    }}</code></pre><p><strong>启动类：</strong></p><pre><code class="lang-java">package com.wkk.provider;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.io.IOException;/** * @author weikunkun * @since 2021/9/5 */public class ProviderClient {    public static void main(String[] args) throws IOException {        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("dubbo-provider.xml");        context.start();        System.in.read();    }}</code></pre><h3 id="CONSUMER"><a href="#CONSUMER" class="headerlink" title="CONSUMER"></a>CONSUMER</h3><blockquote><p> 负责调用对应的接口，为了方便起见，具体的调用直接在<code>consumer</code>中的启动类进行操作</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210905194145303.png" alt="dubbo-consumer" title="">                </div>                <div class="image-caption">dubbo-consumer</div>            </figure><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a><strong>配置</strong></h4><pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--  Licensed to the Apache Software Foundation (ASF) under one or more  contributor license agreements.  See the NOTICE file distributed with  this work for additional information regarding copyright ownership.  The ASF licenses this file to You under the Apache License, Version 2.0  (the "License"); you may not use this file except in compliance with  the License.  You may obtain a copy of the License at      http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software  distributed under the License is distributed on an "AS IS" BASIS,  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language governing permissions and  limitations under the License.  --&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"       xmlns="http://www.springframework.org/schema/beans"       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"&gt;    &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;    &lt;dubbo:application name="consumer-of-helloworld-app"  /&gt;    &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;    &lt;dubbo:reference id="demoService"                     interface="com.wkk.api.HelloApi"                     url="dubbo://xxxx:20880"/&gt;&lt;/beans&gt;</code></pre><h4 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a><strong>依赖</strong></h4><pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;parent&gt;        &lt;artifactId&gt;spring-dubbo-demo&lt;/artifactId&gt;        &lt;groupId&gt;com.wkk&lt;/groupId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;dubbo-consumer&lt;/artifactId&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.wkk&lt;/groupId&gt;            &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><h4 id="相关实现"><a href="#相关实现" class="headerlink" title="相关实现"></a><strong>相关实现</strong></h4><p><strong>启动类</strong></p><pre><code class="lang-java">package com.wkk.consumer;import com.wkk.api.HelloApi;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.Scanner;/** * @author weikunkun * @since 2021/9/5 */public class ConsumerClient {    public static void main(String[] args) {        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("dubbo-consumer.xml");        HelloApi demoService = (HelloApi) context.getBean("demoService");        while (true) {            Scanner sc = new Scanner(System.in);            String str = sc.nextLine();            System.out.println(demoService.hello(str));        }    }}</code></pre><h3 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210905194341579.png" alt="成果展示" title="">                </div>                <div class="image-caption">成果展示</div>            </figure><h2 id="和SpringBoot的结合-未配置ZK"><a href="#和SpringBoot的结合-未配置ZK" class="headerlink" title="和SpringBoot的结合(未配置ZK)"></a>和SpringBoot的结合(未配置ZK)</h2><blockquote><p>整体和Spring结合一致</p></blockquote><h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><blockquote><p>公共接口，然后<code>provider</code>提供对该接口的实现，<code>consume</code>r对其发起调用</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210907165838854.png" alt="api" title="">                </div>                <div class="image-caption">api</div>            </figure><p><strong>接口的设计</strong></p><pre><code class="lang-java">package com.wkk.dubbo.api;/** * @author weikunkun * @since 2021/9/6 */public interface HelloApi {    String hello(String name);}</code></pre><h3 id="PROVIDER-1"><a href="#PROVIDER-1" class="headerlink" title="PROVIDER"></a>PROVIDER</h3><h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><pre><code class="lang-properties">dubbo:  application:    name: demo-provider  registry:    address: N/A  protocol:    name: dubbo    port: 20880</code></pre><h4 id="依赖-2"><a href="#依赖-2" class="headerlink" title="依赖"></a>依赖</h4><pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.5.4&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.wkk.dubbo&lt;/groupId&gt;    &lt;artifactId&gt;provider&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;provider&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;11&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo-spring-boot-starter --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;2.7.13&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.wkk.dubbo&lt;/groupId&gt;            &lt;artifactId&gt;api&lt;/artifactId&gt;            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h4 id="相关实现-1"><a href="#相关实现-1" class="headerlink" title="相关实现"></a>相关实现</h4><pre><code class="lang-java">package com.wkk.dubbo.provider.impl;import com.wkk.dubbo.api.HelloApi;import org.apache.dubbo.config.annotation.DubboService;import org.apache.dubbo.rpc.RpcContext;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;/** * @author weikunkun * @since 2021/9/6 */@Component@DubboService(version = "1.0.0")public class HelloApiImpl implements HelloApi {    private static final Logger logger = LoggerFactory.getLogger(HelloApiImpl.class);    @Override    public String hello(String name) {        try {            Thread.sleep(200); //            logger.info("Hello " + name + ", request from consumer: " + RpcContext.getServerContext().getRemoteAddress());            return "Hello " + name + ", response from provider: " + RpcContext.getServerContext().getLocalAddress();        } catch (InterruptedException e) {            e.printStackTrace();        }        return null;    }}</code></pre><h3 id="CONSUMER-1"><a href="#CONSUMER-1" class="headerlink" title="CONSUMER"></a>CONSUMER</h3><h4 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h4><pre><code class="lang-properties">spring:  application:    name: dubbo-consumer</code></pre><h4 id="依赖-3"><a href="#依赖-3" class="headerlink" title="依赖"></a>依赖</h4><pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.5.4&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.wkk.consumer&lt;/groupId&gt;    &lt;artifactId&gt;consumer&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;consumer&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;11&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo-spring-boot-starter --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;2.7.13&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.wkk.dubbo&lt;/groupId&gt;            &lt;artifactId&gt;api&lt;/artifactId&gt;            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h4 id="相关实现-2"><a href="#相关实现-2" class="headerlink" title="相关实现"></a>相关实现</h4><p><strong>DemoServiceComponent：</strong></p><blockquote><p>用于调用provider中对应的实现方法</p></blockquote><pre><code class="lang-java">package com.wkk.consumer.consumer.comp;import com.wkk.dubbo.api.HelloApi;import org.apache.dubbo.config.annotation.DubboReference;import org.springframework.stereotype.Component;/** * @author weikunkun * @since 2021/9/7 */@Componentpublic class DemoServiceComponent implements HelloApi {    @DubboReference(version = "1.0.0", url = "dubbo://xxxx:20880")    private HelloApi helloApi;    @Override    public String hello(String name) {        return helloApi.hello(name);    }}</code></pre><p><strong>ConsumerApplication：</strong></p><blockquote><p>启动类，通过Scanner做了交互</p></blockquote><pre><code class="lang-java">package com.wkk.consumer.consumer;import com.wkk.dubbo.api.HelloApi;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ConfigurableApplicationContext;import java.util.Scanner;@SpringBootApplicationpublic class ConsumerApplication {    public static void main(String[] args) {        ConfigurableApplicationContext context = SpringApplication.run(ConsumerApplication.class, args);        HelloApi demoService = (HelloApi) context.getBean("demoServiceComponent");        Scanner sc = new Scanner(System.in);        while (true) {            String s = sc.nextLine();            System.out.println(demoService.hello(s));        }    }}</code></pre><h3 id="最终结果-1"><a href="#最终结果-1" class="headerlink" title="最终结果"></a>最终结果</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210907165745246.png" alt="成果展示" title="">                </div>                <div class="image-caption">成果展示</div>            </figure><h2 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a>源码链接</h2><p><a href="https://github.com/Winniekun/dubbo-demo" target="_blank" rel="noopener">源码</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;&lt;code&gt;dubbo&lt;/code&gt;和&lt;code&gt;Spring&lt;/code&gt;、&lt;code&gt;SpringBoot&lt;/code&gt;的集合&lt;/p&gt;
&lt;h3 </summary>
      
    
    
    
    <category term="dubbo" scheme="https://winniekun.github.io/categories/dubbo/"/>
    
    
    <category term="rpc" scheme="https://winniekun.github.io/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>Kafka在Linux上的配置</title>
    <link href="https://winniekun.github.io/kafka-config/"/>
    <id>https://winniekun.github.io/kafka-config/</id>
    <published>2021-08-22T13:24:40.000Z</published>
    <updated>2021-08-22T14:35:22.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><h3 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h3><p><strong>Kafka</strong>是由<a href="https://zh.wikipedia.org/wiki/Apache软件基金会" target="_blank" rel="noopener">Apache软件基金会</a>开发的一个<a href="https://zh.wikipedia.org/wiki/开源" target="_blank" rel="noopener">开源</a><a href="https://zh.wikipedia.org/wiki/流处理" target="_blank" rel="noopener">流处理</a>平台，由<a href="https://zh.wikipedia.org/wiki/Scala" target="_blank" rel="noopener">Scala</a>和<a href="https://zh.wikipedia.org/wiki/Java" target="_blank" rel="noopener">Java</a>编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个“按照分布式事务日志架构的大规模发布/订阅消息队列”，<a href="https://zh.wikipedia.org/wiki/Kafka#cite_note-3" target="_blank" rel="noopener">[3]</a>这使它作为企业级基础设施来处理流式数据非常有价值。此外，Kafka可以通过Kafka Connect连接到外部系统（用于数据输入/输出），并提供了Kafka Streams——一个<a href="https://zh.wikipedia.org/wiki/Java" target="_blank" rel="noopener">Java</a>流式处理<a href="https://zh.wikipedia.org/wiki/库_(计算机" target="_blank" rel="noopener">库</a>)。</p><h3 id="Kafka架构"><a href="#Kafka架构" class="headerlink" title="Kafka架构"></a>Kafka架构</h3><p>Kafka存储的消息来自任意多被称为“生产者”（Producer）的进程。数据从而可以被分配到不同的“分区”（Partition）、不同的“Topic”下。在一个分区内，这些消息被索引并连同时间戳存储在一起。其它被称为“消费者”（Consumer）的进程可以从分区查询消息。Kafka运行在一个由一台或多台服务器组成的集群上，并且分区可以跨集群结点分布。</p><p>Kafka高效地处理实时流式数据，可以实现与Storm、HBase和Spark的集成。作为聚类部署到多台服务器上，Kafka处理它所有的发布和订阅消息系统使用了四个API，即生产者API、消费者API、Stream API和Connector API。它能够传递大规模流式消息，自带容错功能，已经取代了一些传统消息系统，如JMS、AMQP等。</p><p>Kafka架构的主要术语包括Topic、Record和Broker。Topic由Record组成，Record持有不同的信息，而Broker则负责复制消息。Kafka有四个主要API：</p><ul><li><strong>生产者API</strong>：支持应用程序发布Record流。</li><li><strong>消费者API</strong>：支持应用程序订阅Topic和处理Record流。</li><li><strong>Stream API</strong>：将输入流转换为输出流，并产生结果。</li><li><strong>Connector API</strong>：执行可重用的生产者和消费者API，可将Topic链接到现有应用程序。</li></ul><h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><ol><li><a href="https://www.oracle.com/in/java/technologies/javase-downloads.html" target="_blank" rel="noopener">JDK11</a></li><li><a href="https://kafka.apache.org/downloads" target="_blank" rel="noopener">kafka_2.13-2.8.0.tgz</a></li></ol><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>假设<code>Kafka</code>环境和<code>Zookeeper</code>环境都没有</p><h3 id="1-下载并解压"><a href="#1-下载并解压" class="headerlink" title="1. 下载并解压"></a>1. 下载并解压</h3><pre><code class="lang-java">&gt; tar -xzf kafka_2.13-2.8.0.tgz&gt; mv kafka_2.13-2.8.0.tgz  /usr/local/kafka&gt; cd /usr/local/kafka</code></pre><h3 id="2-启动服务"><a href="#2-启动服务" class="headerlink" title="2. 启动服务"></a>2. 启动服务</h3><blockquote><p>kafka的启动依赖于Java环境，所以在使用Kakfa之前，记得配置Java8+的环境</p></blockquote><pre><code class="lang-shell">&gt; bin/zookeeper-server-start.sh config/zookeeper.properties</code></pre><p>打开另一个命令终端启动kafka服务：</p><pre><code class="lang-shell">## 用于后台启动&gt; bin/kafka-server-start.sh config/server.properties &amp;</code></pre><p>一旦所有服务成功启动，那Kafka已经可以使用了。</p><h3 id="3-创建一个主题"><a href="#3-创建一个主题" class="headerlink" title="3. 创建一个主题"></a>3. 创建一个主题</h3><p>创建一个名为“test”的Topic，只有一个分区和一个备份：</p><pre><code class="lang-shell">&gt; bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test</code></pre><p>创建好之后，可以通过运行以下命令，查看已创建的topic信息：</p><pre><code class="lang-shell">&gt; bin/kafka-topics.sh --describe --topic test --bootstrap-server localhost:9092Topic:quickstart-events  PartitionCount:1    ReplicationFactor:1 Configs:Topic: quickstart-events Partition: 0    Leader: 0   Replicas: 0 Isr: 0</code></pre><h3 id="4-发送消息"><a href="#4-发送消息" class="headerlink" title="4. 发送消息"></a>4. 发送消息</h3><p>Kafka提供了一个命令行的工具，可以从输入文件或者命令行中读取消息并发送给Kafka集群。每一行是一条消息。</p><p>运行 <code>producer（生产者）</code>,然后在控制台输入几条消息到服务器。</p><pre><code class="lang-shell">&gt; bin/kafka-console-producer.sh --broker-list localhost:9092 --topic testhello worldwhat's your name</code></pre><h3 id="5-消费消息"><a href="#5-消费消息" class="headerlink" title="5. 消费消息"></a>5. 消费消息</h3><p>Kafka也提供了一个消费消息的命令行工具，将存储的信息输出出来，新打开一个命令控制台，输入：</p><pre><code class="lang-shell">&gt; bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginninghello worldwhat's your name</code></pre><blockquote><p>注意，若是在服务器开启kafka服务，然后本地消费生产的消息，需要在kafka中的 config/service.properties 中修改配置（注意开启服务器对应的端口）</p><p>advertised.listeners=PLAINTEXT://your ip : your port </p></blockquote><h3 id="6-使用-Kafka-Connect-来-导入-导出-数据"><a href="#6-使用-Kafka-Connect-来-导入-导出-数据" class="headerlink" title="6. 使用 Kafka Connect 来 导入/导出 数据"></a>6. 使用 Kafka Connect 来 导入/导出 数据</h3><p>可能现有的系统中拥有大量的数据，如<code>关系型数据库</code>或<code>传统的消息传递系统</code>，以及许多已经使用这些系统的应用程序。Kafka Connect允许你不断地从外部系统提取数据到Kafka，反之亦然。用Kafka整合现有的系统是非常容易的。为了使这个过程更加容易，有数百个这样的连接器现成可用。</p><h3 id="7-使用Kafka-Stream来处理数据"><a href="#7-使用Kafka-Stream来处理数据" class="headerlink" title="7. 使用Kafka Stream来处理数据"></a>7. 使用Kafka Stream来处理数据</h3><p>一旦我们的数据存储在Kafka中，就可以用<a href="">Kafka Streams客户端库</a>来处理这些数据，该库适用于<code>Java/Scala</code>。它允许你实现自己的实时应用程序和微服务，其中输入和/或输出数据存储在Kafka主题中。Kafka Streams将在客户端编写和部署标准Java和Scala应用程序的简单性与Kafka服务器端集群技术的优势相结合，使这些应用程序具有<code>可扩展性</code>、<code>弹性</code>、<code>容错性</code>和<code>分布式</code>。该库支持精确的一次性处理、有状态操作和聚合、窗口化、连接、基于事件时间的处理等等。</p><p>一个初步的体验，实现一个流行的<code>WordCount</code>算法的：</p><pre><code class="lang-java">KStream&lt;String, String&gt; textLines = builder.stream("quickstart-events");KTable&lt;String, Long&gt; wordCounts = textLines            .flatMapValues(line -&gt; Arrays.asList(line.toLowerCase().split(" ")))            .groupBy((keyIgnored, word) -&gt; word)            .count();wordCounts.toStream().to("output-topic", Produced.with(Serdes.String(), Serdes.Long()));</code></pre><h2 id="以系统服务方式启动kafka"><a href="#以系统服务方式启动kafka" class="headerlink" title="以系统服务方式启动kafka"></a>以系统服务方式启动kafka</h2><p>创建 <code>/usr/lib/systemd/system/zookeeper.service</code> 并写入</p><pre><code class="lang-shell">[Unit]Requires=network.targetAfter=network.target[Service]Type=simpleEnvironment="PATH=/opt/jdk-11.0.12/bin:/opt/jdk-11.0.12/jre/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin"LimitNOFILE=1048576ExecStart=/usr/local/kafka/bin/zookeeper-server-start.sh /usr/local/kafka/config/zookeeper.propertiesExecStop=/usr/local/kafka/bin/zookeeper-server-stop.shRestart=Always[Install]WantedBy=multi-user.target</code></pre><p>创建 <code>/usr/lib/systemd/system/kafka.service</code> 并写入</p><pre><code class="lang-shell">[Unit]Requires=zookeeper.serviceAfter=zookeeper.service[Service]Type=simpleEnvironment="PATH=/opt/jdk-11.0.12/bin:/opt/jdk-11.0.12/jre/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin"LimitNOFILE=1048576ExecStart=/usr/local/kafka/bin/kafka-server-start.sh /usr/local/kafka/config/server.propertiesExecStop=/usr/local/kafka/bin/kafka-server-stop.shRestart=Always[Install]WantedBy=multi-user.target</code></pre><p><strong>注意：示例的kafka安装地址在 <code>/usr/local/kafka</code></strong></p><p>因为系统服务不会直接读取我们配置在<code>/etc/profile</code>或者<code>bash_profile</code>中的环境变量，所以<code>Environment</code>一定要记得配置。</p><pre><code class="lang-shell">## 查看当前环境变量export $PATH</code></pre><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>重载系统服务并启动</p><pre><code class="lang-bash">systemctl daemon-reloadsystemctl enable zookeeper &amp;&amp; systemctl enable kafkasystemctl start zookeeper &amp;&amp; systemctl start kafkasystemctl status zookeeper &amp;&amp; systemctl status kafka</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210822223509558.png" alt="zookeeper" title="">                </div>                <div class="image-caption">zookeeper</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210822223415746.png" alt="kafka" title="">                </div>                <div class="image-caption">kafka</div>            </figure><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ol><li><a href="https://zh.wikipedia.org/wiki/Kafka" target="_blank" rel="noopener">维基百科—-kafka</a></li><li><a href="https://www.orchome.com/189" target="_blank" rel="noopener">Kafka教程</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;h3 id=&quot;Kafka简介&quot;&gt;&lt;a href=&quot;#Kafka简介&quot; class=&quot;headerlink&quot; title=&quot;Kafka简介&quot;&gt;&lt;/a&gt;Ka</summary>
      
    
    
    
    <category term="kafka" scheme="https://winniekun.github.io/categories/kafka/"/>
    
    
    <category term="配置" scheme="https://winniekun.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>虚拟内存概览</title>
    <link href="https://winniekun.github.io/virtual-memory/"/>
    <id>https://winniekun.github.io/virtual-memory/</id>
    <published>2021-07-27T06:57:30.000Z</published>
    <updated>2021-08-09T10:11:43.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p><strong>“Any problem in computer science can be solved by another layer of indirection.</strong> </p><p>——<a href="https://book.douban.com/subject/3652388/" target="_blank" rel="noopener">程序员的自我修养</a></p></blockquote><h2 id="物理寻址"><a href="#物理寻址" class="headerlink" title="物理寻址"></a>物理寻址</h2><p>早期，CPU在处理某个进程的时候，处理的流程如下。</p><p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210726165551742.png" alt="物理寻址方式" style="zoom:50%;"></p><p>对于物理寻址而言，我们需要直接将程序全部装入到物理内存中，接下来运行期间，CPU在处理时，直接进行物理寻址。然后执行相关的读写命令。</p><p>对于物理内存而言，是不做任何访问限制的，所以直接操作进行物理寻址会导致一个问题是：</p><ol><li><p>读写内存的安全性问题</p><ol><li>不同的进程被分配到不同的物理内存中，运行期间导致进程A错误修改了进程B占用的物理内存，导致进程B出现问题</li><li>危害操作系统自身的安全。恶意的进程直接修改操作系统所占用的物理空间，导致系统崩溃</li></ol></li><li><p>内存的利用率不高</p><ol><li>一个系统中，不同的进程是共享CPU和物理内存资源的，如果有很多的进程需要很大的内存，那么就会导致这些进程所需的内存大小 &gt; 实际的物理内存，这样就会导致有些有些进程无法被执行。</li></ol></li></ol><p>所以，为了更加有效的管理内存并且少出错，现代的操作系统提供了一种对主存的抽象概念—-<strong>虚拟内存</strong>。<strong>虚拟内存是硬件异常、硬件地址翻译、主存、磁盘和内核软件的完美交互</strong></p><h2 id="虚拟内存概念"><a href="#虚拟内存概念" class="headerlink" title="虚拟内存概念"></a>虚拟内存概念</h2><blockquote><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。<br>现代所有用于一般应用的操作系统都对普通的应用程序使用虚拟内存技术，老一些的操作系统，如DOS和1980年代的Windows，或者那些1960年代的大型机，一般都没有虚拟内存的功能<br>——维基百科</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210726164801304.png" alt="image-20210726164801304" style="zoom: 50%;"></p><p>引入序中所引用的话<strong>Any problem in computer science can be solved by another layer of indirection.</strong> 同理虚拟内存为<code>进程&lt;---&gt;物理内存</code>的中间层，它为进程隐藏了物理内存的概念，同时为其提供了更加简洁易用的接口，供其调用。同时还提供了一些更加复杂的功能。</p><h3 id="能力一：高速缓存"><a href="#能力一：高速缓存" class="headerlink" title="能力一：高速缓存"></a>能力一：高速缓存</h3><p>我们可以将虚拟内存看作是磁盘上的一片空间，当这片空间中的一部分访问比较频繁时，<strong>该部分数据会以页为单位被缓存到主存中</strong>以加速 CPU 访问数据的性能，虚拟内存利用空间较大的磁盘存储作为『内存』并使用主存储缓存进行加速，<strong>让进程认为操作系统的内存很大而且很快，然而区域很大的磁盘并不快，而很快的内存也并不大</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210726225636676.png" alt="虚拟内存作为缓存" title="">                </div>                <div class="image-caption">虚拟内存作为缓存</div>            </figure><p>在虚拟内存中的虚拟页共分为三种类型：</p><ol><li>未分配<ol><li>没有被进程申请使用的，也就是空闲的虚拟内存， 不占用虚拟内存磁盘的任何空间</li></ol></li><li>未缓存<ol><li>仅仅加载到磁盘中的页</li></ol></li><li>已缓存<ol><li>已经加载到内存中的内存页（页框）</li></ol></li></ol><h3 id="能力二：内存管理"><a href="#能力二：内存管理" class="headerlink" title="能力二：内存管理"></a>能力二：内存管理</h3><ul><li><p>简化链接和加载</p></li><li><p>简化内存共享</p><p>将不同的进程中的页表中某些页表项映射到相同的物理地址，即可实现内存的共享。</p></li><li><p>简化内存分配</p><p>独立的虚拟内存空间也会简化内存的分配过程，当用户程序向操作系统申请堆内存时，操作系统可以分配几个连续的虚拟页，但是这些虚拟页可以对应到物理内存中不连续的页中。</p></li></ul><h3 id="能力三：内存保护"><a href="#能力三：内存保护" class="headerlink" title="能力三：内存保护"></a>能力三：内存保护</h3><p>现代操作系统中，用户进程不应该被允许修改它的只读代码段，而且也不应该允许它读取或修改任何内核中的代码和数据结构，并且也不允许其读取或者修改其他进程的私有内存，以及修改和其他进程共享的虚拟页面。如果不对进程的内存访问进行限制，攻击者就能够访问和修改其他进程的私有内存，进而导致整个系统崩溃。</p><p>通过虚拟内存，我们为进程提供了独立的地址空间，同时这也让我们能够快速的区分不同进程的私有内存。同时我们通过虚拟内存到实际的物理内存的转化需要使用地址翻译机制，整体流程如下所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210727001028167.png" alt="虚拟寻址方式" title="">                </div>                <div class="image-caption">虚拟寻址方式</div>            </figure><p>通过MMU，每次都会读取页表中的一个页表条目(PTE)，通过在这些页表条目(PTE)中添加一些标志位，就能够实现对一个虚拟页的访问控制权限。譬如：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210727002025494.png" alt="带标志位的页表" title="">                </div>                <div class="image-caption">带标志位的页表</div>            </figure><h2 id="应用程序如何如何使用和管理虚拟内存"><a href="#应用程序如何如何使用和管理虚拟内存" class="headerlink" title="应用程序如何如何使用和管理虚拟内存"></a>应用程序如何如何使用和管理虚拟内存</h2><ul><li>[ ] TODO </li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虚拟内存的思想，整体来看就是：通过结合磁盘和内存各自的优势，<strong>利用中间层对资源进行更合理地调度，充分提高资源的利用率。并提供和谐以及统一的抽象</strong>。个人目前接触到的最直观的体现就是 JDK中集合类的设计与实现。其也可以算是数据和数据结构之间的中间层，结合其他的技术譬如泛型，为上层的数据提供了接口的同时，隐藏了内部数据结构的实现以及维护。</p><p>最后再总结下为什么需要虚拟内存：</p><ul><li>虚拟内存可以结合磁盘和物理内存的优势为进程提供看起来速度足够快并且容量足够大的存储；</li><li>虚拟内存可以为进程提供独立的内存空间并引入多层的页表结构将虚拟内存翻译成物理内存，进程之间可以共享物理内存减少开销，也能简化程序的链接、装载以及内存分配过程；</li><li>虚拟内存可以控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性；</li></ul><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li>csapp 第九章</li><li>操作系统导论 内存虚拟化部分</li><li><a href="https://draveness.me/whys-the-design-os-virtual-memory/" target="_blank" rel="noopener">为什么Linux需要虚拟内存</a></li><li><a href="https://zhuanlan.zhihu.com/p/96098896" target="_blank" rel="noopener">如何理解虚拟内存</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;“Any problem in computer science can be solved by ano</summary>
      
    
    
    
    <category term="操作系统" scheme="https://winniekun.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="内存管理" scheme="https://winniekun.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap源码分析</title>
    <link href="https://winniekun.github.io/concurrenthashmap-analysis/"/>
    <id>https://winniekun.github.io/concurrenthashmap-analysis/</id>
    <published>2021-07-19T10:40:55.000Z</published>
    <updated>2021-07-19T13:56:53.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>ConcurrentHashMap，可以理解成是HashMap的线程安全版本，同样的，内部使用也是（数组 + 链表 + 红黑树）的结构来存储元素。同时相比于同样提供线程安全的HashTable，效率等各方面都有所提升</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/ConcurrentHashMap.png" alt="ConcurrentHashMap" title="">                </div>                <div class="image-caption">ConcurrentHashMap</div>            </figure><h2 id="阅读套路"><a href="#阅读套路" class="headerlink" title="阅读套路"></a>阅读套路</h2><p>按照正常的逻辑， 首先基础的数据构造, 然后了解其构造方法， 之后了解常用的API(CRUD)操作即可。</p><ul><li>[x] 增</li><li>[x] 删</li><li>[x] 改</li><li>[x] 查</li></ul><h2 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h2><pre><code class="lang-java">// 和hashmap类似transient volatile Node&lt;K,V&gt;[] table;// 用于并发情况下的扩容控制private transient volatile Node&lt;K,V&gt;[] nextTable;// 并发安全控制private transient volatile long baseCount;private transient volatile int sizeCtl;private transient volatile int transferIndex;private transient volatile int cellsBusy;private transient volatile CounterCell[] counterCells;// viewsprivate transient KeySetView&lt;K,V&gt; keySet;private transient ValuesView&lt;K,V&gt; values;private transient EntrySetView&lt;K,V&gt; entrySet;private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * The default initial table capacity.  Must be a power of 2 * (i.e., at least 1) and at most MAXIMUM_CAPACITY. */private static final int DEFAULT_CAPACITY = 16;/** * The largest possible (non-power of two) array size. * Needed by toArray and related methods. */static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * The default concurrency level for this table. Unused but * defined for compatibility with previous versions of this class. */private static final int DEFAULT_CONCURRENCY_LEVEL = 16;/** * The load factor for this table. Overrides of this value in * constructors affect only the initial table capacity.  The * actual floating point value isn't normally used -- it is * simpler to use expressions such as {@code n - (n &gt;&gt;&gt; 2)} for * the associated resizing threshold. */private static final float LOAD_FACTOR = 0.75f;/** * The bin count threshold for using a tree rather than list for a * bin.  Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2, and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */static final int TREEIFY_THRESHOLD = 8;/** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */static final int UNTREEIFY_THRESHOLD = 6;/** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * The value should be at least 4 * TREEIFY_THRESHOLD to avoid * conflicts between resizing and treeification thresholds. */static final int MIN_TREEIFY_CAPACITY = 64;/** * Minimum number of rebinnings per transfer step. Ranges are * subdivided to allow multiple resizer threads.  This value * serves as a lower bound to avoid resizers encountering * excessive memory contention.  The value should be at least * DEFAULT_CAPACITY. */private static final int MIN_TRANSFER_STRIDE = 16;/** * The number of bits used for generation stamp in sizeCtl. * Must be at least 6 for 32bit arrays. */private static int RESIZE_STAMP_BITS = 16;/** * The maximum number of threads that can help resize. * Must fit in 32 - RESIZE_STAMP_BITS bits. */private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;/** * The bit shift for recording size stamp in sizeCtl. */private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;/* * Encodings for Node hash fields. See above for explanation. */static final int MOVED     = -1; // hash for forwarding nodesstatic final int TREEBIN   = -2; // hash for roots of treesstatic final int RESERVED  = -3; // hash for transient reservationsstatic final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash/** Number of CPUS, to place bounds on some sizings */static final int NCPU = Runtime.getRuntime().availableProcessors();</code></pre><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><pre><code class="lang-java">public ConcurrentHashMap() {}public ConcurrentHashMap(int initialCapacity) {    if (initialCapacity &lt; 0)        throw new IllegalArgumentException();    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?               MAXIMUM_CAPACITY :               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));    this.sizeCtl = cap;}public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) {    this.sizeCtl = DEFAULT_CAPACITY;    putAll(m);}public ConcurrentHashMap(int initialCapacity, float loadFactor) {    this(initialCapacity, loadFactor, 1);}public ConcurrentHashMap(int initialCapacity,                         float loadFactor, int concurrencyLevel) {    if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)        throw new IllegalArgumentException();    if (initialCapacity &lt; concurrencyLevel)   // Use at least as many bins        initialCapacity = concurrencyLevel;   // as estimated threads    long size = (long)(1.0 + (long)initialCapacity / loadFactor);    int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?        MAXIMUM_CAPACITY : tableSizeFor((int)size);    this.sizeCtl = cap;}</code></pre><p>构造方法与HashMap对比可以发现，没有了HashMap中的threshold和loadFactor，而是改用了sizeCtl来控制，而且只存储了容量在里面，那么它是怎么用的呢？官方给出的解释如下：</p><pre><code>Table initialization and resizing control.  When negative, thetable is being initialized or resized: -1 for initialization,else -(1 + the number of active resizing threads).  Otherwise,when table is null, holds the initial table size to use uponcreation, or 0 for default. After initialization, holds thenext element count value upon which to resize the table.</code></pre><ol><li>-1 有线程正在初始化</li><li>-(1 + n) 有n个线程正在一起扩容</li><li>0 默认值， 后续在真正初始化的时候使用默认容量</li><li><code>&gt;0</code> 初始化或扩容完成后下一次的扩容门槛</li></ol><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><pre><code class="lang-java">public V put(K key, V value) {    return putVal(key, value, false);}/** Implementation for put and putIfAbsent */final V putVal(K key, V value, boolean onlyIfAbsent) {      // key和value都不能为null    if (key == null || value == null) throw new NullPointerException();    // 计算hash值      int hash = spread(key.hashCode());    // 要插入的元素所在桶的元素个数    int binCount = 0;    // 死循环，结合CAS使用（如果CAS失败，则会重新取整个桶进行下面的流程）    for (Node&lt;K,V&gt;[] tab = table;;) {        Node&lt;K,V&gt; f; int n, i, fh;        if (tab == null || (n = tab.length) == 0)            // 如果桶未初始化或者桶个数为0，则初始化桶            tab = initTable();        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {            // 如果要插入的元素所在的桶还没有元素，则把这个元素插入到这个桶中            if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null)))                // 如果使用CAS插入元素时，发现已经有元素了，则进入下一次循环，重新操作                // 如果使用CAS插入元素成功，则break跳出循环，流程结束                break;                   // no lock when adding to empty bin        }        else if ((fh = f.hash) == MOVED)            // 如果要插入的元素所在的桶的第一个元素的hash是MOVED，则当前线程帮忙一起迁移元素            tab = helpTransfer(tab, f);        else {            // 如果这个桶不为空且不在迁移元素，则锁住这个桶（分段锁）            // 并查找要插入的元素是否在这个桶中            // 存在，则替换值（onlyIfAbsent=false）            // 不存在，则插入到链表结尾或插入树中            V oldVal = null;            synchronized (f) {                // 再次检测第一个元素是否有变化，如果有变化则进入下一次循环，从头来过                if (tabAt(tab, i) == f) {                    // 如果第一个元素的hash值大于等于0（说明不是在迁移，也不是树）                    // 那就是桶中的元素使用的是链表方式存储                    if (fh &gt;= 0) {                        // 桶中元素个数赋值为1                        binCount = 1;                        // 遍历整个桶，每次结束binCount + 1                        for (Node&lt;K,V&gt; e = f;; ++binCount) {                            K ek;                            // 在链表中找到了改元素，覆盖 并退出                            if (e.hash == hash &amp;&amp;                                ((ek = e.key) == key ||                                 (ek != null &amp;&amp; key.equals(ek)))) {                                oldVal = e.val;                                if (!onlyIfAbsent)                                    e.val = value;                                break;                            }                            // 如果没有找到 则 直接在尾部插入改元素                            Node&lt;K,V&gt; pred = e;                            if ((e = e.next) == null) {                                pred.next = new Node&lt;K,V&gt;(hash, key,                                                          value, null);                                break;                            }                        }                    }                    // 树上找点                    else if (f instanceof TreeBin) {                        Node&lt;K,V&gt; p;                        binCount = 2;                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                                       value)) != null) {                            oldVal = p.val;                            if (!onlyIfAbsent)                                p.val = value;                        }                    }                }            }            // 如果binCount不为0，说明成功插入了元素或者寻找到了元素            if (binCount != 0) {                // 如果链表元素个数达到了8，则尝试树化                // 因为上面把元素插入到树中时，binCount只赋值了2，并没有计算整个树中元素的个数                // 所以不会重复树化                if (binCount &gt;= TREEIFY_THRESHOLD)                    treeifyBin(tab, i);                if (oldVal != null)                    return oldVal;                break;            }        }    }    // 成功插入元素，元素个数加1（是否要扩容在这个里面）    addCount(1L, binCount);    return null;}</code></pre><p><strong>流程和hashmap类似：</strong></p><ol><li>如果hash桶未初始化，则先初始化</li><li>如果当前位置无元素，则通过cas的方式放入元素</li><li>如果当前位置存在元素<ol><li>是转移节点（正在扩容），则将当前线程一起加入到扩容中</li><li>不是转移节点，锁这个桶<ol><li>如果为链表节点，进行在链表上查找该元素，找到？覆盖：执行插入操作</li><li>如果为树节点，在红黑树中查找该元素，找到？覆盖：执行插入操作</li></ol></li></ol></li><li>存在该元素时，返回旧value</li><li>不存在，整个map的元素+ 1，并检查是否需要扩容</li></ol><p><strong>因为是线程安全的操作，所以仔细看下在整个put阶段，采用了哪些手段保证线程安全。这个才是我们看CHM源码的关键</strong></p><h3 id="数组初始化时的线程安全措施"><a href="#数组初始化时的线程安全措施" class="headerlink" title="数组初始化时的线程安全措施"></a>数组初始化时的线程安全措施</h3><pre><code class="lang-java">private final Node&lt;K,V&gt;[] initTable() {    Node&lt;K,V&gt;[] tab; int sc;    while ((tab = table) == null || tab.length == 0) {        // 小于 0 代表有线程正在初始化，释放当前 CPU 的调度权，重新发起锁的竞争        if ((sc = sizeCtl) &lt; 0)            Thread.yield(); // lost initialization race; just spin        // CAS 赋值保证当前只有一个线程在初始化，        // -1  代表当前只有一个线程能初始化         // 保证了数组的初始化的安全性        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {            try {                                              // 很有可能执行到这里的时候，table 已经不为空了，这里是双重 check                              // 如果把sizeCtl原子更新为-1成功，则当前线程进入初始化                // 如果原子更新失败则说明有其它线程先一步进入初始化了，则进入下一次循环                           // 如果下一次循环时还没初始化完毕，则sizeCtl&lt;0进入上面if的逻辑让出CPU                           // 如果下一次循环更新完毕了，则table.length!=0，退出循环                if ((tab = table) == null || tab.length == 0) {                    // 进行初始化                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;                    @SuppressWarnings("unchecked")                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];                    table = tab = nt;                    sc = n - (n &gt;&gt;&gt; 2);                }            } finally {                sizeCtl = sc;            }            break;        }    }    return tab;}</code></pre><p><strong>小总结</strong></p><p>数组初始化时：</p><ol><li><p>使用CAS锁控制只有一个线程初始化桶数组并且一定能初始化成功；</p></li><li><p>然后通过 CAS 设置 sizeCtl 变量的值，来保证同一时刻只能有一个线程对数组进行初始化，CAS 成功之后，还会再次判断当前数组 是否已经初始化完成，如果已经初始化完成，就不会继续再执行初始化</p></li><li><p>扩容门槛写死的是桶数组大小的0.75倍，桶数组大小即map的容量，也就是最多存储多少个元素。</p></li></ol><p><strong>通过自旋 + cas + double check 保障了数组初始化时的线程安全。</strong></p><h4 id="Java线程中的一些方法的区别（sleep、yield、wait、join）"><a href="#Java线程中的一些方法的区别（sleep、yield、wait、join）" class="headerlink" title="Java线程中的一些方法的区别（sleep、yield、wait、join）"></a>Java线程中的一些方法的区别（sleep、yield、wait、join）</h4><p>只有runnable到running时才会占用cpu时间片，其他都会出让cpu时间片。<br>线程的资源有不少，整体来看可分为如下两类</p><ol><li>CPU资源</li><li>锁资源</li></ol><p>分析以上四个方法时，查看这两个共享资源是否释放，区分更加明显</p><ol><li><p>sleep：Thread类的方法，必须带一个时间参数。<strong>会让当前线程休眠进入阻塞状态并释放CPU（阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段）</strong>，提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁 可通过调用interrupt()方法来唤醒休眠线程。</p></li><li><p>yield：<strong>让出CPU调度</strong>，Thread类的方法，类似sleep只是<strong>不能由用户指定暂停多长时间 ，</strong>并且yield()方法<strong>只能让同优先级的线程</strong>有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入<strong>到可执行状态后</strong>马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。 </p></li><li><p>wait：Object类的方法(notify()、notifyAll()  也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁</p></li><li><p>join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。</p></li></ol><h3 id="在桶位置放入元素时的线程安全措施（4个措施）"><a href="#在桶位置放入元素时的线程安全措施（4个措施）" class="headerlink" title="在桶位置放入元素时的线程安全措施（4个措施）"></a>在桶位置放入元素时的线程安全措施（4个措施）</h3><pre><code class="lang-java">else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {    if (casTabAt(tab, i, null,                 new Node&lt;K,V&gt;(hash, key, value, null)))        break;                   // no lock when adding to empty bin}static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) {    return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);}</code></pre><ol><li><p>通过自旋死循环保证一定可以新增成功 1⃣️</p><ol><li>在新增之前，通过==for (Node[] tab = table;;)==这样的死循环来保证新增一定可以成功，一旦新增成功，就可以退出当前死循环，新增失败的话，会重复新增的步骤，直到新增成功为止。</li></ol></li><li><p>当前hash桶是否有元素：</p><ol><li><p>无元素 cas 新增 2⃣️</p><p>Java 这里的写法非常严谨，没有在判断槽点为空的情况下直接赋值，因为在判断槽点为空和赋 值的瞬间，很有可能槽点已经被其他线程赋值了，所以我们采用 CAS 算法，能够保证槽点为空 的情况下赋值成功，如果恰好槽点已经被其他线程赋值，当前 CAS 操作失败，会再次执行 for 自旋，再走槽点有值的 put 流程，这里就是自旋 + CAS 的结合。</p></li><li><p>有元素 锁住当前点  （synchronized）3⃣️</p><p>put 时，如果当前槽点有值，就是 key 的 hash 冲突的情况，此时槽点上可能是链表或红黑树， 我们通过锁住槽点，来保证同一时刻只会有一个线程能对槽点进行修改</p></li></ol></li><li><p>红黑树旋转时， 锁住红黑树的根节点，保证同一时刻，当前红黑树只能被一个线程旋转 4⃣️</p></li></ol><h3 id="扩容时的线程安全措施"><a href="#扩容时的线程安全措施" class="headerlink" title="扩容时的线程安全措施"></a>扩容时的线程安全措施</h3><p>ConcurrentHashMap 的扩容时机和 HashMap 相同，都是在 put 方法的最后一步检查是否需要扩 容，如果需要则进行扩容，但两者扩容的过程完全不同，ConcurrentHashMap 扩容的方法叫做 transfer，从 put 方法的 addCount 方法进去，就能找到 transfer 方法</p><pre><code class="lang-java">private final void addCount(long x, int check) {    CounterCell[] as; long b, s;      // 这里使用的思想跟LongAdder类是一模一样的（后面会讲）        // 把数组的大小存储根据不同的线程存储到不同的段上（也是分段锁的思想）        // 并且有一个baseCount，优先更新baseCount，如果失败了再更新不同线程对应的段        // 这样可以保证尽量小的减少冲突        // 先尝试把数量加到baseCount上，如果失败再加到分段的CounterCell上    if ((as = counterCells) != null ||        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {        CounterCell a; long v; int m;        boolean uncontended = true;        if (as == null || (m = as.length - 1) &lt; 0 ||            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||            !(uncontended =              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {            fullAddCount(x, uncontended);            return;        }        if (check &lt;= 1)            return;        s = sumCount();    }    if (check &gt;= 0) {        Node&lt;K,V&gt;[] tab, nt; int n, sc;        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;               (n = tab.length) &lt; MAXIMUM_CAPACITY) {            int rs = resizeStamp(n);            if (sc &lt; 0) {                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||                    transferIndex &lt;= 0)                    break;                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))                    transfer(tab, nt);            }            else if (U.compareAndSwapInt(this, SIZECTL, sc,                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))                transfer(tab, null);            s = sumCount();        }    }}// 真正触发扩容的方式// 扩容主要分 2 步，// 1. 第一新建新的空数组，// 2. 第二移动拷贝每个元素到新数组中去 // tab:原数组，nextTab:新数组private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) {    // 老数组的长度    int n = tab.length, stride;    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)        stride = MIN_TRANSFER_STRIDE; // subdivide range    // 如果新数组为空，初始化，大小为原数组的两倍，n &lt;&lt; 1    if (nextTab == null) {            // initiating        try {            @SuppressWarnings("unchecked")            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];            nextTab = nt;        } catch (Throwable ex) {      // try to cope with OOME            sizeCtl = Integer.MAX_VALUE;            return;        }        nextTable = nextTab;        transferIndex = n;    }    // 新的table长度    int nextn = nextTab.length;    // 代表转移节点，如果原数组上是转移节点，说明该节点正在被扩容 (node的hash值为-1)    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);    boolean advance = true;    boolean finishing = false; // to ensure sweep before committing nextTab    // 无限自旋，i 的值会从原数组的最大值开始，慢慢递减到 0    for (int i = 0, bound = 0;;) {        Node&lt;K,V&gt; f; int fh;        while (advance) {            int nextIndex, nextBound;            // 结束循环的标志            if (--i &gt;= bound || finishing)                advance = false;            // 已经拷贝完成            else if ((nextIndex = transferIndex) &lt;= 0) {                i = -1;                advance = false;            }            // 每次减少 i 的值            else if (U.compareAndSwapInt                     (this, TRANSFERINDEX, nextIndex,                      nextBound = (nextIndex &gt; stride ?                                   nextIndex - stride : 0))) {                bound = nextBound;                i = nextIndex - 1;                advance = false;            }        }        // if 任意条件满足说明拷贝结束了        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {            int sc;            // 拷贝结束，直接赋值，因为每次拷贝完一个节点，都在原数组上放转移节点，所以拷 贝完成的节点的数据一定不会再发生变化。            // 原数组发现是转移节点，是不会操作的，会一直等待转移节点消失之后在进行操作。                      // 也就是说数组节点一旦被标记为转移节点，是不会再发生任何变动的，所以不会有任 何线程安全的问题                        // 所以此处直接赋值，没有任何问题。            if (finishing) {                nextTable = null;                table = nextTab;                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);                return;            }            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)                    return;                finishing = advance = true;                i = n; // recheck before commit            }        }        else if ((f = tabAt(tab, i)) == null)            advance = casTabAt(tab, i, null, fwd);        else if ((fh = f.hash) == MOVED)            advance = true; // already processed        else {            // 进行节点的拷贝            synchronized (f) {                if (tabAt(tab, i) == f) {                    Node&lt;K,V&gt; ln, hn;                    if (fh &gt;= 0) {                        int runBit = fh &amp; n;                        Node&lt;K,V&gt; lastRun = f;                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) {                            int b = p.hash &amp; n;                            if (b != runBit) {                                runBit = b;                                lastRun = p;                            }                        }                        if (runBit == 0) {                            ln = lastRun;                            hn = null;                        }                        else {                            hn = lastRun;                            ln = null;                        }                        // 桶内只有的单个数据， 直接拷贝，为链表，循环多次形成链表拷贝                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) {                            int ph = p.hash; K pk = p.key; V pv = p.val;                            if ((ph &amp; n) == 0)                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);                            else                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);                        }                        // 在新数组位置上放置拷贝的值                        setTabAt(nextTab, i, ln);                        setTabAt(nextTab, i + n, hn);                        // 在老数组位置上放上 ForwardingNode 节点                        // put 时，发现是 ForwardingNode 节点，就不会再动这个节点的数                        setTabAt(tab, i, fwd);                        advance = true;                    }                    // 红黑树的拷贝                    else if (f instanceof TreeBin) {                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;                        TreeNode&lt;K,V&gt; lo = null, loTail = null;                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;                        int lc = 0, hc = 0;                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) {                            int h = e.hash;                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;                                (h, e.key, e.val, null, null);                            if ((h &amp; n) == 0) {                                if ((p.prev = loTail) == null)                                    lo = p;                                else                                    loTail.next = p;                                loTail = p;                                ++lc;                            }                            else {                                if ((p.prev = hiTail) == null)                                    hi = p;                                else                                    hiTail.next = p;                                hiTail = p;                                ++hc;                            }                        }                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;                        setTabAt(nextTab, i, ln);                        setTabAt(nextTab, i + n, hn);                        setTabAt(tab, i, fwd);                        advance = true;                    }                }            }        }    }}</code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>transfer方法的主要思路：</p><ol><li>首先需要把老数组的值全部拷贝到扩容之后的新数组上，先从数组的队尾开始拷贝</li><li>拷贝数组的槽点时，先把原数组槽点锁住，保证原数组槽点不能操作，成功拷贝到新数组时， 把原数组槽点赋值为转移节点</li><li>这时如果有新数据正好需要 put 到此槽点时，发现槽点为转移节点，就会一直等待，所以在 扩容完成之前，该槽点对应的数据是不会发生变化的</li><li>从数组的尾部拷贝到头部，每拷贝成功一次，就把原数组中的节点设置成转移节点;</li><li>直到所有数组数据都拷贝到新数组时，直接把新数组整个赋值给数组容器，拷贝完成。</li></ol><p>通过在原数组上设置转移节点，put 时碰到转移节点时会等待扩容成 功之后才能 put 的策略，来保证了整个扩容过程中肯定是线程安全的，因为数组的槽点一旦被设 置成转移节点，在没有扩容完成之前，是无法进行操作的。</p><p>（1）新桶数组大小是旧桶数组的两倍；</p><p>（2）迁移元素先从靠后的桶开始；</p><p>（3）迁移完成的桶在里面放置一ForwardingNode类型的元素，标记该桶迁移完成；</p><p>（4）迁移时根据hash&amp;n是否等于0把桶中元素分化成两个链表或树；</p><p>（5）低位链表（树）存储在原来的位置；</p><p>（6）高们链表（树）存储在原来的位置加n的位置；</p><p>（7）迁移元素时会锁住当前桶，也是分段锁的思想；</p><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>（1）ConcurrentHashMap是HashMap的线程安全版本；</p><p>（2）ConcurrentHashMap采用（数组 + 链表 + 红黑树）的结构存储元素；</p><p>（3）ConcurrentHashMap相比于同样线程安全的HashTable，效率要高很多；</p><p>（4）ConcurrentHashMap采用的锁有 synchronized，CAS，自旋锁，分段锁，volatile等；</p><p>（5）ConcurrentHashMap中没有threshold和loadFactor这两个字段，而是采用sizeCtl来控制；</p><p>（6）sizeCtl = -1，表示正在进行初始化；</p><p>（7）sizeCtl = 0，默认值，表示后续在真正初始化的时候使用默认容量；</p><p>（8）sizeCtl &gt; 0，在初始化之前存储的是传入的容量，在初始化或扩容后存储的是下一次的扩容门槛；</p><p>（9）sizeCtl = (resizeStamp &lt;&lt; 16) + (1 + nThreads)，表示正在进行扩容，高位存储扩容邮戳，低位存储扩容线程数加1；</p><p>（10）更新操作时如果正在进行扩容，当前线程协助扩容；</p><p>（11）更新操作会采用synchronized锁住当前桶的第一个元素，这是分段锁的思想；</p><p>（12）整个扩容过程都是通过CAS控制sizeCtl这个字段来进行的，这很关键；</p><p>（13）迁移完元素的桶会放置一个ForwardingNode节点，以标识该桶迁移完毕；</p><p>（14）元素个数的存储也是采用的分段思想，类似于LongAdder的实现；</p><p>（15）元素个数的更新会把不同的线程hash到不同的段上，减少资源争用；</p><p>（16）元素个数的更新如果还是出现多个线程同时更新一个段，则会扩容段（CounterCell）；</p><p>（17）获取元素个数是把所有的段（包括baseCount和CounterCell）相加起来得到的；</p><p>（18）查询操作是不会加锁的，所以ConcurrentHashMap不是强一致性的；</p><p>（19）ConcurrentHashMap中不能存储key或value为null的元素；</p><h3 id="一些思想"><a href="#一些思想" class="headerlink" title="一些思想"></a>一些思想</h3><ol><li>cas + 自选 乐观锁的思想，减少线程上下文切换的时间</li><li>分段锁思想，减少同一时间 竞争锁带来的低效问题</li><li>CounterCell，分段存储元素，减少多线程同时更新一个字段带来的低效</li><li>多线程协同进行扩容</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;ConcurrentHashMap，可以理解成是HashMap的线程安全版本，同样的，内部使用也是（数组 + 链表 + 红黑树）的结构来存储元素。同</summary>
      
    
    
    
    <category term="源码" scheme="https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="jdk" scheme="https://winniekun.github.io/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>kafka-consumer-note</title>
    <link href="https://winniekun.github.io/kafka-consumer-note/"/>
    <id>https://winniekun.github.io/kafka-consumer-note/</id>
    <published>2021-07-02T08:32:01.000Z</published>
    <updated>2021-08-28T05:45:49.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mathjax"><a href="#Mathjax" class="headerlink" title="Mathjax"></a>Mathjax</h2><p>$m_i = a ^ {21}$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Mathjax&quot;&gt;&lt;a href=&quot;#Mathjax&quot; class=&quot;headerlink&quot; title=&quot;Mathjax&quot;&gt;&lt;/a&gt;Mathjax&lt;/h2&gt;&lt;p&gt;$m_i = a ^ {21}$&lt;/p&gt;
</summary>
      
    
    
    
    <category term="中间件" scheme="https://winniekun.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="kafka" scheme="https://winniekun.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码解读</title>
    <link href="https://winniekun.github.io/threadlocal-analysis/"/>
    <id>https://winniekun.github.io/threadlocal-analysis/</id>
    <published>2021-05-27T13:21:59.000Z</published>
    <updated>2021-09-08T13:19:53.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>多线程共享可变数据时，涉及到线程见同步的问题，并不是所有的时候，都要用到共享数据，所以就需要线程封闭出场了。数据都被封闭在各自的线程之中，就不需要进行同步，这种通过将数据封闭在线程内而避免使用同步的技术称之为<strong>线程封闭</strong>。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>线程间数据隔离，各线程的 ThreadLocal 互不影响</li><li>方便同一个线程使用某一对象，避免不必要的参数传递</li><li>全链路追踪中的 traceId 或者流程引擎中上下文的传递一般采用 ThreadLocal</li><li>Spring 事务管理器采用了 ThreadLocal</li><li>Spring MVC 的 RequestContextHolder 的实现使用了 ThreadLocal</li></ul><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><pre><code class="lang-java">public class ThreadLocalDemo {    public static final ThreadLocal&lt;String&gt; THREAD_LOCAL = new ThreadLocal&lt;&gt;();    public static final ThreadLocal&lt;String&gt; THREAD_LOCAL_NEXT = new ThreadLocal&lt;&gt;();    @Test    public void demo() {        new ThreadLocalDemo().threadLocalTest();    }    public void threadLocalTest() {        THREAD_LOCAL.set("wkk");        THREAD_LOCAL_NEXT.set("cjsq");        String v = THREAD_LOCAL.get();        String v2 = THREAD_LOCAL_NEXT.get();        System.out.println("子线程 执行前， " + Thread.currentThread().getName() + "线程取到的值：" + v + " " + v2);        Thread child = new Thread(new Runnable() {            @Override            public void run() {                String v = THREAD_LOCAL.get();                String v2 = THREAD_LOCAL_NEXT.get();                System.out.println(Thread.currentThread().getName() + "线程取到的值：" + v + v2);                // 设置 threadLocal                THREAD_LOCAL.set("hhh");                THREAD_LOCAL_NEXT.set("cjpl");                v = THREAD_LOCAL.get();                v2 = THREAD_LOCAL_NEXT.get();                System.out.println("重新设置之后，" + Thread.currentThread().getName() + "线程取到的值为：" + v + " " + v2);                System.out.println(Thread.currentThread().getName() + "线程执行结束");            }        }, "子线程");        child.start();        try {            child.join();        } catch (InterruptedException e) {            e.printStackTrace();        }        v = THREAD_LOCAL.get();        v2 = THREAD_LOCAL_NEXT.get();        System.out.println("子线程线程执行之后，" + Thread.currentThread().getName() + "线程取到的值：" + v + " " + v2);    }}</code></pre><p><strong>输出</strong></p><pre><code class="lang-java">子线程 执行前， main线程取到的值：wkk cjsq子线程线程取到的值：nullnull重新设置之后，子线程线程取到的值为：hhh cjpl子线程线程执行结束子线程线程执行之后，main线程取到的值：wkk cjsq</code></pre><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><pre><code class="lang-java">// Thread类ThreadLocal.ThreadLocalMap threadLocals = null;// 当前threadlocal的hashcode// 用于用于计算该ThreadLocal在线程的threadlocals（map）中的索引位置private final int threadLocalHashCode = nextHashCode();// hash表的阈值，黄金分割比private static final int HASH_INCREMENT = 0x61c88647;// 保证了在一台机器中每个 ThreadLocal 的 threadLocalHashCode 是唯一的private static AtomicInteger nextHashCode = new AtomicInteger();// 用于当前threadlocal的hashcodeprivate static int nextHashCode() {    return nextHashCode.getAndAdd(HASH_INCREMENT);}// 初始话的操作protected T initialValue() {    return null;}// lambda的初始化实现public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) {    return new SuppliedThreadLocal&lt;&gt;(supplier);}</code></pre><h3 id="HashCode散列成果验证"><a href="#HashCode散列成果验证" class="headerlink" title="HashCode散列成果验证"></a>HashCode散列成果验证</h3><p>可以通过和String的hashcode做个对比，然后验证其使用这种方式的hash结果如何</p><pre><code class="lang-java">private static AtomicInteger nextHashCode = new AtomicInteger();private static final int HASH_INCREMENT = 0x61c88647;private static final int SIZE = 32;private static int nextHashCode() {    return nextHashCode.getAndAdd(HASH_INCREMENT);}@Testpublic void test_idx() {    int hashCode = 0;    Set&lt;Integer&gt; setThreadLocal = new HashSet&lt;&gt;();    Set&lt;Integer&gt; setNormal = new HashSet&lt;&gt;();    for (int i = 0; i &lt; SIZE; i++) {        hashCode = nextHashCode();        int threadLocalHashCode = hashCode &amp; (SIZE - 1);        int normalHashCode = String.valueOf(i).hashCode() &amp; (SIZE - 1);        setThreadLocal.add(threadLocalHashCode);        setNormal.add(normalHashCode);        System.out.println(i + " ThreadLocal的散列：" + threadLocalHashCode + " 普通散列：" + normalHashCode);    }    double threadLocalRate = setThreadLocal.size() / (double)SIZE * 100;    double normalRate = setNormal.size() / (double)SIZE * 100;    System.out.println("ThreadLocal的散列：" + threadLocalRate + "% " + " 普通散列：" + normalRate + "% ");}// ThreadLocal的散列：100.0%  普通散列：68.75%</code></pre><h3 id="形象理解"><a href="#形象理解" class="headerlink" title="形象理解"></a>形象理解</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210527191351975.png" alt="ThreadLocal形象理解" title="">                </div>                <div class="image-caption">ThreadLocal形象理解</div>            </figure><p>如果类比为HashMap的话，我们可以将<code>threadlocal</code>类比为<code>key</code>，然后<code>被封闭的数据</code>类比为<code>value</code>。不过稍微不同的是，hashmap中将<code>key</code>和<code>value</code>做映射的操作是<code>map.put(key, value)</code>，而<code>threadlocals</code>中，将<code>threadlocal</code>和<code>被封闭的数据</code>做映射的操作是<code>threadlocal.set(xxx)</code>。</p><h4 id="思路转换"><a href="#思路转换" class="headerlink" title="思路转换"></a>思路转换</h4><p>emmmm怎么说呢，就是我们使用普通map的时候，操作的是一个map，获取key的value时，直接通过map.get()即可。</p><p>但是我们使用threadlocal时，其本身是一个key，怎么获取对应的value呢？</p><ol><li>先获取map（每个线程独有的map，所以根据当前线程获取map）</li><li>然后通过map.get(key)获取value</li><li>返回value</li></ol><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><pre><code class="lang-java">static class ThreadLocalMap {    /**     * The entries in this hash map extend WeakReference, using     * its main ref field as the key (which is always a     * ThreadLocal object).  Note that null keys (i.e. entry.get()     * == null) mean that the key is no longer referenced, so the     * entry can be expunged from table.  Such entries are referred to     * as "stale entries" in the code that follows.     */    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {        /** The value associated with this ThreadLocal. */        Object value;        Entry(ThreadLocal&lt;?&gt; k, Object v) {            super(k);            value = v;        }    }  // 下面的成员变量和hashmap同理  // 初始化容量    private static final int INITIAL_CAPACITY = 16;    // 存储ThreadLocal的键值对，长度为2的幂次    private Entry[] table;    /**     * The number of entries in the table.     */    private int size = 0;    /**     * The next size value at which to resize.     */    private int threshold; // Default to 0}</code></pre><p>ThreadLocalMap就是一个map，和hashmap类似，不过有些机制不同。</p><ul><li>hash冲突解决方式<ol><li>ThreadLocalMap处理hash冲突的方式为线型探测</li><li>HashMap使用的是拉链法</li></ol></li></ul><h3 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h3><p>根据注释和代码，了解到了ThreadLocalMap内部的每个entry中，key设置为<strong>弱引用</strong>的原因，不过value还是正常的引用。这也就导致了如果ThreadLocal没有外部的强引用时，只要发生GC，就会被回收。这样ThreadMap中的key就变成了null，<strong>但是value被Entry引用，Entry被ThreadLocalMap引用，ThreadLocalMap被Thread引用，这也就说明了只要，线程不终止，value的值一直无法被回收，所以可能会出现内存泄漏的现象</strong></p><p>为了避免这种情况，在需要使用threadlocal之后，需要我们手动remove掉。防止 ThreadLocalMap 中 Entry 一直保持对 value 的强引用，导致 value 不能被回收</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><pre><code class="lang-java">public void remove() {    ThreadLocalMap m = getMap(Thread.currentThread());    if (m != null)        m.remove(this);}// 根据当前线程获取其mapThreadLocalMap getMap(Thread t) {    return t.threadLocals;}// 因为使用的线型探测法// 所以要采用线型探测法找到对应的位置private void remove(ThreadLocal&lt;?&gt; key) {    Entry[] tab = table;    int len = tab.length;    // 根据threadlocal获取其hashcode值    int i = key.threadLocalHashCode &amp; (len-1);    for (Entry e = tab[i];         e != null;         e = tab[i = nextIndex(i, len)]) {        if (e.get() == key) {            e.clear();            expungeStaleEntry(i);            return;        }    }}private static int nextIndex(int i, int len) {    return ((i + 1 &lt; len) ? i + 1 : 0);}private int expungeStaleEntry(int staleSlot) {    Entry[] tab = table;    int len = tab.length;    // expunge entry at staleSlot    tab[staleSlot].value = null;    tab[staleSlot] = null;    size--;    // Rehash until we encounter null    Entry e;    int i;    for (i = nextIndex(staleSlot, len);         (e = tab[i]) != null;         i = nextIndex(i, len)) {        ThreadLocal&lt;?&gt; k = e.get();        if (k == null) {            e.value = null;            tab[i] = null;            size--;        } else {            int h = k.threadLocalHashCode &amp; (len - 1);            if (h != i) {                tab[i] = null;                // Unlike Knuth 6.4 Algorithm R, we must scan until                // null because multiple entries could have been stale.                while (tab[h] != null)                    h = nextIndex(h, len);                tab[h] = e;            }        }    }    return i;}</code></pre><ol><li>通过当前线程获取该线程的map</li><li>然后调用map.remove方法</li></ol><p>后续的代码分析不动了。。。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><pre><code class="lang-java">/** * Sets the current thread's copy of this thread-local variable * to the specified value.  Most subclasses will have no need to * override this method, relying solely on the {@link #initialValue} * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of *        this thread-local. */public void set(T value) {    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null)        map.set(this, value);    else        createMap(t, value);}ThreadLocalMap getMap(Thread t) {    return t.threadLocals;}</code></pre><p>set方法的作用是把我们想要存储的value给保存方法，只要流程是：</p><ol><li>先获取当亲的线程</li><li>根据当前线程获取该线程的map</li><li>判断map是否为空<ol><li>为空<ul><li>创建map</li></ul></li><li>不为空<ul><li>在map中放入元素</li></ul></li></ol></li></ol><h3 id="set-ThreadLcoal-lt-gt-key-Object-value"><a href="#set-ThreadLcoal-lt-gt-key-Object-value" class="headerlink" title="set(ThreadLcoal<?> key, Object value)"></a>set(ThreadLcoal&lt;?&gt; key, Object value)</h3><pre><code class="lang-java">// 在map中存储键值对&lt;key, value&gt;private void set(ThreadLocal&lt;?&gt; key, Object value) {    Entry[] tab = table;    int len = tab.length;    int i = key.threadLocalHashCode &amp; (len-1);    // 遍历一段连续的元素，以查找匹配的 ThreadLocal 对象    for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) {        // / 获取该哈希值处的ThreadLocal对象        ThreadLocal&lt;?&gt; k = e.get();        // 键值ThreadLocal匹配，直接更改map中的value        if (k == key) {            e.value = value;            return;        }        // 若 key 是 null，说明 ThreadLocal 被清理了，直接替换掉        if (k == null) {            replaceStaleEntry(key, value, i);            return;        }    }    // 直到遇见了空槽也没找到匹配的ThreadLocal对象，那么在此空槽处安排ThreadLocal对象和缓存的value    tab[i] = new Entry(key, value);    int sz = ++size;    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)        rehash();}</code></pre><p>通过这两种set方式，就更加证明了思路的转换，我们在set时，都需要先获取当前线程获取map，然后再对整个map遍历然后放入value、或者直接放入key、value</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><pre><code class="lang-java">public T get() {    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null) {        ThreadLocalMap.Entry e = map.getEntry(this);        if (e != null) {            @SuppressWarnings("unchecked")            T result = (T)e.value;            return result;        }    }    return setInitialValue();}// 根据threadlocal获取entryprivate Entry getEntry(ThreadLocal&lt;?&gt; key) {    // 计算hashcode，然后获取对应的索引位置    int i = key.threadLocalHashCode &amp; (table.length - 1);    // 根据索引位置获取对应的entry    Entry e = table[i];    if (e != null &amp;&amp; e.get() == key)        return e;    else        return getEntryAfterMiss(key, i, e);}private T setInitialValue() {     T value = initialValue();     Thread t = Thread.currentThread();     ThreadLocalMap map = getMap(t);     if (map != null)         map.set(this, value);     else         createMap(t, value);     return value; }</code></pre><ol><li>先获取当前线程</li><li>获取当前线程的map</li><li>map != null<ol><li>通过key直接获取对应entry</li><li>返回entry.value</li></ol></li><li>map == null<ol><li>初始化map</li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>threadlocal</code>本质属于某种map的一个key值，只不过该值通过泛型实现，支持各种类型。和基础的map不同的是，可以直接通过<code>key.set(value)</code>实现<code>key-value</code>的映射。而这种特殊的map是属于Thread级别的成员变量，多个线程之间该变量互不影响，所以这也就是我们所说的线程本地存储地方。不过需要注意的是，该key是虚引用，需要注意内存泄露的问题，所以在使用过threadlocal之后，记得及时remove。内部的threadlocalmap和hashmap的实现机制类似，不过区别就是对于hash冲突的解决方式为<strong>线型探测</strong></p><h3 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h3><h4 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h4><p>内存泄漏指的是，当某一个对象不再有用的时候，占用的内存却不能被回收，这就叫作<strong>内存泄漏</strong>。</p><p>因为通常情况下，如果一个对象不再有用，那么我们的垃圾回收器 GC，就应该把这部分内存给清理掉。这样的话，就可以让这部分内存后续重新分配到其他的地方去使用；否则，如果对象没有用，但一直不能被回收，这样的垃圾对象如果积累的越来越多，则会导致我们可用的内存越来越少，最后发生内存不够用的 OOM 错误。</p><p>下面我们来分析一下，在 ThreadLocal 中这样的内存泄漏是如何发生的。</p><h4 id="Key-的泄漏"><a href="#Key-的泄漏" class="headerlink" title="Key 的泄漏"></a>Key 的泄漏</h4><p>分析了 ThreadLocal 的内部结构之后，知道了每一个 Thread 都有一个 ThreadLocal.ThreadLocalMap 这样的类型变量，该变量的名字叫作 threadLocals。线程在访问了 ThreadLocal 之后，都会在它的 ThreadLocalMap 里面的 Entry 中去维护该 ThreadLocal 变量与具体实例的映射。</p><p>我们可能会在业务代码中执行了 ThreadLocal instance = null 操作，想清理掉这个 ThreadLocal 实例，但是假设我们在 ThreadLocalMap 的 Entry 中强引用了 ThreadLocal 实例，那么，虽然在业务代码中把 ThreadLocal 实例置为了 null，但是在 Thread 类中依然有这个引用链的存在。</p><p>GC 在垃圾回收的时候会进行可达性分析，它会发现这个 ThreadLocal 对象依然是可达的，所以对于这个 ThreadLocal 对象不会进行垃圾回收，这样的话就造成了内存泄漏的情况。</p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li>Java并发编程</li><li>面试官系统精讲Java源码及大厂真题</li><li>Java并发编程78讲</li><li><a href="https://benjaminwhx.com/2018/04/28/[细谈Java并发]谈谈ThreadLocal/" target="_blank" rel="noopener">【细谈Java并发】谈谈ThreadLocal</a></li><li><a href="https://www.cnblogs.com/wupeixuan/p/12638203.html" target="_blank" rel="noopener">一文搞懂 ThreadLocal 原理</a></li><li><a href="https://blog.csdn.net/vincent_wen0766/article/details/108599292" target="_blank" rel="noopener">为何每次用完 ThreadLocal 都要调用 remove()？——内存泄漏</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;多线程共享可变数据时，涉及到线程见同步的问题，并不是所有的时候，都要用到共享数据，所以就需要线程封闭出场了。数据都被封闭在各自的线程之中，就不需要进</summary>
      
    
    
    
    <category term="源码" scheme="https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="JDK源码" scheme="https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"/>
    
    <category term="lang" scheme="https://winniekun.github.io/tags/lang/"/>
    
  </entry>
  
  <entry>
    <title>死磕双指针</title>
    <link href="https://winniekun.github.io/stick-to-two-pointer/"/>
    <id>https://winniekun.github.io/stick-to-two-pointer/</id>
    <published>2021-05-27T09:10:30.000Z</published>
    <updated>2021-05-27T09:10:30.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>双指针，一个看了脑子里就有画面的算法技巧，主要方式有：</p><ol><li>快慢指针<ul><li>譬如链表环系列问题</li><li>获取链表的第K个节点<ul><li>应该也属于快慢指针吧</li><li>只不过是一个指针先移动一定步长，然后另一个两个指针再以同样的速度移动</li></ul></li></ul></li><li>头尾指针<ul><li>适用于数组和字符串</li><li>根据使用场景，用于优化遍历的时间复杂度</li></ul></li><li>滑动窗口</li></ol><h2 id="普通指针"><a href="#普通指针" class="headerlink" title="普通指针"></a>普通指针</h2><h3 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除有序数组中的重复项</a></h3><pre><code class="lang-java">class Solution {    public int removeDuplicates(int[] nums) {        int i = 0;        int N = nums.length;        for (int j = 1; j &lt; N; j++) {            if (nums[i] != nums[j]) {                nums[++i] = nums[j];            }        }        return i + 1;    }}// 通法class Solution {    public int removeDuplicates(int[] nums) {           return process(nums, 1);    }    int process(int[] nums, int k) {        int idx = 0;         for (int x : nums) {            if (idx &lt; k || nums[idx - k] != x) nums[idx++] = x;        }        return idx;    }}</code></pre><h3 id="80-删除有序数组中的重复项-II"><a href="#80-删除有序数组中的重复项-II" class="headerlink" title="80. 删除有序数组中的重复项 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">80. 删除有序数组中的重复项 II</a></h3><pre><code class="lang-java">public int removeDuplicates(int[] nums) {    return process(nums, 2);}private int process(int[] nums, int k) {    int idx = 0;    for (int x : nums) {        if (idx &lt; k || nums[idx - k] != x) {            nums[idx++] = x;        }    }    return idx;}</code></pre><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></h3><h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组</a></h3><p>归并排序的中的一个步骤</p><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>环系列</p><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></h3><pre><code class="lang-java">public boolean hasCycle(ListNode head) {    if (head == null) {        return false;    }    ListNode fast = head;    ListNode slow = head;    while (fast != null &amp;&amp; fast.next != null) {        fast = fast.next.next;        slow = slow.next;        if (fast == slow) {            return true;        }    }    return false;}</code></pre><h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></h3><h2 id="头尾指针"><a href="#头尾指针" class="headerlink" title="头尾指针"></a>头尾指针</h2><p>可以理解为对整个数组的暴力搜索的优化，正常情况下，是得到所有的区间k的子数组，然后一次计算结果。双指针之后，可以在遍历的过程就的出结果，避免的重复的遍历，并且优化的了遍历的时间复杂度</p><h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></h3><pre><code class="lang-java">public int maxArea(int[] height) {    // 双指针(头尾指针)    int N = height.length;    int left = 0;    int right = N - 1;    int area = 0;    while (left &lt; right) {        int hight = Math.min(height[left], height[right]);        int innerArea = hight * (right - left);        area = Math.max(area, innerArea);        if (height[left] &lt; height[right]) {            left++;        } else {            right--;        }    }    return area;}</code></pre><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></h3><pre><code class="lang-java">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {    // 思路    // 核心思路：双指针 头尾指针    Arrays.sort(nums);    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    int N = nums.length;    for (int i = 0; i &lt; N - 2; i++) {        int rst = -nums[i];        int left = i + 1;        int right = N - 1;        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {            continue;        }        while (left &lt; right) {            int cur = nums[left] + nums[right];            if (cur == rst) {                res.add(new ArrayList&lt;&gt;(Arrays.asList(nums[i], nums[left], nums[right])));                // 处理后序重复的元素                while (left &lt; right &amp;&amp; nums[left + 1] == nums[left]) {                    left++;                }                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) {                    right--;                }                left++;                right--;            } else if (cur &gt; rst) {                right--;            } else {                left++;            }        }    }    return res;}</code></pre><h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></h3><p>和上述类似，不过不用考虑元素重复问题，但是需要考虑最近，所以使用一个变量，用于检测当前结果是否比之前更好。</p><pre><code class="lang-java">public int threeSumClosest(int[] nums, int target) {    int N = nums.length;    Arrays.sort(nums);    // 如何判断最近？    // min(closest, curDistance)    int closest = Integer.MAX_VALUE;    int res = nums[0] + nums[nums.length - 1] + nums[1];    for (int i = 0; i &lt; N - 2; i++) {        int low = i + 1;        int height = N - 1;        while (low &lt; height) {            int innerCur = nums[i] + nums[low] + nums[height];            if (innerCur &lt; target) {                low++;            } else if (innerCur &gt; target) {                height--;            } else {                return target;            }            if (Math.abs(innerCur - target) &lt; closest) {                closest = Math.abs(innerCur - target);                res = innerCur;            }        }    }    return res;}</code></pre><h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h3><p>同样的思路，不过可以做一些细节处理，提前退出循环。</p><pre><code class="lang-java">public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) {    List&lt;List&lt;Integer&gt;&gt; quadruplets = new ArrayList&lt;&gt;();    if (nums == null || nums.length &lt; 4) {        return quadruplets;    }    Arrays.sort(nums);    int length = nums.length;    for (int i = 0; i &lt; length - 3; i++) {        // 重复        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {            continue;        }        // 不符合条件        if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) {            break;        }        // 结果小        if (nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] &lt; target) {            continue;        }        for (int j = i + 1; j &lt; length - 2; j++) {            // 重复            if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) {                continue;            }            // 不符合条件            if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) {                break;            }            // 太小            if (nums[i] + nums[j] + nums[length - 2] + nums[length - 1] &lt; target) {                continue;            }            int left = j + 1, right = length - 1;            while (left &lt; right) {                int sum = nums[i] + nums[j] + nums[left] + nums[right];                if (sum == target) {                    quadruplets.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));                    while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) {                        left++;                    }                    left++;                    while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) {                        right--;                    }                    right--;                } else if (sum &lt; target) {                    left++;                } else {                    right--;                }            }        }    }    return quadruplets;}</code></pre><h3 id="259-较小的三数之和"><a href="#259-较小的三数之和" class="headerlink" title="259. 较小的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-smaller/" target="_blank" rel="noopener">259. 较小的三数之和</a></h3><pre><code class="lang-java">public int threeSumSmaller(int[] nums, int target) {    Arrays.sort(nums);    int N = nums.length;    int count = 0;    for (int i = 0; i &lt; N - 2; i++) {        int left = i + 1;        int right = N - 1;        while (left &lt; right) {            int innerCur = nums[i] + nums[left] + nums[right];            if (innerCur &lt; target) {                int innerCount = right - left;                count += innerCount;                left++;            } else {                right--;            }        }    }    return count;}</code></pre><h3 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30. 串联所有单词的子串"></a><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="noopener">30. 串联所有单词的子串</a></h3><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. 长度最小的子数组</a></h3><pre><code class="lang-java">public int minSubArrayLen(int target, int[] nums) {    int N = nums.length;    int left = 0;    int right = 0;    int ans = Integer.MAX_VALUE;    int sum = 0;    while (right &lt; N) {        sum += nums[right];        while (left &lt;= right &amp;&amp; sum &gt;= target) {            ans = Math.min(ans, right - left + 1);            sum -= nums[left];            left++;        }        right++;    }    return ans == Integer.MAX_VALUE ? 0 : ans;}</code></pre><h3 id="713-乘积小于K的子数组"><a href="#713-乘积小于K的子数组" class="headerlink" title="713. 乘积小于K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-product-less-than-k/" target="_blank" rel="noopener">713. 乘积小于K的子数组</a></h3><p>双指针（滑动窗口）：left 和 right指针开始时均指向 nums数组的开头。</p><p>right指针遍历 nums数组，每遍历一个元素就更新一次乘积，即 product = product * nums[right]：</p><ul><li><p>若当前更新后的 product &lt; k，则直接统计当前窗口中的元素个数（<strong>这恰好就是当前子数组中符合条件的全部子集个数</strong>）</p><ul><li>我们每次都统计以nums[right]为结尾符合条件的子数组个数</li></ul></li><li><p>若更新后的 product &gt;= k，则此时需要缩小窗口的大小，即令当前 product 除以当前 left 指针指向的元素值，然后令 left指针右移一位，直到当前的 produc &lt; k 为止，然后统计当前窗口中的元素个数，即为此时符合条件的子数组的个数，继续令 right 指针右移。</p></li><li>如此反复，直到 right 指针指向 nums 数组的末尾为止。</li></ul><pre><code class="lang-java">public int numSubarrayProductLessThanK(int[] nums, int k) {    // 滑动窗口    int N = nums.length;    int left = 0;    int sum = 1;    int count = 0;    for (int right = 0; right &lt; N; right++) {        sum *= nums[right];        while (left &lt;= right &amp;&amp; sum &gt;= k) {            sum /= nums[left];            left++;        }        count += right - left + 1;    }    return count;}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;双指针，一个看了脑子里就有画面的算法技巧，主要方式有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;快慢指针&lt;ul&gt;
&lt;li&gt;譬如链表环系列问题&lt;/li&gt;
&lt;li&gt;获</summary>
      
    
    
    
    <category term="leetcode" scheme="https://winniekun.github.io/categories/leetcode/"/>
    
    
    <category term="双指针" scheme="https://winniekun.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>PriorityQueue源码解读</title>
    <link href="https://winniekun.github.io/PriorityQueue-analysis/"/>
    <id>https://winniekun.github.io/PriorityQueue-analysis/</id>
    <published>2021-05-22T12:00:56.000Z</published>
    <updated>2021-05-23T12:10:46.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PriorityQueue源码解读"><a href="#PriorityQueue源码解读" class="headerlink" title="PriorityQueue源码解读"></a>PriorityQueue源码解读</h2><a id="more"></a><p>优先队列, 顾名思义就是按照元素的优先级进行弹出等操作, 那么在JDK中使用何种数据结构来实现优先队列嘞, Let’s Go</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/PriorityQueue.png" alt="PriorityQueue" title="">                </div>                <div class="image-caption">PriorityQueue</div>            </figure><p>emmm, 感觉从依赖上来看, 和其他的集合类一样, 实现其对应的接口(Marker Interface的作用?)</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>在阅读基础的时候，我们需要先理解一下什么是堆，其数据结构是啥，有哪些存储方式。</p><ol><li>堆的底层数据结构为<strong>完全二叉树</strong></li><li>存储方式（既然是二叉树，那么其存储方式主要分为如下两种）<ol><li>顺序存储结构<ol><li>根节点下标为0</li><li>若节点p的下标为$i$，则左孩子$2\cdot i$ 右孩子为$2 \cdot i + 1$ </li><li>若节点p的下标为$i$，则父节点的下标为$\lfloor i/2\rfloor$</li></ol></li><li>链式存储结构</li></ol></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/02/26/lrUPGcnu1EvSwy8.png" alt="树的存储结构" title="">                </div>                <div class="image-caption">树的存储结构</div>            </figure><p>由上述的顺序存储结构可知，堆是用<strong>物理上的线性表示逻辑上的非线性的数据结构</strong></p><p>具体的关于堆的操作，如刚开始的建堆，以及插入元素，删除堆顶元素，迭代等操作，可自行百度。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><pre><code class="lang-java">// 默认初始化容量private static final int DEFAULT_INITIAL_CAPACITY = 11;// 底层使用Object[]数组实现, 和ArrayList这些一样transient Object[] queue; // non-private to simplify nested class access// 标记元素个数private int size = 0;// 比较器, 说明其实例均是可比较的private final Comparator&lt;? super E&gt; comparator;// 说明具有fast fail 机制transient int modCount = 0; // non-private to simplify nested class access</code></pre><p>因为底层使用的是数组，同时其本身是支持动态插入和删除的，所以同理，和<strong>ArrayList</strong>同理，扩容应该是其核心的地方。同时也要关注其是否生成新的数组对象。</p><blockquote><p>像ArrayList、HashMap中都有一个属性叫 <code>modCount</code>，每次对集合的修改这个值都会加1，在遍历前记录这个值到 <code>expectedModCount</code>中，遍历中检查两者是否一致，如果出现不一致就说明有修改，则抛出ConcurrentModificationException异常。</p></blockquote><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue()"></a>PriorityQueue()</h3><pre><code class="lang-java">public PriorityQueue() {    this(DEFAULT_INITIAL_CAPACITY, null);}</code></pre><h3 id="PriorityQueue-int-initialCapacity"><a href="#PriorityQueue-int-initialCapacity" class="headerlink" title="PriorityQueue(int initialCapacity)"></a>PriorityQueue(int initialCapacity)</h3><pre><code class="lang-java">public PriorityQueue(int initialCapacity) {    this(initialCapacity, null);}</code></pre><h3 id="PriorityQueue-Comparator-lt-super-E-gt-comparator"><a href="#PriorityQueue-Comparator-lt-super-E-gt-comparator" class="headerlink" title="PriorityQueue(Comparator<? super E> comparator)"></a>PriorityQueue(Comparator&lt;? super E&gt; comparator)</h3><pre><code class="lang-java">public PriorityQueue(Comparator&lt;? super E&gt; comparator) {    this(DEFAULT_INITIAL_CAPACITY, comparator);}</code></pre><h3 id="PriorityQueue-int-initialCapacity-Comparator-lt-super-E-gt-comparator"><a href="#PriorityQueue-int-initialCapacity-Comparator-lt-super-E-gt-comparator" class="headerlink" title="PriorityQueue(int initialCapacity, Comparator<? super E> comparator)"></a>PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator)</h3><pre><code class="lang-java">public PriorityQueue(int initialCapacity,                     Comparator&lt;? super E&gt; comparator) {    // Note: This restriction of at least one is not actually needed,    // but continues for 1.5 compatibility    if (initialCapacity &lt; 1)        throw new IllegalArgumentException();    this.queue = new Object[initialCapacity];    this.comparator = comparator;}</code></pre><p>还有几个构造函数主要是用于将原各种类型的数据放入<code>PriorityQueue</code>中</p><h2 id="增-入队"><a href="#增-入队" class="headerlink" title="增(入队)"></a>增(入队)</h2><p>在阅读这些方法的时候, 想起来自己手撕算法的时候, 经常会记混<code>List</code>, <code>Stack</code>, <code>Queue</code>, <code>Map</code>这些的添加删除操作的API…</p><p>下面罗列的是个人觉得不错的代表数据结构特性的添加/删除操作的API</p><div class="table-container"><table><thead><tr><th style="text-align:left">数据结构</th><th>添加</th><th>删除</th></tr></thead><tbody><tr><td style="text-align:left">List/Set</td><td>add()</td><td>remove()</td></tr><tr><td style="text-align:left">Stack</td><td>push()</td><td>pop()</td></tr><tr><td style="text-align:left">Queue</td><td>offer()</td><td>poll()</td></tr><tr><td style="text-align:left">Map</td><td>put()</td><td>remove()</td></tr></tbody></table></div><p>用于入队的操作有<code>add</code>和<code>offer</code>。</p><pre><code class="lang-java">public boolean add(E e) {    return offer(e);}public boolean offer(E e) {      // 不支持null元素    if (e == null)        throw new NullPointerException();    modCount++;    int i = size;    // 元素数量超过数组数量，引发扩容机制    if (i &gt;= queue.length)        // 扩容机制先按下不表        grow(i + 1);    // 元素数量+1    size = i + 1;      // 如果还没有元素    // 直接插入到数组第一个位置    if (i == 0)        queue[0] = e;    else        // 否则 插入到堆的最后一个元素        // 然后再调整堆        siftUp(i, e);    return true;}</code></pre><p>宏观上来看, <code>offer()</code>方法会先检测是否需要扩容, 之后再插入元素, 最后进行调整, 最后调用<code>siftUp</code>进行调整。</p><h3 id="siftUp"><a href="#siftUp" class="headerlink" title="siftUp"></a>siftUp</h3><p>假设在数组queue的k位置插入元素key（小根堆）</p><ul><li>不断的比较key和k的父节点e （$queue\lfloor(k-1/2\rfloor)$）的关系<ol><li>若$key  &lt;  e$ ，则queue[k] = e, 同时k到达e的位置（parent）</li><li>若$key \geq e$ 或者  $k$已经到达跟节点，则结束循环</li></ol></li><li>$queue[k]==e$</li></ul><pre><code class="lang-java">private void siftUp(int k, E x) {    // 判断比较策略    // 1. X自身实现了Comparable接口，则通过comparable进行比较    // 2. X自身未实现Comparable接口，通过自定义的外部比较器compartor比较    if (comparator != null)        siftUpUsingComparator(k, x);    else        siftUpComparable(k, x);}@SuppressWarnings("unchecked")private void siftUpComparable(int k, E x) {    Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x;    while (k &gt; 0) {        int parent = (k - 1) &gt;&gt;&gt; 1;        Object e = queue[parent];        if (key.compareTo((E) e) &gt;= 0)            break;        queue[k] = e;        k = parent;    }    queue[k] = key;}@SuppressWarnings("unchecked")private void siftUpUsingComparator(int k, E x) {    while (k &gt; 0) {        int parent = (k - 1) &gt;&gt;&gt; 1;        Object e = queue[parent];        if (comparator.compare(x, (E) e) &gt;= 0)            break;        queue[k] = e;        k = parent;    }    queue[k] = x;}</code></pre><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol><li>不允许null元素</li><li>插入元素前，先检测数组长度是否够用，不够进行扩容（扩容机制后续详细阐述）</li><li>在尾部插入元素，之后不断调整</li><li>通过调整的过程，可以知道PrioriryQueue默认是小根堆</li></ol><h2 id="删-出队"><a href="#删-出队" class="headerlink" title="删(出队)"></a>删(出队)</h2><p>出队有两个方法，<code>poll()</code>和<code>remove()</code>，实际上remove调用的还是poll。remove不存在的元素时会报错。</p><pre><code class="lang-java">public E remove() {    E x = poll();    if (x != null)        return x;    else        throw new NoSuchElementException();}public E poll() {    if (size == 0)        return null;    int s = --size;    modCount++;    E result = (E) queue[0];    // 获取当前最后一个元素    // 并将最后一个位置置空    E x = (E) queue[s];    queue[s] = null;    // 如果弹出元素后还有元素    if (s != 0)        //将队列末元素移到队列首        // 再做自上而下的堆化        siftDown(0, x);    return result;}</code></pre><h3 id="siftDown"><a href="#siftDown" class="headerlink" title="siftDown"></a>siftDown</h3><p>自顶向下，选择小的节点，不断的比较、交换，直到：</p><ol><li>下标越界</li><li>节点的值同时小于等于左孩子和右孩子</li></ol><p>假设数组queue最后一个元素的值为key（小根堆），下标k从0开始，当k存在左孩子时，执行以下循环：</p><ul><li>若k有右孩子，则比较左右孩子的值，然后选出小的孩子child</li><li>比较key和c=queue[child]的大小<ol><li>若$key \leq c$ 结束循环</li><li>若$key &gt; c$, 则$queue[k] = c, k = child$， 继续循环</li></ol></li><li>$queue[k] = key$</li></ul><pre><code class="lang-java">private void siftDown(int k, E x) {    // 和 siftUp一样的思路    if (comparator != null)        siftDownUsingComparator(k, x);    else        siftDownComparable(k, x);}@SuppressWarnings("unchecked")private void siftDownComparable(int k, E x) {    // 因为删除是从堆顶开始删除，所以和siftUp相反    Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x;    int half = size &gt;&gt;&gt; 1;        // loop while a non-leaf    while (k &lt; half) {        int child = (k &lt;&lt; 1) + 1; // assume left child is least        Object c = queue[child];        int right = child + 1;        if (right &lt; size &amp;&amp;            ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0)            c = queue[child = right];        if (key.compareTo((E) c) &lt;= 0)            break;        queue[k] = c;        k = child;    }    queue[k] = key;}@SuppressWarnings("unchecked")private void siftDownUsingComparator(int k, E x) {    int half = size &gt;&gt;&gt; 1;    while (k &lt; half) {        int child = (k &lt;&lt; 1) + 1;        Object c = queue[child];        int right = child + 1;        if (right &lt; size &amp;&amp;            comparator.compare((E) c, (E) queue[right]) &gt; 0)            c = queue[child = right];        if (comparator.compare(x, (E) c) &lt;= 0)            break;        queue[k] = c;        k = child;    }    queue[k] = x;}</code></pre><ol><li>将队列首元素弹出</li><li>将队列末元素移到队列首</li><li>自上而下堆化，一直往下与最小的子节点比较</li><li>如果比最小的子节点大，就交换位置，再继续与最小的子节点比较</li><li>如果比最小的子节点小，就不用交换位置了，堆化结束</li></ol><h2 id="获取队头元素"><a href="#获取队头元素" class="headerlink" title="获取队头元素"></a>获取队头元素</h2><pre><code class="lang-java">public E peek() {    return (size == 0) ? null : (E) queue[0];}</code></pre><p>获取第一个元素的值。</p><h2 id="扩容策略"><a href="#扩容策略" class="headerlink" title="扩容策略"></a>扩容策略</h2><pre><code class="lang-java">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;private void grow(int minCapacity) {    int oldCapacity = queue.length;    // Double size if small; else grow by 50%    int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ?                                     (oldCapacity + 2) :                                     (oldCapacity &gt;&gt; 1));    // overflow-conscious code    // 检查是否溢出    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    queue = Arrays.copyOf(queue, newCapacity);}private static int hugeCapacity(int minCapacity) {    if (minCapacity &lt; 0) // overflow        throw new OutOfMemoryError();    return (minCapacity &gt; MAX_ARRAY_SIZE) ?        Integer.MAX_VALUE :        MAX_ARRAY_SIZE;}</code></pre><ol><li>原数组空间大小&lt;64时，默认扩容为原先的两倍再加2个。。。</li><li>原数组空间大小&gt;64时，扩容为原先的1.5倍</li><li>最大容量空间为Integer.MAX_VALUE</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>PriorityQueue内部的数据结构是堆，堆使用的数据结构是完全二叉树，然后使用的是顺序存储结构（数组）</li><li>PriorityQueue默认是小根堆</li><li>堆保证堆顶元素为当前的最值，然后严格遵守字节点的值大于（小于）父节点的值</li><li>堆的删除操作从堆顶进行删除，然后会将最后的一个元素移至堆顶，此时堆的结构被破坏，所以需要执行siftDown</li><li>堆的插入操作从堆尾进行插入，此时堆的结构被破坏，所以需要执行siftUp</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;PriorityQueue源码解读&quot;&gt;&lt;a href=&quot;#PriorityQueue源码解读&quot; class=&quot;headerlink&quot; title=&quot;PriorityQueue源码解读&quot;&gt;&lt;/a&gt;PriorityQueue源码解读&lt;/h2&gt;</summary>
    
    
    
    <category term="源码" scheme="https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="JDK源码" scheme="https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"/>
    
    <category term="Queue" scheme="https://winniekun.github.io/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>https总结</title>
    <link href="https://winniekun.github.io/https-conclution/"/>
    <id>https://winniekun.github.io/https-conclution/</id>
    <published>2021-05-21T14:32:09.000Z</published>
    <updated>2021-06-21T16:37:07.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>引入一个新的概念的时候，必然先阐述其相关方面已有的实现有哪些缺点，新的概念解决了哪些缺点。所以～让我们看看HTTP有哪些却缺点</p><p><strong>缺点：</strong></p><ol><li>明文传输，传输信息容易被窃听 —- <strong>窃听风险</strong></li><li>不验证通信方的身份，因此可能会遭遇伪装 —- <strong>冒充风险</strong></li><li>无法验证报问的完整性，所以通信的信息可能已遭篡改 —- <strong>篡改风险</strong><ol><li>譬如强行植入的广告信息</li></ol></li></ol><p>而HTTPS的出现就正好解决了上述的三个问题。对于窃听风险使用加密措施解决，对于冒充风险使用证书认证解决，对于篡改风险使用完整性保护解决（信息摘要算法）</p><h2 id="HTTPS概述"><a href="#HTTPS概述" class="headerlink" title="HTTPS概述"></a>HTTPS概述</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521144232642.png" alt="https" title="">                </div>                <div class="image-caption">https</div>            </figure><p>HTTPS其实就是<strong>http secure</strong>的意思。HTTP是应用层协议，位于HTTP协议之下是传输协议TCP。TCP负责传输，HTTP则定义了数据如何进行包装。所以HTTP传输给TCP什么样的数据包，其都会原样的发送个通讯方（仅仅将数据包分为了多个报报问段）。</p><blockquote><p>HTTP —&gt; TCP （明文传输）</p></blockquote><p>而HTTPS相对于HTTP有哪些不同呢？其实就是在HTTP和TCP中间加多了一层加密层<strong>TLS/SSL</strong>。</p><blockquote><p>通俗的讲，TLS、SSL其实是类似的东西，SSL是个加密套件，负责对HTTP的数据进行加密。TLS是SSL的升级版。现在提到HTTPS，加密套件基本指的是TLS。</p></blockquote><p>原先是应用层将数据直接给到TCP进行传输，现在改成应用层将数据给到TLS/SSL，将数据加密后，再给到TCP进行传输。如下图所示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521144940926.png" alt="https和http传输过程" title="">                </div>                <div class="image-caption">https和http传输过程</div>            </figure><p>所以HTTPS本身并不是应用层的一个新的协议，只是HTTP在和TCP进行交接的中间，又新增了一层SSL/TLS协议。所以HTTPS可以理解为披着SSL/TLS协议外壳的HTTP而已。</p><h2 id="HTTPS的加密—-混合加密"><a href="#HTTPS的加密—-混合加密" class="headerlink" title="HTTPS的加密—-混合加密"></a>HTTPS的加密—-混合加密</h2><p>首先需要了解<code>对称加密</code>、<code>非对称加密</code>的区别。我们知道实际对通信加密的是SSL/TLS层。SSL/TLS采用是混合加密的机制，也就是对称加密和非对称加密的混合。使用非对称加密传输安全传输对称加密的密钥，之后使用对称加密的密钥进行通信从而提高整体的通讯效率。</p><p>接下来结合WireShark抓包详细阐述TLS的加密流程，TLS 是建立在 TCP 基础上的，因此必定需要先三次 TCP 握手建立 TCP 连接，然后再是建立 TLS。</p><ol><li><strong>Client Hello</strong><ol><li><strong>Client Hello</strong> 报文：客户端对加密算法的支持度不同，因此需要向服务端发送客户端支持的 <strong>加密套件（Cipher Suite）</strong> ，同时还要生成一个 <strong>随机数</strong> 同时保存在客户端和发送给服务</li></ol></li><li><strong>Server Hello</strong><ol><li><strong>ServerCertificate</strong> 报文：服务端收到 Client Hello 之后，向客户端发送 <strong>CA 认证的数字证书</strong>，用来鉴别服务端身份信息，同时还要生成一个 <strong>随机数</strong> 同时保存在服务端和发送给客户端</li><li><strong>Server Hello Done</strong> 报文：表示服务端宣告第一阶段的客户端服务端握手协商结束</li><li>可选：<strong>Certificate Request</strong> 报文：必要情况下，要求客户端发送证书验证身份</li><li>可选：<strong>Server Key Exchange</strong> 报文：如果 CA 认证的数字证书提供的信息不够，服务端还可发送提供补充信息</li></ol></li><li><strong>Client Finish</strong><ol><li><strong>Client Key Exchange</strong> 报文：客户端收到 CA 数字证书并通过验证，然后通过 CA 公钥解密获取到 <strong>服务端公钥</strong>。Client Key Exchange 报文包括有一个随机数，这个随机数被称为 <strong>Pre-master key/secret</strong>；一个表示随后的信息使用双方协商好的加密方法和密钥发送的 <strong>通知</strong> ；还有一个通过协商好的 HASH 算法对前面所有信息内容的 <strong>HASH 计算值</strong>，用来提供服务端校验。<strong>这些信息都通过服务端公钥加密传送给服务端</strong></li><li><strong>ExchangeCipherSpec</strong> 报文：该报文通知服务端，此后的通信都将使用协商好的加密算法计算对称密钥进行加密通信（也就是使用两个随机数以及第三个 Pre-master key/secret 随机数一起算出一个对称密钥 <strong>session key/secret</strong>）</li><li><strong>Finished</strong> 报文：该报文包括连接至此的所有报文的校验值，使用已经生成的对称加密密钥加密</li><li>可选：<strong>ClientCertificate</strong> 报文：如果服务端请求，客户端需要发送 CA 数字证书</li><li>可选：<strong>CertificateVerify</strong> 报文：服务端如果要求 CA 数字证书，那么需要通过 HASH 算法计算一个服务端发送来的信息摘要</li></ol></li><li><strong>Server Finish</strong><ol><li>服务端先私钥得出<strong>Pre-master key</strong>， 同样使用这三个随机数得出对称加密密钥。服务端最后对客户端发送过来的 <strong>Finished</strong> 报文使用服务端对称密钥进行解密校验。</li><li><strong>ClientCipherSpec</strong> 报文：报文通知服务端，此后的通信都将使用协商好的加密算法计算对称密钥 session key/secret 进行加密通信</li><li><strong>Finished</strong> 报文：标志 TLS 连接建立成功</li></ol></li><li>TLS 握手成功此后通过对称密钥 session key/secret 加密通信</li></ol><blockquote><ol><li>握手：证书下发，密钥协商（这个阶段都是明文的）</li><li>数据传输：这个阶段才是加密的，用的就是握手阶段协商出来的对称密钥</li></ol></blockquote><p>进行整理，如下图所示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521215733187.png" alt="image-20210521215733187" title="">                </div>                <div class="image-caption">image-20210521215733187</div>            </figure><h3 id="使用wireshark实战证明"><a href="#使用wireshark实战证明" class="headerlink" title="使用wireshark实战证明"></a>使用wireshark实战证明</h3><p>本地地址和LeetCode-CN的交互</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521174931648.png" alt="wireshark抓包展示" title="">                </div>                <div class="image-caption">wireshark抓包展示</div>            </figure><ol><li><p>客户端想服务端发送https请求链接，同时将自身支持的密码套件（非对称加密算法、对称加密算法、摘要算法）发送个服务端</p><p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521181226105.png" alt="客户端say hello阶段"></p></li><li><p>服务端根据客户端获发送的数据，选择一套密码套件，以及自身的证书发送给客户端</p><p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521182242937.png" alt="服务端选择的密码套件--服务端say hello阶段"></p><p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521182508161.png" alt="服务端将自身的证书发送给客户端--- 服务端Say hello 阶段"></p></li><li><p>客户端进行验证，验证正常自后，随机生成一串数组作为后续通信的对称加密密钥，然后使用服务端证书的公钥进行加密，同时使用摘要算法对本次的会话信息进行加密，然后一并发送给服务端。</p><p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521185850059.png" alt="image-20210521185850059"></p></li><li><p>服务端验证，正常之后，剩下的忘截图了，后面补上</p></li></ol><h2 id="HTTPS的认证—-数字证书"><a href="#HTTPS的认证—-数字证书" class="headerlink" title="HTTPS的认证—-数字证书"></a>HTTPS的认证—-数字证书</h2><p>了解了HTTPS加密通信的流程后，对于数据裸奔的疑虑应该基本打消了。然而，还有一个问题：如何确保证书时可信的？</p><p>证书不可信可能有两种情况：</p><ol><li>证书是伪造的：压根不是CA颁发的</li><li>证书被篡改过：比如将XX网站的公钥给替换了</li></ol><p>数字证书是由权威的CA（Certificate Authority）机构给服务端进行颁发，CA机构通过服务端提供的相关信息生成证书，证书内容包含了<code>持有人的相关信息</code>，<code>服务器的公钥</code>，<code>签署者签名信息（数字签名）</code>等，最重要的是<strong>公钥在数字证书中</strong>。</p><blockquote><p>数字签名和摘要算法的关系</p><p>明文 —&gt; hash运算 —&gt; 摘要 —&gt; 私钥加密 —&gt; 数字签名</p></blockquote><p>数字证书是如何保证公钥来自请求的服务器？</p><ul><li>数字证书上由持有人的相关信息，通过这点可以确定其不是一个中间人</li></ul><p><strong>证书包含的内容：</strong></p><ul><li>一个证书中含有三个部分:<code>证书内容</code>，<code>散列算法</code>，<code>加密密文</code>，证书内容会被散列算法hash计算出摘要，然后使用CA机构提供的私钥进行RSA加密得到数组签名（加密密文）。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Users/weikunkun/Library/Application" alt="证书内容" title="Support/typora-user-images/image-20210521221149447.png">                </div>                <div class="image-caption">Support/typora-user-images/image-20210521221149447.png</div>            </figure><h3 id="证书伪造"><a href="#证书伪造" class="headerlink" title="证书伪造"></a>证书伪造</h3><p>浏览器内置的CA的根证书包含了<strong>CA的公钥</strong></p><ol><li>证书颁发的机构是伪造的：浏览器不认识，直接认为是危险证书</li><li>证书颁发的机构是确实存在的，于是根据CA名，找到对应内置的CA根证书、CA的公钥。</li><li>用CA的公钥，对伪造的证书的摘要进行解密，发现解不了。认为是危险证书</li></ol><h3 id="证书篡改"><a href="#证书篡改" class="headerlink" title="证书篡改"></a>证书篡改</h3><ol><li>根据证书的加密密文（数字签名）使用CA的公钥得到证书摘要A</li><li>根据证书内容使用摘要算法得到证书摘要B</li><li>对比摘要A和摘要B是否相同</li></ol><h2 id="HTTPS的完整性保护—-摘要算法"><a href="#HTTPS的完整性保护—-摘要算法" class="headerlink" title="HTTPS的完整性保护—-摘要算法"></a>HTTPS的完整性保护—-摘要算法</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li>图解HTTP</li><li>趣谈协议—-极客时间</li><li><a href="https://security.stackexchange.com/questions/89383/why-does-the-ssl-tls-handshake-have-a-client-and-server-random" target="_blank" rel="noopener">Why does the SSL/TLS handshake have a client and server random</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;引入一个新的概念的时候，必然先阐述其相关方面已有的实现有哪些缺点，新的概念解决了哪些缺点。所以～让我们看看HTTP有哪些却缺点&lt;/p&gt;
&lt;p&gt;&lt;st</summary>
      
    
    
    
    <category term="网络" scheme="https://winniekun.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="应用层" scheme="https://winniekun.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Spring IoC解读</title>
    <link href="https://winniekun.github.io/spring-ioc-analysis/"/>
    <id>https://winniekun.github.io/spring-ioc-analysis/</id>
    <published>2021-05-21T01:24:20.000Z</published>
    <updated>2021-07-24T07:46:15.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p>IoC控制反转，意思就是将创建对象的控制权从我们自己硬编码来new一个对象反转到了第三方身上。IoC的主要实现方式是依赖注入，Spring中的依赖注入方式有：<code>构造方法注入</code>、<code>settter注入</code>、<code>接口注入</code>。</p><ul><li><strong>控制反转</strong>是一种思想</li><li><strong>依赖注入</strong>是一种设计模式</li></ul><blockquote><p>IoC是一种可以帮助我们解耦各业务对象间依赖关系的对象绑定方式</p></blockquote><h2 id="IoC-Service-Provider"><a href="#IoC-Service-Provider" class="headerlink" title="IoC Service Provider"></a>IoC Service Provider</h2><p>虽然业务对象可以通过IoC方式声明相应的依赖，但是最终仍然需要通过某个角色或者服务将这些依赖的对象绑定到一起。而IoC Service Provider就对应IoC场景中的这一角色。IoC Service Provider在这里是一个抽象出来的概念，它可以指代任何将IoC场景中的业务对象绑定到一起的实现方式。它可以是一段代码，也可以是一组相关的类，甚至可以是比较通用的IoC框架或 者IoC容器实现。</p><h3 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h3><ol><li><p>业务对象的构建管理</p><p>IoC中，业务对象无需关心所依赖注入的对象<strong>如何构建如何取得</strong>，但是这部分的工作还是需要有人来做的。所以<code>IoC Service Provider</code>需要将对象的构建逻辑从<em>客户端</em>对象那里抽离出来，一面这部分逻辑污染业务对象的实现。</p><blockquote><p><strong>客户端</strong>：代使用某个对象或者某种服务的对象。如果对象A需要引用对象B，那么A就是B的客户端对象，而不管A 处于Service层还是数据访问层。</p></blockquote></li><li><p>业务对象之间的依赖绑定</p><p>最艰巨也是最重要的，这 是它的最终使命之所在。如果不能完成这个职责，那么，无论业务对象如何的“呼喊”，也不 会得到依赖对象的任何响应(最常见的倒是会收到一个NullPointerException)。<code>IoC Service Provider</code>通过结合之前构建和管理的所有业务对象，以及各个业务对象间可以识别的依赖关系，将这些对象所依赖的对象注入绑定，从而保证每个业务对象在使用的时候，可以处于就绪状 态。</p></li></ol><h2 id="Spring-IoC容器"><a href="#Spring-IoC容器" class="headerlink" title="Spring IoC容器"></a>Spring IoC容器</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210520140010820.png" alt="image-20210520140010820" title="">                </div>                <div class="image-caption">image-20210520140010820</div>            </figure><p>Spring的IoC容器就是一个IoC Provider，但是其相比于IoC Provider的功能更加的丰富，除了业务对象的构建、依赖关系的绑定这种IoC Provider的基本功能，还新增了业务对象声明周期的管理，AOP支持等。同时Spring提供了两种容器类型:BeanFactory和ApplicationContext。</p><ul><li><p>BeanFactory</p><p>基础类型IoC容器，提供完整的IoC服务支持。如果没有特殊指定，==默认采用延迟初始化策略(lazy-load)==。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的 IoC容器选择。</p></li><li><p>ApplicationContext</p><p>在BeanFactory的基础上构建，是相对比较高 级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。ApplicationContext所管理 的对象，在该类型容器启动之后，==默认全部初始化并绑定完成==。所以，相对于BeanFactory来 说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中， ApplicationContext类型的容器是比较合适的选择。</p></li></ul><h3 id="简单的式例"><a href="#简单的式例" class="headerlink" title="简单的式例"></a>简单的式例</h3><h3 id="Spring-IoC容器的一些特性简介"><a href="#Spring-IoC容器的一些特性简介" class="headerlink" title="Spring IoC容器的一些特性简介"></a>Spring IoC容器的一些特性简介</h3><h4 id="autowire"><a href="#autowire" class="headerlink" title="autowire"></a>autowire</h4><p>自动注入，通过autowire，我们可以略去很多人工显示的配置bean的操作，被依赖的发现和注入都交给了Spring，同时其有几个类型可选择，比如byName、byType等。</p><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><p>BeanFactory和FactoryBean傻傻分不清？虽然两者类似，但是功能不同。FactoryBean是一种工厂Bean，和普通的Bean不一样，FactoryBean是可以生产Bean的Bean。</p><h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends-on"></a>depends-on</h4><p>当一个 bean 直接依赖另一个 bean，可以使用 <code>&lt;ref/&gt;</code> 标签进行配置。不过如某个 bean 并不直接依赖于其他 bean，但又需要其他 bean 先实例化好，这个时候就需要使用 depends-on 特性了。depends-on 特性比较简单，就不演示了。仅贴一下配置文件的内容，如下：</p><p>这里有两个简单的类，其中 Hello 需要 World 在其之前完成实例化。相关配置如下：</p><pre><code class="lang-xml">&lt;bean id="hello" class="xyz.coolblog.depnedson.Hello" depends-on="world"/&gt;&lt;bean id="world" class="xyz.coolblog.depnedson.World" /&gt;</code></pre><h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h4><p>BeanPostProcessor 是 bean 实例化时的后置处理器，包含两个方法，其源码如下：</p><pre><code class="lang-java">public interface BeanPostProcessor {    // bean 初始化前的回调方法    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;    // bean 初始化后的回调方法        Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;}</code></pre><p>BeanPostProcessor是Spring框架的一个扩展点，可以通过BeanPostProcessor接口，我们能够插手Bean的实例化过程，比如AOP就是在bean实例将切面逻辑织入bean实例中，AOP也是正是通过BeanPostProcessor和IoC容器建立了联系</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><pre><code class="lang-java">@Slf4jpublic class LoggerBeanPostProcessor implements BeanPostProcessor {    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) {        log.info("Before  " + beanName + " Initialization");        return bean;    }    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) {        log.info("After  " + beanName + " Initialization");        return bean;    }}</code></pre><h5 id="配置如下"><a href="#配置如下" class="headerlink" title="配置如下"></a><strong>配置如下</strong></h5><pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xsi:schemaLocation="http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;    &lt;bean class="com.titizz.simulation.toyspring.learninng.LoggerBeanPostProcessor"/&gt;    &lt;bean id="car" class="com.titizz.simulation.toyspring.Car"&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h5 id="测试如下"><a href="#测试如下" class="headerlink" title="测试如下"></a><strong>测试如下</strong></h5><pre><code class="lang-java">@Testpublic void testBeanPostProcessor() {    String xmlPath = "test-spring.xml";    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath);}</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/05/02/iUgIOGvfmPo1ws5.png" alt="image-20210502181644978" title="">                </div>                <div class="image-caption">image-20210502181644978</div>            </figure><h3 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h3><h4 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h4><p>以 <code>Resource</code> 接口为核心发散出的几个类，都是用于解决 IoC 容器中的内容从哪里来的问题，也就是 <strong>配置文件从哪里读取、配置文件如何读取</strong> 的问题。</p><div class="table-container"><table><thead><tr><th style="text-align:left">类名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>Resource</code></td><td style="text-align:left">接口，标识一个外部资源。通过 <code>getInputStream()</code> 方法 <strong>获取资源的输入流</strong> 。</td></tr><tr><td style="text-align:left"><code>UrlResource</code></td><td style="text-align:left">实现 <code>Resource</code> 接口的资源类，通过 URL 获取资源。</td></tr><tr><td style="text-align:left"><code>ResourceLoader</code></td><td style="text-align:left">资源加载类。通过 <code>getResource(String)</code> 方法获取一个 <code>Resouce</code> 对象，是 <strong>获取 <code>Resouce</code> 的主要途径</strong> 。</td></tr></tbody></table></div><h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><p><strong>功能：</strong>用于解决Bean的定义问题，包括Bean的名字，类型以及它的属性赋予了什么值或者引用。说白了也就是<strong>解决了在IoC容器中定义一个Bean，使得IoC容器可以根据这个定义来生成实例。</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">类名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>BeanDefinition</code></td><td style="text-align:left">该类保存了 <code>Bean</code> 定义。包括 <code>Bean</code> 的 <strong>名字</strong> <code>String beanClassName</code>、<strong>类型</strong> <code>Class beanClass</code>、<strong>属性</strong> <code>PropertyValues propertyValues</code>。根据其 <strong>类型</strong> 可以生成一个类实例，然后可以把 <strong>属性</strong> 注入进去。<code>propertyValues</code> 里面包含了一个个 <code>PropertyValue</code> 条目，每个条目都是键值对 <code>String</code> - <code>Object</code>，分别对应要生成实例的属性的名字与类型。在 Spring 的 XML 中的 <code>property</code> 中，键是 <code>key</code> ，值是 <code>value</code> 或者 <code>ref</code>。对于 <code>value</code> 只要直接注入属性就行了，但是 <code>ref</code> 要先进行解析。<code>Object</code> 如果是 <code>BeanReference</code> 类型，则说明其是一个引用，其中保存了引用的名字，需要用先进行解析，转化为对应的实际 <code>Object</code>。</td></tr><tr><td style="text-align:left"><code>BeanDefinitionReader</code></td><td style="text-align:left">解析 <code>BeanDefinition</code> 的接口。通过 <code>loadBeanDefinitions(String)</code> 来从一个地址加载类定义。</td></tr><tr><td style="text-align:left"><code>AbstractBeanDefinitionReader</code></td><td style="text-align:left">实现 <code>BeanDefinitionReader</code> 接口的抽象类（未具体实现 <code>loadBeanDefinitions</code>，而是规范了 <code>BeanDefinitionReader</code> 的基本结构）。内置一个 <code>HashMap rigistry</code>，用于保存 <code>String</code> - <code>beanDefinition</code> 的键值对。内置一个 <code>ResourceLoader resourceLoader</code>，用于保存类加载器。用意在于，使用时，只需要向其 <code>loadBeanDefinitions()</code> 传入一个资源地址，就可以自动调用其类加载器，并把解析到的 <code>BeanDefinition</code> 保存到 <code>registry</code> 中去。</td></tr><tr><td style="text-align:left"><code>XmlBeanDefinitionReader</code></td><td style="text-align:left">具体实现了 <code>loadBeanDefinitions()</code> 方法，从 XML 文件中读取类定义。</td></tr></tbody></table></div><h4 id="BeanFactory-question"><a href="#BeanFactory-question" class="headerlink" title="BeanFactory :question:"></a>BeanFactory <span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>以 <code>BeanFactory</code> 接口为核心发散出的几个类，都是用于解决 IoC 容器在 <strong>已经获取 <code>Bean</code> 的定义的情况下，如何装配、获取 <code>Bean</code> 实例</strong> </p><p>的问题。</p><div class="table-container"><table><thead><tr><th style="text-align:left">类名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>BeanFactory</code></td><td style="text-align:left">接口，标识一个 IoC 容器。通过 <code>getBean(String)</code> 方法来 <strong>获取一个对象</strong></td></tr><tr><td style="text-align:left"><code>AbstractBeanFactory</code></td><td style="text-align:left"><code>BeanFactory</code> 的一种抽象类实现，规范了 IoC 容器的基本结构，但是把生成 <code>Bean</code> 的具体实现方式留给子类实现。IoC 容器的结构：<code>AbstractBeanFactory</code> 维护一个 <code>beanDefinitionMap</code> 哈希表用于保存类的定义信息（<code>BeanDefinition</code>）。获取 <code>Bean</code> 时，如果 <code>Bean</code> 已经存在于容器中，则返回之，否则则调用 <code>doCreateBean</code> 方法装配一个 <code>Bean</code>。（所谓存在于容器中，是指容器可以通过 <code>beanDefinitionMap</code> 获取 <code>BeanDefinition</code> 进而通过其 <code>getBean()</code> 方法获取 <code>Bean</code>。）</td></tr><tr><td style="text-align:left"><code>AutowireCapableBeanFactory</code></td><td style="text-align:left">可以实现自动装配的 <code>BeanFactory</code>。在这个工厂中，实现了 <code>doCreateBean</code> 方法，该方法分三步：1，通过 <code>BeanDefinition</code> 中保存的类信息实例化一个对象；2，把对象保存在 <code>BeanDefinition</code> 中，以备下次获取；3，为其装配属性。装配属性时，通过 <code>BeanDefinition</code> 中维护的 <code>PropertyValues</code> 集合类，把 <code>String</code> - <code>Value</code> 键值对注入到 <code>Bean</code> 的属性中去。如果 <code>Value</code> 的类型是 <code>BeanReference</code> 则说明其是一个引用（对应于 XML 中的 <code>ref</code>），通过 <code>getBean</code> 对其进行获取，然后注入到属性中。</td></tr></tbody></table></div><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>以 <code>ApplicationContext</code> 接口为核心发散出的几个类，主要是对前面 <code>Resouce</code> 、 <code>BeanFactory</code>、<code>BeanDefinition</code> 进行了功能的封装，解决 <strong>根据地址获取 IoC 容器并使用</strong> 的问题。</p><div class="table-container"><table><thead><tr><th style="text-align:left">类名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>ApplicationContext</code></td><td style="text-align:left">标记接口，继承了 <code>BeanFactory</code>。通常，要实现一个 IoC 容器时，需要先通过 <code>ResourceLoader</code> 获取一个 <code>Resource</code>，其中包括了容器的配置、<code>Bean</code> 的定义信息。接着，使用 <code>BeanDefinitionReader</code> 读取该 <code>Resource</code> 中的 <code>BeanDefinition</code> 信息。最后，把 <code>BeanDefinition</code> 保存在 <code>BeanFactory</code> 中，容器配置完毕可以使用。注意到 <code>BeanFactory</code> 只实现了 <code>Bean</code> 的 <strong>装配、获取</strong>，并未说明 <code>Bean</code> 的 <strong>来源</strong> 也就是 <code>BeanDefinition</code> 是如何 <strong>加载</strong> 的。该接口把 <code>BeanFactory</code> 和 <code>BeanDefinitionReader</code> 结合在了一起。</td></tr><tr><td style="text-align:left"><code>AbstractApplicationContext</code></td><td style="text-align:left"><code>ApplicationContext</code> 的抽象实现，内部包含一个 <code>BeanFactory</code> 类。主要方法有 <code>getBean()</code> 和 <code>refresh()</code> 方法。<code>getBean()</code> 直接调用了内置 <code>BeanFactory</code> 的 <code>getBean()</code> 方法，<code>refresh()</code> 则用于实现 <code>BeanFactory</code> 的刷新，也就是告诉 <code>BeanFactory</code> 该使用哪个资源（<code>Resource</code>）加载类定义（<code>BeanDefinition</code>）信息，该方法留给子类实现，用以实现 <strong>从不同来源的不同类型的资源加载类定义</strong> 的效果。</td></tr><tr><td style="text-align:left">ClassPathXmlApplicationContext</td><td style="text-align:left">从类路径加载资源的具体实现类。内部通过 <code>XmlBeanDefinitionReader</code> 解析 <code>UrlResourceLoader</code> 读取到的 <code>Resource</code>，获取 <code>BeanDefinition</code> 信息，然后将其保存到内置的 <code>BeanFactory</code> 中。</td></tr></tbody></table></div><blockquote><p>对 <code>ApplicatinoContext</code> 的分层更为细致。<code>AbstractApplicationContext</code> 中为了实现 <strong>不同来源</strong> 的 <strong>不同类型</strong> 的资源加载类定义，把这两步分层实现。以“从类路径读取 XML 定义”为例，首先使用 <code>AbstractXmlApplicationContext</code> 来实现 <strong>不同类型</strong> 的资源解析，接着，通过 <code>ClassPathXmlApplicationContext</code> 来实现 <strong>不同来源</strong> 的资源解析。</p></blockquote><h1 id="战略观望"><a href="#战略观望" class="headerlink" title="战略观望"></a>战略观望</h1><p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210520110056368.png" alt="官网示例" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210520105808650.png" alt="Spring容器功能实现的各个阶段"></p><h2 id="容器启动阶段"><a href="#容器启动阶段" class="headerlink" title="容器启动阶段"></a>容器启动阶段</h2><p>使用Resource相关接口标识我们配置文件从哪里获取，然后使用BeanDefinitionReader对标识的文件进行解析，将分析后的信息编组为相应的BeanDefinition。最后将保存了每个Bean定义信息的BeanDefinition，注册到相应的BeanDefinitionRegistry，这样容器的启动就完成了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210520110900263.png" alt="启动阶段任务" title="">                </div>                <div class="image-caption">启动阶段任务</div>            </figure><h2 id="Bean实例化阶段"><a href="#Bean实例化阶段" class="headerlink" title="Bean实例化阶段"></a>Bean实例化阶段</h2><p>通过容器的启动阶段，现在所有的Bean定义的信息，都通过BeanDefiniton的方式注册到了BeanDefinitionRegistry中，当某个请求方通过容器的getBean方法明确的调用某个对象的时候，或者因为依赖关系容器需要隐式的调用getBean方法，就会出发第二阶段的活动。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210520150106541.png" alt="bean的实例化过程" title="">                </div>                <div class="image-caption">bean的实例化过程</div>            </figure><p>Spring容器将对其所管理的对象全部给予统一的生命周期管理，这些被管理的对象完全摆脱了原 来那种“new完后被使用，脱离作用域后即被回收”的命运</p><h1 id="详细阐述"><a href="#详细阐述" class="headerlink" title="详细阐述"></a>详细阐述</h1><h2 id="最简单的IoC容器"><a href="#最简单的IoC容器" class="headerlink" title="最简单的IoC容器"></a>最简单的IoC容器</h2><pre><code class="lang-java">public class BeanFactory {  // 说白了就是一个map    private Map&lt;String, Object&gt; beanMap = new HashMap&lt;&gt;();    public void registerBean(String name, Object bean) {        beanMap.put(name, bean);    }    public Object getBean(String name) {        return beanMap.get(name);    }}public class SimpleBeanContainerTest {    @Test    public void testGetBean() throws Exception {    // 需要我们去手动new依赖对象，然后放入        BeanFactory beanFactory = new BeanFactory();        beanFactory.registerBean("helloService", new HelloService());        HelloService helloService = (HelloService) beanFactory.getBean("helloService");        assertThat(helloService).isNotNull();        assertThat(helloService.sayHello()).isEqualTo("hello");    }    class HelloService {        public String sayHello() {            System.out.println("hello");            return "hello";        }    }}</code></pre><h2 id="BeanFactoryPostProcess和BeanPostProcessor"><a href="#BeanFactoryPostProcess和BeanPostProcessor" class="headerlink" title="BeanFactoryPostProcess和BeanPostProcessor"></a>BeanFactoryPostProcess和BeanPostProcessor</h2><p>BeanFactoryPostProcess和BeanPostProcessor是spring框架中具有重量级地位的两个接口，理解了这两个接口的作用，基本就理解spring的核心原理了</p><ol><li>BeanFactoryPostProcessor是spring提供的容器拓展机制，允许我们在<strong>bean实例化之前修改bean的定义信息（BeanDedinition）</strong>，其重要的实现类PropertyPlaceholderConfigurer和CustomEditorConfigurer<ul><li>PropertyPlaceholderConfigurer的作用是用properties文件的配置值替换xml文件中的占位符</li><li>CustomEditorConfigurer的作用是实现类型转换。</li></ul></li><li>BeanPostProcessor也是spring提供的容器拓展机制，不同于BeanFactoryPostProcessor，BeanPostProcesssor在<strong>Bean实例化之后修改Bean或替换Bean</strong>。也是实现AOP的关键。</li></ol><p>等等等。。。</p><h2 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a>整体流程图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/iShot2021-05-21%2000.08.58.png" alt="整体流程图" title="">                </div>                <div class="image-caption">整体流程图</div>            </figure><ol><li>BeanDefinitionReader读取Bean的相关配置信息，并将读取到的信息使用BeanDefinition表示，同时注册到BeanDefinitionRegistry中。</li><li>通过实现了BeanFactoryPostProcessor的类，自定义修改BeanDefinition中的信息</li><li>Bean的实例化<ol><li>采用策略模式，策略化Bean的实例，共包含两种方式：cglib、反射</li><li>获取Bean的实例之后，根据BeanDefinition中的信息，填充Bean的属性、依赖</li></ol></li><li>检测各种检测各种Aware接口，并放入Bean中</li><li>调用BeanPostProcessor接口的前置处理方法，处理符合要求的Bean实例</li><li>如果实现了InitializingBean接口，则处理对应的afterPropertiesSet()方法</li><li>如果定义init-method方法，处理对应的初始化方法</li><li>调用BeanPostProcessor接口的后置处理方法，处理符合要求的Bean实例</li><li>使用</li><li>判断Bean的Scope，如果是prototype，不再管理</li><li>如果是单例，如果实现了DisposableBean接口，则执行对应的destroy方法</li><li>如果定义了destory-method，则执行自定义的销毁方法</li></ol><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>整理的还是很乱，虽然看的时候是都看了。。。</p><p>后面慢慢优化吧（涉及到以后==永远不会）<span class="github-emoji"><span>😑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f611.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><ul><li>spring揭秘</li><li><a href="https://github.com/code4craft/tiny-spring" target="_blank" rel="noopener">tiny-spring</a></li><li><a href="https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%AD%96%E7%95%A5InstantiationStrategy" target="_blank" rel="noopener">mini-spring</a></li><li><a href="https://www.zybuluo.com/dugu9sword/note/382745#beanfactory" target="_blank" rel="noopener">tiny-spring分析</a></li><li><a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noopener">Spring IoC容器分析</a></li><li><a href="http://www.tianxiaobo.com/2018/05/30/Spring-IOC-%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/#451-%E5%AE%9E%E7%8E%B0-applicationcontextaware-%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">Spring IOC 容器源码分析系列</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h1&gt;&lt;h2 id=&quot;IoC&quot;&gt;&lt;a href=&quot;#IoC&quot; class=&quot;headerlink&quot; title=&quot;IoC&quot;&gt;&lt;/a&gt;IoC&lt;/h2&gt;&lt;p&gt;IoC</summary>
      
    
    
    
    <category term="spring" scheme="https://winniekun.github.io/categories/spring/"/>
    
    
    <category term="ioc" scheme="https://winniekun.github.io/tags/ioc/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="https://winniekun.github.io/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://winniekun.github.io/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2021-04-30T13:35:01.000Z</published>
    <updated>2021-06-17T04:51:19.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>先选择分界点</li><li>先递归排序</li><li>归并 合二为一</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Users/weikunkun/Library/Application" alt="image-20210419120203122" title="Support/typora-user-images/image-20210419120203122.png">                </div>                <div class="image-caption">Support/typora-user-images/image-20210419120203122.png</div>            </figure><pre><code class="lang-java">private static void mergeSort(int[] array, int l, int r) {        if (l &gt;= r) {            return;        }        int mid = (l + r) / 2;        mergeSort(array, l, mid);        mergeSort(array, mid+1, r);        // 整合        int[] tmp = new int[r - l + 1]; // 临时数组, 用于临时存储 [l,r]区间内排好序的数据        int i = l, j = mid + 1, k = 0;  // 两个指针        // 进行归并        while (i &lt;= mid &amp;&amp; j &lt;= r) {            if (array[i] &lt;= array[j])                 tmp[k++] = array[i++];            else                tmp[k++] = array[j++];        }        while (i &lt;= mid) tmp[k++] = array[i++];        while (j &lt;= r) tmp[k++] = array[j++];        // 进行赋值        for (i = l, j = 0; i &lt;= r; i++, j++)            array[i] = tmp[j];    }</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h2&gt;&lt;h3 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h</summary>
      
    
    
    
    <category term="排序" scheme="https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="归并排序" scheme="https://winniekun.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>死磕数学基础</title>
    <link href="https://winniekun.github.io/stick-to-math/"/>
    <id>https://winniekun.github.io/stick-to-math/</id>
    <published>2021-04-20T11:56:11.000Z</published>
    <updated>2021-05-16T16:42:07.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LeetCode死磕系列十二： 数学基础</p><p>说实话，其实都是刷题都是数学的实现，不过感觉有些题目更加偏向数学应用，譬如蓄水池，等概率抽样…。</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="470-用rand7-实现Rand10"><a href="#470-用rand7-实现Rand10" class="headerlink" title="470 用rand7()实现Rand10()"></a>470 用rand7()实现Rand10()</h3><p><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/cong-zui-ji-chu-de-jiang-qi-ru-he-zuo-dao-jun-yun-/" target="_blank" rel="noopener">从最基础的讲起如何做到均匀的生成随机数</a></p><p>从上述的文章可以得出：</p><blockquote><p><strong>已知:</strong>  <em>$randN()$可以==等概率==生成$[1, N]$范围的数字</em><br><strong>那么:</strong>  $(randN()-1) \times Y  + randY()$可以==等概率==生成$[1, Y \times N]$ 范围的数字</p><p><strong>即：</strong>实现了$randNY()$</p></blockquote><p>以$[(rand9() - 1) \times 7 + rand7()]$为例子</p><div class="table-container"><table><thead><tr><th>rand9()-1\rand7</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td><strong>0</strong></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td><strong>1</strong></td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td></tr><tr><td><strong>2</strong></td><td>15</td><td>16</td><td>17</td><td>18</td><td>19</td><td>20</td><td>21</td></tr><tr><td><strong>3</strong></td><td>22</td><td>23</td><td>24</td><td>25</td><td>26</td><td>27</td><td>28</td></tr><tr><td><strong>4</strong></td><td>29</td><td>30</td><td>31</td><td>32</td><td>33</td><td>34</td><td>35</td></tr><tr><td><strong>5</strong></td><td>36</td><td>37</td><td>38</td><td>39</td><td>40</td><td>41</td><td>42</td></tr><tr><td><strong>6</strong></td><td>43</td><td>44</td><td>45</td><td>46</td><td>47</td><td>48</td><td>49</td></tr><tr><td><strong>7</strong></td><td>50</td><td>51</td><td>52</td><td>53</td><td>54</td><td>55</td><td>56</td></tr><tr><td><strong>8</strong></td><td>57</td><td>58</td><td>59</td><td>60</td><td>61</td><td>62</td><td>63</td></tr></tbody></table></div><p><strong>是不是很神奇，数学证明不会</strong></p><p>那么想到通过rand4()来实现rand2()呢？这个就很简单了，已知rand4()会均匀产生[1,4]的随机数，通过取余，再加1就可以了。如下所示，结果也是等概率的。</p><pre><code>rand4() % 2 + 1 = ?   1 % 2    + 1 = 2   2 % 2    + 1 = 1   3 % 2    + 1 = 2   4 % 2    + 1 = 1</code></pre><p>事实上，只要rand_N()中N是2的倍数，就都可以用来实现rand2()，反之，若N不是2的倍数，则产生的结果不是等概率的。比如：</p><pre><code>rand6() % 2 + 1 = ?   1 % 2    + 1 = 2   2 % 2    + 1 = 1   3 % 2    + 1 = 2   4 % 2    + 1 = 1   5 % 2    + 1 = 2   6 % 2    + 1 = 1rand5() % 2 + 1 = ?   1 % 2    + 1 = 2   2 % 2    + 1 = 1   3 % 2    + 1 = 2   4 % 2    + 1 = 1   5 % 2    + 1 = 2</code></pre><p><strong>通用一些的</strong></p><blockquote><p>如果需要实现$randX()$</p><ol><li>先实现$randN()$<ol><li>$N$为$X$的倍数（$N&gt;X$）</li></ol></li><li>再通过 $randN() \% X + 1$即可</li></ol></blockquote><pre><code class="lang-java">public int rand10() {        // rand 49        while (true) {            int num = (rand7() - 1) * 7 + rand7();  // rand49            if (num &lt;= 40) { // 使用拒绝采样，得到rand40                return num % 10 + 1;  // rand10            }        }    }</code></pre><p><strong>优化</strong></p><pre><code class="lang-java">class Solution extends SolBase {      // 上述拒绝了9个数字，    // 优化之后，减少丢弃值，提高命中率    public int rand10() {        while(true) {            int a = rand7();            int b = rand7();            int num = (a-1)*7 + b; // rand 49            if(num &lt;= 40) return num % 10 + 1; // 拒绝采样            a = num - 40; // rand 9            b = rand7();            num = (a-1)*7 + b; // rand 63            if(num &lt;= 60) return num % 10 + 1;            a = num - 60; // rand 3            b = rand7();            num = (a-1)*7 + b; // rand 21            if(num &lt;= 20) return num % 10 + 1;        }    }}</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;LeetCode死磕系列十二： 数学基础&lt;/p&gt;
&lt;p&gt;说实话，其实都是刷题都是数学的实现，不过感觉有些题目更加偏向数学应用，譬如蓄水池，等概率抽样…。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://winniekun.github.io/categories/LeetCode/"/>
    
    
    <category term="死磕系列" scheme="https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"/>
    
    <category term="数学基础" scheme="https://winniekun.github.io/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>死磕SQL</title>
    <link href="https://winniekun.github.io/stick-to-sql/"/>
    <id>https://winniekun.github.io/stick-to-sql/</id>
    <published>2021-04-20T11:56:11.000Z</published>
    <updated>2021-05-16T16:39:43.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LeetCode死磕系列十： SQL</p><a id="more"></a><p>作为一个后端开发程序员，SQL功底还是很重要的！！！</p><p>所以还是要练习。</p><blockquote><p>还记得去年被字节面试的时候，连SQL都写不出来。。。</p></blockquote><h2 id="LeetCode-SQL题目整理"><a href="#LeetCode-SQL题目整理" class="headerlink" title="LeetCode SQL题目整理"></a>LeetCode SQL题目整理</h2><p>刷了LC上的top70之后，感觉考察最多的还是多表的联合查找，毕竟实际中也不会仅仅是单表的查询。</p><p><strong>主要题型：</strong></p><ol><li>TOP N 问题</li><li>排名问题<ol><li>滑动窗口</li></ol></li><li>自链接问题</li></ol><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="TOP-N问题"><a href="#TOP-N问题" class="headerlink" title="TOP N问题"></a>TOP N问题</h3><h4 id="176-第二高的薪水"><a href="#176-第二高的薪水" class="headerlink" title="176. 第二高的薪水"></a><a href="https://leetcode-cn.com/problems/second-highest-salary/" target="_blank" rel="noopener">176. 第二高的薪水</a></h4><p><strong>思路：</strong></p><ol><li><p>使用limit</p><p>注意判空、去重</p><pre><code class="lang-sql">select ifnull ((select     distinct Salary from    Employeeorder by Salary desclimit 1, 1) , null) as SecondHighestSalary;</code></pre></li></ol><ol><li>先使用max查询最高的薪水 max，之后再通过自查询，查询小于max的max</li></ol><h4 id="184-部门工资最高的员工"><a href="#184-部门工资最高的员工" class="headerlink" title="184. 部门工资最高的员工"></a><a href="https://leetcode-cn.com/problems/department-highest-salary/" target="_blank" rel="noopener">184. 部门工资最高的员工</a></h4><pre><code class="lang-sql">-- 思路： 寻找最大薪资的数据-- join-- 1. 直接join group by  选取最大的即可 但是 无法保证最大的薪资不重复 失败-- 2. 先通过员工信息 寻找最大的薪资+id 的数据A，然后再join 两张表，将A中对应的数据返回-- 1. select     d.Name as Department,    e.Name as Employee,    e.Salary as Salaryfrom     Employee e inner join Department d on e.DepartmentId = d.Idwhere     (e.DepartmentId, e.Salary) in    (select         DepartmentId,        max(Salary)    from         Employee    group by         DepartmentId);</code></pre><h4 id="177-第N高的薪水"><a href="#177-第N高的薪水" class="headerlink" title="177. 第N高的薪水"></a><a href="https://leetcode-cn.com/problems/nth-highest-salary/" target="_blank" rel="noopener">177. 第N高的薪水</a></h4><p>LIMIT PAGE, OFFSET</p><p>跳过 PAGE * OFFSET条数据，接下来的offset条数据， 因为题目中未说明薪资是否不重复，所以还需要使用distinct去重</p><pre><code class="lang-sql">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN  set N:= N-1;  RETURN (        # Write your MySQL query statement below.    select         distinct Salary    from         Employee    order by         Salary desc    limit N,1  );END</code></pre><h4 id="185-部门工资前三高的所有员工"><a href="#185-部门工资前三高的所有员工" class="headerlink" title="185. 部门工资前三高的所有员工"></a><a href="https://leetcode-cn.com/problems/department-top-three-salaries/" target="_blank" rel="noopener">185. 部门工资前三高的所有员工</a></h4><pre><code class="lang-sql">select d.Name as Department, e2.Name as Employee, e2.Salary from Department d inner join (    select e.*,     dense_rank() over(partition by DepartmentID     Order by Salary DESC) as 'rank'    from Employee e ) e2 on d.Id= e2.DepartmentIDwhere e2.rank&lt;=3order by Department AND Salary</code></pre><h3 id="排名问题"><a href="#排名问题" class="headerlink" title="排名问题"></a>排名问题</h3><h4 id="178-分数排名"><a href="#178-分数排名" class="headerlink" title="178.分数排名"></a><a href="https://leetcode-cn.com/problems/rank-scores/" target="_blank" rel="noopener">178.分数排名</a></h4><pre><code class="lang-sql">select     Score, dense_rank() over(order by Score desc) as `Rank`from Scores;</code></pre><h3 id="自链接问题"><a href="#自链接问题" class="headerlink" title="自链接问题"></a>自链接问题</h3><h4 id="603-连续空余座位"><a href="#603-连续空余座位" class="headerlink" title="603. 连续空余座位"></a><a href="https://leetcode-cn.com/problems/consecutive-available-seats/" target="_blank" rel="noopener">603. 连续空余座位</a></h4><pre><code class="lang-sql">-- 几个朋友来到电影院的售票处，准备预约连续空余座位。-- 你能利用表 cinema ，帮他们写一个查询语句，获取所有空余座位，并将它们按照 seat_id 排序后返回吗？select distinct a.seat_idfrom cinema a join cinema b  on abs(a.seat_id - b.seat_id) = 1  and a.free = true and b.free = trueorder by a.seat_id</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;LeetCode死磕系列十： SQL&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://winniekun.github.io/categories/LeetCode/"/>
    
    
    <category term="死磕系列" scheme="https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"/>
    
    <category term="SQL" scheme="https://winniekun.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>死磕多线程</title>
    <link href="https://winniekun.github.io/stick-to-multi-thread/"/>
    <id>https://winniekun.github.io/stick-to-multi-thread/</id>
    <published>2021-04-14T11:56:11.000Z</published>
    <updated>2021-06-06T07:56:37.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LeetCode死磕系列十一： 多线程</p><a id="more"></a><p>看那么多的面经，发现已经开始询问多线程的编程了。个人感觉多线程编程主要是理解，思想。是有固定的套路的，譬如：交替输出，有序的输出哇。深挖下去就是考察对线程通讯的使用，以及一些高阶用法。和哲学家就餐问题、生产者消费者问题、读写者问题差不多。</p><p>所以～～～</p><p>我来开始熟悉并发操作了，毕竟光看不练假把式</p><h2 id="LeetCode-多线程题目整理"><a href="#LeetCode-多线程题目整理" class="headerlink" title="LeetCode 多线程题目整理"></a>LeetCode 多线程题目整理</h2><h3 id="1114-按序打印"><a href="#1114-按序打印" class="headerlink" title="1114. 按序打印"></a><a href="https://leetcode-cn.com/problems/print-in-order/" target="_blank" rel="noopener">1114. 按序打印</a></h3>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;LeetCode死磕系列十一： 多线程&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://winniekun.github.io/categories/LeetCode/"/>
    
    
    <category term="死磕系列" scheme="https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"/>
    
    <category term="多线程" scheme="https://winniekun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一行一行源码分析清楚AbstractQueuedSynchronizer</title>
    <link href="https://winniekun.github.io/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9AAbstractQueuedSynchronizer/"/>
    <id>https://winniekun.github.io/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9AAbstractQueuedSynchronizer/</id>
    <published>2021-03-30T12:14:20.000Z</published>
    <updated>2021-04-05T12:19:21.814Z</updated>
    
    <content type="html"><![CDATA[<p>在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础。</p><p>Google 一下 AbstractQueuedSynchronizer，我们可以找到很多关于 AQS 的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。</p><p>本文将从 ReentrantLock 的公平锁源码出发，分析下 AbstractQueuedSynchronizer 这个类是怎么工作的，希望能给大家提供一些简单的帮助。</p><a id="more"></a><p>申明以下几点：</p><ol><li>本文有点长，但还是挺简单，主要面向读者对象为并发编程的初学者，或者想要阅读 Java 并发包源码的开发者。对于新手来说，可能需要花好几个小时才能完全看懂，但是这时间肯定是值得的。</li><li>源码环境 JDK1.7（1.8没啥变化），看到不懂或有疑惑的部分，最好能自己打开源码看看。Doug Lea 大神的代码写得真心不错。</li><li>本文不分析共享模式，这样可以给读者减少很多负担，<a href="/post/AbstractQueuedSynchronizer-3">第三篇文章</a>对共享模式进行了分析。而且也不分析 condition 部分，所以应该说很容易就可以看懂了。</li><li>本文大量使用我们平时用得最多的 ReentrantLock 的概念，本质上来说是不正确的，读者应该清楚，AQS 不仅仅用来实现可重入锁，只是希望读者可以用锁来联想 AQS 的使用场景，降低阅读压力。</li><li>ReentrantLock 的公平锁和非公平锁只有一点点区别，<a href="/post/AbstractQueuedSynchronizer-2">第二篇文章</a>做了介绍。</li><li>评论区有读者反馈本文直接用代码说不友好，应该多配点流程图，这篇文章确实有这个问题。但是作为过来人，我想告诉大家，对于 AQS 来说，形式真的不重要，重要的是把细节说清楚。</li></ol><h2 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h2><p>先来看看 AQS 有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了，毕竟可以猜嘛！</p><pre><code class="lang-java">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的private transient volatile Node head;// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表private transient volatile Node tail;// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1private volatile int state;// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁// if (currentThread == getExclusiveOwnerThread()) {state++}private transient Thread exclusiveOwnerThread; //继承自AbstractOwnableSynchronizer</code></pre><p>怎么样，看样子应该是很简单的吧，毕竟也就四个属性啊。</p><p>AbstractQueuedSynchronizer 的等待队列示意如下所示，注意了，之后分析过程中所说的 queue，也就是阻塞队列<strong>不包含 head，不包含 head，不包含 head</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-0.png" alt="aqs-0" title="">                </div>                <div class="image-caption">aqs-0</div>            </figure><p>等待队列中每个线程被包装成一个 Node 实例，数据结构是链表，一起看看源码吧：</p><pre><code class="lang-java">static final class Node {    // 标识节点当前在共享模式下    static final Node SHARED = new Node();    // 标识节点当前在独占模式下    static final Node EXCLUSIVE = null;    // ======== 下面的几个int常量是给waitStatus用的 ===========    /** waitStatus value to indicate thread has cancelled */    // 代码此线程取消了争抢这个锁    static final int CANCELLED =  1;    /** waitStatus value to indicate successor's thread needs unparking */    // 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒    static final int SIGNAL    = -1;    /** waitStatus value to indicate thread is waiting on condition */    // 本文不分析condition，所以略过吧，下一篇文章会介绍这个    static final int CONDITION = -2;    /**     * waitStatus value to indicate the next acquireShared should     * unconditionally propagate     */    // 同样的不分析，略过吧    static final int PROPAGATE = -3;    // =====================================================    // 取值为上面的1、-1、-2、-3，或者0(以后会讲到)    // 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，    //    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。    volatile int waitStatus;    // 前驱节点的引用    volatile Node prev;    // 后继节点的引用    volatile Node next;    // 这个就是线程本尊    volatile Thread thread;}</code></pre><p>Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。</p><p>上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说 ReentrantLock 的公平锁。再次强调，我说的阻塞队列不包含 head 节点。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-0.png" alt="aqs-0" title="">                </div>                <div class="image-caption">aqs-0</div>            </figure><p>首先，我们先看下 ReentrantLock 的使用方式。</p><pre><code class="lang-java">// 我用个web开发中的service概念吧public class OrderService {    // 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个    private static ReentrantLock reentrantLock = new ReentrantLock(true);    public void createOrder() {        // 比如我们同一时间，只允许一个线程创建订单        reentrantLock.lock();        // 通常，lock 之后紧跟着 try 语句        try {            // 这块代码同一时间只能有一个线程进来(获取到锁的线程)，            // 其他的线程在lock()方法上阻塞，等待获取到锁，再进来            // 执行代码...            // 执行代码...            // 执行代码...        } finally {            // 释放锁            reentrantLock.unlock();        }    }}</code></pre><p>ReentrantLock 在内部用了内部类 Sync 来管理锁，所以真正的获取锁和释放锁是由 Sync 的实现类来控制的。</p><pre><code class="lang-java">abstract static class Sync extends AbstractQueuedSynchronizer {}</code></pre><p>Sync 有两个实现，分别为 NonfairSync（非公平锁）和 FairSync（公平锁），我们看 FairSync 部分。</p><pre><code class="lang-java">public ReentrantLock(boolean fair) {    sync = fair ? new FairSync() : new NonfairSync();}</code></pre><h2 id="线程抢锁"><a href="#线程抢锁" class="headerlink" title="线程抢锁"></a>线程抢锁</h2><p>很多人肯定开始嫌弃上面废话太多了，下面跟着代码走，我就不废话了。</p><pre><code class="lang-java">static final class FairSync extends Sync {    private static final long serialVersionUID = -3000897897090466540L;      // 争锁    final void lock() {        acquire(1);    }      // 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力    // 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。    // 否则，acquireQueued方法会将线程压到队列中    public final void acquire(int arg) { // 此时 arg == 1        // 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试        // 因为有可能直接就成功了呢，也就不需要进队列排了，        // 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)        if (!tryAcquire(arg) &amp;&amp;            // tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) {              selfInterrupt();        }    }    /**     * Fair version of tryAcquire.  Don't grant access unless     * recursive call or no waiters or is first.     */    // 尝试直接获取锁，返回值是boolean，代表是否获取到锁    // 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取    protected final boolean tryAcquire(int acquires) {        final Thread current = Thread.currentThread();        int c = getState();        // state == 0 此时此刻没有线程持有锁        if (c == 0) {            // 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，            // 看看有没有别人在队列中等了半天了            if (!hasQueuedPredecessors() &amp;&amp;                // 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，                // 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=                // 因为刚刚还没人的，我判断过了                compareAndSetState(0, acquires)) {                // 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁                setExclusiveOwnerThread(current);                return true;            }        }          // 会进入这个else if分支，说明是重入了，需要操作：state=state+1        // 这里不存在并发问题        else if (current == getExclusiveOwnerThread()) {            int nextc = c + acquires;            if (nextc &lt; 0)                throw new Error("Maximum lock count exceeded");            setState(nextc);            return true;        }        // 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁        // 回到上面一个外层调用方法继续看:        // if (!tryAcquire(arg)         //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))         //     selfInterrupt();        return false;    }    // 假设tryAcquire(arg) 返回false，那么代码将执行：      //        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，    // 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)    /**     * Creates and enqueues node for current thread and given mode.     *     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared     * @return the new node     */    // 此方法的作用是把线程包装成node，同时进入到队列中    // 参数mode此时是Node.EXCLUSIVE，代表独占模式    private Node addWaiter(Node mode) {        Node node = new Node(Thread.currentThread(), mode);        // Try the fast path of enq; backup to full enq on failure        // 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后        Node pred = tail;        // tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)        if (pred != null) {             // 将当前的队尾节点，设置为自己的前驱             node.prev = pred;             // 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴            if (compareAndSetTail(pred, node)) {                 // 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，                // 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了                pred.next = node;                // 线程入队了，可以返回了                return node;            }        }        // 仔细看看上面的代码，如果会到这里，        // 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)        // 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的        enq(node);        return node;    }    /**     * Inserts node into queue, initializing if necessary. See picture above.     * @param node the node to insert     * @return node's predecessor     */    // 采用自旋的方式入队    // 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，    // 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的    private Node enq(final Node node) {        for (;;) {            Node t = tail;            // 之前说过，队列为空也会进来这里            if (t == null) { // Must initialize                // 初始化head节点                // 细心的读者会知道原来 head 和 tail 初始化的时候都是 null 的                // 还是一步CAS，你懂的，现在可能是很多线程同时进来呢                if (compareAndSetHead(new Node()))                    // 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了                    // 这个时候有了head，但是tail还是null，设置一下，                    // 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了                    // 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return                    // 所以，设置完了以后，继续for循环，下次就到下面的else分支了                    tail = head;            } else {                // 下面几行，和上一个方法 addWaiter 是一样的，                // 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排                node.prev = t;                if (compareAndSetTail(t, node)) {                    t.next = node;                    return t;                }            }        }    }    // 现在，又回到这段代码了    // if (!tryAcquire(arg)     //        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))     //     selfInterrupt();    // 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列    // 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，    // 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false    // 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了    final boolean acquireQueued(final Node node, int arg) {        boolean failed = true;        try {            boolean interrupted = false;            for (;;) {                final Node p = node.predecessor();                // p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head                // 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列                // 所以当前节点可以去试抢一下锁                // 这里我们说一下，为什么可以去试试：                // 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，                // enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程                // 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，                // tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state                if (p == head &amp;&amp; tryAcquire(arg)) {                    setHead(node);                    p.next = null; // help GC                    failed = false;                    return interrupted;                }                // 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，                // 要么就是tryAcquire(arg)没有抢赢别人，继续往下看                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                    parkAndCheckInterrupt())                    interrupted = true;            }        } finally {            // 什么时候 failed 会为 true???            // tryAcquire() 方法抛异常的情况            if (failed)                cancelAcquire(node);        }    }    /**     * Checks and updates status for a node that failed to acquire.     * Returns true if thread should block. This is the main signal     * control in all acquire loops.  Requires that pred == node.prev     *     * @param pred node's predecessor holding status     * @param node the node     * @return {@code true} if thread should block     */    // 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是："当前线程没有抢到锁，是否需要挂起当前线程？"    // 第一个参数是前驱节点，第二个参数才是代表当前线程的节点    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {        int ws = pred.waitStatus;        // 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true        if (ws == Node.SIGNAL)            /*             * This node has already set status asking a release             * to signal it, so it can safely park.             */            return true;        // 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。        // 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。        // 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，        // 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，        // 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的        if (ws &gt; 0) {            /*             * Predecessor was cancelled. Skip over predecessors and             * indicate retry.             */            do {                node.prev = pred = pred.prev;            } while (pred.waitStatus &gt; 0);            pred.next = node;        } else {            /*             * waitStatus must be 0 or PROPAGATE.  Indicate that we             * need a signal, but don't park yet.  Caller will need to             * retry to make sure it cannot acquire before parking.             */            // 仔细想想，如果进入到这个分支意味着什么            // 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3            // 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0            // 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0            // 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);        }        // 这个方法返回 false，那么会再走一次 for 循序，        //     然后再次进来此方法，此时会从第一个分支返回 true        return false;    }    // private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)    // 这个方法结束根据返回值我们简单分析下：    // 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒    //        我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了    // 如果返回false, 说明当前不需要被挂起，为什么呢？往后看    // 跳回到前面是这个方法    // if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;    //                parkAndCheckInterrupt())    //                interrupted = true;    // 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，    // 那么需要执行parkAndCheckInterrupt():    // 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的    // 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======    private final boolean parkAndCheckInterrupt() {        LockSupport.park(this);        return Thread.interrupted();    }    // 2. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况   // 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。    // 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：    // =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。}</code></pre><p>说到这里，也就明白了，多看几遍 <code>final boolean acquireQueued(final Node node, int arg)</code> 这个方法吧。自己推演下各个分支怎么走，哪种情况下会发生什么，走到哪里。</p><h2 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h2><p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被 <code>LockSupport.park(this);</code> 挂起停止，等待被唤醒。</p><pre><code class="lang-java">// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了public void unlock() {    sync.release(1);}public final boolean release(int arg) {    // 往后看吧    if (tryRelease(arg)) {        Node h = head;        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    }    return false;}// 回到ReentrantLock看tryRelease方法protected final boolean tryRelease(int releases) {    int c = getState() - releases;    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    // 是否完全释放锁    boolean free = false;    // 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉    if (c == 0) {        free = true;        setExclusiveOwnerThread(null);    }    setState(c);    return free;}/** * Wakes up node's successor, if one exists. * * @param node the node */// 唤醒后继节点// 从上面调用处知道，参数node是head头结点private void unparkSuccessor(Node node) {    /*     * If status is negative (i.e., possibly needing signal) try     * to clear in anticipation of signalling.  It is OK if this     * fails or if status is changed by waiting thread.     */    int ws = node.waitStatus;    // 如果head节点当前waitStatus&lt;0, 将其修改为0    if (ws &lt; 0)        compareAndSetWaitStatus(node, ws, 0);    /*     * Thread to unpark is held in successor, which is normally     * just the next node.  But if cancelled or apparently null,     * traverse backwards from tail to find the actual     * non-cancelled successor.     */    // 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）    // 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的    Node s = node.next;    if (s == null || s.waitStatus &gt; 0) {        s = null;        // 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)            if (t.waitStatus &lt;= 0)                s = t;    }    if (s != null)        // 唤醒线程        LockSupport.unpark(s.thread);}</code></pre><p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p><pre><code class="lang-java">private final boolean parkAndCheckInterrupt() {    LockSupport.park(this); // 刚刚线程被挂起在这里了    return Thread.interrupted();}// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</code></pre><p>好了，后面就不分析源码了，剩下的还有问题自己去仔细看看代码吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下吧。</p><p>在并发环境下，加锁和解锁需要以下三个部件的协调：</p><ol><li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li><li>线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。</li><li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现，感兴趣的读者可以参考这篇文章<a href="http://coderbee.net/index.php/concurrent/20131115/577" target="_blank" rel="noopener">关于CLH的介绍</a>，写得简单明了。</li></ol><h2 id="示例图解析"><a href="#示例图解析" class="headerlink" title="示例图解析"></a>示例图解析</h2><p>下面属于回顾环节，用简单的示例来说一遍，如果上面的有些东西没看懂，这里还有一次帮助你理解的机会。</p><p>首先，第一个线程调用 reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回 true 了，结束。只是设置了 state=1，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，那世界就太太太平了，完全没有交集嘛，那我还要 AQS 干嘛。</p><p>如果线程 1 没有调用 unlock() 之前，线程 2 调用了 lock(), 想想会发生什么？</p><p>线程 2 会初始化 head【new Node()】，同时线程 2 也会插入到阻塞队列并挂起 (注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环)</p><pre><code class="lang-java">private Node enq(final Node node) {    for (;;) {        Node t = tail;        if (t == null) { // Must initialize            if (compareAndSetHead(new Node()))                tail = head;        } else {            node.prev = t;            if (compareAndSetTail(t, node)) {                t.next = node;                return t;            }        }    }}</code></pre><p>首先，是线程 2 初始化 head 节点，此时 head==tail, waitStatus==0</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-1.png" alt="aqs-1" title="">                </div>                <div class="image-caption">aqs-1</div>            </figure><p>然后线程 2 入队：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-2.png" alt="aqs-2" title="">                </div>                <div class="image-caption">aqs-2</div>            </figure><p>同时我们也要看此时节点的 waitStatus，我们知道 head 节点是线程 2 初始化的，此时的 waitStatus 没有设置， java 默认会设置为 0，但是到 shouldParkAfterFailedAcquire 这个方法的时候，线程 2 会把前驱节点，也就是 head 的waitStatus设置为 -1。</p><p>那线程 2 节点此时的 waitStatus 是多少呢，由于没有设置，所以是 0；</p><p>如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 shouldParkAfterFailedAcquire 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-3.png" alt="aqs-3" title="">                </div>                <div class="image-caption">aqs-3</div>            </figure><p>这里可以简单说下 waitStatus 中 SIGNAL(-1) 状态的意思，Doug Lea 注释的是：代表后继节点需要被唤醒。也就是说这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着 “waitStatus代表后继节点的状态” 这种思路去看一遍源码。</p><p>（全文完）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础。&lt;/p&gt;
&lt;p&gt;Google 一下 AbstractQueuedSynchronizer，我们可以找到很多关于 AQS 的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。&lt;/p&gt;
&lt;p&gt;本文将从 ReentrantLock 的公平锁源码出发，分析下 AbstractQueuedSynchronizer 这个类是怎么工作的，希望能给大家提供一些简单的帮助。&lt;/p&gt;</summary>
    
    
    
    <category term="concurrency" scheme="https://winniekun.github.io/categories/concurrency/"/>
    
    
  </entry>
  
  <entry>
    <title>2020年总结</title>
    <link href="https://winniekun.github.io/2020%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>https://winniekun.github.io/2020%E5%B9%B4%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-02T16:11:11.000Z</published>
    <updated>2021-01-02T16:40:50.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="啊"><a href="#啊" class="headerlink" title="啊"></a>啊</h2><a id="more"></a><p>2020年到底还是结束了，感觉现在的自己也不喜欢做各种阶段性总结了，总感觉把自己的经历写出来是一种特别矫情的事情。相反，更想把这些经历仅供自己慢慢回味和感触。但是，时间久了，有些东西记得就不够客观了（虽然现在记忆的也不够观。。。）</p><p>所以，以后的每一年都还是做一次年终小结吧。</p><h2 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h2><p>因为疫情，上半年一直在家里呆着，每天的生活差不多如下</p><div class="table-container"><table><thead><tr><th>时间</th><th>干啥</th></tr></thead><tbody><tr><td>上午</td><td>网课（挂机，干自己的事情）</td></tr><tr><td>下午</td><td>网课（挂机，干自己的事情）</td></tr><tr><td>晚上</td><td>和韩老师还有沈总打游戏</td></tr></tbody></table></div><p>在上网课的3个月里，自己虽然课没好好上过，不过还是做了一些事情的：</p><ol><li>剑指offer刷了3遍</li><li>LeetCode300大关完成</li><li>深入理解JVM虚拟机终于是看懂了</li><li>JDK源码（collection、juc）嗑了一遍<ol><li>HashMap的设计是真的精妙</li><li>红黑树真的不是正常人写的来的</li></ol></li><li>操作系统过了一遍</li></ol><p>为啥要做这些事情嘞，主要还是想找实习，感觉在学校里面呆腻了，想出来看看（什么**想法）…</p><p>终于，在我的艰苦复习和准备之下，我心仪的字节还是把我拒绝了（今年只面了字节一家大厂），被打击到了之后，也就没再继续投递其他大厂。后面通过牛客上的内推，来到了蔚来汽车实习。</p><h2 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a>下半年</h2><p>从9月中旬起，开始我的实习生活，从刚开始的不适应，到后面的一脸懵逼，再到现在的勉强适应。让我认识到了自己技术上的不足，以及交流上的问题。所以基本每天回来都会主动去看每个节点的所负责的业务逻辑，涉及哪些技术栈，这些技术栈是怎么使用的，和我之前自己写着玩儿的有什么区别。自己也学会了在做任务的时候，先去看需求背景，再去看实现方案，然后脑子构建实现方式，最后再看是撸代码。遇到了自己解决不了的，有疑惑的地方，也渐渐的学会主动去请教同事了。最后，在距离实习结束还有两个月不到的时间里，希望能够拓宽自己的技术栈，精进自己的技术深度。主动去和同事交流，学习经验。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;啊&quot;&gt;&lt;a href=&quot;#啊&quot; class=&quot;headerlink&quot; title=&quot;啊&quot;&gt;&lt;/a&gt;啊&lt;/h2&gt;</summary>
    
    
    
    <category term="碎碎念" scheme="https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="杂谈" scheme="https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>2021年书单【年汇总】</title>
    <link href="https://winniekun.github.io/2021%E5%B9%B4%E4%B9%A6%E5%8D%95%E3%80%90%E5%B9%B4%E6%B1%87%E6%80%BB%E3%80%91/"/>
    <id>https://winniekun.github.io/2021%E5%B9%B4%E4%B9%A6%E5%8D%95%E3%80%90%E5%B9%B4%E6%B1%87%E6%80%BB%E3%80%91/</id>
    <published>2021-01-01T07:01:10.000Z</published>
    <updated>2021-02-24T12:06:26.477Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 <a href="https://blog.jamespan.me/" target="_blank" rel="noopener">摘自鶸道场</a></p></blockquote><p>趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。</p><a id="more"></a><h2 id="书籍相关"><a href="#书籍相关" class="headerlink" title="书籍相关"></a>书籍相关</h2><ul><li>程序员代码面试指南- IT名企算法与数据结构题目最优解<ul><li>计划的是去年年底开始刷，然后计划赶不上变化</li><li>公司安排的1230的任务挺复杂的，还挺多，就没有开始搞</li><li>不过终于在31号，下定决心先把书买了，然后1号正式开刷</li></ul></li></ul><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><h2 id="电影、电视剧、综艺、纪录片"><a href="#电影、电视剧、综艺、纪录片" class="headerlink" title="电影、电视剧、综艺、纪录片"></a>电影、电视剧、综艺、纪录片</h2><ul><li>一点就通<ul><li>合伙人2 ？？？</li></ul></li><li>温暖的抱抱</li><li>拆弹专家2</li><li>送你一朵小红花</li><li>赘婿<ul><li>上头看的</li></ul></li><li>哪吒重生<ul><li>够朋克</li></ul></li><li><p>你好李焕英</p><ul><li>好看的</li></ul></li><li><p>因为是男高所以很幸福</p><ul><li>憨批一家人哇</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 &lt;a href=&quot;https://blog.jamespan.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摘自鶸道场&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。&lt;/p&gt;</summary>
    
    
    
    <category term="碎碎念" scheme="https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="书单" scheme="https://winniekun.github.io/tags/%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>if-else代码优化的几种方案</title>
    <link href="https://winniekun.github.io/if-else-code-optimization/"/>
    <id>https://winniekun.github.io/if-else-code-optimization/</id>
    <published>2020-11-02T11:46:42.000Z</published>
    <updated>2020-11-02T12:46:17.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代码中涉及到较为复杂的逻辑是，一般情况下会出现大量的<code>if-else</code>，虽然实现了整个功能，但是阅读起来比较耗时，并且维护的时候也十分的困难，同时只要有一个地方没有考虑清楚，修改起来就难免出现<code>bug</code>。最近在做公司某个节点的性能优化，就遇到了这个问题，然后在<code>review</code>的时候，同事和我讲了一些优化方案，以及默认的规范之后。自己重新修改之后，感觉很舒服，后续自己重新整理一下，所以就写了这篇博客。</p><a id="more"></a><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><h3 id="优化一：提前return，去除不必要的else"><a href="#优化一：提前return，去除不必要的else" class="headerlink" title="优化一：提前return，去除不必要的else"></a>优化一：提前return，去除不必要的else</h3><p>如果<code>if-else</code>代码块包含<code>return</code>语句，可以考虑通过提前<code>return</code>，把多余<code>else</code>干掉，使代码更加优雅。</p><h4 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h4><pre><code class="lang-java">if(condition){  // do something} else {  // do other thing  return;}</code></pre><h4 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h4><pre><code class="lang-java">if(!condition) {  return;} // do something</code></pre><h3 id="优化二：使用三元运算"><a href="#优化二：使用三元运算" class="headerlink" title="优化二：使用三元运算"></a>优化二：使用三元运算</h3><h4 id="优化前-1"><a href="#优化前-1" class="headerlink" title="优化前"></a>优化前</h4><pre><code class="lang-java">int price;if(condition){  price = 10;} else {  price = 20;}</code></pre><h4 id="优化后-1"><a href="#优化后-1" class="headerlink" title="优化后"></a>优化后</h4><pre><code class="lang-java">int price = condition ? 10 : 20;</code></pre><h3 id="优化三：使用枚举"><a href="#优化三：使用枚举" class="headerlink" title="优化三：使用枚举"></a>优化三：使用枚举</h3><h4 id="优化前-2"><a href="#优化前-2" class="headerlink" title="优化前"></a>优化前</h4><pre><code class="lang-java">int orderStatus = getXXX(xxx);String OrderStatusDes;if(orderStatus == 0) {    OrderStatusDes = "订单未支付";}else if(OrderStatus == 1) {    OrderStatusDes = "订单已支付";}else if(OrderStatus == 2) {   OrderStatusDes = "已发货";}</code></pre><h4 id="优化后-2"><a href="#优化后-2" class="headerlink" title="优化后"></a>优化后</h4><p><strong>先定义一个枚举类型</strong></p><pre><code class="lang-java">public enum OrderStatusEnum {    UN_PAID(0,"订单未支付"),PAIDED(1,"订单已支付"),SENDED(2,"已发货"),;    private int index;    private String desc;    public int getIndex() {        return index;    }    public String getDesc() {        return desc;    }    OrderStatusEnum(int index, String desc){        this.index = index;        this.desc =desc;    }    OrderStatusEnum ofCode(int orderStatus) {        for (OrderStatusEnum temp : OrderStatusEnum.values()) {            if (temp.getIndex() == orderStatus) {                return temp;            }        }        return null;    }}</code></pre><p>有了枚举之后，以上if-else逻辑分支，可以优化为一行代码</p><pre><code class="lang-java">String OrderStatusDes = OrderStatusEnum.ofCode(orderStatus).getDesc();</code></pre><h3 id="优化四：合并条件表达式"><a href="#优化四：合并条件表达式" class="headerlink" title="优化四：合并条件表达式"></a>优化四：合并条件表达式</h3><p>如果有一系列条件返回一样的结果，可以将它们合并为一个条件表达式，让逻辑更加清晰。</p><h4 id="优化前-3"><a href="#优化前-3" class="headerlink" title="优化前"></a>优化前</h4><pre><code class="lang-java">double getVipDiscount() {    if(age&lt;18){        return 0.8;    }    if("深圳".equals(city)){        return 0.8;    }    if(isStudent){        return 0.8;    }    //do somethig}</code></pre><h4 id="优化后-3"><a href="#优化后-3" class="headerlink" title="优化后"></a>优化后</h4><pre><code class="lang-java">double getVipDiscount(){    if(age&lt;18|| "深圳".equals(city)||isStudent){        return 0.8;    }    //doSomthing}</code></pre><p>如果返回统一结果的条件过多，可以再编写一个方法，封装起来<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h3 id="优化五：使用Optional"><a href="#优化五：使用Optional" class="headerlink" title="优化五：使用Optional"></a>优化五：使用Optional</h3><p>有时候<code>if-else</code>比较多，是因为非空判断导致的，这时候你可以使用<code>Java9</code>的<code>Optional</code>进行优化。</p><h4 id="优化前-4"><a href="#优化前-4" class="headerlink" title="优化前"></a>优化前</h4><pre><code class="lang-java">String str = "wkk";if (str != null) {    System.out.println(str);} else {    System.out.println("Null");}</code></pre><h4 id="优化后-4"><a href="#优化后-4" class="headerlink" title="优化后"></a>优化后</h4><pre><code class="lang-java">Optional&lt;String&gt; strOptional = Optional.ofNullable("wkk");strOptional.ifPresentOrElse(System.out::println, () -&gt; System.out.println("Null"));</code></pre><p><code>Java8</code>的<code>Optional</code>虽然没有这个方法，但是我们可以用Optional来优化非空的赋值操作</p><p><strong>示例：</strong></p><p>电池平台服役状态赋值：如果为null，赋值为0，否则为原来的值</p><pre><code class="lang-java">batteryBasicInfoCollectDto.setFlowControlState(Optional.ofNullable(batteryInfo.getFlowControlState()).orElse(0));</code></pre><h3 id="优化六：表驱动法"><a href="#优化六：表驱动法" class="headerlink" title="优化六：表驱动法"></a>优化六：表驱动法</h3><h4 id="优化前-5"><a href="#优化前-5" class="headerlink" title="优化前"></a>优化前</h4><p><strong>表驱动法</strong>，又称之为表驱动、表驱动方法。表驱动方法是一种使你可以在表中查找信息，而不必用很多的逻辑语句（if或Case）来把它们找出来的方法。以下的demo，把map抽象成表，在map中查找信息，而省去不必要的逻辑语句。</p><pre><code class="lang-java">if (param.equals(value1)) {    doAction1(someParams);} else if (param.equals(value2)) {    doAction2(someParams);} else if (param.equals(value3)) {    doAction3(someParams);}</code></pre><h4 id="优化后-5"><a href="#优化后-5" class="headerlink" title="优化后"></a>优化后</h4><pre><code class="lang-java">// 这里泛型是为方便演示，实际可替换为你需要的类型Map&lt;?, Function&lt;?&gt; action&gt; actionMappings = new HashMap&lt;&gt;(); // 初始化actionMappings.put(value1, (someParams) -&gt; { doAction1(someParams)});actionMappings.put(value2, (someParams) -&gt; { doAction2(someParams)});actionMappings.put(value3, (someParams) -&gt; { doAction3(someParams)});// 省略多余逻辑语句actionMappings.get(param).apply(someParams);</code></pre><h3 id="优化七：优化逻辑结构，让正常流程走主干"><a href="#优化七：优化逻辑结构，让正常流程走主干" class="headerlink" title="优化七：优化逻辑结构，让正常流程走主干"></a>优化七：优化逻辑结构，让正常流程走主干</h3><h4 id="优化前-6"><a href="#优化前-6" class="headerlink" title="优化前"></a>优化前</h4><pre><code class="lang-java">public double getAdjustedCapital(){    if(_capital &lt;= 0.0 ){        return 0.0;    }    if(_intRate &gt; 0 &amp;&amp; _duration &gt;0){        return (_income / _duration) *ADJ_FACTOR;    }    return 0.0;}</code></pre><h4 id="优化后-6"><a href="#优化后-6" class="headerlink" title="优化后"></a>优化后</h4><pre><code class="lang-java">public double getAdjustedCapital(){    if(_capital &lt;= 0.0 ){        return 0.0;    }    if(_intRate &lt;= 0 || _duration &lt;= 0){        return 0.0;    }    return (_income / _duration) *ADJ_FACTOR;}</code></pre><p><strong>将条件反转使异常情况先退出，让正常流程维持在主干流程，可以让代码结构更加清晰。</strong></p><h3 id="优化八：策略模式-工厂方法消除if-else"><a href="#优化八：策略模式-工厂方法消除if-else" class="headerlink" title="优化八：策略模式+工厂方法消除if-else"></a>优化八：策略模式+工厂方法消除if-else</h3><p><strong>策略类定义</strong>：一个策略接口和一组实现这个接口的策略类。</p><p><strong>特点</strong>：客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。</p><p><strong>假设需求</strong>：根据不同勋章类型，处理相对应的勋章服务</p><h4 id="优化前-7"><a href="#优化前-7" class="headerlink" title="优化前"></a>优化前</h4><pre><code class="lang-java">String medalType = "guest";if ("guest".equals(medalType)) {    System.out.println("嘉宾勋章");} else if ("vip".equals(medalType)) {    System.out.println("会员勋章");} else if ("guard".equals(medalType)) {    System.out.println("展示守护勋章");}</code></pre><h4 id="优化后-7"><a href="#优化后-7" class="headerlink" title="优化后"></a>优化后</h4><p>首先，我们把每个条件逻辑代码块，抽象成一个公共的接口，可以得出以下代码：</p><pre><code class="lang-java">//勋章接口public interface IMedalService {    void showMedal();}</code></pre><p>我们根据每个逻辑条件，定义相对应的策略实现类，可得以下代码：</p><pre><code class="lang-java">//守护勋章策略实现类public class GuardMedalServiceImpl implements IMedalService {    @Override    public void showMedal() {        System.out.println("展示守护勋章");    }}//嘉宾勋章策略实现类public class GuestMedalServiceImpl implements IMedalService {    @Override    public void showMedal() {        System.out.println("嘉宾勋章");    }}//VIP勋章策略实现类public class VipMedalServiceImpl implements IMedalService {    @Override    public void showMedal() {        System.out.println("会员勋章");    }}</code></pre><p>接下来，我们再定义策略工厂类，用来管理这些勋章实现策略类，如下：</p><pre><code class="lang-java">//勋章服务工产类public class MedalServicesFactory {    private static final Map&lt;String, IMedalService&gt; map = new HashMap&lt;&gt;();    static {        map.put("guard", new GuardMedalServiceImpl());        map.put("vip", new VipMedalServiceImpl());        map.put("guest", new GuestMedalServiceImpl());    }    public static IMedalService getMedalService(String medalType) {        return map.get(medalType);    }}</code></pre><p>使用了策略+工厂模式之后，代码变得简洁多了，如下：</p><pre><code class="lang-java">public class Test {    public static void main(String[] args) {        String medalType = "guest";        IMedalService medalService = MedalServicesFactory.getMedalService(medalType);        medalService.showMedal();    }}</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;代码中涉及到较为复杂的逻辑是，一般情况下会出现大量的&lt;code&gt;if-else&lt;/code&gt;，虽然实现了整个功能，但是阅读起来比较耗时，并且维护的时候也十分的困难，同时只要有一个地方没有考虑清楚，修改起来就难免出现&lt;code&gt;bug&lt;/code&gt;。最近在做公司某个节点的性能优化，就遇到了这个问题，然后在&lt;code&gt;review&lt;/code&gt;的时候，同事和我讲了一些优化方案，以及默认的规范之后。自己重新修改之后，感觉很舒服，后续自己重新整理一下，所以就写了这篇博客。&lt;/p&gt;</summary>
    
    
    
    <category term="代码质量" scheme="https://winniekun.github.io/categories/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"/>
    
    
    <category term="if-else优化" scheme="https://winniekun.github.io/tags/if-else%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>lombok介绍</title>
    <link href="https://winniekun.github.io/lombok-introduce/"/>
    <id>https://winniekun.github.io/lombok-introduce/</id>
    <published>2020-10-02T12:08:21.000Z</published>
    <updated>2020-10-04T14:34:01.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lombok使用"><a href="#Lombok使用" class="headerlink" title="Lombok使用"></a>Lombok使用</h2><blockquote><p>Lombok是一款好用顺手的工具，值得去好好去熟练使用和深究。<strong>Lombok是一种Java™实用工具，可用来帮助开发人员消除Java的冗长代码，尤其是对于简单的Java对象（POJO）。它通过注释实现这一目的</strong>。通过在开发环境中实现Lombok，开发人员可以节省构建诸如hashCode()和equals()这样的方法以及以往用来分类各种accessor和mutator的大量时间。</p></blockquote><a id="more"></a><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li><p>导入Maven依赖</p><pre><code class="lang-xml">&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;${lomok.version}&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>在IDE中安装对应的插件（<strong>lombok plugin</strong>）</p></li></ol><h2 id="常用注解详解"><a href="#常用注解详解" class="headerlink" title="常用注解详解"></a>常用注解详解</h2><h3 id="简化代码，增加可读性"><a href="#简化代码，增加可读性" class="headerlink" title="简化代码，增加可读性"></a>简化代码，增加可读性</h3><h4 id="Getter-amp-Setter"><a href="#Getter-amp-Setter" class="headerlink" title="@Getter&amp;@Setter"></a>@Getter&amp;@Setter</h4><pre><code class="lang-java">@Getter@Setterpublic class Person {    private Integer id;    private String name;    private String age;}</code></pre><p>通过<code>@Getter和@Setter</code>之后，其就类似于如下的代码：</p><pre><code class="lang-java">public class Persons {    private Integer id;    private String name;    private String age;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getAge() {        return age;    }    public void setAge(String age) {        this.age = age;    }}</code></pre><h4 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h4><p>其等同于如下的几个注解，使用的频率最高</p><ul><li>@Getter/@Setter</li><li>@ToString</li><li>@EqualsAndHashCode</li><li>@RequiredArgsConstructor</li></ul><h4 id="Buider"><a href="#Buider" class="headerlink" title="@Buider"></a>@Buider</h4><p>自动生成流式set写法，能够快速的设定<code>Object</code>值。但是需要注意的是，虽然该方法很好，但是因为大多数的框架都使用到了<code>set</code>方法进进行注入，<strong>所以在开发的时候，我们一般是将<code>@Builder</code>和<code>@Data</code>一起使用</strong>。</p><pre><code class="lang-java">// 方便查看输出对象@ToString@Builderpublic class Person {    private Integer id;    private String name;    private String age;    public static void main(String[] args) {        Person person = Person.builder().age("11").id(1).name("wkk").build();        System.out.println(person);    }}//Builder的使用等同于如下public static class PersonBuilder {        private Integer id;        private String name;        private String age;        PersonBuilder() {        }        public Person.PersonBuilder id(Integer id) {            this.id = id;            return this;        }        public Person.PersonBuilder name(String name) {            this.name = name;            return this;        }        public Person.PersonBuilder age(String age) {            this.age = age;            return this;        }        public Person build() {            return new Person(this.id, this.name, this.age);        }        public String toString() {            return "Person.PersonBuilder(id=" + this.id + ", name=" + this.name + ", age=" + this.age + ")";        }    }</code></pre><h3 id="日志使用"><a href="#日志使用" class="headerlink" title="日志使用"></a>日志使用</h3><p>一般情况下，我们做日志处理，都会先生成一个Logger的静态常量，使用<code>@Slf4j</code>之后，我们就可以完全不用new一个该常量了。</p><pre><code class="lang-java">public class Person{    private static final Logger logger = LoggerFactory.getLogger(Person.class);    private Integer id;    private String name;    private String age;      public static void main(String[] args){          logger.info("logger: {}", "aaaa");    }}// Lombok实现@Slf4jpublic class Person {    private Integer id;    private String name;    private String age;    public static void main(String[] args) {        System.out.println("fsda");        log.info("Person: {}", "fdsa");    }}</code></pre><h3 id="流式对象的关闭"><a href="#流式对象的关闭" class="headerlink" title="流式对象的关闭"></a><del>流式对象的关闭</del></h3>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Lombok使用&quot;&gt;&lt;a href=&quot;#Lombok使用&quot; class=&quot;headerlink&quot; title=&quot;Lombok使用&quot;&gt;&lt;/a&gt;Lombok使用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Lombok是一款好用顺手的工具，值得去好好去熟练使用和深究。&lt;strong&gt;Lombok是一种Java™实用工具，可用来帮助开发人员消除Java的冗长代码，尤其是对于简单的Java对象（POJO）。它通过注释实现这一目的&lt;/strong&gt;。通过在开发环境中实现Lombok，开发人员可以节省构建诸如hashCode()和equals()这样的方法以及以往用来分类各种accessor和mutator的大量时间。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="java" scheme="https://winniekun.github.io/categories/java/"/>
    
    
    <category term="基础" scheme="https://winniekun.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
