<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wkkの笔记</title>
  
  <subtitle>好记性不如烂键盘</subtitle>
  <link href="https://winniekun.github.io/atom.xml" rel="self"/>
  
  <link href="https://winniekun.github.io/"/>
  <updated>2021-05-27T13:24:37.843Z</updated>
  <id>https://winniekun.github.io/</id>
  
  <author>
    <name>weikunkun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ThreadLocal源码解读</title>
    <link href="https://winniekun.github.io/threadlocal-analysis/"/>
    <id>https://winniekun.github.io/threadlocal-analysis/</id>
    <published>2021-05-27T13:21:59.000Z</published>
    <updated>2021-05-27T13:24:37.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>多线程共享可变数据时，涉及到线程见同步的问题，并不是所有的时候，都要用到共享数据，所以就需要线程封闭出场了。数据都被封闭在各自的线程之中，就不需要进行同步，这种通过将数据封闭在线程内而避免使用同步的技术称之为<strong>线程封闭</strong>。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>线程间数据隔离，各线程的 ThreadLocal 互不影响</li><li>方便同一个线程使用某一对象，避免不必要的参数传递</li><li>全链路追踪中的 traceId 或者流程引擎中上下文的传递一般采用 ThreadLocal</li><li>Spring 事务管理器采用了 ThreadLocal</li><li>Spring MVC 的 RequestContextHolder 的实现使用了 ThreadLocal</li></ul><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; THREAD_LOCAL = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; THREAD_LOCAL_NEXT = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> ThreadLocalDemo().threadLocalTest();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadLocalTest</span><span class="params">()</span> </span>{</span><br><span class="line">        THREAD_LOCAL.set(<span class="string">"wkk"</span>);</span><br><span class="line">        THREAD_LOCAL_NEXT.set(<span class="string">"cjsq"</span>);</span><br><span class="line">        String v = THREAD_LOCAL.get();</span><br><span class="line">        String v2 = THREAD_LOCAL_NEXT.get();</span><br><span class="line">        System.out.println(<span class="string">"子线程 执行前， "</span> + Thread.currentThread().getName() + <span class="string">"线程取到的值："</span> + v + <span class="string">" "</span> + v2);</span><br><span class="line"></span><br><span class="line">        Thread child = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                String v = THREAD_LOCAL.get();</span><br><span class="line">                String v2 = THREAD_LOCAL_NEXT.get();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"线程取到的值："</span> + v + v2);</span><br><span class="line">                <span class="comment">// 设置 threadLocal</span></span><br><span class="line">                THREAD_LOCAL.set(<span class="string">"hhh"</span>);</span><br><span class="line">                THREAD_LOCAL_NEXT.set(<span class="string">"cjpl"</span>);</span><br><span class="line">                v = THREAD_LOCAL.get();</span><br><span class="line">                v2 = THREAD_LOCAL_NEXT.get();</span><br><span class="line">                System.out.println(<span class="string">"重新设置之后，"</span> + Thread.currentThread().getName() + <span class="string">"线程取到的值为："</span> + v + <span class="string">" "</span> + v2);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"线程执行结束"</span>);</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"子线程"</span>);</span><br><span class="line">        child.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            child.join();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        v = THREAD_LOCAL.get();</span><br><span class="line">        v2 = THREAD_LOCAL_NEXT.get();</span><br><span class="line">        System.out.println(<span class="string">"子线程线程执行之后，"</span> + Thread.currentThread().getName() + <span class="string">"线程取到的值："</span> + v + <span class="string">" "</span> + v2);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>输出</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">子线程 执行前， main线程取到的值：wkk cjsq</span><br><span class="line">子线程线程取到的值：nullnull</span><br><span class="line">重新设置之后，子线程线程取到的值为：hhh cjpl</span><br><span class="line">子线程线程执行结束</span><br><span class="line">子线程线程执行之后，main线程取到的值：wkk cjsq</span><br></pre></td></tr></tbody></table></figure><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread类</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前threadlocal的hashcode</span></span><br><span class="line"><span class="comment">// 用于用于计算该ThreadLocal在线程的threadlocals（map）中的索引位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="comment">// hash表的阈值，黄金分割比</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"><span class="comment">// 保证了在一台机器中每个 ThreadLocal 的 threadLocalHashCode 是唯一的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">// 用于当前threadlocal的hashcode</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始话的操作</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// lambda的初始化实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="HashCode散列成果验证"><a href="#HashCode散列成果验证" class="headerlink" title="HashCode散列成果验证"></a>HashCode散列成果验证</h3><p>可以通过和String的hashcode做个对比，然后验证其使用这种方式的hash结果如何</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">32</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_idx</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> hashCode = <span class="number">0</span>;</span><br><span class="line">    Set&lt;Integer&gt; setThreadLocal = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; setNormal = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) {</span><br><span class="line">        hashCode = nextHashCode();</span><br><span class="line">        <span class="keyword">int</span> threadLocalHashCode = hashCode &amp; (SIZE - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> normalHashCode = String.valueOf(i).hashCode() &amp; (SIZE - <span class="number">1</span>);</span><br><span class="line">        setThreadLocal.add(threadLocalHashCode);</span><br><span class="line">        setNormal.add(normalHashCode);</span><br><span class="line">        System.out.println(i + <span class="string">" ThreadLocal的散列："</span> + threadLocalHashCode + <span class="string">" 普通散列："</span> + normalHashCode);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">double</span> threadLocalRate = setThreadLocal.size() / (<span class="keyword">double</span>)SIZE * <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">double</span> normalRate = setNormal.size() / (<span class="keyword">double</span>)SIZE * <span class="number">100</span>;</span><br><span class="line">    System.out.println(<span class="string">"ThreadLocal的散列："</span> + threadLocalRate + <span class="string">"% "</span> + <span class="string">" 普通散列："</span> + normalRate + <span class="string">"% "</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// ThreadLocal的散列：100.0%  普通散列：68.75%</span></span><br></pre></td></tr></tbody></table></figure><h3 id="形象理解"><a href="#形象理解" class="headerlink" title="形象理解"></a>形象理解</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210527191351975.png" alt="ThreadLocal形象理解" title="">                </div>                <div class="image-caption">ThreadLocal形象理解</div>            </figure><p>如果类比为HashMap的话，我们可以将<code>threadlocal</code>类比为<code>key</code>，然后<code>被封闭的数据</code>类比为<code>value</code>。不过稍微不同的是，hashmap中将<code>key</code>和<code>value</code>做映射的操作是<code>map.put(key, value)</code>，而<code>threadlocals</code>中，将<code>threadlocal</code>和<code>被封闭的数据</code>做映射的操作是<code>threadlocal.set(xxx)</code>。</p><h4 id="思路转换"><a href="#思路转换" class="headerlink" title="思路转换"></a>思路转换</h4><p>emmmm怎么说呢，就是我们使用普通map的时候，操作的是一个map，获取key的value时，直接通过map.get()即可。</p><p>但是我们使用threadlocal时，其本身是一个key，怎么获取对应的value呢？</p><ol><li>先获取map（每个线程独有的map，所以根据当前线程获取map）</li><li>然后通过map.get(key)获取value</li><li>返回value</li></ol><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">     * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">     * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">     * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">     * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>{</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) {</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  <span class="comment">// 下面的成员变量和hashmap同理</span></span><br><span class="line">  <span class="comment">// 初始化容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 存储ThreadLocal的键值对，长度为2的幂次</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of entries in the table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ThreadLocalMap就是一个map，和hashmap类似，不过有些机制不同。</p><ul><li>hash冲突解决方式<ol><li>ThreadLocalMap处理hash冲突的方式为线型探测</li><li>HashMap使用的是拉链法</li></ol></li></ul><h3 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h3><p>根据注释和代码，了解到了ThreadLocalMap内部的每个entry中，key设置为<strong>虚引用</strong>的原因，不过value还是正常的引用。这也就导致了如果ThreadLocal没有外部的强引用时，只要发生GC，就会被回收。这样ThreadMap中的key就变成了null，<strong>但是value被Entry引用，Entry被ThreadLocalMap引用，ThreadLocalMap被Thread引用，这也就说明了只要，线程不终止，value的值一直无法被回收，所以可能会出现内存泄漏的现象</strong></p><p>为了避免这种情况，在需要使用threadloca之后，需要我们手动remove掉。防止 ThreadLocalMap 中 Entry 一直保持对 value 的强引用，导致 value 不能被回收</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>{</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据当前线程获取其map</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为使用的线型探测法</span></span><br><span class="line"><span class="comment">// 所以要采用线型探测法找到对应的位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>{</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 根据threadlocal获取其hashcode值</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) {</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) {</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>{</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) {</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) {</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) {</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>通过当前线程获取该线程的map</li><li>然后调用map.remove方法</li></ol><p>后续的代码分析不动了。。。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment"> * override this method, relying solely on the {<span class="doctag">@link</span> #initialValue}</span></span><br><span class="line"><span class="comment"> * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>{</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>set方法的作用是把我们想要存储的value给保存方法，只要流程是：</p><ol><li>先获取当亲的线程</li><li>根据当前线程获取该线程的map</li><li>判断map是否为空<ol><li>为空<ul><li>创建map</li></ul></li><li>不为空<ul><li>在map中放入元素</li></ul></li></ol></li></ol><h3 id="set-ThreadLcoal-lt-gt-key-Object-value"><a href="#set-ThreadLcoal-lt-gt-key-Object-value" class="headerlink" title="set(ThreadLcoal<?> key, Object value)"></a>set(ThreadLcoal&lt;?&gt; key, Object value)</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在map中存储键值对&lt;key, value&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>{</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 遍历一段连续的元素，以查找匹配的 ThreadLocal 对象</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) {</span><br><span class="line">        <span class="comment">// / 获取该哈希值处的ThreadLocal对象</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 键值ThreadLocal匹配，直接更改map中的value</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) {</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 若 key 是 null，说明 ThreadLocal 被清理了，直接替换掉</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) {</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 直到遇见了空槽也没找到匹配的ThreadLocal对象，那么在此空槽处安排ThreadLocal对象和缓存的value</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过这两种set方式，就更加证明了思路的转换，我们在set时，都需要先获取当前线程获取map，然后再对整个map遍历然后放入value、或者直接放入key、value</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>{</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) {</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据threadlocal获取entry</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>{</span><br><span class="line">    <span class="comment">// 计算hashcode，然后获取对应的索引位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 根据索引位置获取对应的entry</span></span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>{</span><br><span class="line">     T value = initialValue();</span><br><span class="line">     Thread t = Thread.currentThread();</span><br><span class="line">     ThreadLocalMap map = getMap(t);</span><br><span class="line">     <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">         map.set(<span class="keyword">this</span>, value);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         createMap(t, value);</span><br><span class="line">     <span class="keyword">return</span> value;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><ol><li>先获取当前线程</li><li>获取当前线程的map</li><li>map != null<ol><li>通过key直接获取对应entry</li><li>返回entry.value</li></ol></li><li>map == null<ol><li>初始化map</li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>threadlocal</code>本质属于某种map的一个key值，只不过该值通过泛型实现，支持各种类型。和基础的map不同的是，可以直接通过<code>key.set(value)</code>实现<code>key-value</code>的映射。而这种特殊的map是属于Thread级别的成员变量，多个线程之间该变量互不影响，所以这也就是我们所说的线程本地存储地方。不过需要注意的是，该key是虚引用，需要注意内存泄露的问题，所以在使用过threadlocal之后，记得及时remove。内部的threadlocalmap和hashmap的实现机制类似，不过区别就是对于hash冲突的解决方式为<strong>线型探测</strong></p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li>Java并发编程</li><li>面试官系统精讲Java源码及大厂真题</li><li>Java并发编程78讲</li><li><a href="https://benjaminwhx.com/2018/04/28/[%E7%BB%86%E8%B0%88Java%E5%B9%B6%E5%8F%91]%E8%B0%88%E8%B0%88ThreadLocal/" target="_blank" rel="noopener">【细谈Java并发】谈谈ThreadLocal</a></li><li><a href="https://www.cnblogs.com/wupeixuan/p/12638203.html" target="_blank" rel="noopener">一文搞懂 ThreadLocal 原理</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;多线程共享可变数据时，涉及到线程见同步的问题，并不是所有的时候，都要用到共享数据，所以就需要线程封闭出场了。数据都被封闭在各自的线程之中，就不需要进</summary>
      
    
    
    
    <category term="源码" scheme="https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="JDK源码" scheme="https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"/>
    
    <category term="lang" scheme="https://winniekun.github.io/tags/lang/"/>
    
  </entry>
  
  <entry>
    <title>死磕双指针</title>
    <link href="https://winniekun.github.io/stick-to-two-pointer/"/>
    <id>https://winniekun.github.io/stick-to-two-pointer/</id>
    <published>2021-05-27T09:10:30.000Z</published>
    <updated>2021-05-27T09:10:30.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>双指针，一个看了脑子里就有画面的算法技巧，主要方式有：</p><ol><li>快慢指针<ul><li>譬如链表环系列问题</li><li>获取链表的第K个节点<ul><li>应该也属于快慢指针吧</li><li>只不过是一个指针先移动一定步长，然后另一个两个指针再以同样的速度移动</li></ul></li></ul></li><li>头尾指针<ul><li>适用于数组和字符串</li><li>根据使用场景，用于优化遍历的时间复杂度</li></ul></li><li>滑动窗口</li></ol><h2 id="普通指针"><a href="#普通指针" class="headerlink" title="普通指针"></a>普通指针</h2><h3 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除有序数组中的重复项</a></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; j++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[j]) {</span><br><span class="line">                nums[++i] = nums[j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 通法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{   </span><br><span class="line">        <span class="keyword">return</span> process(nums, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) {</span><br><span class="line">            <span class="keyword">if</span> (idx &lt; k || nums[idx - k] != x) nums[idx++] = x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="80-删除有序数组中的重复项-II"><a href="#80-删除有序数组中的重复项-II" class="headerlink" title="80. 删除有序数组中的重复项 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">80. 删除有序数组中的重复项 II</a></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> process(nums, <span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) {</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; k || nums[idx - k] != x) {</span><br><span class="line">            nums[idx++] = x;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></h3><h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组</a></h3><p>归并排序的中的一个步骤</p><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>环系列</p><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) {</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></h3><h2 id="头尾指针"><a href="#头尾指针" class="headerlink" title="头尾指针"></a>头尾指针</h2><p>可以理解为对整个数组的暴力搜索的优化，正常情况下，是得到所有的区间k的子数组，然后一次计算结果。双指针之后，可以在遍历的过程就的出结果，避免的重复的遍历，并且优化的了遍历的时间复杂度</p><h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>{</span><br><span class="line">    <span class="comment">// 双指针(头尾指针)</span></span><br><span class="line">    <span class="keyword">int</span> N = height.length;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = N - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">        <span class="keyword">int</span> hight = Math.min(height[left], height[right]);</span><br><span class="line">        <span class="keyword">int</span> innerArea = hight * (right - left);</span><br><span class="line">        area = Math.max(area, innerArea);</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) {</span><br><span class="line">            left++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) {</span><br><span class="line">    <span class="comment">// 思路</span></span><br><span class="line">    <span class="comment">// 核心思路：双指针 头尾指针</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">2</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> rst = -nums[i];</span><br><span class="line">        <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">            <span class="keyword">int</span> cur = nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span> (cur == rst) {</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(nums[i], nums[left], nums[right])));</span><br><span class="line">                <span class="comment">// 处理后序重复的元素</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left + <span class="number">1</span>] == nums[left]) {</span><br><span class="line">                    left++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) {</span><br><span class="line">                    right--;</span><br><span class="line">                }</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (cur &gt; rst) {</span><br><span class="line">                right--;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                left++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></h3><p>和上述类似，不过不用考虑元素重复问题，但是需要考虑最近，所以使用一个变量，用于检测当前结果是否比之前更好。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="comment">// 如何判断最近？</span></span><br><span class="line">    <span class="comment">// min(closest, curDistance)</span></span><br><span class="line">    <span class="keyword">int</span> closest = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>] + nums[nums.length - <span class="number">1</span>] + nums[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">2</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> low = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> height = N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; height) {</span><br><span class="line">            <span class="keyword">int</span> innerCur = nums[i] + nums[low] + nums[height];</span><br><span class="line">            <span class="keyword">if</span> (innerCur &lt; target) {</span><br><span class="line">                low++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (innerCur &gt; target) {</span><br><span class="line">                height--;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(innerCur - target) &lt; closest) {</span><br><span class="line">                closest = Math.abs(innerCur - target);</span><br><span class="line">                res = innerCur;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h3><p>同样的思路，不过可以做一些细节处理，提前退出循环。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) {</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; quadruplets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>) {</span><br><span class="line">        <span class="keyword">return</span> quadruplets;</span><br><span class="line">    }</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> length = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">3</span>; i++) {</span><br><span class="line">        <span class="comment">// 重复</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 不符合条件</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 结果小</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[length - <span class="number">3</span>] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length - <span class="number">2</span>; j++) {</span><br><span class="line">            <span class="comment">// 重复</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 不符合条件</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 太小</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> left = j + <span class="number">1</span>, right = length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == target) {</span><br><span class="line">                    quadruplets.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) {</span><br><span class="line">                        left++;</span><br><span class="line">                    }</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) {</span><br><span class="line">                        right--;</span><br><span class="line">                    }</span><br><span class="line">                    right--;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) {</span><br><span class="line">                    left++;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    right--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> quadruplets;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="259-较小的三数之和"><a href="#259-较小的三数之和" class="headerlink" title="259. 较小的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-smaller/" target="_blank" rel="noopener">259. 较小的三数之和</a></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumSmaller</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">2</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">            <span class="keyword">int</span> innerCur = nums[i] + nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span> (innerCur &lt; target) {</span><br><span class="line">                <span class="keyword">int</span> innerCount = right - left;</span><br><span class="line">                count += innerCount;</span><br><span class="line">                left++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                right--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30. 串联所有单词的子串"></a><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="noopener">30. 串联所有单词的子串</a></h3><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. 长度最小的子数组</a></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; N) {</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; sum &gt;= target) {</span><br><span class="line">            ans = Math.min(ans, right - left + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        }</span><br><span class="line">        right++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="713-乘积小于K的子数组"><a href="#713-乘积小于K的子数组" class="headerlink" title="713. 乘积小于K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-product-less-than-k/" target="_blank" rel="noopener">713. 乘积小于K的子数组</a></h3><p>双指针（滑动窗口）：left 和 right指针开始时均指向 nums数组的开头。</p><p>right指针遍历 nums数组，每遍历一个元素就更新一次乘积，即 product = product * nums[right]：</p><ul><li><p>若当前更新后的 product &lt; k，则直接统计当前窗口中的元素个数（<strong>这恰好就是当前子数组中符合条件的全部子集个数</strong>）</p><ul><li>我们每次都统计以nums[right]为结尾符合条件的子数组个数</li></ul></li><li><p>若更新后的 product &gt;= k，则此时需要缩小窗口的大小，即令当前 product 除以当前 left 指针指向的元素值，然后令 left指针右移一位，直到当前的 produc &lt; k 为止，然后统计当前窗口中的元素个数，即为此时符合条件的子数组的个数，继续令 right 指针右移。</p></li><li><p>如此反复，直到 right 指针指向 nums 数组的末尾为止。</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; N; right++) {</span><br><span class="line">        sum *= nums[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; sum &gt;= k) {</span><br><span class="line">            sum /= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        }</span><br><span class="line">        count += right - left + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;双指针，一个看了脑子里就有画面的算法技巧，主要方式有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;快慢指针&lt;ul&gt;
&lt;li&gt;譬如链表环系列问题&lt;/li&gt;
&lt;li&gt;获</summary>
      
    
    
    
    <category term="leetcode" scheme="https://winniekun.github.io/categories/leetcode/"/>
    
    
    <category term="双指针" scheme="https://winniekun.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>PriorityQueue源码解读</title>
    <link href="https://winniekun.github.io/PriorityQueue-analysis/"/>
    <id>https://winniekun.github.io/PriorityQueue-analysis/</id>
    <published>2021-05-22T12:00:56.000Z</published>
    <updated>2021-05-23T12:10:46.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PriorityQueue源码解读"><a href="#PriorityQueue源码解读" class="headerlink" title="PriorityQueue源码解读"></a>PriorityQueue源码解读</h2><a id="more"></a><p>优先队列, 顾名思义就是按照元素的优先级进行弹出等操作, 那么在JDK中使用何种数据结构来实现优先队列嘞, Let’s Go</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/PriorityQueue.png" alt="PriorityQueue" title="">                </div>                <div class="image-caption">PriorityQueue</div>            </figure><p>emmm, 感觉从依赖上来看, 和其他的集合类一样, 实现其对应的接口(Marker Interface的作用?)</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>在阅读基础的时候，我们需要先理解一下什么是堆，其数据结构是啥，有哪些存储方式。</p><ol><li>堆的底层数据结构为<strong>完全二叉树</strong></li><li>存储方式（既然是二叉树，那么其存储方式主要分为如下两种）<ol><li>顺序存储结构<ol><li>根节点下标为0</li><li>若节点p的下标为$i$，则左孩子$2\cdot i$ 右孩子为$2 \cdot i + 1$ </li><li>若节点p的下标为$i$，则父节点的下标为$\lfloor i/2\rfloor$</li></ol></li><li>链式存储结构</li></ol></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/02/26/lrUPGcnu1EvSwy8.png" alt="树的存储结构" title="">                </div>                <div class="image-caption">树的存储结构</div>            </figure><p>由上述的顺序存储结构可知，堆是用<strong>物理上的线性表示逻辑上的非线性的数据结构</strong></p><p>具体的关于堆的操作，如刚开始的建堆，以及插入元素，删除堆顶元素，迭代等操作，可自行百度。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始化容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 底层使用Object[]数组实现, 和ArrayList这些一样</span></span><br><span class="line"><span class="keyword">transient</span> Object[] queue; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">// 标记元素个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 比较器, 说明其实例均是可比较的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"><span class="comment">// 说明具有fast fail 机制</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></tbody></table></figure><p>因为底层使用的是数组，同时其本身是支持动态插入和删除的，所以同理，和<strong>ArrayList</strong>同理，扩容应该是其核心的地方。同时也要关注其是否生成新的数组对象。</p><blockquote><p>像ArrayList、HashMap中都有一个属性叫 <code>modCount</code>，每次对集合的修改这个值都会加1，在遍历前记录这个值到 <code>expectedModCount</code>中，遍历中检查两者是否一致，如果出现不一致就说明有修改，则抛出ConcurrentModificationException异常。</p></blockquote><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue()"></a>PriorityQueue()</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="PriorityQueue-int-initialCapacity"><a href="#PriorityQueue-int-initialCapacity" class="headerlink" title="PriorityQueue(int initialCapacity)"></a>PriorityQueue(int initialCapacity)</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="PriorityQueue-Comparator-lt-super-E-gt-comparator"><a href="#PriorityQueue-Comparator-lt-super-E-gt-comparator" class="headerlink" title="PriorityQueue(Comparator<? super E> comparator)"></a>PriorityQueue(Comparator&lt;? super E&gt; comparator)</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="PriorityQueue-int-initialCapacity-Comparator-lt-super-E-gt-comparator"><a href="#PriorityQueue-int-initialCapacity-Comparator-lt-super-E-gt-comparator" class="headerlink" title="PriorityQueue(int initialCapacity, Comparator<? super E> comparator)"></a>PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator)</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>{</span><br><span class="line">    <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">    <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>还有几个构造函数主要是用于将原各种类型的数据放入<code>PriorityQueue</code>中</p><h2 id="增-入队"><a href="#增-入队" class="headerlink" title="增(入队)"></a>增(入队)</h2><p>在阅读这些方法的时候, 想起来自己手撕算法的时候, 经常会记混<code>List</code>, <code>Stack</code>, <code>Queue</code>, <code>Map</code>这些的添加删除操作的API…</p><p>下面罗列的是个人觉得不错的代表数据结构特性的添加/删除操作的API</p><table><thead><tr><th align="left">数据结构</th><th>添加</th><th>删除</th></tr></thead><tbody><tr><td align="left">List/Set</td><td>add()</td><td>remove()</td></tr><tr><td align="left">Stack</td><td>push()</td><td>pop()</td></tr><tr><td align="left">Queue</td><td>offer()</td><td>poll()</td></tr><tr><td align="left">Map</td><td>put()</td><td>remove()</td></tr></tbody></table><p>用于入队的操作有<code>add</code>和<code>offer</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>{</span><br><span class="line">  <span class="comment">// 不支持null元素</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="comment">// 元素数量超过数组数量，引发扩容机制</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        <span class="comment">// 扩容机制先按下不表</span></span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 元素数量+1</span></span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 如果还没有元素</span></span><br><span class="line">    <span class="comment">// 直接插入到数组第一个位置</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则 插入到堆的最后一个元素</span></span><br><span class="line">        <span class="comment">// 然后再调整堆</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>宏观上来看, <code>offer()</code>方法会先检测是否需要扩容, 之后再插入元素, 最后进行调整, 最后调用<code>siftUp</code>进行调整。</p><h3 id="siftUp"><a href="#siftUp" class="headerlink" title="siftUp"></a>siftUp</h3><p>假设在数组queue的k位置插入元素key（小根堆）</p><ul><li>不断的比较key和k的父节点e （$queue\lfloor(k-1/2\rfloor)$）的关系<ol><li>若$key  &lt;  e$ ，则queue[k] = e, 同时k到达e的位置（parent）</li><li>若$key \geq e$ 或者  $k$已经到达跟节点，则结束循环</li></ol></li><li>$queue[k]==e$</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{</span><br><span class="line">    <span class="comment">// 判断比较策略</span></span><br><span class="line">    <span class="comment">// 1. X自身实现了Comparable接口，则通过comparable进行比较</span></span><br><span class="line">    <span class="comment">// 2. X自身未实现Comparable接口，通过自定义的外部比较器compartor比较</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">}</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    }</span><br><span class="line">    queue[k] = key;</span><br><span class="line">}</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    }</span><br><span class="line">    queue[k] = x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol><li>不允许null元素</li><li>插入元素前，先检测数组长度是否够用，不够进行扩容（扩容机制后续详细阐述）</li><li>在尾部插入元素，之后不断调整</li><li>通过调整的过程，可以知道PrioriryQueue默认是小根堆</li></ol><h2 id="删-出队"><a href="#删-出队" class="headerlink" title="删(出队)"></a>删(出队)</h2><p>出队有两个方法，<code>poll()</code>和<code>remove()</code>，实际上remove调用的还是poll。remove不存在的元素时会报错。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>{</span><br><span class="line">    E x = poll();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 获取当前最后一个元素</span></span><br><span class="line">    <span class="comment">// 并将最后一个位置置空</span></span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果弹出元素后还有元素</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//将队列末元素移到队列首</span></span><br><span class="line">        <span class="comment">// 再做自上而下的堆化</span></span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="siftDown"><a href="#siftDown" class="headerlink" title="siftDown"></a>siftDown</h3><p>自顶向下，选择小的节点，不断的比较、交换，直到：</p><ol><li>下标越界</li><li>节点的值同时小于等于左孩子和右孩子</li></ol><p>假设数组queue最后一个元素的值为key（小根堆），下标k从0开始，当k存在左孩子时，执行以下循环：</p><ul><li> 若k有右孩子，则比较左右孩子的值，然后选出小的孩子child</li><li>比较key和c=queue[child]的大小<ol><li>若$key \leq c$ 结束循环</li><li>若$key &gt; c$, 则$queue[k] = c, k = child$， 继续循环</li></ol></li><li> $queue[k] = key$</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{</span><br><span class="line">    <span class="comment">// 和 siftUp一样的思路</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">}</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{</span><br><span class="line">    <span class="comment">// 因为删除是从堆顶开始删除，所以和siftUp相反</span></span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) {</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    }</span><br><span class="line">    queue[k] = key;</span><br><span class="line">}</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) {</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    }</span><br><span class="line">    queue[k] = x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>将队列首元素弹出</li><li>将队列末元素移到队列首</li><li>自上而下堆化，一直往下与最小的子节点比较</li><li>如果比最小的子节点大，就交换位置，再继续与最小的子节点比较</li><li>如果比最小的子节点小，就不用交换位置了，堆化结束</li></ol><h2 id="获取队头元素"><a href="#获取队头元素" class="headerlink" title="获取队头元素"></a>获取队头元素</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>获取第一个元素的值。</p><h2 id="扩容策略"><a href="#扩容策略" class="headerlink" title="扩容策略"></a>扩容策略</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">    <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                     (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                     (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// 检查是否溢出</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>原数组空间大小&lt;64时，默认扩容为原先的两倍再加2个。。。</li><li>原数组空间大小&gt;64时，扩容为原先的1.5倍</li><li>最大容量空间为Integer.MAX_VALUE</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>PriorityQueue内部的数据结构是堆，堆使用的数据结构是完全二叉树，然后使用的是顺序存储结构（数组）</li><li>PriorityQueue默认是小根堆</li><li>堆保证堆顶元素为当前的最值，然后严格遵守字节点的值大于（小于）父节点的值</li><li>堆的删除操作从堆顶进行删除，然后会将最后的一个元素移至堆顶，此时堆的结构被破坏，所以需要执行siftDown</li><li>堆的插入操作从堆尾进行插入，此时堆的结构被破坏，所以需要执行siftUp</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;PriorityQueue源码解读&quot;&gt;&lt;a href=&quot;#PriorityQueue源码解读&quot; class=&quot;headerlink&quot; title=&quot;PriorityQueue源码解读&quot;&gt;&lt;/a&gt;PriorityQueue源码解读&lt;/h2&gt;</summary>
    
    
    
    <category term="源码" scheme="https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="JDK源码" scheme="https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"/>
    
    <category term="Queue" scheme="https://winniekun.github.io/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>https总结</title>
    <link href="https://winniekun.github.io/https-conclution/"/>
    <id>https://winniekun.github.io/https-conclution/</id>
    <published>2021-05-21T14:32:09.000Z</published>
    <updated>2021-05-21T14:34:02.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>引入一个新的概念的时候，必然先阐述其相关方面已有的实现有哪些缺点，新的概念解决了哪些缺点。所以～让我们看看HTTP有哪些却缺点</p><p><strong>缺点：</strong></p><ol><li>明文传输，传输信息容易被窃听 — <strong>窃听风险</strong></li><li>不验证通信方的身份，因此可能会遭遇伪装 — <strong>冒充风险</strong></li><li>无法验证报问的完整性，所以通信的信息可能已遭篡改 — <strong>篡改风险</strong><ol><li>譬如强行植入的广告信息</li></ol></li></ol><p>而HTTPS的出现就正好解决了上述的三个问题。对于窃听风险使用加密措施解决，对于冒充风险使用证书认证解决，对于篡改风险使用完整性保护解决（信息摘要算法）</p><h2 id="HTTPS概述"><a href="#HTTPS概述" class="headerlink" title="HTTPS概述"></a>HTTPS概述</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521144232642.png" alt="https" title="">                </div>                <div class="image-caption">https</div>            </figure><p>HTTPS其实就是<strong>http secure</strong>的意思。HTTP是应用层协议，位于HTTP协议之下是传输协议TCP。TCP负责传输，HTTP则定义了数据如何进行包装。所以HTTP传输给TCP什么样的数据包，其都会原样的发送个通讯方（仅仅将数据包分为了多个报报问段）。</p><blockquote><p>HTTP –&gt; TCP （明文传输）</p></blockquote><p>而HTTPS相对于HTTP有哪些不同呢？其实就是在HTTP和TCP中间加多了一层加密层<strong>TLS/SSL</strong>。</p><blockquote><p>通俗的讲，TLS、SSL其实是类似的东西，SSL是个加密套件，负责对HTTP的数据进行加密。TLS是SSL的升级版。现在提到HTTPS，加密套件基本指的是TLS。</p></blockquote><p>原先是应用层将数据直接给到TCP进行传输，现在改成应用层将数据给到TLS/SSL，将数据加密后，再给到TCP进行传输。如下图所示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521144940926.png" alt="https和http传输过程" title="">                </div>                <div class="image-caption">https和http传输过程</div>            </figure><p>所以HTTPS本身并不是应用层的一个新的协议，只是HTTP在和TCP进行交接的中间，又新增了一层SSL/TLS协议。所以HTTPS可以理解为披着SSL/TLS协议外壳的HTTP而已。</p><h2 id="HTTPS的加密—混合加密"><a href="#HTTPS的加密—混合加密" class="headerlink" title="HTTPS的加密—混合加密"></a>HTTPS的加密—混合加密</h2><p>首先需要了解<code>对称加密</code>、<code>非对称加密</code>的区别。我们知道实际对通信加密的是SSL/TLS层。SSL/TLS采用是混合加密的机制，也就是对称加密和非对称加密的混合。使用非对称加密传输安全传输对称加密的密钥，之后使用对称加密的密钥进行通信从而提高整体的通讯效率。</p><p>接下来结合WireShark抓包详细阐述TLS的加密流程，TLS 是建立在 TCP 基础上的，因此必定需要先三次 TCP 握手建立 TCP 连接，然后再是建立 TLS。</p><ol><li><strong>Client Hello</strong><ol><li><strong>Client Hello</strong> 报文：客户端对加密算法的支持度不同，因此需要向服务端发送客户端支持的 <strong>加密套件（Cipher Suite）</strong> ，同时还要生成一个 <strong>随机数</strong> 同时保存在客户端和发送给服务</li></ol></li><li><strong>Server Hello</strong><ol><li><strong>ServerCertificate</strong> 报文：服务端收到 Client Hello 之后，向客户端发送 <strong>CA 认证的数字证书</strong>，用来鉴别服务端身份信息，同时还要生成一个 <strong>随机数</strong> 同时保存在服务端和发送给客户端</li><li><strong>Server Hello Done</strong> 报文：表示服务端宣告第一阶段的客户端服务端握手协商结束</li><li>可选：<strong>Certificate Request</strong> 报文：必要情况下，要求客户端发送证书验证身份</li><li>可选：<strong>Server Key Exchange</strong> 报文：如果 CA 认证的数字证书提供的信息不够，服务端还可发送提供补充信息</li></ol></li><li><strong>Client Finish</strong><ol><li><strong>Client Key Exchange</strong> 报文：客户端收到 CA 数字证书并通过验证，然后通过 CA 公钥解密获取到 <strong>服务端公钥</strong>。Client Key Exchange 报文包括有一个随机数，这个随机数被称为 <strong>Pre-master key/secret</strong>；一个表示随后的信息使用双方协商好的加密方法和密钥发送的 <strong>通知</strong> ；还有一个通过协商好的 HASH 算法对前面所有信息内容的 <strong>HASH 计算值</strong>，用来提供服务端校验。这些信息都通过服务端公钥加密传送给服务端</li><li><strong>ClientCipherSpec</strong> 报文：该报文通知服务端，此后的通信都将使用协商好的加密算法计算对称密钥进行加密通信（也就是使用两个随机数以及第三个 Pre-master key/secret 随机数一起算出一个对称密钥 <strong>session key/secret</strong>）</li><li><strong>Finished</strong> 报文：该报文包括连接至此的所有报文的校验值，使用已经生成的对称加密密钥加密</li><li>可选：<strong>ClientCertificate</strong> 报文：如果服务端请求，客户端需要发送 CA 数字证书</li><li>可选：<strong>CertificateVerify</strong> 报文：服务端如果要求 CA 数字证书，那么需要通过 HASH 算法计算一个服务端发送来的信息摘要</li></ol></li><li><strong>Server Finish</strong><ol><li>服务端先私钥得出<strong>Pre-master key</strong>， 同样使用这三个随机数得出对称加密密钥。服务端最后对客户端发送过来的 <strong>Finished</strong> 报文使用服务端对称密钥进行解密校验。</li><li><strong>ClientCipherSpec</strong> 报文：报文通知服务端，此后的通信都将使用协商好的加密算法计算对称密钥 session key/secret 进行加密通信</li><li><strong>Finished</strong> 报文：标志 TLS 连接建立成功</li></ol></li><li>TLS 握手成功此后通过对称密钥 session key/secret 加密通信</li></ol><blockquote><ol><li>握手：证书下发，密钥协商（这个阶段都是明文的）</li><li>数据传输：这个阶段才是加密的，用的就是握手阶段协商出来的对称密钥</li></ol></blockquote><p>进行整理，如下图所示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521215733187.png" alt="image-20210521215733187" title="">                </div>                <div class="image-caption">image-20210521215733187</div>            </figure><h3 id="使用wireshark实战证明"><a href="#使用wireshark实战证明" class="headerlink" title="使用wireshark实战证明"></a>使用wireshark实战证明</h3><p>本地地址和LeetCode-CN的交互</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521174931648.png" alt="wireshark抓包展示" title="">                </div>                <div class="image-caption">wireshark抓包展示</div>            </figure><ol><li><p>客户端想服务端发送https请求链接，同时将自身支持的密码套件（非对称加密算法、对称加密算法、摘要算法）发送个服务端</p><p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521181226105.png" alt="客户端say hello阶段"></p></li><li><p>服务端根据客户端获发送的数据，选择一套密码套件，以及自身的证书发送给客户端</p><p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521182242937.png" alt="服务端选择的密码套件--服务端say hello阶段"></p><p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521182508161.png" alt="服务端将自身的证书发送给客户端--- 服务端Say hello 阶段"></p></li><li><p>客户端进行验证，验证正常自后，随机生成一串数组作为后续通信的对称加密密钥，然后使用服务端证书的公钥进行加密，同时使用摘要算法对本次的会话信息进行加密，然后一并发送给服务端。</p><p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521185850059.png" alt="image-20210521185850059"></p></li><li><p>服务端验证，正常之后，剩下的忘截图了，后面补上</p></li></ol><h2 id="HTTPS的认证—数字证书"><a href="#HTTPS的认证—数字证书" class="headerlink" title="HTTPS的认证—数字证书"></a>HTTPS的认证—数字证书</h2><p>了解了HTTPS加密通信的流程后，对于数据裸奔的疑虑应该基本打消了。然而，还有一个问题：如何确保证书时可信的？</p><p>证书不可信可能有两种情况：</p><ol><li>证书是伪造的：压根不是CA颁发的</li><li>证书被篡改过：比如将XX网站的公钥给替换了</li></ol><p>数字证书是由权威的CA（Certificate Authority）机构给服务端进行颁发，CA机构通过服务端提供的相关信息生成证书，证书内容包含了<code>持有人的相关信息</code>，<code>服务器的公钥</code>，<code>签署者签名信息（数字签名）</code>等，最重要的是<strong>公钥在数字证书中</strong>。</p><blockquote><p>数字签名和摘要算法的关系</p><p>明文 –&gt; hash运算 –&gt; 摘要 –&gt; 私钥加密 –&gt; 数字签名</p></blockquote><p>数字证书是如何保证公钥来自请求的服务器？</p><ul><li>数字证书上由持有人的相关信息，通过这点可以确定其不是一个中间人</li></ul><p><strong>证书包含的内容：</strong></p><ul><li>一个证书中含有三个部分:<code>证书内容</code>，<code>散列算法</code>，<code>加密密文</code>，证书内容会被散列算法hash计算出摘要，然后使用CA机构提供的私钥进行RSA加密得到数组签名（加密密文）。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Users/weikunkun/Library/Application" alt="证书内容" title="Support/typora-user-images/image-20210521221149447.png">                </div>                <div class="image-caption">Support/typora-user-images/image-20210521221149447.png</div>            </figure><h3 id="证书伪造"><a href="#证书伪造" class="headerlink" title="证书伪造"></a>证书伪造</h3><p>浏览器内置的CA的根证书包含了<strong>CA的公钥</strong></p><ol><li>证书颁发的机构是伪造的：浏览器不认识，直接认为是危险证书</li><li>证书颁发的机构是确实存在的，于是根据CA名，找到对应内置的CA根证书、CA的公钥。</li><li>用CA的公钥，对伪造的证书的摘要进行解密，发现解不了。认为是危险证书</li></ol><h3 id="证书篡改"><a href="#证书篡改" class="headerlink" title="证书篡改"></a>证书篡改</h3><ol><li>根据证书的加密密文（数字签名）使用CA的公钥得到证书摘要A</li><li>根据证书内容使用摘要算法得到证书摘要B</li><li>对比摘要A和摘要B是否相同</li></ol><h2 id="HTTPS的完整性保护—摘要算法"><a href="#HTTPS的完整性保护—摘要算法" class="headerlink" title="HTTPS的完整性保护—摘要算法"></a>HTTPS的完整性保护—摘要算法</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li>图解HTTP</li><li>趣谈协议—极客时间</li><li><a href="https://security.stackexchange.com/questions/89383/why-does-the-ssl-tls-handshake-have-a-client-and-server-random" target="_blank" rel="noopener">Why does the SSL/TLS handshake have a client and server random</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;引入一个新的概念的时候，必然先阐述其相关方面已有的实现有哪些缺点，新的概念解决了哪些缺点。所以～让我们看看HTTP有哪些却缺点&lt;/p&gt;
&lt;p&gt;&lt;st</summary>
      
    
    
    
    <category term="网络" scheme="https://winniekun.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="应用层" scheme="https://winniekun.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Spring IoC解读</title>
    <link href="https://winniekun.github.io/spring-ioc-analysis/"/>
    <id>https://winniekun.github.io/spring-ioc-analysis/</id>
    <published>2021-05-21T01:24:20.000Z</published>
    <updated>2021-05-21T01:27:09.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p>IoC控制反转，意思就是将创建对象的控制权从我们自己硬编码来new一个对象反转到了第三方身上。IoC的主要实现方式是依赖注入，Spring中的依赖注入方式有：<code>构造方法注入</code>、<code>settter注入</code>、<code>接口注入</code>。</p><ul><li><strong>控制反转</strong>是一种思想</li><li><strong>依赖注入</strong>是一种设计模式</li></ul><blockquote><p>IoC是一种可以帮助我们解耦各业务对象间依赖关系的对象绑定方式</p></blockquote><h2 id="IoC-Service-Provider"><a href="#IoC-Service-Provider" class="headerlink" title="IoC Service Provider"></a>IoC Service Provider</h2><p>虽然业务对象可以通过IoC方式声明相应的依赖，但是最终仍然需要通过某个角色或者服务将这些依赖的对象绑定到一起。而IoC Service Provider就对应IoC场景中的这一角色。IoC Service Provider在这里是一个抽象出来的概念，它可以指代任何将IoC场景中的业务对象绑定到一起的实现方式。它可以是一段代码，也可以是一组相关的类，甚至可以是比较通用的IoC框架或 者IoC容器实现。</p><h3 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h3><ol><li><p>业务对象的构建管理</p><p>IoC中，业务对象无需关心所依赖注入的对象<strong>如何构建如何取得</strong>，但是这部分的工作还是需要有人来做的。所以<code>IoC Service Provider</code>需要将对象的构建逻辑从<em>客户端</em>对象那里抽离出来，一面这部分逻辑污染业务对象的实现。</p><blockquote><p><strong>客户端</strong>：代使用某个对象或者某种服务的对象。如果对象A需要引用对象B，那么A就是B的客户端对象，而不管A 处于Service层还是数据访问层。</p></blockquote></li><li><p>业务对象之间的依赖绑定</p><p>最艰巨也是最重要的，这 是它的最终使命之所在。如果不能完成这个职责，那么，无论业务对象如何的“呼喊”，也不 会得到依赖对象的任何响应(最常见的倒是会收到一个NullPointerException)。<code>IoC Service Provider</code>通过结合之前构建和管理的所有业务对象，以及各个业务对象间可以识别的依赖关系，将这些对象所依赖的对象注入绑定，从而保证每个业务对象在使用的时候，可以处于就绪状 态。</p></li></ol><h2 id="Spring-IoC容器"><a href="#Spring-IoC容器" class="headerlink" title="Spring IoC容器"></a>Spring IoC容器</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210520140010820.png" alt="image-20210520140010820" title="">                </div>                <div class="image-caption">image-20210520140010820</div>            </figure><p>Spring的IoC容器就是一个IoC Provider，但是其相比于IoC Provider的功能更加的丰富，除了业务对象的构建、依赖关系的绑定这种IoC Provider的基本功能，还新增了业务对象声明周期的管理，AOP支持等。同时Spring提供了两种容器类型:BeanFactory和ApplicationContext。</p><ul><li><p>BeanFactory</p><p>基础类型IoC容器，提供完整的IoC服务支持。如果没有特殊指定，==默认采用延迟初始化策略(lazy-load)==。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的 IoC容器选择。</p></li><li><p>ApplicationContext</p><p>在BeanFactory的基础上构建，是相对比较高 级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。ApplicationContext所管理 的对象，在该类型容器启动之后，==默认全部初始化并绑定完成==。所以，相对于BeanFactory来 说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中， ApplicationContext类型的容器是比较合适的选择。</p></li></ul><h3 id="简单的式例"><a href="#简单的式例" class="headerlink" title="简单的式例"></a>简单的式例</h3><h3 id="Spring-IoC容器的一些特性简介"><a href="#Spring-IoC容器的一些特性简介" class="headerlink" title="Spring IoC容器的一些特性简介"></a>Spring IoC容器的一些特性简介</h3><h4 id="autowire"><a href="#autowire" class="headerlink" title="autowire"></a>autowire</h4><p>自动注入，通过autowire，我们可以略去很多人工显示的配置bean的操作，被依赖的发现和注入都交给了Spring，同时其有几个类型可选择，比如byName、byType等。</p><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><p>BeanFactory和FactoryBean傻傻分不清？虽然两者类似，但是功能不同。FactoryBean是一种工厂Bean，和普通的Bean不一样，FactoryBean是可以生产Bean的Bean。</p><h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends-on"></a>depends-on</h4><p>当一个 bean 直接依赖另一个 bean，可以使用 <code>&lt;ref/&gt;</code> 标签进行配置。不过如某个 bean 并不直接依赖于其他 bean，但又需要其他 bean 先实例化好，这个时候就需要使用 depends-on 特性了。depends-on 特性比较简单，就不演示了。仅贴一下配置文件的内容，如下：</p><p>这里有两个简单的类，其中 Hello 需要 World 在其之前完成实例化。相关配置如下：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"xyz.coolblog.depnedson.Hello"</span> <span class="attr">depends-on</span>=<span class="string">"world"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"world"</span> <span class="attr">class</span>=<span class="string">"xyz.coolblog.depnedson.World"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h4><p>BeanPostProcessor 是 bean 实例化时的后置处理器，包含两个方法，其源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>{</span><br><span class="line">    <span class="comment">// bean 初始化前的回调方法</span></span><br><span class="line">    <span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bean 初始化后的回调方法    </span></span><br><span class="line">    <span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>BeanPostProcessor是Spring框架的一个扩展点，可以通过BeanPostProcessor接口，我们能够插手Bean的实例化过程，比如AOP就是在bean实例将切面逻辑织入bean实例中，AOP也是正是通过BeanPostProcessor和IoC容器建立了联系</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>{</span><br><span class="line">        log.info(<span class="string">"Before  "</span> + beanName + <span class="string">" Initialization"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>{</span><br><span class="line">        log.info(<span class="string">"After  "</span> + beanName + <span class="string">" Initialization"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="配置如下"><a href="#配置如下" class="headerlink" title="配置如下"></a><strong>配置如下</strong></h5><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.titizz.simulation.toyspring.learninng.LoggerBeanPostProcessor"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"com.titizz.simulation.toyspring.Car"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h5 id="测试如下"><a href="#测试如下" class="headerlink" title="测试如下"></a><strong>测试如下</strong></h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanPostProcessor</span><span class="params">()</span> </span>{</span><br><span class="line">    String xmlPath = <span class="string">"test-spring.xml"</span>;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(xmlPath);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/05/02/iUgIOGvfmPo1ws5.png" alt="image-20210502181644978" title="">                </div>                <div class="image-caption">image-20210502181644978</div>            </figure><h3 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h3><h4 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h4><p>以 <code>Resource</code> 接口为核心发散出的几个类，都是用于解决 IoC 容器中的内容从哪里来的问题，也就是 <strong>配置文件从哪里读取、配置文件如何读取</strong> 的问题。</p><table><thead><tr><th align="left">类名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>Resource</code></td><td align="left">接口，标识一个外部资源。通过 <code>getInputStream()</code> 方法 <strong>获取资源的输入流</strong> 。</td></tr><tr><td align="left"><code>UrlResource</code></td><td align="left">实现 <code>Resource</code> 接口的资源类，通过 URL 获取资源。</td></tr><tr><td align="left"><code>ResourceLoader</code></td><td align="left">资源加载类。通过 <code>getResource(String)</code> 方法获取一个 <code>Resouce</code> 对象，是 <strong>获取 <code>Resouce</code> 的主要途径</strong> 。</td></tr></tbody></table><h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><p><strong>功能：</strong>用于解决Bean的定义问题，包括Bean的名字，类型以及它的属性赋予了什么值或者引用。说白了也就是<strong>解决了在IoC容器中定义一个Bean，使得IoC容器可以根据这个定义来生成实例。</strong></p><table><thead><tr><th align="left">类名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>BeanDefinition</code></td><td align="left">该类保存了 <code>Bean</code> 定义。包括 <code>Bean</code> 的 <strong>名字</strong> <code>String beanClassName</code>、<strong>类型</strong> <code>Class beanClass</code>、<strong>属性</strong> <code>PropertyValues propertyValues</code>。根据其 <strong>类型</strong> 可以生成一个类实例，然后可以把 <strong>属性</strong> 注入进去。<code>propertyValues</code> 里面包含了一个个 <code>PropertyValue</code> 条目，每个条目都是键值对 <code>String</code> - <code>Object</code>，分别对应要生成实例的属性的名字与类型。在 Spring 的 XML 中的 <code>property</code> 中，键是 <code>key</code> ，值是 <code>value</code> 或者 <code>ref</code>。对于 <code>value</code> 只要直接注入属性就行了，但是 <code>ref</code> 要先进行解析。<code>Object</code> 如果是 <code>BeanReference</code> 类型，则说明其是一个引用，其中保存了引用的名字，需要用先进行解析，转化为对应的实际 <code>Object</code>。</td></tr><tr><td align="left"><code>BeanDefinitionReader</code></td><td align="left">解析 <code>BeanDefinition</code> 的接口。通过 <code>loadBeanDefinitions(String)</code> 来从一个地址加载类定义。</td></tr><tr><td align="left"><code>AbstractBeanDefinitionReader</code></td><td align="left">实现 <code>BeanDefinitionReader</code> 接口的抽象类（未具体实现 <code>loadBeanDefinitions</code>，而是规范了 <code>BeanDefinitionReader</code> 的基本结构）。内置一个 <code>HashMap rigistry</code>，用于保存 <code>String</code> - <code>beanDefinition</code> 的键值对。内置一个 <code>ResourceLoader resourceLoader</code>，用于保存类加载器。用意在于，使用时，只需要向其 <code>loadBeanDefinitions()</code> 传入一个资源地址，就可以自动调用其类加载器，并把解析到的 <code>BeanDefinition</code> 保存到 <code>registry</code> 中去。</td></tr><tr><td align="left"><code>XmlBeanDefinitionReader</code></td><td align="left">具体实现了 <code>loadBeanDefinitions()</code> 方法，从 XML 文件中读取类定义。</td></tr></tbody></table><h4 id="BeanFactory-question"><a href="#BeanFactory-question" class="headerlink" title="BeanFactory :question:"></a>BeanFactory <span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>以 <code>BeanFactory</code> 接口为核心发散出的几个类，都是用于解决 IoC 容器在 <strong>已经获取 <code>Bean</code> 的定义的情况下，如何装配、获取 <code>Bean</code> 实例</strong> </p><p>的问题。</p><table><thead><tr><th align="left">类名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>BeanFactory</code></td><td align="left">接口，标识一个 IoC 容器。通过 <code>getBean(String)</code> 方法来 <strong>获取一个对象</strong></td></tr><tr><td align="left"><code>AbstractBeanFactory</code></td><td align="left"><code>BeanFactory</code> 的一种抽象类实现，规范了 IoC 容器的基本结构，但是把生成 <code>Bean</code> 的具体实现方式留给子类实现。IoC 容器的结构：<code>AbstractBeanFactory</code> 维护一个 <code>beanDefinitionMap</code> 哈希表用于保存类的定义信息（<code>BeanDefinition</code>）。获取 <code>Bean</code> 时，如果 <code>Bean</code> 已经存在于容器中，则返回之，否则则调用 <code>doCreateBean</code> 方法装配一个 <code>Bean</code>。（所谓存在于容器中，是指容器可以通过 <code>beanDefinitionMap</code> 获取 <code>BeanDefinition</code> 进而通过其 <code>getBean()</code> 方法获取 <code>Bean</code>。）</td></tr><tr><td align="left"><code>AutowireCapableBeanFactory</code></td><td align="left">可以实现自动装配的 <code>BeanFactory</code>。在这个工厂中，实现了 <code>doCreateBean</code> 方法，该方法分三步：1，通过 <code>BeanDefinition</code> 中保存的类信息实例化一个对象；2，把对象保存在 <code>BeanDefinition</code> 中，以备下次获取；3，为其装配属性。装配属性时，通过 <code>BeanDefinition</code> 中维护的 <code>PropertyValues</code> 集合类，把 <code>String</code> - <code>Value</code> 键值对注入到 <code>Bean</code> 的属性中去。如果 <code>Value</code> 的类型是 <code>BeanReference</code> 则说明其是一个引用（对应于 XML 中的 <code>ref</code>），通过 <code>getBean</code> 对其进行获取，然后注入到属性中。</td></tr></tbody></table><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>以 <code>ApplicationContext</code> 接口为核心发散出的几个类，主要是对前面 <code>Resouce</code> 、 <code>BeanFactory</code>、<code>BeanDefinition</code> 进行了功能的封装，解决 <strong>根据地址获取 IoC 容器并使用</strong> 的问题。</p><table><thead><tr><th align="left">类名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>ApplicationContext</code></td><td align="left">标记接口，继承了 <code>BeanFactory</code>。通常，要实现一个 IoC 容器时，需要先通过 <code>ResourceLoader</code> 获取一个 <code>Resource</code>，其中包括了容器的配置、<code>Bean</code> 的定义信息。接着，使用 <code>BeanDefinitionReader</code> 读取该 <code>Resource</code> 中的 <code>BeanDefinition</code> 信息。最后，把 <code>BeanDefinition</code> 保存在 <code>BeanFactory</code> 中，容器配置完毕可以使用。注意到 <code>BeanFactory</code> 只实现了 <code>Bean</code> 的 <strong>装配、获取</strong>，并未说明 <code>Bean</code> 的 <strong>来源</strong> 也就是 <code>BeanDefinition</code> 是如何 <strong>加载</strong> 的。该接口把 <code>BeanFactory</code> 和 <code>BeanDefinitionReader</code> 结合在了一起。</td></tr><tr><td align="left"><code>AbstractApplicationContext</code></td><td align="left"><code>ApplicationContext</code> 的抽象实现，内部包含一个 <code>BeanFactory</code> 类。主要方法有 <code>getBean()</code> 和 <code>refresh()</code> 方法。<code>getBean()</code> 直接调用了内置 <code>BeanFactory</code> 的 <code>getBean()</code> 方法，<code>refresh()</code> 则用于实现 <code>BeanFactory</code> 的刷新，也就是告诉 <code>BeanFactory</code> 该使用哪个资源（<code>Resource</code>）加载类定义（<code>BeanDefinition</code>）信息，该方法留给子类实现，用以实现 <strong>从不同来源的不同类型的资源加载类定义</strong> 的效果。</td></tr><tr><td align="left">ClassPathXmlApplicationContext</td><td align="left">从类路径加载资源的具体实现类。内部通过 <code>XmlBeanDefinitionReader</code> 解析 <code>UrlResourceLoader</code> 读取到的 <code>Resource</code>，获取 <code>BeanDefinition</code> 信息，然后将其保存到内置的 <code>BeanFactory</code> 中。</td></tr></tbody></table><blockquote><p>对 <code>ApplicatinoContext</code> 的分层更为细致。<code>AbstractApplicationContext</code> 中为了实现 <strong>不同来源</strong> 的 <strong>不同类型</strong> 的资源加载类定义，把这两步分层实现。以“从类路径读取 XML 定义”为例，首先使用 <code>AbstractXmlApplicationContext</code> 来实现 <strong>不同类型</strong> 的资源解析，接着，通过 <code>ClassPathXmlApplicationContext</code> 来实现 <strong>不同来源</strong> 的资源解析。</p></blockquote><h1 id="战略观望"><a href="#战略观望" class="headerlink" title="战略观望"></a>战略观望</h1><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210520110056368.png" alt="官网示例" style="zoom:50%;"><p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210520105808650.png" alt="Spring容器功能实现的各个阶段"></p><h2 id="容器启动阶段"><a href="#容器启动阶段" class="headerlink" title="容器启动阶段"></a>容器启动阶段</h2><p>使用Resource相关接口标识我们配置文件从哪里获取，然后使用BeanDefinitionReader对标识的文件进行解析，将分析后的信息编组为相应的BeanDefinition。最后将保存了每个Bean定义信息的BeanDefinition，注册到相应的BeanDefinitionRegistry，这样容器的启动就完成了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210520110900263.png" alt="启动阶段任务" title="">                </div>                <div class="image-caption">启动阶段任务</div>            </figure><h2 id="Bean实例化阶段"><a href="#Bean实例化阶段" class="headerlink" title="Bean实例化阶段"></a>Bean实例化阶段</h2><p>通过容器的启动阶段，现在所有的Bean定义的信息，都通过BeanDefiniton的方式注册到了BeanDefinitionRegistry中，当某个请求方通过容器的getBean方法明确的调用某个对象的时候，或者因为依赖关系容器需要隐式的调用getBean方法，就会出发第二阶段的活动。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210520150106541.png" alt="bean的实例化过程" title="">                </div>                <div class="image-caption">bean的实例化过程</div>            </figure><p>Spring容器将对其所管理的对象全部给予统一的生命周期管理，这些被管理的对象完全摆脱了原 来那种“new完后被使用，脱离作用域后即被回收”的命运</p><h1 id="详细阐述"><a href="#详细阐述" class="headerlink" title="详细阐述"></a>详细阐述</h1><h2 id="最简单的IoC容器"><a href="#最简单的IoC容器" class="headerlink" title="最简单的IoC容器"></a>最简单的IoC容器</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>{</span><br><span class="line">  <span class="comment">// 说白了就是一个map</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; beanMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(String name, Object bean)</span> </span>{</span><br><span class="line">beanMap.put(name, bean);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> beanMap.get(name);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBeanContainerTest</span> </span>{</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">// 需要我们去手动new依赖对象，然后放入</span></span><br><span class="line">BeanFactory beanFactory = <span class="keyword">new</span> BeanFactory();</span><br><span class="line">beanFactory.registerBean(<span class="string">"helloService"</span>, <span class="keyword">new</span> HelloService());</span><br><span class="line">HelloService helloService = (HelloService) beanFactory.getBean(<span class="string">"helloService"</span>);</span><br><span class="line">assertThat(helloService).isNotNull();</span><br><span class="line">assertThat(helloService.sayHello()).isEqualTo(<span class="string">"hello"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>{</span><br><span class="line">System.out.println(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="BeanFactoryPostProcess和BeanPostProcessor"><a href="#BeanFactoryPostProcess和BeanPostProcessor" class="headerlink" title="BeanFactoryPostProcess和BeanPostProcessor"></a>BeanFactoryPostProcess和BeanPostProcessor</h2><p>BeanFactoryPostProcess和BeanPostProcessor是spring框架中具有重量级地位的两个接口，理解了这两个接口的作用，基本就理解spring的核心原理了</p><ol><li>BeanFactoryPostProcessor是spring提供的容器拓展机制，允许我们在<strong>bean实例化之前修改bean的定义信息（BeanDedinition）</strong>，其重要的实现类PropertyPlaceholderConfigurer和CustomEditorConfigurer<ul><li>PropertyPlaceholderConfigurer的作用是用properties文件的配置值替换xml文件中的占位符</li><li>CustomEditorConfigurer的作用是实现类型转换。</li></ul></li><li>BeanPostProcessor也是spring提供的容器拓展机制，不同于BeanFactoryPostProcessor，BeanPostProcesssor在<strong>Bean实例化之后修改Bean或替换Bean</strong>。也是实现AOP的关键。</li></ol><p>等等等。。。</p><h2 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a>整体流程图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/iShot2021-05-21%2000.08.58.png" alt="整体流程图" title="">                </div>                <div class="image-caption">整体流程图</div>            </figure><ol><li>BeanDefinitionReader读取Bean的相关配置信息，并将读取到的信息使用BeanDefinition表示，同时注册到BeanDefinitionRegistry中。</li><li>通过实现了BeanFactoryPostProcessor的类，自定义修改BeanDefinition中的信息</li><li>Bean的实例化<ol><li>采用策略模式，策略化Bean的实例，共包含两种方式：cglib、反射</li><li>获取Bean的实例之后，根据BeanDefinition中的信息，填充Bean的属性、依赖</li></ol></li><li>检测各种检测各种Aware接口，并放入Bean中</li><li>调用BeanPostProcessor接口的前置处理方法，处理符合要求的Bean实例</li><li>如果实现了InitializingBean接口，则处理对应的afterPropertiesSet()方法</li><li>如果定义init-method方法，处理对应的初始化方法</li><li>调用BeanPostProcessor接口的后置处理方法，处理符合要求的Bean实例</li><li>使用</li><li>判断Bean的Scope，如果是prototype，不再管理</li><li>如果是单例，如果实现了DisposableBean接口，则执行对应的destroy方法</li><li>如果定义了destory-method，则执行自定义的销毁方法</li></ol><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>整理的还是很乱，虽然看的时候是都看了。。。</p><p>后面慢慢优化吧（涉及到以后==永远不会）<span class="github-emoji"><span>😑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f611.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><ul><li>spring揭秘</li><li><a href="https://github.com/code4craft/tiny-spring" target="_blank" rel="noopener">tiny-spring</a></li><li><a href="https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%AD%96%E7%95%A5InstantiationStrategy" target="_blank" rel="noopener">mini-spring</a></li><li><a href="https://www.zybuluo.com/dugu9sword/note/382745#beanfactory" target="_blank" rel="noopener">tiny-spring分析</a></li><li><a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noopener">Spring IoC容器分析</a></li><li><a href="http://www.tianxiaobo.com/2018/05/30/Spring-IOC-%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/#451-%E5%AE%9E%E7%8E%B0-applicationcontextaware-%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">Spring IOC 容器源码分析系列</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h1&gt;&lt;h2 id=&quot;IoC&quot;&gt;&lt;a href=&quot;#IoC&quot; class=&quot;headerlink&quot; title=&quot;IoC&quot;&gt;&lt;/a&gt;IoC&lt;/h2&gt;&lt;p&gt;IoC</summary>
      
    
    
    
    <category term="spring" scheme="https://winniekun.github.io/categories/spring/"/>
    
    
    <category term="ioc" scheme="https://winniekun.github.io/tags/ioc/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="https://winniekun.github.io/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://winniekun.github.io/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2021-04-30T13:35:01.000Z</published>
    <updated>2021-05-16T16:43:06.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>先选择分界点</li><li>先递归排序</li><li>归并 合二为一</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Users/weikunkun/Library/Application" alt="image-20210419120203122" title="Support/typora-user-images/image-20210419120203122.png">                </div>                <div class="image-caption">Support/typora-user-images/image-20210419120203122.png</div>            </figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(array, l, mid);</span><br><span class="line">        mergeSort(array, mid+<span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// 整合</span></span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>]; <span class="comment">// 临时数组, 用于临时存储 [l,r]区间内排好序的数据</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;  <span class="comment">// 两个指针</span></span><br><span class="line">        <span class="comment">// 进行归并</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) {</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt;= array[j]) </span><br><span class="line">                tmp[k++] = array[i++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tmp[k++] = array[j++];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = array[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r) tmp[k++] = array[j++];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进行赋值</span></span><br><span class="line">        <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">            array[i] = tmp[j];</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h2&gt;&lt;h3 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h</summary>
      
    
    
    
    <category term="排序" scheme="https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="归并排序" scheme="https://winniekun.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>死磕数学基础</title>
    <link href="https://winniekun.github.io/stick-to-math/"/>
    <id>https://winniekun.github.io/stick-to-math/</id>
    <published>2021-04-20T11:56:11.000Z</published>
    <updated>2021-05-16T16:42:07.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LeetCode死磕系列十二： 数学基础</p><p>说实话，其实都是刷题都是数学的实现，不过感觉有些题目更加偏向数学应用，譬如蓄水池，等概率抽样…。</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="470-用rand7-实现Rand10"><a href="#470-用rand7-实现Rand10" class="headerlink" title="470 用rand7()实现Rand10()"></a>470 用rand7()实现Rand10()</h3><p><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/cong-zui-ji-chu-de-jiang-qi-ru-he-zuo-dao-jun-yun-/" target="_blank" rel="noopener">从最基础的讲起如何做到均匀的生成随机数</a></p><p>从上述的文章可以得出：</p><blockquote><p><strong>已知:</strong>  <em>$randN()$可以==等概率==生成$[1, N]$范围的数字</em><br><strong>那么:</strong>  $(randN()-1) \times Y  + randY()$可以==等概率==生成$[1, Y \times N]$ 范围的数字</p><p><strong>即：</strong>实现了$randNY()$</p></blockquote><p>以$[(rand9() - 1) \times 7 + rand7()]$为例子</p><table><thead><tr><th>rand9()-1\rand7</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td><strong>0</strong></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td><strong>1</strong></td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td></tr><tr><td><strong>2</strong></td><td>15</td><td>16</td><td>17</td><td>18</td><td>19</td><td>20</td><td>21</td></tr><tr><td><strong>3</strong></td><td>22</td><td>23</td><td>24</td><td>25</td><td>26</td><td>27</td><td>28</td></tr><tr><td><strong>4</strong></td><td>29</td><td>30</td><td>31</td><td>32</td><td>33</td><td>34</td><td>35</td></tr><tr><td><strong>5</strong></td><td>36</td><td>37</td><td>38</td><td>39</td><td>40</td><td>41</td><td>42</td></tr><tr><td><strong>6</strong></td><td>43</td><td>44</td><td>45</td><td>46</td><td>47</td><td>48</td><td>49</td></tr><tr><td><strong>7</strong></td><td>50</td><td>51</td><td>52</td><td>53</td><td>54</td><td>55</td><td>56</td></tr><tr><td><strong>8</strong></td><td>57</td><td>58</td><td>59</td><td>60</td><td>61</td><td>62</td><td>63</td></tr></tbody></table><p><strong>是不是很神奇，数学证明不会</strong></p><p>那么想到通过rand4()来实现rand2()呢？这个就很简单了，已知rand4()会均匀产生[1,4]的随机数，通过取余，再加1就可以了。如下所示，结果也是等概率的。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rand4() % 2 + 1 = ?</span><br><span class="line">   1 % 2    + 1 = 2</span><br><span class="line">   2 % 2    + 1 = 1</span><br><span class="line">   3 % 2    + 1 = 2</span><br><span class="line">   4 % 2    + 1 = 1</span><br></pre></td></tr></tbody></table></figure><p>事实上，只要rand_N()中N是2的倍数，就都可以用来实现rand2()，反之，若N不是2的倍数，则产生的结果不是等概率的。比如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rand6() % 2 + 1 = ?</span><br><span class="line">   1 % 2    + 1 = 2</span><br><span class="line">   2 % 2    + 1 = 1</span><br><span class="line">   3 % 2    + 1 = 2</span><br><span class="line">   4 % 2    + 1 = 1</span><br><span class="line">   5 % 2    + 1 = 2</span><br><span class="line">   6 % 2    + 1 = 1</span><br><span class="line"></span><br><span class="line">rand5() % 2 + 1 = ?</span><br><span class="line">   1 % 2    + 1 = 2</span><br><span class="line">   2 % 2    + 1 = 1</span><br><span class="line">   3 % 2    + 1 = 2</span><br><span class="line">   4 % 2    + 1 = 1</span><br><span class="line">   5 % 2    + 1 = 2</span><br></pre></td></tr></tbody></table></figure><p><strong>通用一些的</strong></p><blockquote><p>如果需要实现$randX()$</p><ol><li>先实现$randN()$<ol><li>$N$为$X$的倍数（$N&gt;X$）</li></ol></li><li>再通过 $randN() % X + 1$即可</li></ol></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// rand 49</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">int</span> num = (rand7() - <span class="number">1</span>) * <span class="number">7</span> + rand7();  <span class="comment">// rand49</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt;= <span class="number">40</span>) { <span class="comment">// 使用拒绝采样，得到rand40</span></span><br><span class="line">                <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>;  <span class="comment">// rand10</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><strong>优化</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">SolBase</span> </span>{</span><br><span class="line">  <span class="comment">// 上述拒绝了9个数字，</span></span><br><span class="line">    <span class="comment">// 优化之后，减少丢弃值，提高命中率</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">int</span> a = rand7();</span><br><span class="line">            <span class="keyword">int</span> b = rand7();</span><br><span class="line">            <span class="keyword">int</span> num = (a-<span class="number">1</span>)*<span class="number">7</span> + b; <span class="comment">// rand 49</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">40</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>; <span class="comment">// 拒绝采样</span></span><br><span class="line">            </span><br><span class="line">            a = num - <span class="number">40</span>; <span class="comment">// rand 9</span></span><br><span class="line">            b = rand7();</span><br><span class="line">            num = (a-<span class="number">1</span>)*<span class="number">7</span> + b; <span class="comment">// rand 63</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">60</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            a = num - <span class="number">60</span>; <span class="comment">// rand 3</span></span><br><span class="line">            b = rand7();</span><br><span class="line">            num = (a-<span class="number">1</span>)*<span class="number">7</span> + b; <span class="comment">// rand 21</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">20</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;LeetCode死磕系列十二： 数学基础&lt;/p&gt;
&lt;p&gt;说实话，其实都是刷题都是数学的实现，不过感觉有些题目更加偏向数学应用，譬如蓄水池，等概率抽样…。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://winniekun.github.io/categories/LeetCode/"/>
    
    
    <category term="死磕系列" scheme="https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"/>
    
    <category term="数学基础" scheme="https://winniekun.github.io/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>死磕SQL</title>
    <link href="https://winniekun.github.io/stick-to-sql/"/>
    <id>https://winniekun.github.io/stick-to-sql/</id>
    <published>2021-04-20T11:56:11.000Z</published>
    <updated>2021-05-16T16:39:43.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LeetCode死磕系列十： SQL</p><a id="more"></a><p>作为一个后端开发程序员，SQL功底还是很重要的！！！</p><p>所以还是要练习。</p><blockquote><p>还记得去年被字节面试的时候，连SQL都写不出来。。。</p></blockquote><h2 id="LeetCode-SQL题目整理"><a href="#LeetCode-SQL题目整理" class="headerlink" title="LeetCode SQL题目整理"></a>LeetCode SQL题目整理</h2><p>刷了LC上的top70之后，感觉考察最多的还是多表的联合查找，毕竟实际中也不会仅仅是单表的查询。</p><p><strong>主要题型：</strong></p><ol><li>TOP N 问题</li><li>排名问题<ol><li>滑动窗口</li></ol></li><li>自链接问题</li></ol><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="TOP-N问题"><a href="#TOP-N问题" class="headerlink" title="TOP N问题"></a>TOP N问题</h3><h4 id="176-第二高的薪水"><a href="#176-第二高的薪水" class="headerlink" title="176. 第二高的薪水"></a><a href="https://leetcode-cn.com/problems/second-highest-salary/" target="_blank" rel="noopener">176. 第二高的薪水</a></h4><p><strong>思路：</strong></p><ol><li><p>使用limit</p><p>注意判空、去重</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">ifnull</span> ((<span class="keyword">select</span> </span><br><span class="line">    <span class="keyword">distinct</span> Salary </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    Employee</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">1</span>, <span class="number">1</span>) , <span class="literal">null</span>) <span class="keyword">as</span> SecondHighestSalary;</span><br></pre></td></tr></tbody></table></figure></li><li><p>先使用max查询最高的薪水 max，之后再通过自查询，查询小于max的max</p></li></ol><h4 id="184-部门工资最高的员工"><a href="#184-部门工资最高的员工" class="headerlink" title="184. 部门工资最高的员工"></a><a href="https://leetcode-cn.com/problems/department-highest-salary/" target="_blank" rel="noopener">184. 部门工资最高的员工</a></h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 思路： 寻找最大薪资的数据</span></span><br><span class="line"><span class="comment">-- join</span></span><br><span class="line"><span class="comment">-- 1. 直接join group by  选取最大的即可 但是 无法保证最大的薪资不重复 失败</span></span><br><span class="line"><span class="comment">-- 2. 先通过员工信息 寻找最大的薪资+id 的数据A，然后再join 两张表，将A中对应的数据返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1. </span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    d.Name <span class="keyword">as</span> Department,</span><br><span class="line">    e.Name <span class="keyword">as</span> Employee,</span><br><span class="line">    e.Salary <span class="keyword">as</span> Salary</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">    Employee e <span class="keyword">inner</span> <span class="keyword">join</span> Department d <span class="keyword">on</span> e.DepartmentId = d.Id</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">    (e.DepartmentId, e.Salary) <span class="keyword">in</span></span><br><span class="line">    (<span class="keyword">select</span> </span><br><span class="line">        DepartmentId,</span><br><span class="line">        <span class="keyword">max</span>(Salary)</span><br><span class="line">    <span class="keyword">from</span> </span><br><span class="line">        Employee</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> </span><br><span class="line">        DepartmentId);</span><br></pre></td></tr></tbody></table></figure><h4 id="177-第N高的薪水"><a href="#177-第N高的薪水" class="headerlink" title="177. 第N高的薪水"></a><a href="https://leetcode-cn.com/problems/nth-highest-salary/" target="_blank" rel="noopener">177. 第N高的薪水</a></h4><p>LIMIT PAGE, OFFSET</p><p>跳过 PAGE * OFFSET条数据，接下来的offset条数据， 因为题目中未说明薪资是否不重复，所以还需要使用distinct去重</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">set</span> N:= N<span class="number">-1</span>;</span><br><span class="line">  RETURN (  </span><br><span class="line">      <span class="comment"># Write your MySQL query statement below.</span></span><br><span class="line">    <span class="keyword">select</span> </span><br><span class="line">        <span class="keyword">distinct</span> Salary</span><br><span class="line">    <span class="keyword">from</span> </span><br><span class="line">        Employee</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> </span><br><span class="line">        Salary <span class="keyword">desc</span></span><br><span class="line">    <span class="keyword">limit</span> N,<span class="number">1</span></span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></tbody></table></figure><h4 id="185-部门工资前三高的所有员工"><a href="#185-部门工资前三高的所有员工" class="headerlink" title="185. 部门工资前三高的所有员工"></a><a href="https://leetcode-cn.com/problems/department-top-three-salaries/" target="_blank" rel="noopener">185. 部门工资前三高的所有员工</a></h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.Name <span class="keyword">as</span> Department, </span><br><span class="line">e2.Name <span class="keyword">as</span> Employee, </span><br><span class="line">e2.Salary <span class="keyword">from</span> </span><br><span class="line">Department d <span class="keyword">inner</span> <span class="keyword">join</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> e.*, </span><br><span class="line">    <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> DepartmentID </span><br><span class="line">    <span class="keyword">Order</span> <span class="keyword">by</span> Salary <span class="keyword">DESC</span>) <span class="keyword">as</span> <span class="string">'rank'</span></span><br><span class="line">    <span class="keyword">from</span> Employee e </span><br><span class="line">) e2 <span class="keyword">on</span> d.Id= e2.DepartmentID</span><br><span class="line"><span class="keyword">where</span> e2.rank&lt;=<span class="number">3</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Department <span class="keyword">AND</span> Salary</span><br></pre></td></tr></tbody></table></figure><h3 id="排名问题"><a href="#排名问题" class="headerlink" title="排名问题"></a>排名问题</h3><h4 id="178-分数排名"><a href="#178-分数排名" class="headerlink" title="178.分数排名"></a><a href="https://leetcode-cn.com/problems/rank-scores/" target="_blank" rel="noopener">178.分数排名</a></h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">Score, <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> Score <span class="keyword">desc</span>) <span class="keyword">as</span> <span class="string">`Rank`</span></span><br><span class="line"><span class="keyword">from</span> Scores;</span><br></pre></td></tr></tbody></table></figure><h3 id="自链接问题"><a href="#自链接问题" class="headerlink" title="自链接问题"></a>自链接问题</h3><h4 id="603-连续空余座位"><a href="#603-连续空余座位" class="headerlink" title="603. 连续空余座位"></a><a href="https://leetcode-cn.com/problems/consecutive-available-seats/" target="_blank" rel="noopener">603. 连续空余座位</a></h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 几个朋友来到电影院的售票处，准备预约连续空余座位。</span></span><br><span class="line"><span class="comment">-- 你能利用表&nbsp;cinema&nbsp;，帮他们写一个查询语句，获取所有空余座位，并将它们按照 seat_id 排序后返回吗？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> a.seat_id</span><br><span class="line"><span class="keyword">from</span> cinema a <span class="keyword">join</span> cinema b</span><br><span class="line">  <span class="keyword">on</span> <span class="keyword">abs</span>(a.seat_id - b.seat_id) = <span class="number">1</span></span><br><span class="line">  <span class="keyword">and</span> a.free = <span class="literal">true</span> <span class="keyword">and</span> b.free = <span class="literal">true</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> a.seat_id</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;LeetCode死磕系列十： SQL&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://winniekun.github.io/categories/LeetCode/"/>
    
    
    <category term="死磕系列" scheme="https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"/>
    
    <category term="SQL" scheme="https://winniekun.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>死磕多线程</title>
    <link href="https://winniekun.github.io/stick-to-multi-thread/"/>
    <id>https://winniekun.github.io/stick-to-multi-thread/</id>
    <published>2021-04-14T11:56:11.000Z</published>
    <updated>2021-05-16T16:38:48.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LeetCode死磕系列十一： 多线程</p><a id="more"></a><p>看那么多的面经，发现已经开始询问多线程的编程了。个人感觉多线程编程主要是理解，思想。是有固定的套路的，譬如：交替输出，有序的输出哇。深挖下去就是考察对线程通讯的使用，以及一些高阶用法。和哲学家就餐问题、生产者消费者问题、读写者问题差不多。</p><h2 id="LeetCode-多线程题目整理"><a href="#LeetCode-多线程题目整理" class="headerlink" title="LeetCode 多线程题目整理"></a>LeetCode 多线程题目整理</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;LeetCode死磕系列十一： 多线程&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://winniekun.github.io/categories/LeetCode/"/>
    
    
    <category term="死磕系列" scheme="https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"/>
    
    <category term="多线程" scheme="https://winniekun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一行一行源码分析清楚AbstractQueuedSynchronizer</title>
    <link href="https://winniekun.github.io/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9AAbstractQueuedSynchronizer/"/>
    <id>https://winniekun.github.io/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9AAbstractQueuedSynchronizer/</id>
    <published>2021-03-30T12:14:20.000Z</published>
    <updated>2021-04-05T12:19:21.814Z</updated>
    
    <content type="html"><![CDATA[<p>在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础。</p><p>Google 一下 AbstractQueuedSynchronizer，我们可以找到很多关于 AQS 的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。</p><p>本文将从 ReentrantLock 的公平锁源码出发，分析下 AbstractQueuedSynchronizer 这个类是怎么工作的，希望能给大家提供一些简单的帮助。</p><a id="more"></a><p>申明以下几点：</p><ol><li>本文有点长，但还是挺简单，主要面向读者对象为并发编程的初学者，或者想要阅读 Java 并发包源码的开发者。对于新手来说，可能需要花好几个小时才能完全看懂，但是这时间肯定是值得的。</li><li>源码环境 JDK1.7（1.8没啥变化），看到不懂或有疑惑的部分，最好能自己打开源码看看。Doug Lea 大神的代码写得真心不错。</li><li>本文不分析共享模式，这样可以给读者减少很多负担，<a href="/post/AbstractQueuedSynchronizer-3">第三篇文章</a>对共享模式进行了分析。而且也不分析 condition 部分，所以应该说很容易就可以看懂了。</li><li>本文大量使用我们平时用得最多的 ReentrantLock 的概念，本质上来说是不正确的，读者应该清楚，AQS 不仅仅用来实现可重入锁，只是希望读者可以用锁来联想 AQS 的使用场景，降低阅读压力。</li><li>ReentrantLock 的公平锁和非公平锁只有一点点区别，<a href="/post/AbstractQueuedSynchronizer-2">第二篇文章</a>做了介绍。</li><li>评论区有读者反馈本文直接用代码说不友好，应该多配点流程图，这篇文章确实有这个问题。但是作为过来人，我想告诉大家，对于 AQS 来说，形式真的不重要，重要的是把细节说清楚。</li></ol><h2 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h2><p>先来看看 AQS 有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了，毕竟可以猜嘛！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span></span><br><span class="line"><span class="comment">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span></span><br><span class="line"><span class="comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">// if (currentThread == getExclusiveOwnerThread()) {state++}</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; <span class="comment">//继承自AbstractOwnableSynchronizer</span></span><br></pre></td></tr></tbody></table></figure><p>怎么样，看样子应该是很简单的吧，毕竟也就四个属性啊。</p><p>AbstractQueuedSynchronizer 的等待队列示意如下所示，注意了，之后分析过程中所说的 queue，也就是阻塞队列<strong>不包含 head，不包含 head，不包含 head</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-0.png" alt="aqs-0" title="">                </div>                <div class="image-caption">aqs-0</div>            </figure><p>等待队列中每个线程被包装成一个 Node 实例，数据结构是链表，一起看看源码吧：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="comment">// 标识节点当前在共享模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 标识节点当前在独占模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ======== 下面的几个int常量是给waitStatus用的 ===========</span></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">    <span class="comment">// 代码此线程取消了争抢这个锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">    <span class="comment">// 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="comment">// 本文不分析condition，所以略过吧，下一篇文章会介绍这个</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">     * unconditionally propagate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 同样的不分析，略过吧</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">// =====================================================</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 取值为上面的1、-1、-2、-3，或者0(以后会讲到)</span></span><br><span class="line">    <span class="comment">// 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span></span><br><span class="line">    <span class="comment">//    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 后继节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 这个就是线程本尊</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。</p><p>上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说 ReentrantLock 的公平锁。再次强调，我说的阻塞队列不包含 head 节点。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-0.png" alt="aqs-0" title="">                </div>                <div class="image-caption">aqs-0</div>            </figure><p>首先，我们先看下 ReentrantLock 的使用方式。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我用个web开发中的service概念吧</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>{</span><br><span class="line">    <span class="comment">// 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrder</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 比如我们同一时间，只允许一个线程创建订单</span></span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="comment">// 通常，lock 之后紧跟着 try 语句</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 这块代码同一时间只能有一个线程进来(获取到锁的线程)，</span></span><br><span class="line">            <span class="comment">// 其他的线程在lock()方法上阻塞，等待获取到锁，再进来</span></span><br><span class="line">            <span class="comment">// 执行代码...</span></span><br><span class="line">            <span class="comment">// 执行代码...</span></span><br><span class="line">            <span class="comment">// 执行代码...</span></span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ReentrantLock 在内部用了内部类 Sync 来管理锁，所以真正的获取锁和释放锁是由 Sync 的实现类来控制的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Sync 有两个实现，分别为 NonfairSync（非公平锁）和 FairSync（公平锁），我们看 FairSync 部分。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>{</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="线程抢锁"><a href="#线程抢锁" class="headerlink" title="线程抢锁"></a>线程抢锁</h2><p>很多人肯定开始嫌弃上面废话太多了，下面跟着代码走，我就不废话了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line">  <span class="comment">// 争锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">  <span class="comment">// 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力</span></span><br><span class="line">    <span class="comment">// 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。</span></span><br><span class="line">    <span class="comment">// 否则，acquireQueued方法会将线程压到队列中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{ <span class="comment">// 此时 arg == 1</span></span><br><span class="line">        <span class="comment">// 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试</span></span><br><span class="line">        <span class="comment">// 因为有可能直接就成功了呢，也就不需要进队列排了，</span></span><br><span class="line">        <span class="comment">// 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) {</span><br><span class="line">              selfInterrupt();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span></span><br><span class="line">    <span class="comment">// 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// state == 0 此时此刻没有线程持有锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class="line">            <span class="comment">// 看看有没有别人在队列中等了半天了</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                <span class="comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span></span><br><span class="line">                <span class="comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span></span><br><span class="line">                <span class="comment">// 因为刚刚还没人的，我判断过了</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line">              </span><br><span class="line">                <span class="comment">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">      <span class="comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span></span><br><span class="line">        <span class="comment">// 这里不存在并发问题</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span></span><br><span class="line">        <span class="comment">// 回到上面一个外层调用方法继续看:</span></span><br><span class="line">        <span class="comment">// if (!tryAcquire(arg) </span></span><br><span class="line">        <span class="comment">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span></span><br><span class="line">        <span class="comment">//     selfInterrupt();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 假设tryAcquire(arg) 返回false，那么代码将执行：</span></span><br><span class="line">  <span class="comment">//acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，</span></span><br><span class="line">    <span class="comment">// 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 此方法的作用是把线程包装成node，同时进入到队列中</span></span><br><span class="line">    <span class="comment">// 参数mode此时是Node.EXCLUSIVE，代表独占模式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>{</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="comment">// 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) { </span><br><span class="line">            <span class="comment">// 将当前的队尾节点，设置为自己的前驱 </span></span><br><span class="line">            node.prev = pred; </span><br><span class="line">            <span class="comment">// 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) { </span><br><span class="line">                <span class="comment">// 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，</span></span><br><span class="line">                <span class="comment">// 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="comment">// 线程入队了，可以返回了</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 仔细看看上面的代码，如果会到这里，</span></span><br><span class="line">        <span class="comment">// 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span></span><br><span class="line">        <span class="comment">// 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> node's predecessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 采用自旋的方式入队</span></span><br><span class="line">    <span class="comment">// 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，</span></span><br><span class="line">    <span class="comment">// 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="comment">// 之前说过，队列为空也会进来这里</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) { <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="comment">// 初始化head节点</span></span><br><span class="line">                <span class="comment">// 细心的读者会知道原来 head 和 tail 初始化的时候都是 null 的</span></span><br><span class="line">                <span class="comment">// 还是一步CAS，你懂的，现在可能是很多线程同时进来呢</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    <span class="comment">// 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了</span></span><br><span class="line">                  </span><br><span class="line">                    <span class="comment">// 这个时候有了head，但是tail还是null，设置一下，</span></span><br><span class="line">                    <span class="comment">// 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了</span></span><br><span class="line">                    <span class="comment">// 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return</span></span><br><span class="line">                    <span class="comment">// 所以，设置完了以后，继续for循环，下次就到下面的else分支了</span></span><br><span class="line">                    tail = head;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 下面几行，和上一个方法 addWaiter 是一样的，</span></span><br><span class="line">                <span class="comment">// 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) {</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 现在，又回到这段代码了</span></span><br><span class="line">    <span class="comment">// if (!tryAcquire(arg) </span></span><br><span class="line">    <span class="comment">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span></span><br><span class="line">    <span class="comment">//     selfInterrupt();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列</span></span><br><span class="line">    <span class="comment">// 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，</span></span><br><span class="line">    <span class="comment">// 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false</span></span><br><span class="line">    <span class="comment">// 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head</span></span><br><span class="line">                <span class="comment">// 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列</span></span><br><span class="line">                <span class="comment">// 所以当前节点可以去试抢一下锁</span></span><br><span class="line">                <span class="comment">// 这里我们说一下，为什么可以去试试：</span></span><br><span class="line">                <span class="comment">// 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span></span><br><span class="line">                <span class="comment">// enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span></span><br><span class="line">                <span class="comment">// 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span></span><br><span class="line">                <span class="comment">// tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，</span></span><br><span class="line">                <span class="comment">// 要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 什么时候 failed 会为 true???</span></span><br><span class="line">            <span class="comment">// tryAcquire() 方法抛异常的情况</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment">     * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment">     * control in all acquire loops.  Requires that pred == node.prev</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pred node's predecessor holding status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if thread should block</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是："当前线程没有抢到锁，是否需要挂起当前线程？"</span></span><br><span class="line">    <span class="comment">// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="comment">// 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span></span><br><span class="line">        <span class="comment">// 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span></span><br><span class="line">        <span class="comment">// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span></span><br><span class="line">        <span class="comment">// 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span></span><br><span class="line">        <span class="comment">// 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> {</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            } <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 仔细想想，如果进入到这个分支意味着什么</span></span><br><span class="line">            <span class="comment">// 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span></span><br><span class="line">            <span class="comment">// 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span></span><br><span class="line">            <span class="comment">// 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span></span><br><span class="line">            <span class="comment">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 这个方法返回 false，那么会再走一次 for 循序，</span></span><br><span class="line">        <span class="comment">//     然后再次进来此方法，此时会从第一个分支返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)</span></span><br><span class="line">    <span class="comment">// 这个方法结束根据返回值我们简单分析下：</span></span><br><span class="line">    <span class="comment">// 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒</span></span><br><span class="line">    <span class="comment">//我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span></span><br><span class="line">    <span class="comment">// 如果返回false, 说明当前不需要被挂起，为什么呢？往后看</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 跳回到前面是这个方法</span></span><br><span class="line">    <span class="comment">// if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span></span><br><span class="line">    <span class="comment">//                parkAndCheckInterrupt())</span></span><br><span class="line">    <span class="comment">//                interrupted = true;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，</span></span><br><span class="line">    <span class="comment">// 那么需要执行parkAndCheckInterrupt():</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的</span></span><br><span class="line">    <span class="comment">// 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>{</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：</span></span><br><span class="line">    <span class="comment">// =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>说到这里，也就明白了，多看几遍 <code>final boolean acquireQueued(final Node node, int arg)</code> 这个方法吧。自己推演下各个分支怎么走，哪种情况下会发生什么，走到哪里。</p><h2 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h2><p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被 <code>LockSupport.park(this);</code> 挂起停止，等待被唤醒。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="comment">// 往后看吧</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) {</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回到ReentrantLock看tryRelease方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 是否完全释放锁</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up node's successor, if one exists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 唤醒后继节点</span></span><br><span class="line"><span class="comment">// 从上面调用处知道，参数node是head头结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果head节点当前waitStatus&lt;0, 将其修改为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）</span></span><br><span class="line">    <span class="comment">// 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) {</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 唤醒线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>{</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 刚刚线程被挂起在这里了</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</span></span><br></pre></td></tr></tbody></table></figure><p>好了，后面就不分析源码了，剩下的还有问题自己去仔细看看代码吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下吧。</p><p>在并发环境下，加锁和解锁需要以下三个部件的协调：</p><ol><li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li><li>线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。</li><li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现，感兴趣的读者可以参考这篇文章<a href="http://coderbee.net/index.php/concurrent/20131115/577" target="_blank" rel="noopener">关于CLH的介绍</a>，写得简单明了。</li></ol><h2 id="示例图解析"><a href="#示例图解析" class="headerlink" title="示例图解析"></a>示例图解析</h2><p>下面属于回顾环节，用简单的示例来说一遍，如果上面的有些东西没看懂，这里还有一次帮助你理解的机会。</p><p>首先，第一个线程调用 reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回 true 了，结束。只是设置了 state=1，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，那世界就太太太平了，完全没有交集嘛，那我还要 AQS 干嘛。</p><p>如果线程 1 没有调用 unlock() 之前，线程 2 调用了 lock(), 想想会发生什么？</p><p>线程 2 会初始化 head【new Node()】，同时线程 2 也会插入到阻塞队列并挂起 (注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) { <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) {</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>首先，是线程 2 初始化 head 节点，此时 head==tail, waitStatus==0</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-1.png" alt="aqs-1" title="">                </div>                <div class="image-caption">aqs-1</div>            </figure><p>然后线程 2 入队：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-2.png" alt="aqs-2" title="">                </div>                <div class="image-caption">aqs-2</div>            </figure><p>同时我们也要看此时节点的 waitStatus，我们知道 head 节点是线程 2 初始化的，此时的 waitStatus 没有设置， java 默认会设置为 0，但是到 shouldParkAfterFailedAcquire 这个方法的时候，线程 2 会把前驱节点，也就是 head 的waitStatus设置为 -1。</p><p>那线程 2 节点此时的 waitStatus 是多少呢，由于没有设置，所以是 0；</p><p>如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 shouldParkAfterFailedAcquire 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-3.png" alt="aqs-3" title="">                </div>                <div class="image-caption">aqs-3</div>            </figure><p>这里可以简单说下 waitStatus 中 SIGNAL(-1) 状态的意思，Doug Lea 注释的是：代表后继节点需要被唤醒。也就是说这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着 “waitStatus代表后继节点的状态” 这种思路去看一遍源码。</p><p>（全文完）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础。&lt;/p&gt;
&lt;p&gt;Google 一下 AbstractQueuedSynchronizer，我们可以找到很多关于 AQS 的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。&lt;/p&gt;
&lt;p&gt;本文将从 ReentrantLock 的公平锁源码出发，分析下 AbstractQueuedSynchronizer 这个类是怎么工作的，希望能给大家提供一些简单的帮助。&lt;/p&gt;</summary>
    
    
    
    <category term="concurrency" scheme="https://winniekun.github.io/categories/concurrency/"/>
    
    
  </entry>
  
  <entry>
    <title>2020年总结</title>
    <link href="https://winniekun.github.io/2020%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>https://winniekun.github.io/2020%E5%B9%B4%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-02T16:11:11.000Z</published>
    <updated>2021-01-02T16:40:50.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="啊"><a href="#啊" class="headerlink" title="啊"></a>啊</h2><a id="more"></a><p>2020年到底还是结束了，感觉现在的自己也不喜欢做各种阶段性总结了，总感觉把自己的经历写出来是一种特别矫情的事情。相反，更想把这些经历仅供自己慢慢回味和感触。但是，时间久了，有些东西记得就不够客观了（虽然现在记忆的也不够观。。。）</p><p>所以，以后的每一年都还是做一次年终小结吧。</p><h2 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h2><p>因为疫情，上半年一直在家里呆着，每天的生活差不多如下</p><table><thead><tr><th>时间</th><th>干啥</th></tr></thead><tbody><tr><td>上午</td><td>网课（挂机，干自己的事情）</td></tr><tr><td>下午</td><td>网课（挂机，干自己的事情）</td></tr><tr><td>晚上</td><td>和韩老师还有沈总打游戏</td></tr></tbody></table><p>在上网课的3个月里，自己虽然课没好好上过，不过还是做了一些事情的：</p><ol><li>剑指offer刷了3遍</li><li>LeetCode300大关完成</li><li>深入理解JVM虚拟机终于是看懂了</li><li>JDK源码（collection、juc）嗑了一遍<ol><li>HashMap的设计是真的精妙</li><li>红黑树真的不是正常人写的来的</li></ol></li><li>操作系统过了一遍</li></ol><p>为啥要做这些事情嘞，主要还是想找实习，感觉在学校里面呆腻了，想出来看看（什么**想法）…</p><p>终于，在我的艰苦复习和准备之下，我心仪的字节还是把我拒绝了（今年只面了字节一家大厂），被打击到了之后，也就没再继续投递其他大厂。后面通过牛客上的内推，来到了蔚来汽车实习。</p><h2 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a>下半年</h2><p>从9月中旬起，开始我的实习生活，从刚开始的不适应，到后面的一脸懵逼，再到现在的勉强适应。让我认识到了自己技术上的不足，以及交流上的问题。所以基本每天回来都会主动去看每个节点的所负责的业务逻辑，涉及哪些技术栈，这些技术栈是怎么使用的，和我之前自己写着玩儿的有什么区别。自己也学会了在做任务的时候，先去看需求背景，再去看实现方案，然后脑子构建实现方式，最后再看是撸代码。遇到了自己解决不了的，有疑惑的地方，也渐渐的学会主动去请教同事了。最后，在距离实习结束还有两个月不到的时间里，希望能够拓宽自己的技术栈，精进自己的技术深度。主动去和同事交流，学习经验。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;啊&quot;&gt;&lt;a href=&quot;#啊&quot; class=&quot;headerlink&quot; title=&quot;啊&quot;&gt;&lt;/a&gt;啊&lt;/h2&gt;</summary>
    
    
    
    <category term="碎碎念" scheme="https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="杂谈" scheme="https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>2021年书单【年汇总】</title>
    <link href="https://winniekun.github.io/2021%E5%B9%B4%E4%B9%A6%E5%8D%95%E3%80%90%E5%B9%B4%E6%B1%87%E6%80%BB%E3%80%91/"/>
    <id>https://winniekun.github.io/2021%E5%B9%B4%E4%B9%A6%E5%8D%95%E3%80%90%E5%B9%B4%E6%B1%87%E6%80%BB%E3%80%91/</id>
    <published>2021-01-01T07:01:10.000Z</published>
    <updated>2021-02-24T12:06:26.477Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 <a href="https://blog.jamespan.me/" target="_blank" rel="noopener">摘自鶸道场</a></p></blockquote><p>趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。</p><a id="more"></a><h2 id="书籍相关"><a href="#书籍相关" class="headerlink" title="书籍相关"></a>书籍相关</h2><ul><li>程序员代码面试指南- IT名企算法与数据结构题目最优解<ul><li>计划的是去年年底开始刷，然后计划赶不上变化</li><li>公司安排的1230的任务挺复杂的，还挺多，就没有开始搞</li><li>不过终于在31号，下定决心先把书买了，然后1号正式开刷</li></ul></li></ul><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><h2 id="电影、电视剧、综艺、纪录片"><a href="#电影、电视剧、综艺、纪录片" class="headerlink" title="电影、电视剧、综艺、纪录片"></a>电影、电视剧、综艺、纪录片</h2><ul><li><p>一点就通</p><ul><li>合伙人2 ？？？</li></ul></li><li><p>温暖的抱抱</p></li><li><p>拆弹专家2</p></li><li><p>送你一朵小红花</p></li><li><p>赘婿</p><ul><li>上头看的</li></ul></li><li><p>哪吒重生</p><ul><li>够朋克</li></ul></li><li><p>你好李焕英</p><ul><li>好看的</li></ul></li><li><p>因为是男高所以很幸福</p><ul><li>憨批一家人哇</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 &lt;a href=&quot;https://blog.jamespan.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摘自鶸道场&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。&lt;/p&gt;</summary>
    
    
    
    <category term="碎碎念" scheme="https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="书单" scheme="https://winniekun.github.io/tags/%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>if-else代码优化的几种方案</title>
    <link href="https://winniekun.github.io/if-else-code-optimization/"/>
    <id>https://winniekun.github.io/if-else-code-optimization/</id>
    <published>2020-11-02T11:46:42.000Z</published>
    <updated>2020-11-02T12:46:17.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代码中涉及到较为复杂的逻辑是，一般情况下会出现大量的<code>if-else</code>，虽然实现了整个功能，但是阅读起来比较耗时，并且维护的时候也十分的困难，同时只要有一个地方没有考虑清楚，修改起来就难免出现<code>bug</code>。最近在做公司某个节点的性能优化，就遇到了这个问题，然后在<code>review</code>的时候，同事和我讲了一些优化方案，以及默认的规范之后。自己重新修改之后，感觉很舒服，后续自己重新整理一下，所以就写了这篇博客。</p><a id="more"></a><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><h3 id="优化一：提前return，去除不必要的else"><a href="#优化一：提前return，去除不必要的else" class="headerlink" title="优化一：提前return，去除不必要的else"></a>优化一：提前return，去除不必要的else</h3><p>如果<code>if-else</code>代码块包含<code>return</code>语句，可以考虑通过提前<code>return</code>，把多余<code>else</code>干掉，使代码更加优雅。</p><h4 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition){</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="comment">// do other thing</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!condition) {</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">} </span><br><span class="line"><span class="comment">// do something</span></span><br></pre></td></tr></tbody></table></figure><h3 id="优化二：使用三元运算"><a href="#优化二：使用三元运算" class="headerlink" title="优化二：使用三元运算"></a>优化二：使用三元运算</h3><h4 id="优化前-1"><a href="#优化前-1" class="headerlink" title="优化前"></a>优化前</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">if</span>(condition){</span><br><span class="line">  price = <span class="number">10</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  price = <span class="number">20</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="优化后-1"><a href="#优化后-1" class="headerlink" title="优化后"></a>优化后</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> price = condition ? <span class="number">10</span> : <span class="number">20</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="优化三：使用枚举"><a href="#优化三：使用枚举" class="headerlink" title="优化三：使用枚举"></a>优化三：使用枚举</h3><h4 id="优化前-2"><a href="#优化前-2" class="headerlink" title="优化前"></a>优化前</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> orderStatus = getXXX(xxx);</span><br><span class="line">String OrderStatusDes;</span><br><span class="line"><span class="keyword">if</span>(orderStatus == <span class="number">0</span>) {</span><br><span class="line">    OrderStatusDes = <span class="string">"订单未支付"</span>;</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(OrderStatus == <span class="number">1</span>) {</span><br><span class="line">    OrderStatusDes = <span class="string">"订单已支付"</span>;</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(OrderStatus == <span class="number">2</span>) {</span><br><span class="line">   OrderStatusDes = <span class="string">"已发货"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="优化后-2"><a href="#优化后-2" class="headerlink" title="优化后"></a>优化后</h4><p><strong>先定义一个枚举类型</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OrderStatusEnum {</span><br><span class="line">    UN_PAID(<span class="number">0</span>,<span class="string">"订单未支付"</span>),PAIDED(<span class="number">1</span>,<span class="string">"订单已支付"</span>),SENDED(<span class="number">2</span>,<span class="string">"已发货"</span>),;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    OrderStatusEnum(<span class="keyword">int</span> index, String desc){</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">        <span class="keyword">this</span>.desc =desc;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function">OrderStatusEnum <span class="title">ofCode</span><span class="params">(<span class="keyword">int</span> orderStatus)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (OrderStatusEnum temp : OrderStatusEnum.values()) {</span><br><span class="line">            <span class="keyword">if</span> (temp.getIndex() == orderStatus) {</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>有了枚举之后，以上if-else逻辑分支，可以优化为一行代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String OrderStatusDes = OrderStatusEnum.ofCode(orderStatus).getDesc();</span><br></pre></td></tr></tbody></table></figure><h3 id="优化四：合并条件表达式"><a href="#优化四：合并条件表达式" class="headerlink" title="优化四：合并条件表达式"></a>优化四：合并条件表达式</h3><p>如果有一系列条件返回一样的结果，可以将它们合并为一个条件表达式，让逻辑更加清晰。</p><h4 id="优化前-3"><a href="#优化前-3" class="headerlink" title="优化前"></a>优化前</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getVipDiscount</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(age&lt;<span class="number">18</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"深圳"</span>.equals(city)){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(isStudent){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//do somethig</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="优化后-3"><a href="#优化后-3" class="headerlink" title="优化后"></a>优化后</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getVipDiscount</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(age&lt;<span class="number">18</span>|| <span class="string">"深圳"</span>.equals(city)||isStudent){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//doSomthing</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果返回统一结果的条件过多，可以再编写一个方法，封装起来<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h3 id="优化五：使用Optional"><a href="#优化五：使用Optional" class="headerlink" title="优化五：使用Optional"></a>优化五：使用Optional</h3><p>有时候<code>if-else</code>比较多，是因为非空判断导致的，这时候你可以使用<code>Java9</code>的<code>Optional</code>进行优化。</p><h4 id="优化前-4"><a href="#优化前-4" class="headerlink" title="优化前"></a>优化前</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"wkk"</span>;</span><br><span class="line"><span class="keyword">if</span> (str != <span class="keyword">null</span>) {</span><br><span class="line">    System.out.println(str);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    System.out.println(<span class="string">"Null"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="优化后-4"><a href="#优化后-4" class="headerlink" title="优化后"></a>优化后</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; strOptional = Optional.ofNullable(<span class="string">"wkk"</span>);</span><br><span class="line">strOptional.ifPresentOrElse(System.out::println, () -&gt; System.out.println(<span class="string">"Null"</span>));</span><br></pre></td></tr></tbody></table></figure><p><code>Java8</code>的<code>Optional</code>虽然没有这个方法，但是我们可以用Optional来优化非空的赋值操作</p><p><strong>示例：</strong></p><p>电池平台服役状态赋值：如果为null，赋值为0，否则为原来的值</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">batteryBasicInfoCollectDto.setFlowControlState(Optional.ofNullable(batteryInfo.getFlowControlState()).orElse(<span class="number">0</span>));</span><br></pre></td></tr></tbody></table></figure><h3 id="优化六：表驱动法"><a href="#优化六：表驱动法" class="headerlink" title="优化六：表驱动法"></a>优化六：表驱动法</h3><h4 id="优化前-5"><a href="#优化前-5" class="headerlink" title="优化前"></a>优化前</h4><p><strong>表驱动法</strong>，又称之为表驱动、表驱动方法。表驱动方法是一种使你可以在表中查找信息，而不必用很多的逻辑语句（if或Case）来把它们找出来的方法。以下的demo，把map抽象成表，在map中查找信息，而省去不必要的逻辑语句。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (param.equals(value1)) {</span><br><span class="line">    doAction1(someParams);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (param.equals(value2)) {</span><br><span class="line">    doAction2(someParams);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (param.equals(value3)) {</span><br><span class="line">    doAction3(someParams);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="优化后-5"><a href="#优化后-5" class="headerlink" title="优化后"></a>优化后</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里泛型是为方便演示，实际可替换为你需要的类型</span></span><br><span class="line">Map&lt;?, Function&lt;?&gt; action&gt; actionMappings = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">actionMappings.put(value1, (someParams) -&gt; { doAction1(someParams)});</span><br><span class="line">actionMappings.put(value2, (someParams) -&gt; { doAction2(someParams)});</span><br><span class="line">actionMappings.put(value3, (someParams) -&gt; { doAction3(someParams)});</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 省略多余逻辑语句</span></span><br><span class="line">actionMappings.get(param).apply(someParams);</span><br></pre></td></tr></tbody></table></figure><h3 id="优化七：优化逻辑结构，让正常流程走主干"><a href="#优化七：优化逻辑结构，让正常流程走主干" class="headerlink" title="优化七：优化逻辑结构，让正常流程走主干"></a>优化七：优化逻辑结构，让正常流程走主干</h3><h4 id="优化前-6"><a href="#优化前-6" class="headerlink" title="优化前"></a>优化前</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAdjustedCapital</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(_capital &lt;= <span class="number">0.0</span> ){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(_intRate &gt; <span class="number">0</span> &amp;&amp; _duration &gt;<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> (_income / _duration) *ADJ_FACTOR;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="优化后-6"><a href="#优化后-6" class="headerlink" title="优化后"></a>优化后</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAdjustedCapital</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(_capital &lt;= <span class="number">0.0</span> ){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(_intRate &lt;= <span class="number">0</span> || _duration &lt;= <span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> (_income / _duration) *ADJ_FACTOR;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>将条件反转使异常情况先退出，让正常流程维持在主干流程，可以让代码结构更加清晰。</strong></p><h3 id="优化八：策略模式-工厂方法消除if-else"><a href="#优化八：策略模式-工厂方法消除if-else" class="headerlink" title="优化八：策略模式+工厂方法消除if-else"></a>优化八：策略模式+工厂方法消除if-else</h3><p><strong>策略类定义</strong>：一个策略接口和一组实现这个接口的策略类。</p><p><strong>特点</strong>：客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。</p><p><strong>假设需求</strong>：根据不同勋章类型，处理相对应的勋章服务</p><h4 id="优化前-7"><a href="#优化前-7" class="headerlink" title="优化前"></a>优化前</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String medalType = <span class="string">"guest"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"guest"</span>.equals(medalType)) {</span><br><span class="line">    System.out.println(<span class="string">"嘉宾勋章"</span>);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"vip"</span>.equals(medalType)) {</span><br><span class="line">    System.out.println(<span class="string">"会员勋章"</span>);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"guard"</span>.equals(medalType)) {</span><br><span class="line">    System.out.println(<span class="string">"展示守护勋章"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="优化后-7"><a href="#优化后-7" class="headerlink" title="优化后"></a>优化后</h4><p>首先，我们把每个条件逻辑代码块，抽象成一个公共的接口，可以得出以下代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//勋章接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMedalService</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showMedal</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们根据每个逻辑条件，定义相对应的策略实现类，可得以下代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//守护勋章策略实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuardMedalServiceImpl</span> <span class="keyword">implements</span> <span class="title">IMedalService</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMedal</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"展示守护勋章"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//嘉宾勋章策略实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuestMedalServiceImpl</span> <span class="keyword">implements</span> <span class="title">IMedalService</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMedal</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"嘉宾勋章"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//VIP勋章策略实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VipMedalServiceImpl</span> <span class="keyword">implements</span> <span class="title">IMedalService</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMedal</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"会员勋章"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来，我们再定义策略工厂类，用来管理这些勋章实现策略类，如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//勋章服务工产类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedalServicesFactory</span> </span>{</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, IMedalService&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        map.put(<span class="string">"guard"</span>, <span class="keyword">new</span> GuardMedalServiceImpl());</span><br><span class="line">        map.put(<span class="string">"vip"</span>, <span class="keyword">new</span> VipMedalServiceImpl());</span><br><span class="line">        map.put(<span class="string">"guest"</span>, <span class="keyword">new</span> GuestMedalServiceImpl());</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IMedalService <span class="title">getMedalService</span><span class="params">(String medalType)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> map.get(medalType);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用了策略+工厂模式之后，代码变得简洁多了，如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String medalType = <span class="string">"guest"</span>;</span><br><span class="line">        IMedalService medalService = MedalServicesFactory.getMedalService(medalType);</span><br><span class="line">        medalService.showMedal();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;代码中涉及到较为复杂的逻辑是，一般情况下会出现大量的&lt;code&gt;if-else&lt;/code&gt;，虽然实现了整个功能，但是阅读起来比较耗时，并且维护的时候也十分的困难，同时只要有一个地方没有考虑清楚，修改起来就难免出现&lt;code&gt;bug&lt;/code&gt;。最近在做公司某个节点的性能优化，就遇到了这个问题，然后在&lt;code&gt;review&lt;/code&gt;的时候，同事和我讲了一些优化方案，以及默认的规范之后。自己重新修改之后，感觉很舒服，后续自己重新整理一下，所以就写了这篇博客。&lt;/p&gt;</summary>
    
    
    
    <category term="代码质量" scheme="https://winniekun.github.io/categories/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"/>
    
    
    <category term="if-else优化" scheme="https://winniekun.github.io/tags/if-else%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>lombok介绍</title>
    <link href="https://winniekun.github.io/lombok-introduce/"/>
    <id>https://winniekun.github.io/lombok-introduce/</id>
    <published>2020-10-02T12:08:21.000Z</published>
    <updated>2020-10-04T14:34:01.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lombok使用"><a href="#Lombok使用" class="headerlink" title="Lombok使用"></a>Lombok使用</h2><blockquote><p>Lombok是一款好用顺手的工具，值得去好好去熟练使用和深究。<strong>Lombok是一种Java™实用工具，可用来帮助开发人员消除Java的冗长代码，尤其是对于简单的Java对象（POJO）。它通过注释实现这一目的</strong>。通过在开发环境中实现Lombok，开发人员可以节省构建诸如hashCode()和equals()这样的方法以及以往用来分类各种accessor和mutator的大量时间。</p></blockquote><a id="more"></a><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li><p>导入Maven依赖</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>${lomok.version}<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>在IDE中安装对应的插件（<strong>lombok plugin</strong>）</p></li></ol><h2 id="常用注解详解"><a href="#常用注解详解" class="headerlink" title="常用注解详解"></a>常用注解详解</h2><h3 id="简化代码，增加可读性"><a href="#简化代码，增加可读性" class="headerlink" title="简化代码，增加可读性"></a>简化代码，增加可读性</h3><h4 id="Getter-amp-Setter"><a href="#Getter-amp-Setter" class="headerlink" title="@Getter&amp;@Setter"></a>@Getter&amp;@Setter</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过<code>@Getter和@Setter</code>之后，其就类似于如下的代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Persons</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h4><p>其等同于如下的几个注解，使用的频率最高</p><ul><li>@Getter/@Setter</li><li>@ToString</li><li>@EqualsAndHashCode</li><li>@RequiredArgsConstructor</li></ul><h4 id="Buider"><a href="#Buider" class="headerlink" title="@Buider"></a>@Buider</h4><p>自动生成流式set写法，能够快速的设定<code>Object</code>值。但是需要注意的是，虽然该方法很好，但是因为大多数的框架都使用到了<code>set</code>方法进进行注入，<strong>所以在开发的时候，我们一般是将<code>@Builder</code>和<code>@Data</code>一起使用</strong>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方便查看输出对象</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Person person = Person.builder().age(<span class="string">"11"</span>).id(<span class="number">1</span>).name(<span class="string">"wkk"</span>).build();</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Builder的使用等同于如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonBuilder</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">        PersonBuilder() {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Person.<span class="function">PersonBuilder <span class="title">id</span><span class="params">(Integer id)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Person.<span class="function">PersonBuilder <span class="title">name</span><span class="params">(String name)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Person.<span class="function">PersonBuilder <span class="title">age</span><span class="params">(String age)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="keyword">this</span>.id, <span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Person.PersonBuilder(id="</span> + <span class="keyword">this</span>.id + <span class="string">", name="</span> + <span class="keyword">this</span>.name + <span class="string">", age="</span> + <span class="keyword">this</span>.age + <span class="string">")"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="日志使用"><a href="#日志使用" class="headerlink" title="日志使用"></a>日志使用</h3><p>一般情况下，我们做日志处理，都会先生成一个Logger的静态常量，使用<code>@Slf4j</code>之后，我们就可以完全不用new一个该常量了。</p> <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">      logger.info(<span class="string">"logger: {}"</span>, <span class="string">"aaaa"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lombok实现</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"fsda"</span>);</span><br><span class="line">        log.info(<span class="string">"Person: {}"</span>, <span class="string">"fdsa"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="流式对象的关闭"><a href="#流式对象的关闭" class="headerlink" title="流式对象的关闭"></a><del>流式对象的关闭</del></h3>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Lombok使用&quot;&gt;&lt;a href=&quot;#Lombok使用&quot; class=&quot;headerlink&quot; title=&quot;Lombok使用&quot;&gt;&lt;/a&gt;Lombok使用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Lombok是一款好用顺手的工具，值得去好好去熟练使用和深究。&lt;strong&gt;Lombok是一种Java™实用工具，可用来帮助开发人员消除Java的冗长代码，尤其是对于简单的Java对象（POJO）。它通过注释实现这一目的&lt;/strong&gt;。通过在开发环境中实现Lombok，开发人员可以节省构建诸如hashCode()和equals()这样的方法以及以往用来分类各种accessor和mutator的大量时间。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="java" scheme="https://winniekun.github.io/categories/java/"/>
    
    
    <category term="基础" scheme="https://winniekun.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>2020实习前的总结</title>
    <link href="https://winniekun.github.io/before-internship/"/>
    <id>https://winniekun.github.io/before-internship/</id>
    <published>2020-09-06T11:11:50.000Z</published>
    <updated>2020-10-01T15:12:36.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2020年2月底，在自己确定要找实习的时候，开始和女朋友哭诉所害怕自己找不到实习，没有公司要我，我太菜了等等等。经过耗时半年的时间，终于确定下来的了实习地点和实习公司，感觉整个过程还挺好玩儿的，所以就记录下来吧。</p><a id="more"></a><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p>挺尴尬的，本来想着再实习之前把文章写好，但是后面有别的事情就没有来得及写，最后想写的时候，发现<code>hexo</code>出问题了。所以就一直拖到了国庆假期，抽了点时间改改，终于又能重新写blog了。</p><p>目前已经在NIO实习两周了，第一周还好，就是看看公司文档，然后按照需求完善了一个接口，后面老师安排我看几个节点的代码，然后修复<code>sonarQube</code>上检测出的<code>Bug</code>。第二周就开始忙碌了，刚好排期，分配了我还挺多的任务，希望能做的又好又棒。</p><p>放张我所在楼的前台，感觉还挺好看的（假期前一天走的晚，刚好没有多少人，顺手拍的<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/10/01/87TWFU4HfEacrxw.jpg" alt="NIO" title="">                </div>                <div class="image-caption">NIO</div>            </figure><p>国庆假期人是真的多，虹桥车站爆满。不知道为什么，脑子里竟然是釜山行的画面…</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/10/01/aob7WsqUM2pTzxi.jpg" alt="虹桥火车站" title="">                </div>                <div class="image-caption">虹桥火车站</div>            </figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面试真的并不可怕，大不了就是给面试官感觉你不行，在面试官面前尬聊一个小时，其他的真的没什么。面多了就感觉还挺好玩儿的（就是每次面试前还是会紧张好长时间）。面试期间，感觉有一些问题并没有标准的答案，所以可以使用和面试官讨论的形式阐述自己的观点。最后就是记得面试后做好复盘，这样不仅可以帮助自己查缺补漏，还能让自己能够更好的梳理知识点。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2020年2月底，在自己确定要找实习的时候，开始和女朋友哭诉所害怕自己找不到实习，没有公司要我，我太菜了等等等。经过耗时半年的时间，终于确定下来的了实习地点和实习公司，感觉整个过程还挺好玩儿的，所以就记录下来吧。&lt;/p&gt;</summary>
    
    
    
    <category term="碎碎念" scheme="https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="杂谈" scheme="https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>死磕图</title>
    <link href="https://winniekun.github.io/stick-to-graph/"/>
    <id>https://winniekun.github.io/stick-to-graph/</id>
    <published>2020-08-20T00:59:56.000Z</published>
    <updated>2020-08-30T04:50:22.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LeetCode死磕系列九： 图</p><p>说实话图目前遇到的题目类型不多, 再加上今年图论课程上的一些算法, 只能说算是覆盖了图相关的一丢丢的内容<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>最近LeetCode每日一题, 遇到了较多的图遍历(深度遍历, 广度遍历)问题, 感觉是有迹可循的, 所以做一下整理吧.</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li><p><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. 被围绕的区域</a></p></li><li><p><a href="https://leetcode-cn.com/problems/clone-graph/" target="_blank" rel="noopener">133. 克隆图</a></p></li><li><p><a href="https://leetcode-cn.com/problems/flood-fill/" target="_blank" rel="noopener">733. 图像渲染</a></p></li><li><p><a href="https://leetcode-cn.com/problems/minesweeper/" target="_blank" rel="noopener">529. 扫雷游戏</a></p></li></ol><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;LeetCode死磕系列九： 图&lt;/p&gt;
&lt;p&gt;说实话图目前遇到的题目类型不多, 再加上今年图论课程上的一些算法, 只能说算是覆盖了图相关的一丢丢的内容&lt;span class=&quot;github-emoji&quot;&gt;&lt;span&gt;😄&lt;/span&gt;&lt;img src=&quot;https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8&quot; aria-hidden=&quot;true&quot; onerror=&quot;this.parent.classList.add(&#39;github-emoji-fallback&#39;)&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最近LeetCode每日一题, 遇到了较多的图遍历(深度遍历, 广度遍历)问题, 感觉是有迹可循的, 所以做一下整理吧.&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://winniekun.github.io/categories/LeetCode/"/>
    
    
    <category term="死磕系列" scheme="https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"/>
    
    <category term="dfs" scheme="https://winniekun.github.io/tags/dfs/"/>
    
    <category term="bfs" scheme="https://winniekun.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>ArrayDeque-analysis</title>
    <link href="https://winniekun.github.io/ArrayDeque-analysis/"/>
    <id>https://winniekun.github.io/ArrayDeque-analysis/</id>
    <published>2020-07-08T07:27:56.000Z</published>
    <updated>2020-08-30T04:50:22.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><a id="more"></a><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/08/3I9zKjOpsNvPdMw.png" alt="ArrayDeque依赖" title="">                </div>                <div class="image-caption">ArrayDeque依赖</div>            </figure><p>实现了Deque接口, Serializable接口, Cloneable接口, 继承了AbstractCollection类, 同时可以看到的是Deque接口继承自Queue接口, 它是对Queue的一种增强. Deque 接口的实现类可以被当作 FIFO（队列）使用，也可以当作 LIFO（栈）来使用</p><h2 id="Queue和Deque"><a href="#Queue和Deque" class="headerlink" title="Queue和Deque"></a>Queue和Deque</h2><p>Deque是对Queue的增强, 我们可以先看下Queue的具体设计:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 不同的实现使用的添加方式不同</span></span><br><span class="line">    <span class="comment">// list使用add</span></span><br><span class="line">    <span class="comment">// queue使用offer</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 弹出</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取头部数据</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Deque的设计</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function">E <span class="title">pollLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function">E <span class="title">getFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function">E <span class="title">getLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function">E <span class="title">peekFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function">E <span class="title">peekLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// *** 栈 ***//</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// *** Collection中的方法 ***</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Deque中新增了以下几类方法：</p><ol><li>*First，表示从队列头操作元素；</li><li>*Last，表示从队列尾操作元素；</li><li>*push(e)，pop()，以栈的方式操作元素的方法；</li></ol><p>其抽象的样子</p><h2 id="字段-amp-属性"><a href="#字段-amp-属性" class="headerlink" title="字段&amp;属性"></a>字段&amp;属性</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 底层使用数组存储元素</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elements; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">// 队列头位置</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> head;</span><br><span class="line"><span class="comment">// 队列尾位置</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> tail;</span><br><span class="line"><span class="comment">// 最小初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_INITIAL_CAPACITY = <span class="number">8</span>;</span><br></pre></td></tr></tbody></table></figure><p>使用数组存储元素, 默认的最小初始化容量为8, 同时有头尾两个标记位</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数数组容量为16</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">()</span> </span>{</span><br><span class="line">    elements = <span class="keyword">new</span> Object[<span class="number">16</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定初始容量构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>{</span><br><span class="line">    allocateElements(numElements);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将集合c中的元素初始化到数组中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>{</span><br><span class="line">    allocateElements(c.size());</span><br><span class="line">    addAll(c);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数组</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>{</span><br><span class="line">    elements = <span class="keyword">new</span> Object[calculateSize(numElements)];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和HashMap的类似, 求大于且最接近numelemnets的2的幂次且不小于8</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateSize</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (numElements &gt;= initialCapacity) {</span><br><span class="line">        initialCapacity = numElements;</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        initialCapacity++;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// Too many elements, must back off</span></span><br><span class="line">            initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">// Good luck allocating 2 ^ 30 elements</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> initialCapacity;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过构造方法，我们知道默认初始容量是16，最小容量是8。</p><h2 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h2><h3 id="头部入队"><a href="#头部入队" class="headerlink" title="头部入队"></a>头部入队</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 将head指针减1并与数组长度减1取模</span></span><br><span class="line">    <span class="comment">// 这是为了防止数组到头了边界溢出</span></span><br><span class="line">    <span class="comment">// 如果到头了就从尾再向前</span></span><br><span class="line">    <span class="comment">// 相当于循环利用数组</span></span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">    <span class="comment">// 如果头尾挨在一起了，就扩容</span></span><br><span class="line">    <span class="comment">// 扩容规则也很简单，直接两倍</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩容为两倍</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacity</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">assert</span> head == tail;</span><br><span class="line">    <span class="keyword">int</span> p = head;</span><br><span class="line">    <span class="keyword">int</span> n = elements.length;</span><br><span class="line">    <span class="keyword">int</span> r = n - p; <span class="comment">// number of elements to the right of p</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Sorry, deque too big"</span>);</span><br><span class="line">    Object[] a = <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">    <span class="comment">// 将旧数组head之后的元素拷贝到新数组中</span></span><br><span class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);</span><br><span class="line">    <span class="comment">// 将旧数组下标0到head之间的元素拷贝到新数组中</span></span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);</span><br><span class="line">    <span class="comment">// 赋值为新数组</span></span><br><span class="line">    elements = a;</span><br><span class="line">    <span class="comment">// head指向0，tail指向旧数组长度表示的位置</span></span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = n;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/08/lzG7NoCmk6ZJjpB.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="尾部入队"><a href="#尾部入队" class="headerlink" title="尾部入队"></a>尾部入队</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 在尾指针的位置放入元素</span></span><br><span class="line">    <span class="comment">// 可以看到tail指针指向的是队列最后一个元素的下一个位置</span></span><br><span class="line">    elements[tail] = e;</span><br><span class="line">    <span class="comment">// tail指针加1，如果到数组尾了就从头开始</span></span><br><span class="line">    <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>入队有两种方式，从队列头或者从队列尾；</li><li>如果容量不够了，直接扩大为两倍；</li><li>通过取模的方式让头尾指针在数组范围内循环；</li><li>x &amp; (len - 1) = x % len，使用&amp;的方式更快(<strong>len=2的幂次等式成立</strong>)；</li></ol><h2 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h2><h3 id="头部出队"><a href="#头部出队" class="headerlink" title="头部出队"></a>头部出队</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> h = head;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">// 取队列头元素</span></span><br><span class="line">    E result = (E) elements[h];</span><br><span class="line">    <span class="comment">// Element is null if deque empty</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 队头元素为空</span></span><br><span class="line">    elements[h] = <span class="keyword">null</span>;     <span class="comment">// Must null out slot</span></span><br><span class="line">    <span class="comment">// 队头右移</span></span><br><span class="line">    head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="尾部出队"><a href="#尾部出队" class="headerlink" title="尾部出队"></a>尾部出队</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 因为队尾标记的是最后一个为不为空的元素的后一位</span></span><br><span class="line">    <span class="keyword">int</span> t = (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">// 获取队尾元素</span></span><br><span class="line">    E result = (E) elements[t];</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 队尾设置为空</span></span><br><span class="line">    elements[t] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 重新设置tail</span></span><br><span class="line">    tail = t;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以下是一次ArrayDeque的头部入队, 尾部出队的可视化操作</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayDeque&lt;Integer&gt; arrayDeque = <span class="keyword">new</span> ArrayDeque&lt;&gt;(<span class="number">6</span>);</span><br><span class="line">ArrayDequeUtil.getField(arrayDeque);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) {</span><br><span class="line">    arrayDeque.addFirst(i);</span><br><span class="line">    ArrayDequeUtil.getField(arrayDeque);</span><br><span class="line">}</span><br><span class="line">arrayDeque.pollLast();</span><br><span class="line">ArrayDequeUtil.getField(arrayDeque);</span><br></pre></td></tr></tbody></table></figure><p><img src="https://i.loli.net/2020/07/08/4uyjsf9nVXdGZTm.png" alt="模拟可视化操作"></p><h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><p>以下是Deque实现入栈的操作</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    addFirst(e);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">    <span class="keyword">if</span> (head == tail)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后, 其依赖的还是<code>addFirst()</code>, 也就是从头部添加元素</p><h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><p>以下是Deque实现出栈的操作</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>{</span><br><span class="line">    E x = pollFirst();</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后, 其依赖的还是<code>pollFirst()</code>, 也就是从头部删除元素,  也就是后入的元素先出</p><p>说白了<strong>实现栈的方式就是仅仅只操作队列头即可</strong></p><h2 id="总结-amp-面试小问题"><a href="#总结-amp-面试小问题" class="headerlink" title="总结&amp;面试小问题"></a>总结&amp;面试小问题</h2><ol><li>什么是双端队列？<ul><li>双端队列是一种特殊的队列，它的两端都可以进出元素，故而得名双端队列</li></ul></li><li>ArrayDeque是怎么实现双端队列的？<ul><li>底层为数组, 然后通过取模的方式构造一个循环数组, 出队入队是通过头尾指针循环利用数组实现的. </li></ul></li><li>ArrayDeque是线程安全的吗？<ul><li>不是线程安全</li></ul></li><li>ArrayDeque的扩容机制？<ul><li>ArrayDeque在容量不足时(head == tail)会出发扩容, 扩容为原先的两倍, 具体的扩容机制, 可以看上述可视化过程</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;依赖&quot;&gt;&lt;a href=&quot;#依赖&quot; class=&quot;headerlink&quot; title=&quot;依赖&quot;&gt;&lt;/a&gt;依赖&lt;/h2&gt;</summary>
    
    
    
    <category term="源码" scheme="https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="JDK源码" scheme="https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"/>
    
    <category term="Queue" scheme="https://winniekun.github.io/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>trie</title>
    <link href="https://winniekun.github.io/trie/"/>
    <id>https://winniekun.github.io/trie/</id>
    <published>2020-07-07T11:58:58.000Z</published>
    <updated>2020-08-30T04:50:22.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前缀树原理"><a href="#前缀树原理" class="headerlink" title="前缀树原理"></a>前缀树原理</h2><a id="more"></a><p>Trie, 由<code>Edward Fredkin</code>提出, 来自英文单词<code>retrieval</code>, Trie也称为前缀树, 用于保存<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">关联数组</a>，其中的键通常是<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2" target="_blank" rel="noopener">字符串</a>。与<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91" target="_blank" rel="noopener">二叉查找树</a>不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的<a href="https://zh.wikipedia.org/wiki/%E5%89%8D%E7%BC%80" target="_blank" rel="noopener">前缀</a>，也就是这个节点对应的字符串，而根节点对应<a href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2" target="_blank" rel="noopener">空字符串</a>。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。 </p><p>对于字符Trie而言, 如果使用二叉树那样的两个分支明显是不够的. 举个例子, 英语中一共有26个字母, 每个字母还区分大小写, 如果忽略大小写的话, 那么可以使用简单的限定分支(子树)个数为26. 如下图所示为一个字符串Trie</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/07/eMrDF8pubcj5kth.png" alt="Trie" title="">                </div>                <div class="image-caption">Trie</div>            </figure><blockquote><p>一个保存了8个键的trie结构，”A”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn</p></blockquote><p> 这只是针对于不区分大小写的英语字母, 若是区分大小写, 同时还有标点等, 那么分之的数量会更加的庞大且不确定, 这是我们可以使用散列表来解决动态数量的分支.</p><p>Trie的出现, 解决了散列表无法解决的字符串数集问题:</p><ul><li>找到具有同一前缀的全部键值。</li><li>按词典序枚举字符串的数据集。</li></ul><p>同时Trie由散列表的另一方面是: 随着数据量的增大, 散列表的查找效率可能会降低到$O(n)$, 与哈希表相比, Trie 树在存储多个具有相同前缀的键时可以使用较少的空间. 此时Trie只需要$O(m)$的时间复杂度，其中$m$为键长。</p><h2 id="前缀树的实现"><a href="#前缀树的实现" class="headerlink" title="前缀树的实现"></a>前缀树的实现</h2><p>Trie 树是一个有根的树，其结点具有以下字段：。</p><ul><li>最多$R$个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母, 简单起见, 假定$R$为 26, 小写英语字母数量</li><li>布尔字段, 以指定节点是对应键的结尾还是只是键前缀.</li></ul><h3 id="节点构造"><a href="#节点构造" class="headerlink" title="节点构造"></a>节点构造</h3><p>在构造之前, 先展示包含三个单词”sea”,”sells”,”she”的 Trie的样子, 加深理解</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/07/A16vF79kB23HYKl.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> TrieNode[] links;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">26</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>{</span><br><span class="line">        links = <span class="keyword">new</span> TrieNode[R];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> links[ch - <span class="string">'a'</span>] != <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">char</span> ch, TrieNode node)</span> </span>{</span><br><span class="line">        links[ch - <span class="string">'a'</span>] = node;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> links[ch - <span class="string">'a'</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">()</span> </span>{</span><br><span class="line">        isEnd = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnd</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> isEnd;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>{</span><br><span class="line">    <span class="comment">// 从根节点开始, 根节点为空</span></span><br><span class="line">    TrieNode node = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) {</span><br><span class="line">        <span class="keyword">char</span> current = word.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!node.containsKey(current)) {</span><br><span class="line">            node.put(current, <span class="keyword">new</span> TrieNode());</span><br><span class="line">        }</span><br><span class="line">        node = node.get(current);</span><br><span class="line">    }</span><br><span class="line">    node.setEnd();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>每个键在 trie 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始，。检查当前节点中与键字符对应的链接。有两种情况：</p><ol><li>存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。</li><li>不存在链接。若已无键字符，且当前结点标记为 isEnd，则返回 true。否则有两种可能，均返回 false :<ol><li>还有键字符剩余，但无法跟随 Trie 树的键路径，找不到键。</li><li>没有键字符剩余，但当前结点没有标记为 isEnd。也就是说，待查找键只是Trie树中另一个键的前缀。</li></ol></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TrieNode <span class="title">searchPrefix</span><span class="params">(String word)</span> </span>{</span><br><span class="line">    TrieNode node = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) {</span><br><span class="line">        <span class="keyword">char</span> current = word.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (node.containsKey(current)) {</span><br><span class="line">            node = node.get(current);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>{</span><br><span class="line">    TrieNode node = searchPrefix(word);</span><br><span class="line">    <span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.isEnd();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否存在输入前缀的字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>{</span><br><span class="line">    TrieNode node = searchPrefix(prefix);</span><br><span class="line">    <span class="keyword">return</span> node != <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>{</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>{</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) {</span><br><span class="line">            <span class="keyword">char</span> current = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!node.containsKey(current)) {</span><br><span class="line">                node.put(current, <span class="keyword">new</span> TrieNode());</span><br><span class="line">            }</span><br><span class="line">            node = node.get(current);</span><br><span class="line">        }</span><br><span class="line">        node.setEnd();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>{</span><br><span class="line">        TrieNode node = searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.isEnd();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">searchPrefix</span><span class="params">(String word)</span> </span>{</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) {</span><br><span class="line">            <span class="keyword">char</span> current = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (node.containsKey(current)) {</span><br><span class="line">                node = node.get(current);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在输入前缀的字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>{</span><br><span class="line">        TrieNode node = searchPrefix(prefix);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> TrieNode[] links;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>{</span><br><span class="line">            links = <span class="keyword">new</span> TrieNode[R];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> links[ch - <span class="string">'a'</span>] != <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">char</span> ch, TrieNode node)</span> </span>{</span><br><span class="line">            links[ch - <span class="string">'a'</span>] = node;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> links[ch - <span class="string">'a'</span>];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">()</span> </span>{</span><br><span class="line">            isEnd = <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnd</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> isEnd;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="敏感词过滤的前缀树实现"><a href="#敏感词过滤的前缀树实现" class="headerlink" title="敏感词过滤的前缀树实现"></a>敏感词过滤的前缀树实现</h2><p>因为敏感词除了英文字母之外, 还有其他的字符, 所以使用散列表来实现, </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>{</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line"><span class="keyword">private</span> TrieNode rootNode = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将一个敏感词添加到前缀树中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addKeyword</span><span class="params">(String keyword)</span> </span>{</span><br><span class="line">        TrieNode tempNode = rootNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyword.length(); i++) {</span><br><span class="line">            <span class="keyword">char</span> c = keyword.charAt(i);</span><br><span class="line">            TrieNode subNode = tempNode.getSubNode(c);</span><br><span class="line">            <span class="keyword">if</span>(!tempNode.containsKey(c)){</span><br><span class="line">                tempNode.addSubNode(c, <span class="keyword">new</span> TrieNode());</span><br><span class="line">            }</span><br><span class="line">            tempNode = tempNode.getSubNode(c);</span><br><span class="line">        }</span><br><span class="line">        tempNode.setKeywordEnd(<span class="keyword">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>{</span><br><span class="line">        <span class="comment">// 关键词结束标识</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isKeywordEnd = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 子节点(key是下级字符,value是下级节点)</span></span><br><span class="line">        <span class="keyword">private</span> Map&lt;Character, TrieNode&gt; subNodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isKeywordEnd</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> isKeywordEnd;</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeywordEnd</span><span class="params">(<span class="keyword">boolean</span> keywordEnd)</span> </span>{</span><br><span class="line">            isKeywordEnd = keywordEnd;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 添加子节点</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSubNode</span><span class="params">(Character c, TrieNode node)</span> </span>{</span><br><span class="line">            subNodes.put(c, node);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 获取子节点</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TrieNode <span class="title">getSubNode</span><span class="params">(Character c)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> subNodes.get(c);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h3><h3 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SensitiveFilter</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 替换符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPLACEMENT = <span class="string">"***"</span>;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode rootNode = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    <span class="comment">// 加载敏感字符, 只加载一次</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                InputStream is = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">"sensitive-word.txt"</span>);</span><br><span class="line">                BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">        ) {</span><br><span class="line">            String keyword;</span><br><span class="line">            <span class="keyword">while</span> ((keyword = reader.readLine()) != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 添加到前缀树</span></span><br><span class="line">                <span class="keyword">this</span>.addKeyword(keyword);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            logger.error(<span class="string">"加载敏感词文件失败: "</span> + e.getMessage());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 将一个敏感词添加到前缀树中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addKeyword</span><span class="params">(String keyword)</span> </span>{</span><br><span class="line">        TrieNode tempNode = rootNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyword.length(); i++) {</span><br><span class="line">            <span class="keyword">char</span> c = keyword.charAt(i);</span><br><span class="line">            TrieNode subNode = tempNode.getSubNode(c);</span><br><span class="line">            <span class="keyword">if</span>(!tempNode.containsKey(c)){</span><br><span class="line">                tempNode.addSubNode(c, <span class="keyword">new</span> TrieNode());</span><br><span class="line">            }</span><br><span class="line">            tempNode = tempNode.getSubNode(c);</span><br><span class="line">        }</span><br><span class="line">        tempNode.setKeywordEnd(<span class="keyword">true</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤敏感词</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 待过滤的文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 过滤后的文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filter</span><span class="params">(String text)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(text)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 指针1</span></span><br><span class="line">        TrieNode tempNode = rootNode;</span><br><span class="line">        <span class="comment">// 指针2</span></span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 指针3</span></span><br><span class="line">        <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 结果</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (position &lt; text.length()) {</span><br><span class="line">            <span class="keyword">char</span> c = text.charAt(position);</span><br><span class="line">            <span class="comment">// 跳过符号</span></span><br><span class="line">            <span class="keyword">if</span> (isSymbol(c)) {</span><br><span class="line">                <span class="comment">// 若指针1处于根节点,将此符号计入结果,让指针2向下走一步</span></span><br><span class="line">                <span class="keyword">if</span> (tempNode == rootNode) {</span><br><span class="line">                    sb.append(c);</span><br><span class="line">                    begin++;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 无论符号在开头或中间,指针3都向下走一步</span></span><br><span class="line">                position++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 检查下级节点</span></span><br><span class="line">            tempNode = tempNode.getSubNode(c);</span><br><span class="line">            <span class="keyword">if</span> (tempNode == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 以begin开头的字符串不是敏感词</span></span><br><span class="line">                sb.append(text.charAt(begin));</span><br><span class="line">                <span class="comment">// 进入下一个位置</span></span><br><span class="line">                position = ++begin;</span><br><span class="line">                <span class="comment">// 重新指向根节点</span></span><br><span class="line">                tempNode = rootNode;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (tempNode.isKeywordEnd()) {</span><br><span class="line">                <span class="comment">// 发现敏感词,将begin~position字符串替换掉</span></span><br><span class="line">                sb.append(REPLACEMENT);</span><br><span class="line">                <span class="comment">// 进入下一个位置</span></span><br><span class="line">                begin = ++position;</span><br><span class="line">                <span class="comment">// 重新指向根节点</span></span><br><span class="line">                tempNode = rootNode;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 检查下一个字符</span></span><br><span class="line">                position++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 将最后一批字符计入结果</span></span><br><span class="line">        sb.append(text.substring(begin));</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 判断是否为符号</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymbol</span><span class="params">(Character c)</span> </span>{</span><br><span class="line">        <span class="comment">// 0x2E80~0x9FFF 是东亚文字范围</span></span><br><span class="line">        <span class="keyword">return</span> !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (c &lt; <span class="number">0x2E80</span> || c &gt; <span class="number">0x9FFF</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 前缀树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>{</span><br><span class="line">        <span class="comment">// 关键词结束标识</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isKeywordEnd = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 子节点(key是下级字符,value是下级节点)</span></span><br><span class="line">        <span class="keyword">private</span> Map&lt;Character, TrieNode&gt; subNodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isKeywordEnd</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> isKeywordEnd;</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeywordEnd</span><span class="params">(<span class="keyword">boolean</span> keywordEnd)</span> </span>{</span><br><span class="line">            isKeywordEnd = keywordEnd;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 添加子节点</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSubNode</span><span class="params">(Character c, TrieNode node)</span> </span>{</span><br><span class="line">            subNodes.put(c, node);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 获取子节点</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TrieNode <span class="title">getSubNode</span><span class="params">(Character c)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> subNodes.get(c);</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Character c)</span></span>{</span><br><span class="line">            <span class="keyword">return</span> subNodes.containsKey(c);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><p>算法新解</p></li><li><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode/" target="_blank" rel="noopener">实现 Trie (前缀树)</a></p></li><li><p><a href="https://blog.nowcoder.net/n/543c682c844f4fcaab6be5d22b0530d4" target="_blank" rel="noopener">问答社区-敏感词过滤</a></p></li><li><p><a href="https://490.github.io/%E5%9F%BA%E4%BA%8E%E5%89%8D%E7%BC%80%E6%A0%91%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/" target="_blank" rel="noopener">基于前缀树图文详解敏感词过滤</a></p></li><li><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt/" target="_blank" rel="noopener">Trie Tree 的实现 (适合初学者)</a>   </p></li><li><p> <a href="https://www.cnblogs.com/kubidemanong/p/10834993.html" target="_blank" rel="noopener">面试被虐 说说游戏中的敏感词过滤是如何实现的？</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前缀树原理&quot;&gt;&lt;a href=&quot;#前缀树原理&quot; class=&quot;headerlink&quot; title=&quot;前缀树原理&quot;&gt;&lt;/a&gt;前缀树原理&lt;/h2&gt;</summary>
    
    
    
    <category term="算法" scheme="https://winniekun.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="trie" scheme="https://winniekun.github.io/tags/trie/"/>
    
  </entry>
  
  <entry>
    <title>Cookie和Session</title>
    <link href="https://winniekun.github.io/Cookie-Session/"/>
    <id>https://winniekun.github.io/Cookie-Session/</id>
    <published>2020-07-06T01:36:34.000Z</published>
    <updated>2020-08-30T04:50:22.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><a id="more"></a><p>Session和Cookie的作用是为了保持访问用户与后端服务器的交互状态</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie的作用通俗来讲就是当一个用户通过HTTP请求访问服务器的时候, 服务器将<strong>一些Key/Value的键值对</strong>返回给客户端, 并且还可以给这些数据添加一些限制条件: 存活时间, 生效范围等, 在符合限制条件的情况下, 该用户再次发起请求, 数据将会被完整的返回给服务器.</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/cookie/set"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">setCookie</span><span class="params">(HttpServletResponse response)</span></span>{</span><br><span class="line">    <span class="comment">// 生成cookie</span></span><br><span class="line">    Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"wkk"</span>, CommunityUtil.generateUUID());</span><br><span class="line">    <span class="comment">// 设置生效范围</span></span><br><span class="line">    cookie.setPath(<span class="string">"/community/alpha"</span>);</span><br><span class="line">    <span class="comment">// 设置cookie的生效时间（默认存在内存中， 设置时间之后会存在硬盘中）</span></span><br><span class="line">    cookie.setMaxAge(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 发送给客户端</span></span><br><span class="line">    response.addCookie(cookie);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"set cookie"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/06/wKDn9qhSYXgevE2.png" alt="Cookie" title="">                </div>                <div class="image-caption">Cookie</div>            </figure><p>W3C在设计Cookie的时候, 实际上考虑的是为了<strong>记录用户在一段时间的web应用的行为路径.</strong> 因为HTTP是无状态协议, 当用户访问完一次请求结束之后, 后端服务器无法知道下一次来访的是否还是上次访问的用户.   </p><p>使用Cookies带来的优势:</p><ol><li>短时间内, 如果与用户相关的数据频繁被访问, 可以为该数据添加缓存, 提高数据的访问性能</li></ol><p>若是同一客户端发送的请求, 每次发出的请求都会包含第一次访问服务器之后, 服务器设置的信息, 这样服务器就可以根据Cookie来划分用户.</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>虽然Cookie的出现可以让服务器识别每个客户的请求, 但是每次客户的访问都必须返回这些Cookie, 如果Cookie很多, 无疑是增加了客户端和服务端之间数据的传输量, 而Session的存在就是为了解决这个问题.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/06/WLICDZ4cBMKu6k7.png" alt="Session" title="">                </div>                <div class="image-caption">Session</div>            </figure><p>同一个客户端每次和服务端交互的时候, 不需要每次都传回所有的Cookie值, 而只要传回一个ID, 这个ID是客户端第一次访问服务器时生成的, 而且每个客户端是唯一的, 这样每个客户端就有了唯一的ID, 客户端只要返回ID即可, 这个ID就是名为<strong>JSSIONID</strong>的一个Cookie</p><h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><p>虽然Cookie和Session都可以跟踪客户端的访问记录,  但是工作方式不同, Cookie是通过把所有要保存的数据通过HTTP的头部从客户端传递到服务度端, 然后又从服务端传到客户端, 所有的数据都存储到客户端的浏览器中, 这些Cookie数据可以直接访问到, 设置可以修改, 所以安全性受到很大的挑战</p><p>相比而言, Session的安全性高很多, 因为Session的数据存储在服务器里, 只是通过Cookie传递一个SessionID而已, 所以Session更适合存储用户隐私和重要的数据</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;</summary>
    
    
    
    <category term="网络" scheme="https://winniekun.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="http" scheme="https://winniekun.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://winniekun.github.io/SingletonPattern/"/>
    <id>https://winniekun.github.io/SingletonPattern/</id>
    <published>2020-07-02T13:35:20.000Z</published>
    <updated>2021-03-31T11:22:40.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><a id="more"></a><blockquote><p>“你知道茴香豆的‘茴’字有几种写法吗？”</p></blockquote><p>纠结单例模式有几种写法有用吗? 有点用, 面试中经常选择其中一种或几种写法作为话头, 以此展开考察面试者的code style 以及其他相关的知识点. 但是过于纠结这些写法, 反而类似于”茴”字有几个写法…</p><p>思想, 思想, 思想. 重要事情说三遍</p><h3 id="类加载顺序"><a href="#类加载顺序" class="headerlink" title="类加载顺序"></a>类加载顺序</h3><p>类加载(classLoader)机制一般遵从下面的加载顺序</p><p>如果类还没有被加载：</p><ul><li>先执行父类的静态代码块和静态变量初始化，静态代码块和静态变量的执行顺序跟代码中出现的顺序有关。</li><li>执行子类的静态代码块和静态变量初始化。</li><li>执行父类的实例变量初始化</li><li>执行父类的构造函数</li><li>执行子类的实例变量初始化</li><li>执行子类的构造函数</li></ul><p>同时，加载类的过程是线程私有的，别的线程无法进入。</p><p>如果类已经被加载：</p><p>静态代码块和静态变量不在重复执行，再创建类对象时，只执行与实例相关的变量初始化和构造方法。</p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>一个类中如果有成员变量或者方法被static关键字修饰，那么该成员变量或方法将独立于该类的任何对象。它不依赖类特定的实例，被类的所有实例共享，只要这个类被加载，该成员变量或方法就可以通过类名去进行访问，它的作用用一句话来描述就是，不用创建对象就可以调用方法或者变量，这简直就是为单例模式的代码实现量身打造的。</p><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在类加载的时候就完成了实例化, 避免了多线程的同步问题. 当然缺点也是有的, 因为类加载时就实例化了, 没有达到Lazy Loading (懒加载) 的效果, 如果该实例没被使用, 内存就浪费了. </p><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>顾名思义,  就是初始化的时候, 不会主动的去创建实例, 而是在调用**getInstance()**的时候, 才会被动的去创建. </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>){</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在单线程的情况下, 没有任何问题, 但是因为其为线程不安全的,  在多线程的情况下, 譬如两个线程A,  B都执行了**getInstance()**方法, 并且都执行到了第9行代码, 然后A因为其他原因, 休眠了一会儿, 待B创建了实例对象之后, A有创建了一个, 显然, 这是不符合单利模式的</p><h3 id="解决1"><a href="#解决1" class="headerlink" title="解决1"></a>解决1</h3><p>在**getInstance()**方法内部添加同步代码块, 或者直接将该方法改为同步方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>){</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>好处是写起来简单, 且绝对线程安全; 坏处是并发性能极差, 事实上完全退化到了串行. 单例只需要初始化一次, 但就算初始化以后, synchronized的锁也无法避开, 从而**getInstance()**完全变成了串行操作. <strong>性能不敏感的场景建议使用</strong>。</p><h3 id="解决2"><a href="#解决2" class="headerlink" title="解决2"></a>解决2</h3><p>也就是臭名昭著的双重检验方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双重锁检验</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) { <span class="comment">// 第7行</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>{</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton(); <span class="comment">// 第10行</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于指令重排序的问题, 可能会被重排序为如下:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> Singleton(); <span class="comment">// 第10行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以分解为以下三个步骤</span></span><br><span class="line"><span class="number">1</span> memory=allocate();<span class="comment">// 分配内存 相当于c的malloc</span></span><br><span class="line"><span class="number">2</span> ctorInstanc(memory) <span class="comment">//初始化对象</span></span><br><span class="line"><span class="number">3</span> s=memory <span class="comment">//设置s指向刚分配的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述三个步骤可能会被重排序为 1-3-2，也就是：</span></span><br><span class="line"><span class="number">1</span> memory=allocate();<span class="comment">// 分配内存 相当于c的malloc</span></span><br><span class="line"><span class="number">3</span> s=memory <span class="comment">//设置s指向刚分配的地址</span></span><br><span class="line"><span class="number">2</span> ctorInstanc(memory) <span class="comment">//初始化对象</span></span><br></pre></td></tr></tbody></table></figure><p><strong>而一旦假设发生了这样的重排序，比如线程A在第10行执行了步骤1和步骤3，但是步骤2还没有执行完。这个时候另一个线程B执行到了第7行，它会判定instance不为空，然后直接返回了一个未初始化完成的instance！</strong></p><h3 id="解决3"><a href="#解决3" class="headerlink" title="解决3"></a>解决3</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双重锁检验</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) { <span class="comment">// 第7行</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>{</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton(); <span class="comment">// 第10行</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样就保证了线程的安全</p><h2 id="枚举模式"><a href="#枚举模式" class="headerlink" title="枚举模式"></a>枚举模式</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="comment">// ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton4 {</span><br><span class="line">  SINGLETON;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用javap进行反编译得到如下结果</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="comment">// ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">Singleton4</span>&gt; </span>{</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton4 SINGLETON = <span class="keyword">new</span> Singleton4();</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到, 其本质也还是饿汉模式</p><h2 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JVM在类的初始化阶段（class被加在后，且被线程使用之前）会执行类的初始化</span></span><br><span class="line"><span class="comment"> * 执行类的初始化期间，JVM会去获取一个锁，锁会同步多个线程对同一个类的初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weikunkun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/3/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>{</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.object;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://winniekun.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="创建型模式" scheme="https://winniekun.github.io/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
