<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wkkの笔记</title>
  
  <subtitle>好记性不如烂键盘</subtitle>
  <link href="https://winniekun.github.io/atom.xml" rel="self"/>
  
  <link href="https://winniekun.github.io/"/>
  <updated>2021-08-22T14:35:22.469Z</updated>
  <id>https://winniekun.github.io/</id>
  
  <author>
    <name>weikunkun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kafka在Linux上的配置</title>
    <link href="https://winniekun.github.io/kafka-config/"/>
    <id>https://winniekun.github.io/kafka-config/</id>
    <published>2021-08-22T13:24:40.000Z</published>
    <updated>2021-08-22T14:35:22.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><h3 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h3><p><strong>Kafka</strong>是由<a href="https://zh.wikipedia.org/wiki/Apache%E8%BD%AF%E4%BB%B6%E5%9F%BA%E9%87%91%E4%BC%9A" target="_blank" rel="noopener">Apache软件基金会</a>开发的一个<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%BA%90" target="_blank" rel="noopener">开源</a><a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E5%A4%84%E7%90%86" target="_blank" rel="noopener">流处理</a>平台，由<a href="https://zh.wikipedia.org/wiki/Scala" target="_blank" rel="noopener">Scala</a>和<a href="https://zh.wikipedia.org/wiki/Java" target="_blank" rel="noopener">Java</a>编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个“按照分布式事务日志架构的大规模发布/订阅消息队列”，[<a href="https://zh.wikipedia.org/wiki/Kafka#cite_note-3" target="_blank" rel="noopener">3]</a>这使它作为企业级基础设施来处理流式数据非常有价值。此外，Kafka可以通过Kafka Connect连接到外部系统（用于数据输入/输出），并提供了Kafka Streams——一个<a href="https://zh.wikipedia.org/wiki/Java" target="_blank" rel="noopener">Java</a>流式处理<a href="https://zh.wikipedia.org/wiki/%E5%BA%93_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener">库</a>。</p><h3 id="Kafka架构"><a href="#Kafka架构" class="headerlink" title="Kafka架构"></a>Kafka架构</h3><p>Kafka存储的消息来自任意多被称为“生产者”（Producer）的进程。数据从而可以被分配到不同的“分区”（Partition）、不同的“Topic”下。在一个分区内，这些消息被索引并连同时间戳存储在一起。其它被称为“消费者”（Consumer）的进程可以从分区查询消息。Kafka运行在一个由一台或多台服务器组成的集群上，并且分区可以跨集群结点分布。</p><p>Kafka高效地处理实时流式数据，可以实现与Storm、HBase和Spark的集成。作为聚类部署到多台服务器上，Kafka处理它所有的发布和订阅消息系统使用了四个API，即生产者API、消费者API、Stream API和Connector API。它能够传递大规模流式消息，自带容错功能，已经取代了一些传统消息系统，如JMS、AMQP等。</p><p>Kafka架构的主要术语包括Topic、Record和Broker。Topic由Record组成，Record持有不同的信息，而Broker则负责复制消息。Kafka有四个主要API：</p><ul><li><strong>生产者API</strong>：支持应用程序发布Record流。</li><li><strong>消费者API</strong>：支持应用程序订阅Topic和处理Record流。</li><li><strong>Stream API</strong>：将输入流转换为输出流，并产生结果。</li><li><strong>Connector API</strong>：执行可重用的生产者和消费者API，可将Topic链接到现有应用程序。</li></ul><h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><ol><li><a href="https://www.oracle.com/in/java/technologies/javase-downloads.html" target="_blank" rel="noopener">JDK11</a></li><li><a href="https://kafka.apache.org/downloads" target="_blank" rel="noopener">kafka_2.13-2.8.0.tgz</a></li></ol><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>假设<code>Kafka</code>环境和<code>Zookeeper</code>环境都没有</p><h3 id="1-下载并解压"><a href="#1-下载并解压" class="headerlink" title="1. 下载并解压"></a>1. 下载并解压</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; tar -xzf kafka_2<span class="number">.13</span>-<span class="number">2.8</span><span class="number">.0</span>.tgz</span><br><span class="line">&gt; mv kafka_2<span class="number">.13</span>-<span class="number">2.8</span><span class="number">.0</span>.tgz  /usr/local/kafka</span><br><span class="line">&gt; cd /usr/local/kafka</span><br></pre></td></tr></tbody></table></figure><h3 id="2-启动服务"><a href="#2-启动服务" class="headerlink" title="2. 启动服务"></a>2. 启动服务</h3><blockquote><p>kafka的启动依赖于Java环境，所以在使用Kakfa之前，记得配置Java8+的环境</p></blockquote><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> bin/zookeeper-server-start.sh config/zookeeper.properties</span></span><br></pre></td></tr></tbody></table></figure><p>打开另一个命令终端启动kafka服务：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 用于后台启动</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> bin/kafka-server-start.sh config/server.properties &amp;</span></span><br></pre></td></tr></tbody></table></figure><p>一旦所有服务成功启动，那Kafka已经可以使用了。</p><h3 id="3-创建一个主题"><a href="#3-创建一个主题" class="headerlink" title="3. 创建一个主题"></a>3. 创建一个主题</h3><p>创建一个名为“test”的Topic，只有一个分区和一个备份：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span></span><br></pre></td></tr></tbody></table></figure><p>创建好之后，可以通过运行以下命令，查看已创建的topic信息：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> bin/kafka-topics.sh --describe --topic <span class="built_in">test</span> --bootstrap-server localhost:9092</span></span><br><span class="line"></span><br><span class="line">Topic:quickstart-events  PartitionCount:1    ReplicationFactor:1 Configs:</span><br><span class="line">Topic: quickstart-events Partition: 0    Leader: 0   Replicas: 0 Isr: 0</span><br></pre></td></tr></tbody></table></figure><h3 id="4-发送消息"><a href="#4-发送消息" class="headerlink" title="4. 发送消息"></a>4. 发送消息</h3><p>Kafka提供了一个命令行的工具，可以从输入文件或者命令行中读取消息并发送给Kafka集群。每一行是一条消息。</p><p>运行 <code>producer（生产者）</code>,然后在控制台输入几条消息到服务器。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> bin/kafka-console-producer.sh --broker-list localhost:9092 --topic <span class="built_in">test</span></span></span><br><span class="line">hello world</span><br><span class="line">what's your name</span><br></pre></td></tr></tbody></table></figure><h3 id="5-消费消息"><a href="#5-消费消息" class="headerlink" title="5. 消费消息"></a>5. 消费消息</h3><p>Kafka也提供了一个消费消息的命令行工具，将存储的信息输出出来，新打开一个命令控制台，输入：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning</span></span><br><span class="line">hello world</span><br><span class="line">what's your name</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意，若是在服务器开启kafka服务，然后本地消费生产的消息，需要在kafka中的 config/service.properties 中修改配置（注意开启服务器对应的端口）</p><p>advertised.listeners=PLAINTEXT://your ip : your port </p></blockquote><h3 id="6-使用-Kafka-Connect-来-导入-导出-数据"><a href="#6-使用-Kafka-Connect-来-导入-导出-数据" class="headerlink" title="6. 使用 Kafka Connect 来 导入/导出 数据"></a>6. 使用 Kafka Connect 来 导入/导出 数据</h3><p>可能现有的系统中拥有大量的数据，如<code>关系型数据库</code>或<code>传统的消息传递系统</code>，以及许多已经使用这些系统的应用程序。Kafka Connect允许你不断地从外部系统提取数据到Kafka，反之亦然。用Kafka整合现有的系统是非常容易的。为了使这个过程更加容易，有数百个这样的连接器现成可用。</p><h3 id="7-使用Kafka-Stream来处理数据"><a href="#7-使用Kafka-Stream来处理数据" class="headerlink" title="7. 使用Kafka Stream来处理数据"></a>7. 使用Kafka Stream来处理数据</h3><p>一旦我们的数据存储在Kafka中，就可以用<a href="">Kafka Streams客户端库</a>来处理这些数据，该库适用于<code>Java/Scala</code>。它允许你实现自己的实时应用程序和微服务，其中输入和/或输出数据存储在Kafka主题中。Kafka Streams将在客户端编写和部署标准Java和Scala应用程序的简单性与Kafka服务器端集群技术的优势相结合，使这些应用程序具有<code>可扩展性</code>、<code>弹性</code>、<code>容错性</code>和<code>分布式</code>。该库支持精确的一次性处理、有状态操作和聚合、窗口化、连接、基于事件时间的处理等等。</p><p>一个初步的体验，实现一个流行的<code>WordCount</code>算法的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">KStream&lt;String, String&gt; textLines = builder.stream(<span class="string">"quickstart-events"</span>);</span><br><span class="line"></span><br><span class="line">KTable&lt;String, Long&gt; wordCounts = textLines</span><br><span class="line">            .flatMapValues(line -&gt; Arrays.asList(line.toLowerCase().split(<span class="string">" "</span>)))</span><br><span class="line">            .groupBy((keyIgnored, word) -&gt; word)</span><br><span class="line">            .count();</span><br><span class="line"></span><br><span class="line">wordCounts.toStream().to(<span class="string">"output-topic"</span>, Produced.with(Serdes.String(), Serdes.Long()));</span><br></pre></td></tr></tbody></table></figure><h2 id="以系统服务方式启动kafka"><a href="#以系统服务方式启动kafka" class="headerlink" title="以系统服务方式启动kafka"></a>以系统服务方式启动kafka</h2><p>创建 <code>/usr/lib/systemd/system/zookeeper.service</code> 并写入</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Requires=network.target</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">Environment="PATH=/opt/jdk-11.0.12/bin:/opt/jdk-11.0.12/jre/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin"</span><br><span class="line">LimitNOFILE=1048576</span><br><span class="line">ExecStart=/usr/local/kafka/bin/zookeeper-server-start.sh /usr/local/kafka/config/zookeeper.properties</span><br><span class="line">ExecStop=/usr/local/kafka/bin/zookeeper-server-stop.sh</span><br><span class="line">Restart=Always</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></tbody></table></figure><p>创建 <code>/usr/lib/systemd/system/kafka.service</code> 并写入</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Requires=zookeeper.service</span><br><span class="line">After=zookeeper.service</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">Environment="PATH=/opt/jdk-11.0.12/bin:/opt/jdk-11.0.12/jre/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin"</span><br><span class="line">LimitNOFILE=1048576</span><br><span class="line">ExecStart=/usr/local/kafka/bin/kafka-server-start.sh /usr/local/kafka/config/server.properties</span><br><span class="line">ExecStop=/usr/local/kafka/bin/kafka-server-stop.sh</span><br><span class="line">Restart=Always</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></tbody></table></figure><p><strong>注意：示例的kafka安装地址在 <code>/usr/local/kafka</code></strong></p><p>因为系统服务不会直接读取我们配置在<code>/etc/profile</code>或者<code>bash_profile</code>中的环境变量，所以<code>Environment</code>一定要记得配置。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看当前环境变量</span></span></span><br><span class="line">export $PATH</span><br></pre></td></tr></tbody></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>重载系统服务并启动</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> zookeeper &amp;&amp; systemctl <span class="built_in">enable</span> kafka</span><br><span class="line">systemctl start zookeeper &amp;&amp; systemctl start kafka</span><br><span class="line">systemctl status zookeeper &amp;&amp; systemctl status kafka</span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210822223509558.png" alt="zookeeper" title="">                </div>                <div class="image-caption">zookeeper</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210822223415746.png" alt="kafka" title="">                </div>                <div class="image-caption">kafka</div>            </figure><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ol><li><a href="https://zh.wikipedia.org/wiki/Kafka" target="_blank" rel="noopener">维基百科—kafka</a></li><li><a href="https://www.orchome.com/189" target="_blank" rel="noopener">Kafka教程</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;h3 id=&quot;Kafka简介&quot;&gt;&lt;a href=&quot;#Kafka简介&quot; class=&quot;headerlink&quot; title=&quot;Kafka简介&quot;&gt;&lt;/a&gt;Ka</summary>
      
    
    
    
    <category term="kafka" scheme="https://winniekun.github.io/categories/kafka/"/>
    
    
    <category term="配置" scheme="https://winniekun.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>虚拟内存概览</title>
    <link href="https://winniekun.github.io/virtual-memory/"/>
    <id>https://winniekun.github.io/virtual-memory/</id>
    <published>2021-07-27T06:57:30.000Z</published>
    <updated>2021-08-09T10:11:43.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p><strong>“Any problem in computer science can be solved by another layer of indirection.</strong> </p><p>——<a href="https://book.douban.com/subject/3652388/" target="_blank" rel="noopener">程序员的自我修养</a></p></blockquote><h2 id="物理寻址"><a href="#物理寻址" class="headerlink" title="物理寻址"></a>物理寻址</h2><p>早期，CPU在处理某个进程的时候，处理的流程如下。</p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210726165551742.png" alt="物理寻址方式" style="zoom:50%;"><p>对于物理寻址而言，我们需要直接将程序全部装入到物理内存中，接下来运行期间，CPU在处理时，直接进行物理寻址。然后执行相关的读写命令。</p><p>对于物理内存而言，是不做任何访问限制的，所以直接操作进行物理寻址会导致一个问题是：</p><ol><li><p>读写内存的安全性问题</p><ol><li>不同的进程被分配到不同的物理内存中，运行期间导致进程A错误修改了进程B占用的物理内存，导致进程B出现问题</li><li>危害操作系统自身的安全。恶意的进程直接修改操作系统所占用的物理空间，导致系统崩溃</li></ol></li><li><p>内存的利用率不高</p><ol><li>一个系统中，不同的进程是共享CPU和物理内存资源的，如果有很多的进程需要很大的内存，那么就会导致这些进程所需的内存大小 &gt; 实际的物理内存，这样就会导致有些有些进程无法被执行。</li></ol></li></ol><p>所以，为了更加有效的管理内存并且少出错，现代的操作系统提供了一种对主存的抽象概念—<strong>虚拟内存</strong>。<strong>虚拟内存是硬件异常、硬件地址翻译、主存、磁盘和内核软件的完美交互</strong></p><h2 id="虚拟内存概念"><a href="#虚拟内存概念" class="headerlink" title="虚拟内存概念"></a>虚拟内存概念</h2><blockquote><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。<br>现代所有用于一般应用的操作系统都对普通的应用程序使用虚拟内存技术，老一些的操作系统，如DOS和1980年代的Windows，或者那些1960年代的大型机，一般都没有虚拟内存的功能<br>——维基百科</p></blockquote><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210726164801304.png" alt="image-20210726164801304" style="zoom: 50%;"><p>引入序中所引用的话<strong>Any problem in computer science can be solved by another layer of indirection.</strong> 同理虚拟内存为<code>进程&lt;---&gt;物理内存</code>的中间层，它为进程隐藏了物理内存的概念，同时为其提供了更加简洁易用的接口，供其调用。同时还提供了一些更加复杂的功能。</p><h3 id="能力一：高速缓存"><a href="#能力一：高速缓存" class="headerlink" title="能力一：高速缓存"></a>能力一：高速缓存</h3><p>我们可以将虚拟内存看作是磁盘上的一片空间，当这片空间中的一部分访问比较频繁时，<strong>该部分数据会以页为单位被缓存到主存中</strong>以加速 CPU 访问数据的性能，虚拟内存利用空间较大的磁盘存储作为『内存』并使用主存储缓存进行加速，<strong>让进程认为操作系统的内存很大而且很快，然而区域很大的磁盘并不快，而很快的内存也并不大</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210726225636676.png" alt="虚拟内存作为缓存" title="">                </div>                <div class="image-caption">虚拟内存作为缓存</div>            </figure><p>在虚拟内存中的虚拟页共分为三种类型：</p><ol><li>未分配<ol><li>没有被进程申请使用的，也就是空闲的虚拟内存， 不占用虚拟内存磁盘的任何空间</li></ol></li><li>未缓存<ol><li>仅仅加载到磁盘中的页</li></ol></li><li>已缓存<ol><li>已经加载到内存中的内存页（页框）</li></ol></li></ol><h3 id="能力二：内存管理"><a href="#能力二：内存管理" class="headerlink" title="能力二：内存管理"></a>能力二：内存管理</h3><ul><li><p>简化链接和加载</p></li><li><p>简化内存共享</p><p>将不同的进程中的页表中某些页表项映射到相同的物理地址，即可实现内存的共享。</p></li><li><p>简化内存分配</p><p>独立的虚拟内存空间也会简化内存的分配过程，当用户程序向操作系统申请堆内存时，操作系统可以分配几个连续的虚拟页，但是这些虚拟页可以对应到物理内存中不连续的页中。</p></li></ul><h3 id="能力三：内存保护"><a href="#能力三：内存保护" class="headerlink" title="能力三：内存保护"></a>能力三：内存保护</h3><p>现代操作系统中，用户进程不应该被允许修改它的只读代码段，而且也不应该允许它读取或修改任何内核中的代码和数据结构，并且也不允许其读取或者修改其他进程的私有内存，以及修改和其他进程共享的虚拟页面。如果不对进程的内存访问进行限制，攻击者就能够访问和修改其他进程的私有内存，进而导致整个系统崩溃。</p><p>通过虚拟内存，我们为进程提供了独立的地址空间，同时这也让我们能够快速的区分不同进程的私有内存。同时我们通过虚拟内存到实际的物理内存的转化需要使用地址翻译机制，整体流程如下所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210727001028167.png" alt="虚拟寻址方式" title="">                </div>                <div class="image-caption">虚拟寻址方式</div>            </figure><p>通过MMU，每次都会读取页表中的一个页表条目(PTE)，通过在这些页表条目(PTE)中添加一些标志位，就能够实现对一个虚拟页的访问控制权限。譬如：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210727002025494.png" alt="带标志位的页表" title="">                </div>                <div class="image-caption">带标志位的页表</div>            </figure><h2 id="应用程序如何如何使用和管理虚拟内存"><a href="#应用程序如何如何使用和管理虚拟内存" class="headerlink" title="应用程序如何如何使用和管理虚拟内存"></a>应用程序如何如何使用和管理虚拟内存</h2><ul><li><input disabled="" type="checkbox"> TODO </li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虚拟内存的思想，整体来看就是：通过结合磁盘和内存各自的优势，<strong>利用中间层对资源进行更合理地调度，充分提高资源的利用率。并提供和谐以及统一的抽象</strong>。个人目前接触到的最直观的体现就是 JDK中集合类的设计与实现。其也可以算是数据和数据结构之间的中间层，结合其他的技术譬如泛型，为上层的数据提供了接口的同时，隐藏了内部数据结构的实现以及维护。</p><p>最后再总结下为什么需要虚拟内存：</p><ul><li>虚拟内存可以结合磁盘和物理内存的优势为进程提供看起来速度足够快并且容量足够大的存储；</li><li>虚拟内存可以为进程提供独立的内存空间并引入多层的页表结构将虚拟内存翻译成物理内存，进程之间可以共享物理内存减少开销，也能简化程序的链接、装载以及内存分配过程；</li><li>虚拟内存可以控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性；</li></ul><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li>csapp 第九章</li><li>操作系统导论 内存虚拟化部分</li><li><a href="https://draveness.me/whys-the-design-os-virtual-memory/" target="_blank" rel="noopener">为什么Linux需要虚拟内存</a></li><li><a href="https://zhuanlan.zhihu.com/p/96098896" target="_blank" rel="noopener">如何理解虚拟内存</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;“Any problem in computer science can be solved by ano</summary>
      
    
    
    
    <category term="操作系统" scheme="https://winniekun.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="内存管理" scheme="https://winniekun.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap源码分析</title>
    <link href="https://winniekun.github.io/concurrenthashmap-analysis/"/>
    <id>https://winniekun.github.io/concurrenthashmap-analysis/</id>
    <published>2021-07-19T10:40:55.000Z</published>
    <updated>2021-07-19T13:56:53.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>ConcurrentHashMap，可以理解成是HashMap的线程安全版本，同样的，内部使用也是（数组 + 链表 + 红黑树）的结构来存储元素。同时相比于同样提供线程安全的HashTable，效率等各方面都有所提升</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/ConcurrentHashMap.png" alt="ConcurrentHashMap" title="">                </div>                <div class="image-caption">ConcurrentHashMap</div>            </figure><h2 id="阅读套路"><a href="#阅读套路" class="headerlink" title="阅读套路"></a>阅读套路</h2><p>按照正常的逻辑， 首先基础的数据构造, 然后了解其构造方法， 之后了解常用的API(CRUD)操作即可。</p><ul><li><input checked="" disabled="" type="checkbox"> 增</li><li><input checked="" disabled="" type="checkbox"> 删</li><li><input checked="" disabled="" type="checkbox"> 改</li><li><input checked="" disabled="" type="checkbox"> 查</li></ul><h2 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和hashmap类似</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 用于并发情况下的扩容控制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="comment">// 并发安全控制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"><span class="comment">// views</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial table capacity.  Must be a power of 2</span></span><br><span class="line"><span class="comment"> * (i.e., at least 1) and at most MAXIMUM_CAPACITY.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The largest possible (non-power of two) array size.</span></span><br><span class="line"><span class="comment"> * Needed by toArray and related methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default concurrency level for this table. Unused but</span></span><br><span class="line"><span class="comment"> * defined for compatibility with previous versions of this class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for this table. Overrides of this value in</span></span><br><span class="line"><span class="comment"> * constructors affect only the initial table capacity.  The</span></span><br><span class="line"><span class="comment"> * actual floating point value isn't normally used -- it is</span></span><br><span class="line"><span class="comment"> * simpler to use expressions such as {<span class="doctag">@code</span> n - (n &gt;&gt;&gt; 2)} for</span></span><br><span class="line"><span class="comment"> * the associated resizing threshold.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2, and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * The value should be at least 4 * TREEIFY_THRESHOLD to avoid</span></span><br><span class="line"><span class="comment"> * conflicts between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Minimum number of rebinnings per transfer step. Ranges are</span></span><br><span class="line"><span class="comment"> * subdivided to allow multiple resizer threads.  This value</span></span><br><span class="line"><span class="comment"> * serves as a lower bound to avoid resizers encountering</span></span><br><span class="line"><span class="comment"> * excessive memory contention.  The value should be at least</span></span><br><span class="line"><span class="comment"> * DEFAULT_CAPACITY.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of bits used for generation stamp in sizeCtl.</span></span><br><span class="line"><span class="comment"> * Must be at least 6 for 32bit arrays.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum number of threads that can help resize.</span></span><br><span class="line"><span class="comment"> * Must fit in 32 - RESIZE_STAMP_BITS bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bit shift for recording size stamp in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Encodings for Node hash fields. See above for explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// hash for roots of trees</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"><span class="comment">/** Number of CPUS, to place bounds on some sizings */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></tbody></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>构造方法与HashMap对比可以发现，没有了HashMap中的threshold和loadFactor，而是改用了sizeCtl来控制，而且只存储了容量在里面，那么它是怎么用的呢？官方给出的解释如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Table initialization and resizing control.  When negative, the</span><br><span class="line">table is being initialized or resized: -1 for initialization,</span><br><span class="line">else -(1 + the number of active resizing threads).  Otherwise,</span><br><span class="line">when table is null, holds the initial table size to use upon</span><br><span class="line">creation, or 0 for default. After initialization, holds the</span><br><span class="line">next element count value upon which to resize the table.</span><br></pre></td></tr></tbody></table></figure><ol><li>-1 有线程正在初始化</li><li>-(1 + n) 有n个线程正在一起扩容</li><li>0 默认值， 后续在真正初始化的时候使用默认容量</li><li><code>&gt;0</code> 初始化或扩容完成后下一次的扩容门槛</li></ol><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>{</span><br><span class="line">  <span class="comment">// key和value都不能为null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 计算hash值</span></span><br><span class="line">  <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 要插入的元素所在桶的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 死循环，结合CAS使用（如果CAS失败，则会重新取整个桶进行下面的流程）</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) {</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果桶未初始化或者桶个数为0，则初始化桶</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 如果要插入的元素所在的桶还没有元素，则把这个元素插入到这个桶中</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="comment">// 如果使用CAS插入元素时，发现已经有元素了，则进入下一次循环，重新操作</span></span><br><span class="line">                <span class="comment">// 如果使用CAS插入元素成功，则break跳出循环，流程结束</span></span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 如果要插入的元素所在的桶的第一个元素的hash是MOVED，则当前线程帮忙一起迁移元素</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 如果这个桶不为空且不在迁移元素，则锁住这个桶（分段锁）</span></span><br><span class="line">            <span class="comment">// 并查找要插入的元素是否在这个桶中</span></span><br><span class="line">            <span class="comment">// 存在，则替换值（onlyIfAbsent=false）</span></span><br><span class="line">            <span class="comment">// 不存在，则插入到链表结尾或插入树中</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) {</span><br><span class="line">                <span class="comment">// 再次检测第一个元素是否有变化，如果有变化则进入下一次循环，从头来过</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) {</span><br><span class="line">                    <span class="comment">// 如果第一个元素的hash值大于等于0（说明不是在迁移，也不是树）</span></span><br><span class="line">                    <span class="comment">// 那就是桶中的元素使用的是链表方式存储</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) {</span><br><span class="line">                        <span class="comment">// 桶中元素个数赋值为1</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历整个桶，每次结束binCount + 1</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) {</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 在链表中找到了改元素，覆盖 并退出</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) {</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                            <span class="comment">// 如果没有找到 则 直接在尾部插入改元素</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) {</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 树上找点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) {</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) {</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果binCount不为0，说明成功插入了元素或者寻找到了元素</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) {</span><br><span class="line">                <span class="comment">// 如果链表元素个数达到了8，则尝试树化</span></span><br><span class="line">                <span class="comment">// 因为上面把元素插入到树中时，binCount只赋值了2，并没有计算整个树中元素的个数</span></span><br><span class="line">                <span class="comment">// 所以不会重复树化</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 成功插入元素，元素个数加1（是否要扩容在这个里面）</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>流程和hashmap类似：</strong></p><ol><li>如果hash桶未初始化，则先初始化</li><li>如果当前位置无元素，则通过cas的方式放入元素</li><li>如果当前位置存在元素<ol><li>是转移节点（正在扩容），则将当前线程一起加入到扩容中</li><li>不是转移节点，锁这个桶<ol><li>如果为链表节点，进行在链表上查找该元素，找到？覆盖：执行插入操作</li><li>如果为树节点，在红黑树中查找该元素，找到？覆盖：执行插入操作</li></ol></li></ol></li><li>存在该元素时，返回旧value</li><li>不存在，整个map的元素+ 1，并检查是否需要扩容</li></ol><p><strong>因为是线程安全的操作，所以仔细看下在整个put阶段，采用了哪些手段保证线程安全。这个才是我们看CHM源码的关键</strong></p><h3 id="数组初始化时的线程安全措施"><a href="#数组初始化时的线程安全措施" class="headerlink" title="数组初始化时的线程安全措施"></a>数组初始化时的线程安全措施</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() {</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 小于 0 代表有线程正在初始化，释放当前 CPU 的调度权，重新发起锁的竞争</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// CAS 赋值保证当前只有一个线程在初始化，</span></span><br><span class="line">        <span class="comment">// -1  代表当前只有一个线程能初始化 </span></span><br><span class="line">        <span class="comment">// 保证了数组的初始化的安全性</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) {</span><br><span class="line">            <span class="keyword">try</span> {              </span><br><span class="line"><span class="comment">// 很有可能执行到这里的时候，table 已经不为空了，这里是双重 check</span></span><br><span class="line">  <span class="comment">// 如果把sizeCtl原子更新为-1成功，则当前线程进入初始化</span></span><br><span class="line">                <span class="comment">// 如果原子更新失败则说明有其它线程先一步进入初始化了，则进入下一次循环           </span></span><br><span class="line">                <span class="comment">// 如果下一次循环时还没初始化完毕，则sizeCtl&lt;0进入上面if的逻辑让出CPU           </span></span><br><span class="line">                <span class="comment">// 如果下一次循环更新完毕了，则table.length!=0，退出循环</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// 进行初始化</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>小总结</strong></p><p>数组初始化时：</p><ol><li><p>使用CAS锁控制只有一个线程初始化桶数组并且一定能初始化成功；</p></li><li><p>然后通过 CAS 设置 sizeCtl 变量的值，来保证同一时刻只能有一个线程对数组进行初始化，CAS 成功之后，还会再次判断当前数组 是否已经初始化完成，如果已经初始化完成，就不会继续再执行初始化</p></li><li><p>扩容门槛写死的是桶数组大小的0.75倍，桶数组大小即map的容量，也就是最多存储多少个元素。</p></li></ol><p><strong>通过自旋 + cas + double check 保障了数组初始化时的线程安全。</strong></p><h4 id="Java线程中的一些方法的区别（sleep、yield、wait、join）"><a href="#Java线程中的一些方法的区别（sleep、yield、wait、join）" class="headerlink" title="Java线程中的一些方法的区别（sleep、yield、wait、join）"></a>Java线程中的一些方法的区别（sleep、yield、wait、join）</h4><p>只有runnable到running时才会占用cpu时间片，其他都会出让cpu时间片。<br>线程的资源有不少，整体来看可分为如下两类</p><ol><li>CPU资源</li><li>锁资源</li></ol><p>分析以上四个方法时，查看这两个共享资源是否释放，区分更加明显</p><ol><li><p>sleep：Thread类的方法，必须带一个时间参数。<strong>会让当前线程休眠进入阻塞状态并释放CPU（阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段）</strong>，提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁 可通过调用interrupt()方法来唤醒休眠线程。</p></li><li><p>yield：<strong>让出CPU调度</strong>，Thread类的方法，类似sleep只是<strong>不能由用户指定暂停多长时间 ，</strong>并且yield()方法<strong>只能让同优先级的线程</strong>有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入<strong>到可执行状态后</strong>马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。 </p></li><li><p>wait：Object类的方法(notify()、notifyAll()  也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁</p></li><li><p>join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。</p></li></ol><h3 id="在桶位置放入元素时的线程安全措施（4个措施）"><a href="#在桶位置放入元素时的线程安全措施（4个措施）" class="headerlink" title="在桶位置放入元素时的线程安全措施（4个措施）"></a>在桶位置放入元素时的线程安全措施（4个措施）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                 <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li><p>通过自旋死循环保证一定可以新增成功 1⃣️</p><ol><li>在新增之前，通过==for (Node[] tab = table;;)==这样的死循环来保证新增一定可以成功，一旦新增成功，就可以退出当前死循环，新增失败的话，会重复新增的步骤，直到新增成功为止。</li></ol></li><li><p>当前hash桶是否有元素：</p><ol><li><p>无元素 cas 新增 2⃣️</p><p>Java 这里的写法非常严谨，没有在判断槽点为空的情况下直接赋值，因为在判断槽点为空和赋 值的瞬间，很有可能槽点已经被其他线程赋值了，所以我们采用 CAS 算法，能够保证槽点为空 的情况下赋值成功，如果恰好槽点已经被其他线程赋值，当前 CAS 操作失败，会再次执行 for 自旋，再走槽点有值的 put 流程，这里就是自旋 + CAS 的结合。</p></li><li><p>有元素 锁住当前点  （synchronized）3⃣️</p><p>put 时，如果当前槽点有值，就是 key 的 hash 冲突的情况，此时槽点上可能是链表或红黑树， 我们通过锁住槽点，来保证同一时刻只会有一个线程能对槽点进行修改</p></li></ol></li><li><p>红黑树旋转时， 锁住红黑树的根节点，保证同一时刻，当前红黑树只能被一个线程旋转 4⃣️</p></li></ol><h3 id="扩容时的线程安全措施"><a href="#扩容时的线程安全措施" class="headerlink" title="扩容时的线程安全措施"></a>扩容时的线程安全措施</h3><p>ConcurrentHashMap 的扩容时机和 HashMap 相同，都是在 put 方法的最后一步检查是否需要扩 容，如果需要则进行扩容，但两者扩容的过程完全不同，ConcurrentHashMap 扩容的方法叫做 transfer，从 put 方法的 addCount 方法进去，就能找到 transfer 方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>{</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">  <span class="comment">// 这里使用的思想跟LongAdder类是一模一样的（后面会讲）</span></span><br><span class="line"><span class="comment">// 把数组的大小存储根据不同的线程存储到不同的段上（也是分段锁的思想）</span></span><br><span class="line"><span class="comment">// 并且有一个baseCount，优先更新baseCount，如果失败了再更新不同线程对应的段</span></span><br><span class="line"><span class="comment">// 这样可以保证尽量小的减少冲突</span></span><br><span class="line"><span class="comment">// 先尝试把数量加到baseCount上，如果失败再加到分段的CounterCell上</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) {</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) {</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) {</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正触发扩容的方式</span></span><br><span class="line"><span class="comment">// 扩容主要分 2 步，</span></span><br><span class="line"><span class="comment">// 1. 第一新建新的空数组，</span></span><br><span class="line"><span class="comment">// 2. 第二移动拷贝每个元素到新数组中去 </span></span><br><span class="line"><span class="comment">// tab:原数组，nextTab:新数组</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>{</span><br><span class="line">    <span class="comment">// 老数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">// 如果新数组为空，初始化，大小为原数组的两倍，n &lt;&lt; 1</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) {            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable ex) {      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 新的table长度</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">// 代表转移节点，如果原数组上是转移节点，说明该节点正在被扩容 (node的hash值为-1)</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">// 无限自旋，i 的值会从原数组的最大值开始，慢慢递减到 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) {</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) {</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">// 结束循环的标志</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 已经拷贝完成</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) {</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 每次减少 i 的值</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) {</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// if 任意条件满足说明拷贝结束了</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) {</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="comment">// 拷贝结束，直接赋值，因为每次拷贝完一个节点，都在原数组上放转移节点，所以拷 贝完成的节点的数据一定不会再发生变化。</span></span><br><span class="line">            <span class="comment">// 原数组发现是转移节点，是不会操作的，会一直等待转移节点消失之后在进行操作。</span></span><br><span class="line">  <span class="comment">// 也就是说数组节点一旦被标记为转移节点，是不会再发生任何变动的，所以不会有任 何线程安全的问题</span></span><br><span class="line"><span class="comment">// 所以此处直接赋值，没有任何问题。</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) {</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) {</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 进行节点的拷贝</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) {</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) {</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) {</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) {</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) {</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) {</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span> {</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="comment">// 桶内只有的单个数据， 直接拷贝，为链表，循环多次形成链表拷贝</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) {</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        }</span><br><span class="line">                        <span class="comment">// 在新数组位置上放置拷贝的值</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 在老数组位置上放上 ForwardingNode 节点</span></span><br><span class="line">                        <span class="comment">// put 时，发现是 ForwardingNode 节点，就不会再动这个节点的数</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 红黑树的拷贝</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) {</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) {</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) {</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            }</span><br><span class="line">                            <span class="keyword">else</span> {</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>transfer方法的主要思路：</p><ol><li>首先需要把老数组的值全部拷贝到扩容之后的新数组上，先从数组的队尾开始拷贝</li><li>拷贝数组的槽点时，先把原数组槽点锁住，保证原数组槽点不能操作，成功拷贝到新数组时， 把原数组槽点赋值为转移节点</li><li>这时如果有新数据正好需要 put 到此槽点时，发现槽点为转移节点，就会一直等待，所以在 扩容完成之前，该槽点对应的数据是不会发生变化的</li><li>从数组的尾部拷贝到头部，每拷贝成功一次，就把原数组中的节点设置成转移节点;</li><li>直到所有数组数据都拷贝到新数组时，直接把新数组整个赋值给数组容器，拷贝完成。</li></ol><p>通过在原数组上设置转移节点，put 时碰到转移节点时会等待扩容成 功之后才能 put 的策略，来保证了整个扩容过程中肯定是线程安全的，因为数组的槽点一旦被设 置成转移节点，在没有扩容完成之前，是无法进行操作的。</p><p>（1）新桶数组大小是旧桶数组的两倍；</p><p>（2）迁移元素先从靠后的桶开始；</p><p>（3）迁移完成的桶在里面放置一ForwardingNode类型的元素，标记该桶迁移完成；</p><p>（4）迁移时根据hash&amp;n是否等于0把桶中元素分化成两个链表或树；</p><p>（5）低位链表（树）存储在原来的位置；</p><p>（6）高们链表（树）存储在原来的位置加n的位置；</p><p>（7）迁移元素时会锁住当前桶，也是分段锁的思想；</p><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>（1）ConcurrentHashMap是HashMap的线程安全版本；</p><p>（2）ConcurrentHashMap采用（数组 + 链表 + 红黑树）的结构存储元素；</p><p>（3）ConcurrentHashMap相比于同样线程安全的HashTable，效率要高很多；</p><p>（4）ConcurrentHashMap采用的锁有 synchronized，CAS，自旋锁，分段锁，volatile等；</p><p>（5）ConcurrentHashMap中没有threshold和loadFactor这两个字段，而是采用sizeCtl来控制；</p><p>（6）sizeCtl = -1，表示正在进行初始化；</p><p>（7）sizeCtl = 0，默认值，表示后续在真正初始化的时候使用默认容量；</p><p>（8）sizeCtl &gt; 0，在初始化之前存储的是传入的容量，在初始化或扩容后存储的是下一次的扩容门槛；</p><p>（9）sizeCtl = (resizeStamp &lt;&lt; 16) + (1 + nThreads)，表示正在进行扩容，高位存储扩容邮戳，低位存储扩容线程数加1；</p><p>（10）更新操作时如果正在进行扩容，当前线程协助扩容；</p><p>（11）更新操作会采用synchronized锁住当前桶的第一个元素，这是分段锁的思想；</p><p>（12）整个扩容过程都是通过CAS控制sizeCtl这个字段来进行的，这很关键；</p><p>（13）迁移完元素的桶会放置一个ForwardingNode节点，以标识该桶迁移完毕；</p><p>（14）元素个数的存储也是采用的分段思想，类似于LongAdder的实现；</p><p>（15）元素个数的更新会把不同的线程hash到不同的段上，减少资源争用；</p><p>（16）元素个数的更新如果还是出现多个线程同时更新一个段，则会扩容段（CounterCell）；</p><p>（17）获取元素个数是把所有的段（包括baseCount和CounterCell）相加起来得到的；</p><p>（18）查询操作是不会加锁的，所以ConcurrentHashMap不是强一致性的；</p><p>（19）ConcurrentHashMap中不能存储key或value为null的元素；</p><h3 id="一些思想"><a href="#一些思想" class="headerlink" title="一些思想"></a>一些思想</h3><ol><li>cas + 自选 乐观锁的思想，减少线程上下文切换的时间</li><li>分段锁思想，减少同一时间 竞争锁带来的低效问题</li><li>CounterCell，分段存储元素，减少多线程同时更新一个字段带来的低效</li><li>多线程协同进行扩容</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;ConcurrentHashMap，可以理解成是HashMap的线程安全版本，同样的，内部使用也是（数组 + 链表 + 红黑树）的结构来存储元素。同</summary>
      
    
    
    
    <category term="源码" scheme="https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="jdk" scheme="https://winniekun.github.io/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>kafka消费者整理</title>
    <link href="https://winniekun.github.io/kafka-consumer-note/"/>
    <id>https://winniekun.github.io/kafka-consumer-note/</id>
    <published>2021-07-02T08:32:01.000Z</published>
    <updated>2021-08-20T08:54:38.082Z</updated>
    
    
    
    
    <category term="中间件" scheme="https://winniekun.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="kafka" scheme="https://winniekun.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码解读</title>
    <link href="https://winniekun.github.io/threadlocal-analysis/"/>
    <id>https://winniekun.github.io/threadlocal-analysis/</id>
    <published>2021-05-27T13:21:59.000Z</published>
    <updated>2021-05-27T14:43:58.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>多线程共享可变数据时，涉及到线程见同步的问题，并不是所有的时候，都要用到共享数据，所以就需要线程封闭出场了。数据都被封闭在各自的线程之中，就不需要进行同步，这种通过将数据封闭在线程内而避免使用同步的技术称之为<strong>线程封闭</strong>。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>线程间数据隔离，各线程的 ThreadLocal 互不影响</li><li>方便同一个线程使用某一对象，避免不必要的参数传递</li><li>全链路追踪中的 traceId 或者流程引擎中上下文的传递一般采用 ThreadLocal</li><li>Spring 事务管理器采用了 ThreadLocal</li><li>Spring MVC 的 RequestContextHolder 的实现使用了 ThreadLocal</li></ul><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; THREAD_LOCAL = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; THREAD_LOCAL_NEXT = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> ThreadLocalDemo().threadLocalTest();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadLocalTest</span><span class="params">()</span> </span>{</span><br><span class="line">        THREAD_LOCAL.set(<span class="string">"wkk"</span>);</span><br><span class="line">        THREAD_LOCAL_NEXT.set(<span class="string">"cjsq"</span>);</span><br><span class="line">        String v = THREAD_LOCAL.get();</span><br><span class="line">        String v2 = THREAD_LOCAL_NEXT.get();</span><br><span class="line">        System.out.println(<span class="string">"子线程 执行前， "</span> + Thread.currentThread().getName() + <span class="string">"线程取到的值："</span> + v + <span class="string">" "</span> + v2);</span><br><span class="line"></span><br><span class="line">        Thread child = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                String v = THREAD_LOCAL.get();</span><br><span class="line">                String v2 = THREAD_LOCAL_NEXT.get();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"线程取到的值："</span> + v + v2);</span><br><span class="line">                <span class="comment">// 设置 threadLocal</span></span><br><span class="line">                THREAD_LOCAL.set(<span class="string">"hhh"</span>);</span><br><span class="line">                THREAD_LOCAL_NEXT.set(<span class="string">"cjpl"</span>);</span><br><span class="line">                v = THREAD_LOCAL.get();</span><br><span class="line">                v2 = THREAD_LOCAL_NEXT.get();</span><br><span class="line">                System.out.println(<span class="string">"重新设置之后，"</span> + Thread.currentThread().getName() + <span class="string">"线程取到的值为："</span> + v + <span class="string">" "</span> + v2);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"线程执行结束"</span>);</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"子线程"</span>);</span><br><span class="line">        child.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            child.join();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        v = THREAD_LOCAL.get();</span><br><span class="line">        v2 = THREAD_LOCAL_NEXT.get();</span><br><span class="line">        System.out.println(<span class="string">"子线程线程执行之后，"</span> + Thread.currentThread().getName() + <span class="string">"线程取到的值："</span> + v + <span class="string">" "</span> + v2);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>输出</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">子线程 执行前， main线程取到的值：wkk cjsq</span><br><span class="line">子线程线程取到的值：nullnull</span><br><span class="line">重新设置之后，子线程线程取到的值为：hhh cjpl</span><br><span class="line">子线程线程执行结束</span><br><span class="line">子线程线程执行之后，main线程取到的值：wkk cjsq</span><br></pre></td></tr></tbody></table></figure><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread类</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前threadlocal的hashcode</span></span><br><span class="line"><span class="comment">// 用于用于计算该ThreadLocal在线程的threadlocals（map）中的索引位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="comment">// hash表的阈值，黄金分割比</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"><span class="comment">// 保证了在一台机器中每个 ThreadLocal 的 threadLocalHashCode 是唯一的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">// 用于当前threadlocal的hashcode</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始话的操作</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// lambda的初始化实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="HashCode散列成果验证"><a href="#HashCode散列成果验证" class="headerlink" title="HashCode散列成果验证"></a>HashCode散列成果验证</h3><p>可以通过和String的hashcode做个对比，然后验证其使用这种方式的hash结果如何</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">32</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_idx</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> hashCode = <span class="number">0</span>;</span><br><span class="line">    Set&lt;Integer&gt; setThreadLocal = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; setNormal = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) {</span><br><span class="line">        hashCode = nextHashCode();</span><br><span class="line">        <span class="keyword">int</span> threadLocalHashCode = hashCode &amp; (SIZE - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> normalHashCode = String.valueOf(i).hashCode() &amp; (SIZE - <span class="number">1</span>);</span><br><span class="line">        setThreadLocal.add(threadLocalHashCode);</span><br><span class="line">        setNormal.add(normalHashCode);</span><br><span class="line">        System.out.println(i + <span class="string">" ThreadLocal的散列："</span> + threadLocalHashCode + <span class="string">" 普通散列："</span> + normalHashCode);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">double</span> threadLocalRate = setThreadLocal.size() / (<span class="keyword">double</span>)SIZE * <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">double</span> normalRate = setNormal.size() / (<span class="keyword">double</span>)SIZE * <span class="number">100</span>;</span><br><span class="line">    System.out.println(<span class="string">"ThreadLocal的散列："</span> + threadLocalRate + <span class="string">"% "</span> + <span class="string">" 普通散列："</span> + normalRate + <span class="string">"% "</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// ThreadLocal的散列：100.0%  普通散列：68.75%</span></span><br></pre></td></tr></tbody></table></figure><h3 id="形象理解"><a href="#形象理解" class="headerlink" title="形象理解"></a>形象理解</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210527191351975.png" alt="ThreadLocal形象理解" title="">                </div>                <div class="image-caption">ThreadLocal形象理解</div>            </figure><p>如果类比为HashMap的话，我们可以将<code>threadlocal</code>类比为<code>key</code>，然后<code>被封闭的数据</code>类比为<code>value</code>。不过稍微不同的是，hashmap中将<code>key</code>和<code>value</code>做映射的操作是<code>map.put(key, value)</code>，而<code>threadlocals</code>中，将<code>threadlocal</code>和<code>被封闭的数据</code>做映射的操作是<code>threadlocal.set(xxx)</code>。</p><h4 id="思路转换"><a href="#思路转换" class="headerlink" title="思路转换"></a>思路转换</h4><p>emmmm怎么说呢，就是我们使用普通map的时候，操作的是一个map，获取key的value时，直接通过map.get()即可。</p><p>但是我们使用threadlocal时，其本身是一个key，怎么获取对应的value呢？</p><ol><li>先获取map（每个线程独有的map，所以根据当前线程获取map）</li><li>然后通过map.get(key)获取value</li><li>返回value</li></ol><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">     * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">     * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">     * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">     * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>{</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) {</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  <span class="comment">// 下面的成员变量和hashmap同理</span></span><br><span class="line">  <span class="comment">// 初始化容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 存储ThreadLocal的键值对，长度为2的幂次</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of entries in the table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ThreadLocalMap就是一个map，和hashmap类似，不过有些机制不同。</p><ul><li>hash冲突解决方式<ol><li>ThreadLocalMap处理hash冲突的方式为线型探测</li><li>HashMap使用的是拉链法</li></ol></li></ul><h3 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h3><p>根据注释和代码，了解到了ThreadLocalMap内部的每个entry中，key设置为<strong>弱引用</strong>的原因，不过value还是正常的引用。这也就导致了如果ThreadLocal没有外部的强引用时，只要发生GC，就会被回收。这样ThreadMap中的key就变成了null，<strong>但是value被Entry引用，Entry被ThreadLocalMap引用，ThreadLocalMap被Thread引用，这也就说明了只要，线程不终止，value的值一直无法被回收，所以可能会出现内存泄漏的现象</strong></p><p>为了避免这种情况，在需要使用threadlocal之后，需要我们手动remove掉。防止 ThreadLocalMap 中 Entry 一直保持对 value 的强引用，导致 value 不能被回收</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>{</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据当前线程获取其map</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为使用的线型探测法</span></span><br><span class="line"><span class="comment">// 所以要采用线型探测法找到对应的位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>{</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 根据threadlocal获取其hashcode值</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) {</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) {</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>{</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) {</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) {</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) {</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>通过当前线程获取该线程的map</li><li>然后调用map.remove方法</li></ol><p>后续的代码分析不动了。。。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment"> * override this method, relying solely on the {<span class="doctag">@link</span> #initialValue}</span></span><br><span class="line"><span class="comment"> * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>{</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>set方法的作用是把我们想要存储的value给保存方法，只要流程是：</p><ol><li>先获取当亲的线程</li><li>根据当前线程获取该线程的map</li><li>判断map是否为空<ol><li>为空<ul><li>创建map</li></ul></li><li>不为空<ul><li>在map中放入元素</li></ul></li></ol></li></ol><h3 id="set-ThreadLcoal-lt-gt-key-Object-value"><a href="#set-ThreadLcoal-lt-gt-key-Object-value" class="headerlink" title="set(ThreadLcoal<?> key, Object value)"></a>set(ThreadLcoal&lt;?&gt; key, Object value)</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在map中存储键值对&lt;key, value&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>{</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 遍历一段连续的元素，以查找匹配的 ThreadLocal 对象</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) {</span><br><span class="line">        <span class="comment">// / 获取该哈希值处的ThreadLocal对象</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 键值ThreadLocal匹配，直接更改map中的value</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) {</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 若 key 是 null，说明 ThreadLocal 被清理了，直接替换掉</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) {</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 直到遇见了空槽也没找到匹配的ThreadLocal对象，那么在此空槽处安排ThreadLocal对象和缓存的value</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过这两种set方式，就更加证明了思路的转换，我们在set时，都需要先获取当前线程获取map，然后再对整个map遍历然后放入value、或者直接放入key、value</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>{</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) {</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据threadlocal获取entry</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>{</span><br><span class="line">    <span class="comment">// 计算hashcode，然后获取对应的索引位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 根据索引位置获取对应的entry</span></span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>{</span><br><span class="line">     T value = initialValue();</span><br><span class="line">     Thread t = Thread.currentThread();</span><br><span class="line">     ThreadLocalMap map = getMap(t);</span><br><span class="line">     <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">         map.set(<span class="keyword">this</span>, value);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         createMap(t, value);</span><br><span class="line">     <span class="keyword">return</span> value;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><ol><li>先获取当前线程</li><li>获取当前线程的map</li><li>map != null<ol><li>通过key直接获取对应entry</li><li>返回entry.value</li></ol></li><li>map == null<ol><li>初始化map</li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>threadlocal</code>本质属于某种map的一个key值，只不过该值通过泛型实现，支持各种类型。和基础的map不同的是，可以直接通过<code>key.set(value)</code>实现<code>key-value</code>的映射。而这种特殊的map是属于Thread级别的成员变量，多个线程之间该变量互不影响，所以这也就是我们所说的线程本地存储地方。不过需要注意的是，该key是虚引用，需要注意内存泄露的问题，所以在使用过threadlocal之后，记得及时remove。内部的threadlocalmap和hashmap的实现机制类似，不过区别就是对于hash冲突的解决方式为<strong>线型探测</strong></p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li>Java并发编程</li><li>面试官系统精讲Java源码及大厂真题</li><li>Java并发编程78讲</li><li><a href="https://benjaminwhx.com/2018/04/28/[%E7%BB%86%E8%B0%88Java%E5%B9%B6%E5%8F%91]%E8%B0%88%E8%B0%88ThreadLocal/" target="_blank" rel="noopener">【细谈Java并发】谈谈ThreadLocal</a></li><li><a href="https://www.cnblogs.com/wupeixuan/p/12638203.html" target="_blank" rel="noopener">一文搞懂 ThreadLocal 原理</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;多线程共享可变数据时，涉及到线程见同步的问题，并不是所有的时候，都要用到共享数据，所以就需要线程封闭出场了。数据都被封闭在各自的线程之中，就不需要进</summary>
      
    
    
    
    <category term="源码" scheme="https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="JDK源码" scheme="https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"/>
    
    <category term="lang" scheme="https://winniekun.github.io/tags/lang/"/>
    
  </entry>
  
  <entry>
    <title>死磕双指针</title>
    <link href="https://winniekun.github.io/stick-to-two-pointer/"/>
    <id>https://winniekun.github.io/stick-to-two-pointer/</id>
    <published>2021-05-27T09:10:30.000Z</published>
    <updated>2021-05-27T09:10:30.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>双指针，一个看了脑子里就有画面的算法技巧，主要方式有：</p><ol><li>快慢指针<ul><li>譬如链表环系列问题</li><li>获取链表的第K个节点<ul><li>应该也属于快慢指针吧</li><li>只不过是一个指针先移动一定步长，然后另一个两个指针再以同样的速度移动</li></ul></li></ul></li><li>头尾指针<ul><li>适用于数组和字符串</li><li>根据使用场景，用于优化遍历的时间复杂度</li></ul></li><li>滑动窗口</li></ol><h2 id="普通指针"><a href="#普通指针" class="headerlink" title="普通指针"></a>普通指针</h2><h3 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除有序数组中的重复项</a></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; j++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[j]) {</span><br><span class="line">                nums[++i] = nums[j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 通法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{   </span><br><span class="line">        <span class="keyword">return</span> process(nums, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) {</span><br><span class="line">            <span class="keyword">if</span> (idx &lt; k || nums[idx - k] != x) nums[idx++] = x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="80-删除有序数组中的重复项-II"><a href="#80-删除有序数组中的重复项-II" class="headerlink" title="80. 删除有序数组中的重复项 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">80. 删除有序数组中的重复项 II</a></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> process(nums, <span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) {</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; k || nums[idx - k] != x) {</span><br><span class="line">            nums[idx++] = x;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></h3><h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组</a></h3><p>归并排序的中的一个步骤</p><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>环系列</p><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) {</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></h3><h2 id="头尾指针"><a href="#头尾指针" class="headerlink" title="头尾指针"></a>头尾指针</h2><p>可以理解为对整个数组的暴力搜索的优化，正常情况下，是得到所有的区间k的子数组，然后一次计算结果。双指针之后，可以在遍历的过程就的出结果，避免的重复的遍历，并且优化的了遍历的时间复杂度</p><h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>{</span><br><span class="line">    <span class="comment">// 双指针(头尾指针)</span></span><br><span class="line">    <span class="keyword">int</span> N = height.length;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = N - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">        <span class="keyword">int</span> hight = Math.min(height[left], height[right]);</span><br><span class="line">        <span class="keyword">int</span> innerArea = hight * (right - left);</span><br><span class="line">        area = Math.max(area, innerArea);</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) {</span><br><span class="line">            left++;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) {</span><br><span class="line">    <span class="comment">// 思路</span></span><br><span class="line">    <span class="comment">// 核心思路：双指针 头尾指针</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">2</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> rst = -nums[i];</span><br><span class="line">        <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">            <span class="keyword">int</span> cur = nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span> (cur == rst) {</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(nums[i], nums[left], nums[right])));</span><br><span class="line">                <span class="comment">// 处理后序重复的元素</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left + <span class="number">1</span>] == nums[left]) {</span><br><span class="line">                    left++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) {</span><br><span class="line">                    right--;</span><br><span class="line">                }</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (cur &gt; rst) {</span><br><span class="line">                right--;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                left++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></h3><p>和上述类似，不过不用考虑元素重复问题，但是需要考虑最近，所以使用一个变量，用于检测当前结果是否比之前更好。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="comment">// 如何判断最近？</span></span><br><span class="line">    <span class="comment">// min(closest, curDistance)</span></span><br><span class="line">    <span class="keyword">int</span> closest = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>] + nums[nums.length - <span class="number">1</span>] + nums[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">2</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> low = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> height = N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; height) {</span><br><span class="line">            <span class="keyword">int</span> innerCur = nums[i] + nums[low] + nums[height];</span><br><span class="line">            <span class="keyword">if</span> (innerCur &lt; target) {</span><br><span class="line">                low++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (innerCur &gt; target) {</span><br><span class="line">                height--;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(innerCur - target) &lt; closest) {</span><br><span class="line">                closest = Math.abs(innerCur - target);</span><br><span class="line">                res = innerCur;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h3><p>同样的思路，不过可以做一些细节处理，提前退出循环。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) {</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; quadruplets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>) {</span><br><span class="line">        <span class="keyword">return</span> quadruplets;</span><br><span class="line">    }</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> length = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">3</span>; i++) {</span><br><span class="line">        <span class="comment">// 重复</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 不符合条件</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 结果小</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[length - <span class="number">3</span>] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length - <span class="number">2</span>; j++) {</span><br><span class="line">            <span class="comment">// 重复</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 不符合条件</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 太小</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] + nums[length - <span class="number">2</span>] + nums[length - <span class="number">1</span>] &lt; target) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> left = j + <span class="number">1</span>, right = length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == target) {</span><br><span class="line">                    quadruplets.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) {</span><br><span class="line">                        left++;</span><br><span class="line">                    }</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) {</span><br><span class="line">                        right--;</span><br><span class="line">                    }</span><br><span class="line">                    right--;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) {</span><br><span class="line">                    left++;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    right--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> quadruplets;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="259-较小的三数之和"><a href="#259-较小的三数之和" class="headerlink" title="259. 较小的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-smaller/" target="_blank" rel="noopener">259. 较小的三数之和</a></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumSmaller</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">2</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">            <span class="keyword">int</span> innerCur = nums[i] + nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span> (innerCur &lt; target) {</span><br><span class="line">                <span class="keyword">int</span> innerCount = right - left;</span><br><span class="line">                count += innerCount;</span><br><span class="line">                left++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                right--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30. 串联所有单词的子串"></a><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="noopener">30. 串联所有单词的子串</a></h3><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. 长度最小的子数组</a></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; N) {</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; sum &gt;= target) {</span><br><span class="line">            ans = Math.min(ans, right - left + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        }</span><br><span class="line">        right++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="713-乘积小于K的子数组"><a href="#713-乘积小于K的子数组" class="headerlink" title="713. 乘积小于K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-product-less-than-k/" target="_blank" rel="noopener">713. 乘积小于K的子数组</a></h3><p>双指针（滑动窗口）：left 和 right指针开始时均指向 nums数组的开头。</p><p>right指针遍历 nums数组，每遍历一个元素就更新一次乘积，即 product = product * nums[right]：</p><ul><li><p>若当前更新后的 product &lt; k，则直接统计当前窗口中的元素个数（<strong>这恰好就是当前子数组中符合条件的全部子集个数</strong>）</p><ul><li>我们每次都统计以nums[right]为结尾符合条件的子数组个数</li></ul></li><li><p>若更新后的 product &gt;= k，则此时需要缩小窗口的大小，即令当前 product 除以当前 left 指针指向的元素值，然后令 left指针右移一位，直到当前的 produc &lt; k 为止，然后统计当前窗口中的元素个数，即为此时符合条件的子数组的个数，继续令 right 指针右移。</p></li><li><p>如此反复，直到 right 指针指向 nums 数组的末尾为止。</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; N; right++) {</span><br><span class="line">        sum *= nums[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; sum &gt;= k) {</span><br><span class="line">            sum /= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        }</span><br><span class="line">        count += right - left + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;双指针，一个看了脑子里就有画面的算法技巧，主要方式有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;快慢指针&lt;ul&gt;
&lt;li&gt;譬如链表环系列问题&lt;/li&gt;
&lt;li&gt;获</summary>
      
    
    
    
    <category term="leetcode" scheme="https://winniekun.github.io/categories/leetcode/"/>
    
    
    <category term="双指针" scheme="https://winniekun.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>PriorityQueue源码解读</title>
    <link href="https://winniekun.github.io/PriorityQueue-analysis/"/>
    <id>https://winniekun.github.io/PriorityQueue-analysis/</id>
    <published>2021-05-22T12:00:56.000Z</published>
    <updated>2021-05-23T12:10:46.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PriorityQueue源码解读"><a href="#PriorityQueue源码解读" class="headerlink" title="PriorityQueue源码解读"></a>PriorityQueue源码解读</h2><a id="more"></a><p>优先队列, 顾名思义就是按照元素的优先级进行弹出等操作, 那么在JDK中使用何种数据结构来实现优先队列嘞, Let’s Go</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/PriorityQueue.png" alt="PriorityQueue" title="">                </div>                <div class="image-caption">PriorityQueue</div>            </figure><p>emmm, 感觉从依赖上来看, 和其他的集合类一样, 实现其对应的接口(Marker Interface的作用?)</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>在阅读基础的时候，我们需要先理解一下什么是堆，其数据结构是啥，有哪些存储方式。</p><ol><li>堆的底层数据结构为<strong>完全二叉树</strong></li><li>存储方式（既然是二叉树，那么其存储方式主要分为如下两种）<ol><li>顺序存储结构<ol><li>根节点下标为0</li><li>若节点p的下标为$i$，则左孩子$2\cdot i$ 右孩子为$2 \cdot i + 1$ </li><li>若节点p的下标为$i$，则父节点的下标为$\lfloor i/2\rfloor$</li></ol></li><li>链式存储结构</li></ol></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/02/26/lrUPGcnu1EvSwy8.png" alt="树的存储结构" title="">                </div>                <div class="image-caption">树的存储结构</div>            </figure><p>由上述的顺序存储结构可知，堆是用<strong>物理上的线性表示逻辑上的非线性的数据结构</strong></p><p>具体的关于堆的操作，如刚开始的建堆，以及插入元素，删除堆顶元素，迭代等操作，可自行百度。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始化容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 底层使用Object[]数组实现, 和ArrayList这些一样</span></span><br><span class="line"><span class="keyword">transient</span> Object[] queue; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">// 标记元素个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 比较器, 说明其实例均是可比较的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"><span class="comment">// 说明具有fast fail 机制</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></tbody></table></figure><p>因为底层使用的是数组，同时其本身是支持动态插入和删除的，所以同理，和<strong>ArrayList</strong>同理，扩容应该是其核心的地方。同时也要关注其是否生成新的数组对象。</p><blockquote><p>像ArrayList、HashMap中都有一个属性叫 <code>modCount</code>，每次对集合的修改这个值都会加1，在遍历前记录这个值到 <code>expectedModCount</code>中，遍历中检查两者是否一致，如果出现不一致就说明有修改，则抛出ConcurrentModificationException异常。</p></blockquote><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue()"></a>PriorityQueue()</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="PriorityQueue-int-initialCapacity"><a href="#PriorityQueue-int-initialCapacity" class="headerlink" title="PriorityQueue(int initialCapacity)"></a>PriorityQueue(int initialCapacity)</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="PriorityQueue-Comparator-lt-super-E-gt-comparator"><a href="#PriorityQueue-Comparator-lt-super-E-gt-comparator" class="headerlink" title="PriorityQueue(Comparator<? super E> comparator)"></a>PriorityQueue(Comparator&lt;? super E&gt; comparator)</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="PriorityQueue-int-initialCapacity-Comparator-lt-super-E-gt-comparator"><a href="#PriorityQueue-int-initialCapacity-Comparator-lt-super-E-gt-comparator" class="headerlink" title="PriorityQueue(int initialCapacity, Comparator<? super E> comparator)"></a>PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator)</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>{</span><br><span class="line">    <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">    <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>还有几个构造函数主要是用于将原各种类型的数据放入<code>PriorityQueue</code>中</p><h2 id="增-入队"><a href="#增-入队" class="headerlink" title="增(入队)"></a>增(入队)</h2><p>在阅读这些方法的时候, 想起来自己手撕算法的时候, 经常会记混<code>List</code>, <code>Stack</code>, <code>Queue</code>, <code>Map</code>这些的添加删除操作的API…</p><p>下面罗列的是个人觉得不错的代表数据结构特性的添加/删除操作的API</p><table><thead><tr><th align="left">数据结构</th><th>添加</th><th>删除</th></tr></thead><tbody><tr><td align="left">List/Set</td><td>add()</td><td>remove()</td></tr><tr><td align="left">Stack</td><td>push()</td><td>pop()</td></tr><tr><td align="left">Queue</td><td>offer()</td><td>poll()</td></tr><tr><td align="left">Map</td><td>put()</td><td>remove()</td></tr></tbody></table><p>用于入队的操作有<code>add</code>和<code>offer</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>{</span><br><span class="line">  <span class="comment">// 不支持null元素</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="comment">// 元素数量超过数组数量，引发扩容机制</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        <span class="comment">// 扩容机制先按下不表</span></span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 元素数量+1</span></span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 如果还没有元素</span></span><br><span class="line">    <span class="comment">// 直接插入到数组第一个位置</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则 插入到堆的最后一个元素</span></span><br><span class="line">        <span class="comment">// 然后再调整堆</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>宏观上来看, <code>offer()</code>方法会先检测是否需要扩容, 之后再插入元素, 最后进行调整, 最后调用<code>siftUp</code>进行调整。</p><h3 id="siftUp"><a href="#siftUp" class="headerlink" title="siftUp"></a>siftUp</h3><p>假设在数组queue的k位置插入元素key（小根堆）</p><ul><li>不断的比较key和k的父节点e （$queue\lfloor(k-1/2\rfloor)$）的关系<ol><li>若$key  &lt;  e$ ，则queue[k] = e, 同时k到达e的位置（parent）</li><li>若$key \geq e$ 或者  $k$已经到达跟节点，则结束循环</li></ol></li><li>$queue[k]==e$</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{</span><br><span class="line">    <span class="comment">// 判断比较策略</span></span><br><span class="line">    <span class="comment">// 1. X自身实现了Comparable接口，则通过comparable进行比较</span></span><br><span class="line">    <span class="comment">// 2. X自身未实现Comparable接口，通过自定义的外部比较器compartor比较</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">}</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    }</span><br><span class="line">    queue[k] = key;</span><br><span class="line">}</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    }</span><br><span class="line">    queue[k] = x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol><li>不允许null元素</li><li>插入元素前，先检测数组长度是否够用，不够进行扩容（扩容机制后续详细阐述）</li><li>在尾部插入元素，之后不断调整</li><li>通过调整的过程，可以知道PrioriryQueue默认是小根堆</li></ol><h2 id="删-出队"><a href="#删-出队" class="headerlink" title="删(出队)"></a>删(出队)</h2><p>出队有两个方法，<code>poll()</code>和<code>remove()</code>，实际上remove调用的还是poll。remove不存在的元素时会报错。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>{</span><br><span class="line">    E x = poll();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 获取当前最后一个元素</span></span><br><span class="line">    <span class="comment">// 并将最后一个位置置空</span></span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果弹出元素后还有元素</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//将队列末元素移到队列首</span></span><br><span class="line">        <span class="comment">// 再做自上而下的堆化</span></span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="siftDown"><a href="#siftDown" class="headerlink" title="siftDown"></a>siftDown</h3><p>自顶向下，选择小的节点，不断的比较、交换，直到：</p><ol><li>下标越界</li><li>节点的值同时小于等于左孩子和右孩子</li></ol><p>假设数组queue最后一个元素的值为key（小根堆），下标k从0开始，当k存在左孩子时，执行以下循环：</p><ul><li> 若k有右孩子，则比较左右孩子的值，然后选出小的孩子child</li><li>比较key和c=queue[child]的大小<ol><li>若$key \leq c$ 结束循环</li><li>若$key &gt; c$, 则$queue[k] = c, k = child$， 继续循环</li></ol></li><li> $queue[k] = key$</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{</span><br><span class="line">    <span class="comment">// 和 siftUp一样的思路</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">}</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{</span><br><span class="line">    <span class="comment">// 因为删除是从堆顶开始删除，所以和siftUp相反</span></span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) {</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    }</span><br><span class="line">    queue[k] = key;</span><br><span class="line">}</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) {</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    }</span><br><span class="line">    queue[k] = x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>将队列首元素弹出</li><li>将队列末元素移到队列首</li><li>自上而下堆化，一直往下与最小的子节点比较</li><li>如果比最小的子节点大，就交换位置，再继续与最小的子节点比较</li><li>如果比最小的子节点小，就不用交换位置了，堆化结束</li></ol><h2 id="获取队头元素"><a href="#获取队头元素" class="headerlink" title="获取队头元素"></a>获取队头元素</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>获取第一个元素的值。</p><h2 id="扩容策略"><a href="#扩容策略" class="headerlink" title="扩容策略"></a>扩容策略</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">    <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                     (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                     (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// 检查是否溢出</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>原数组空间大小&lt;64时，默认扩容为原先的两倍再加2个。。。</li><li>原数组空间大小&gt;64时，扩容为原先的1.5倍</li><li>最大容量空间为Integer.MAX_VALUE</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>PriorityQueue内部的数据结构是堆，堆使用的数据结构是完全二叉树，然后使用的是顺序存储结构（数组）</li><li>PriorityQueue默认是小根堆</li><li>堆保证堆顶元素为当前的最值，然后严格遵守字节点的值大于（小于）父节点的值</li><li>堆的删除操作从堆顶进行删除，然后会将最后的一个元素移至堆顶，此时堆的结构被破坏，所以需要执行siftDown</li><li>堆的插入操作从堆尾进行插入，此时堆的结构被破坏，所以需要执行siftUp</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;PriorityQueue源码解读&quot;&gt;&lt;a href=&quot;#PriorityQueue源码解读&quot; class=&quot;headerlink&quot; title=&quot;PriorityQueue源码解读&quot;&gt;&lt;/a&gt;PriorityQueue源码解读&lt;/h2&gt;</summary>
    
    
    
    <category term="源码" scheme="https://winniekun.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="JDK源码" scheme="https://winniekun.github.io/tags/JDK%E6%BA%90%E7%A0%81/"/>
    
    <category term="Queue" scheme="https://winniekun.github.io/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>https总结</title>
    <link href="https://winniekun.github.io/https-conclution/"/>
    <id>https://winniekun.github.io/https-conclution/</id>
    <published>2021-05-21T14:32:09.000Z</published>
    <updated>2021-06-21T16:37:07.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>引入一个新的概念的时候，必然先阐述其相关方面已有的实现有哪些缺点，新的概念解决了哪些缺点。所以～让我们看看HTTP有哪些却缺点</p><p><strong>缺点：</strong></p><ol><li>明文传输，传输信息容易被窃听 — <strong>窃听风险</strong></li><li>不验证通信方的身份，因此可能会遭遇伪装 — <strong>冒充风险</strong></li><li>无法验证报问的完整性，所以通信的信息可能已遭篡改 — <strong>篡改风险</strong><ol><li>譬如强行植入的广告信息</li></ol></li></ol><p>而HTTPS的出现就正好解决了上述的三个问题。对于窃听风险使用加密措施解决，对于冒充风险使用证书认证解决，对于篡改风险使用完整性保护解决（信息摘要算法）</p><h2 id="HTTPS概述"><a href="#HTTPS概述" class="headerlink" title="HTTPS概述"></a>HTTPS概述</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521144232642.png" alt="https" title="">                </div>                <div class="image-caption">https</div>            </figure><p>HTTPS其实就是<strong>http secure</strong>的意思。HTTP是应用层协议，位于HTTP协议之下是传输协议TCP。TCP负责传输，HTTP则定义了数据如何进行包装。所以HTTP传输给TCP什么样的数据包，其都会原样的发送个通讯方（仅仅将数据包分为了多个报报问段）。</p><blockquote><p>HTTP –&gt; TCP （明文传输）</p></blockquote><p>而HTTPS相对于HTTP有哪些不同呢？其实就是在HTTP和TCP中间加多了一层加密层<strong>TLS/SSL</strong>。</p><blockquote><p>通俗的讲，TLS、SSL其实是类似的东西，SSL是个加密套件，负责对HTTP的数据进行加密。TLS是SSL的升级版。现在提到HTTPS，加密套件基本指的是TLS。</p></blockquote><p>原先是应用层将数据直接给到TCP进行传输，现在改成应用层将数据给到TLS/SSL，将数据加密后，再给到TCP进行传输。如下图所示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521144940926.png" alt="https和http传输过程" title="">                </div>                <div class="image-caption">https和http传输过程</div>            </figure><p>所以HTTPS本身并不是应用层的一个新的协议，只是HTTP在和TCP进行交接的中间，又新增了一层SSL/TLS协议。所以HTTPS可以理解为披着SSL/TLS协议外壳的HTTP而已。</p><h2 id="HTTPS的加密—混合加密"><a href="#HTTPS的加密—混合加密" class="headerlink" title="HTTPS的加密—混合加密"></a>HTTPS的加密—混合加密</h2><p>首先需要了解<code>对称加密</code>、<code>非对称加密</code>的区别。我们知道实际对通信加密的是SSL/TLS层。SSL/TLS采用是混合加密的机制，也就是对称加密和非对称加密的混合。使用非对称加密传输安全传输对称加密的密钥，之后使用对称加密的密钥进行通信从而提高整体的通讯效率。</p><p>接下来结合WireShark抓包详细阐述TLS的加密流程，TLS 是建立在 TCP 基础上的，因此必定需要先三次 TCP 握手建立 TCP 连接，然后再是建立 TLS。</p><ol><li><strong>Client Hello</strong><ol><li><strong>Client Hello</strong> 报文：客户端对加密算法的支持度不同，因此需要向服务端发送客户端支持的 <strong>加密套件（Cipher Suite）</strong> ，同时还要生成一个 <strong>随机数</strong> 同时保存在客户端和发送给服务</li></ol></li><li><strong>Server Hello</strong><ol><li><strong>ServerCertificate</strong> 报文：服务端收到 Client Hello 之后，向客户端发送 <strong>CA 认证的数字证书</strong>，用来鉴别服务端身份信息，同时还要生成一个 <strong>随机数</strong> 同时保存在服务端和发送给客户端</li><li><strong>Server Hello Done</strong> 报文：表示服务端宣告第一阶段的客户端服务端握手协商结束</li><li>可选：<strong>Certificate Request</strong> 报文：必要情况下，要求客户端发送证书验证身份</li><li>可选：<strong>Server Key Exchange</strong> 报文：如果 CA 认证的数字证书提供的信息不够，服务端还可发送提供补充信息</li></ol></li><li><strong>Client Finish</strong><ol><li><strong>Client Key Exchange</strong> 报文：客户端收到 CA 数字证书并通过验证，然后通过 CA 公钥解密获取到 <strong>服务端公钥</strong>。Client Key Exchange 报文包括有一个随机数，这个随机数被称为 <strong>Pre-master key/secret</strong>；一个表示随后的信息使用双方协商好的加密方法和密钥发送的 <strong>通知</strong> ；还有一个通过协商好的 HASH 算法对前面所有信息内容的 <strong>HASH 计算值</strong>，用来提供服务端校验。<strong>这些信息都通过服务端公钥加密传送给服务端</strong></li><li><strong>ExchangeCipherSpec</strong> 报文：该报文通知服务端，此后的通信都将使用协商好的加密算法计算对称密钥进行加密通信（也就是使用两个随机数以及第三个 Pre-master key/secret 随机数一起算出一个对称密钥 <strong>session key/secret</strong>）</li><li><strong>Finished</strong> 报文：该报文包括连接至此的所有报文的校验值，使用已经生成的对称加密密钥加密</li><li>可选：<strong>ClientCertificate</strong> 报文：如果服务端请求，客户端需要发送 CA 数字证书</li><li>可选：<strong>CertificateVerify</strong> 报文：服务端如果要求 CA 数字证书，那么需要通过 HASH 算法计算一个服务端发送来的信息摘要</li></ol></li><li><strong>Server Finish</strong><ol><li>服务端先私钥得出<strong>Pre-master key</strong>， 同样使用这三个随机数得出对称加密密钥。服务端最后对客户端发送过来的 <strong>Finished</strong> 报文使用服务端对称密钥进行解密校验。</li><li><strong>ClientCipherSpec</strong> 报文：报文通知服务端，此后的通信都将使用协商好的加密算法计算对称密钥 session key/secret 进行加密通信</li><li><strong>Finished</strong> 报文：标志 TLS 连接建立成功</li></ol></li><li>TLS 握手成功此后通过对称密钥 session key/secret 加密通信</li></ol><blockquote><ol><li>握手：证书下发，密钥协商（这个阶段都是明文的）</li><li>数据传输：这个阶段才是加密的，用的就是握手阶段协商出来的对称密钥</li></ol></blockquote><p>进行整理，如下图所示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521215733187.png" alt="image-20210521215733187" title="">                </div>                <div class="image-caption">image-20210521215733187</div>            </figure><h3 id="使用wireshark实战证明"><a href="#使用wireshark实战证明" class="headerlink" title="使用wireshark实战证明"></a>使用wireshark实战证明</h3><p>本地地址和LeetCode-CN的交互</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521174931648.png" alt="wireshark抓包展示" title="">                </div>                <div class="image-caption">wireshark抓包展示</div>            </figure><ol><li><p>客户端想服务端发送https请求链接，同时将自身支持的密码套件（非对称加密算法、对称加密算法、摘要算法）发送个服务端</p><p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521181226105.png" alt="客户端say hello阶段"></p></li><li><p>服务端根据客户端获发送的数据，选择一套密码套件，以及自身的证书发送给客户端</p><p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521182242937.png" alt="服务端选择的密码套件--服务端say hello阶段"></p><p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521182508161.png" alt="服务端将自身的证书发送给客户端--- 服务端Say hello 阶段"></p></li><li><p>客户端进行验证，验证正常自后，随机生成一串数组作为后续通信的对称加密密钥，然后使用服务端证书的公钥进行加密，同时使用摘要算法对本次的会话信息进行加密，然后一并发送给服务端。</p><p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210521185850059.png" alt="image-20210521185850059"></p></li><li><p>服务端验证，正常之后，剩下的忘截图了，后面补上</p></li></ol><h2 id="HTTPS的认证—数字证书"><a href="#HTTPS的认证—数字证书" class="headerlink" title="HTTPS的认证—数字证书"></a>HTTPS的认证—数字证书</h2><p>了解了HTTPS加密通信的流程后，对于数据裸奔的疑虑应该基本打消了。然而，还有一个问题：如何确保证书时可信的？</p><p>证书不可信可能有两种情况：</p><ol><li>证书是伪造的：压根不是CA颁发的</li><li>证书被篡改过：比如将XX网站的公钥给替换了</li></ol><p>数字证书是由权威的CA（Certificate Authority）机构给服务端进行颁发，CA机构通过服务端提供的相关信息生成证书，证书内容包含了<code>持有人的相关信息</code>，<code>服务器的公钥</code>，<code>签署者签名信息（数字签名）</code>等，最重要的是<strong>公钥在数字证书中</strong>。</p><blockquote><p>数字签名和摘要算法的关系</p><p>明文 –&gt; hash运算 –&gt; 摘要 –&gt; 私钥加密 –&gt; 数字签名</p></blockquote><p>数字证书是如何保证公钥来自请求的服务器？</p><ul><li>数字证书上由持有人的相关信息，通过这点可以确定其不是一个中间人</li></ul><p><strong>证书包含的内容：</strong></p><ul><li>一个证书中含有三个部分:<code>证书内容</code>，<code>散列算法</code>，<code>加密密文</code>，证书内容会被散列算法hash计算出摘要，然后使用CA机构提供的私钥进行RSA加密得到数组签名（加密密文）。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Users/weikunkun/Library/Application" alt="证书内容" title="Support/typora-user-images/image-20210521221149447.png">                </div>                <div class="image-caption">Support/typora-user-images/image-20210521221149447.png</div>            </figure><h3 id="证书伪造"><a href="#证书伪造" class="headerlink" title="证书伪造"></a>证书伪造</h3><p>浏览器内置的CA的根证书包含了<strong>CA的公钥</strong></p><ol><li>证书颁发的机构是伪造的：浏览器不认识，直接认为是危险证书</li><li>证书颁发的机构是确实存在的，于是根据CA名，找到对应内置的CA根证书、CA的公钥。</li><li>用CA的公钥，对伪造的证书的摘要进行解密，发现解不了。认为是危险证书</li></ol><h3 id="证书篡改"><a href="#证书篡改" class="headerlink" title="证书篡改"></a>证书篡改</h3><ol><li>根据证书的加密密文（数字签名）使用CA的公钥得到证书摘要A</li><li>根据证书内容使用摘要算法得到证书摘要B</li><li>对比摘要A和摘要B是否相同</li></ol><h2 id="HTTPS的完整性保护—摘要算法"><a href="#HTTPS的完整性保护—摘要算法" class="headerlink" title="HTTPS的完整性保护—摘要算法"></a>HTTPS的完整性保护—摘要算法</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li>图解HTTP</li><li>趣谈协议—极客时间</li><li><a href="https://security.stackexchange.com/questions/89383/why-does-the-ssl-tls-handshake-have-a-client-and-server-random" target="_blank" rel="noopener">Why does the SSL/TLS handshake have a client and server random</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;引入一个新的概念的时候，必然先阐述其相关方面已有的实现有哪些缺点，新的概念解决了哪些缺点。所以～让我们看看HTTP有哪些却缺点&lt;/p&gt;
&lt;p&gt;&lt;st</summary>
      
    
    
    
    <category term="网络" scheme="https://winniekun.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="应用层" scheme="https://winniekun.github.io/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Spring IoC解读</title>
    <link href="https://winniekun.github.io/spring-ioc-analysis/"/>
    <id>https://winniekun.github.io/spring-ioc-analysis/</id>
    <published>2021-05-21T01:24:20.000Z</published>
    <updated>2021-07-24T07:46:15.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p>IoC控制反转，意思就是将创建对象的控制权从我们自己硬编码来new一个对象反转到了第三方身上。IoC的主要实现方式是依赖注入，Spring中的依赖注入方式有：<code>构造方法注入</code>、<code>settter注入</code>、<code>接口注入</code>。</p><ul><li><strong>控制反转</strong>是一种思想</li><li><strong>依赖注入</strong>是一种设计模式</li></ul><blockquote><p>IoC是一种可以帮助我们解耦各业务对象间依赖关系的对象绑定方式</p></blockquote><h2 id="IoC-Service-Provider"><a href="#IoC-Service-Provider" class="headerlink" title="IoC Service Provider"></a>IoC Service Provider</h2><p>虽然业务对象可以通过IoC方式声明相应的依赖，但是最终仍然需要通过某个角色或者服务将这些依赖的对象绑定到一起。而IoC Service Provider就对应IoC场景中的这一角色。IoC Service Provider在这里是一个抽象出来的概念，它可以指代任何将IoC场景中的业务对象绑定到一起的实现方式。它可以是一段代码，也可以是一组相关的类，甚至可以是比较通用的IoC框架或 者IoC容器实现。</p><h3 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h3><ol><li><p>业务对象的构建管理</p><p>IoC中，业务对象无需关心所依赖注入的对象<strong>如何构建如何取得</strong>，但是这部分的工作还是需要有人来做的。所以<code>IoC Service Provider</code>需要将对象的构建逻辑从<em>客户端</em>对象那里抽离出来，一面这部分逻辑污染业务对象的实现。</p><blockquote><p><strong>客户端</strong>：代使用某个对象或者某种服务的对象。如果对象A需要引用对象B，那么A就是B的客户端对象，而不管A 处于Service层还是数据访问层。</p></blockquote></li><li><p>业务对象之间的依赖绑定</p><p>最艰巨也是最重要的，这 是它的最终使命之所在。如果不能完成这个职责，那么，无论业务对象如何的“呼喊”，也不 会得到依赖对象的任何响应(最常见的倒是会收到一个NullPointerException)。<code>IoC Service Provider</code>通过结合之前构建和管理的所有业务对象，以及各个业务对象间可以识别的依赖关系，将这些对象所依赖的对象注入绑定，从而保证每个业务对象在使用的时候，可以处于就绪状 态。</p></li></ol><h2 id="Spring-IoC容器"><a href="#Spring-IoC容器" class="headerlink" title="Spring IoC容器"></a>Spring IoC容器</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210520140010820.png" alt="image-20210520140010820" title="">                </div>                <div class="image-caption">image-20210520140010820</div>            </figure><p>Spring的IoC容器就是一个IoC Provider，但是其相比于IoC Provider的功能更加的丰富，除了业务对象的构建、依赖关系的绑定这种IoC Provider的基本功能，还新增了业务对象声明周期的管理，AOP支持等。同时Spring提供了两种容器类型:BeanFactory和ApplicationContext。</p><ul><li><p>BeanFactory</p><p>基础类型IoC容器，提供完整的IoC服务支持。如果没有特殊指定，==默认采用延迟初始化策略(lazy-load)==。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的 IoC容器选择。</p></li><li><p>ApplicationContext</p><p>在BeanFactory的基础上构建，是相对比较高 级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。ApplicationContext所管理 的对象，在该类型容器启动之后，==默认全部初始化并绑定完成==。所以，相对于BeanFactory来 说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中， ApplicationContext类型的容器是比较合适的选择。</p></li></ul><h3 id="简单的式例"><a href="#简单的式例" class="headerlink" title="简单的式例"></a>简单的式例</h3><h3 id="Spring-IoC容器的一些特性简介"><a href="#Spring-IoC容器的一些特性简介" class="headerlink" title="Spring IoC容器的一些特性简介"></a>Spring IoC容器的一些特性简介</h3><h4 id="autowire"><a href="#autowire" class="headerlink" title="autowire"></a>autowire</h4><p>自动注入，通过autowire，我们可以略去很多人工显示的配置bean的操作，被依赖的发现和注入都交给了Spring，同时其有几个类型可选择，比如byName、byType等。</p><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><p>BeanFactory和FactoryBean傻傻分不清？虽然两者类似，但是功能不同。FactoryBean是一种工厂Bean，和普通的Bean不一样，FactoryBean是可以生产Bean的Bean。</p><h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends-on"></a>depends-on</h4><p>当一个 bean 直接依赖另一个 bean，可以使用 <code>&lt;ref/&gt;</code> 标签进行配置。不过如某个 bean 并不直接依赖于其他 bean，但又需要其他 bean 先实例化好，这个时候就需要使用 depends-on 特性了。depends-on 特性比较简单，就不演示了。仅贴一下配置文件的内容，如下：</p><p>这里有两个简单的类，其中 Hello 需要 World 在其之前完成实例化。相关配置如下：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"xyz.coolblog.depnedson.Hello"</span> <span class="attr">depends-on</span>=<span class="string">"world"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"world"</span> <span class="attr">class</span>=<span class="string">"xyz.coolblog.depnedson.World"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h4><p>BeanPostProcessor 是 bean 实例化时的后置处理器，包含两个方法，其源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>{</span><br><span class="line">    <span class="comment">// bean 初始化前的回调方法</span></span><br><span class="line">    <span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bean 初始化后的回调方法    </span></span><br><span class="line">    <span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>BeanPostProcessor是Spring框架的一个扩展点，可以通过BeanPostProcessor接口，我们能够插手Bean的实例化过程，比如AOP就是在bean实例将切面逻辑织入bean实例中，AOP也是正是通过BeanPostProcessor和IoC容器建立了联系</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>{</span><br><span class="line">        log.info(<span class="string">"Before  "</span> + beanName + <span class="string">" Initialization"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>{</span><br><span class="line">        log.info(<span class="string">"After  "</span> + beanName + <span class="string">" Initialization"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="配置如下"><a href="#配置如下" class="headerlink" title="配置如下"></a><strong>配置如下</strong></h5><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.titizz.simulation.toyspring.learninng.LoggerBeanPostProcessor"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"com.titizz.simulation.toyspring.Car"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h5 id="测试如下"><a href="#测试如下" class="headerlink" title="测试如下"></a><strong>测试如下</strong></h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanPostProcessor</span><span class="params">()</span> </span>{</span><br><span class="line">    String xmlPath = <span class="string">"test-spring.xml"</span>;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(xmlPath);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2021/05/02/iUgIOGvfmPo1ws5.png" alt="image-20210502181644978" title="">                </div>                <div class="image-caption">image-20210502181644978</div>            </figure><h3 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h3><h4 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h4><p>以 <code>Resource</code> 接口为核心发散出的几个类，都是用于解决 IoC 容器中的内容从哪里来的问题，也就是 <strong>配置文件从哪里读取、配置文件如何读取</strong> 的问题。</p><table><thead><tr><th align="left">类名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>Resource</code></td><td align="left">接口，标识一个外部资源。通过 <code>getInputStream()</code> 方法 <strong>获取资源的输入流</strong> 。</td></tr><tr><td align="left"><code>UrlResource</code></td><td align="left">实现 <code>Resource</code> 接口的资源类，通过 URL 获取资源。</td></tr><tr><td align="left"><code>ResourceLoader</code></td><td align="left">资源加载类。通过 <code>getResource(String)</code> 方法获取一个 <code>Resouce</code> 对象，是 <strong>获取 <code>Resouce</code> 的主要途径</strong> 。</td></tr></tbody></table><h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><p><strong>功能：</strong>用于解决Bean的定义问题，包括Bean的名字，类型以及它的属性赋予了什么值或者引用。说白了也就是<strong>解决了在IoC容器中定义一个Bean，使得IoC容器可以根据这个定义来生成实例。</strong></p><table><thead><tr><th align="left">类名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>BeanDefinition</code></td><td align="left">该类保存了 <code>Bean</code> 定义。包括 <code>Bean</code> 的 <strong>名字</strong> <code>String beanClassName</code>、<strong>类型</strong> <code>Class beanClass</code>、<strong>属性</strong> <code>PropertyValues propertyValues</code>。根据其 <strong>类型</strong> 可以生成一个类实例，然后可以把 <strong>属性</strong> 注入进去。<code>propertyValues</code> 里面包含了一个个 <code>PropertyValue</code> 条目，每个条目都是键值对 <code>String</code> - <code>Object</code>，分别对应要生成实例的属性的名字与类型。在 Spring 的 XML 中的 <code>property</code> 中，键是 <code>key</code> ，值是 <code>value</code> 或者 <code>ref</code>。对于 <code>value</code> 只要直接注入属性就行了，但是 <code>ref</code> 要先进行解析。<code>Object</code> 如果是 <code>BeanReference</code> 类型，则说明其是一个引用，其中保存了引用的名字，需要用先进行解析，转化为对应的实际 <code>Object</code>。</td></tr><tr><td align="left"><code>BeanDefinitionReader</code></td><td align="left">解析 <code>BeanDefinition</code> 的接口。通过 <code>loadBeanDefinitions(String)</code> 来从一个地址加载类定义。</td></tr><tr><td align="left"><code>AbstractBeanDefinitionReader</code></td><td align="left">实现 <code>BeanDefinitionReader</code> 接口的抽象类（未具体实现 <code>loadBeanDefinitions</code>，而是规范了 <code>BeanDefinitionReader</code> 的基本结构）。内置一个 <code>HashMap rigistry</code>，用于保存 <code>String</code> - <code>beanDefinition</code> 的键值对。内置一个 <code>ResourceLoader resourceLoader</code>，用于保存类加载器。用意在于，使用时，只需要向其 <code>loadBeanDefinitions()</code> 传入一个资源地址，就可以自动调用其类加载器，并把解析到的 <code>BeanDefinition</code> 保存到 <code>registry</code> 中去。</td></tr><tr><td align="left"><code>XmlBeanDefinitionReader</code></td><td align="left">具体实现了 <code>loadBeanDefinitions()</code> 方法，从 XML 文件中读取类定义。</td></tr></tbody></table><h4 id="BeanFactory-question"><a href="#BeanFactory-question" class="headerlink" title="BeanFactory :question:"></a>BeanFactory <span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>以 <code>BeanFactory</code> 接口为核心发散出的几个类，都是用于解决 IoC 容器在 <strong>已经获取 <code>Bean</code> 的定义的情况下，如何装配、获取 <code>Bean</code> 实例</strong> </p><p>的问题。</p><table><thead><tr><th align="left">类名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>BeanFactory</code></td><td align="left">接口，标识一个 IoC 容器。通过 <code>getBean(String)</code> 方法来 <strong>获取一个对象</strong></td></tr><tr><td align="left"><code>AbstractBeanFactory</code></td><td align="left"><code>BeanFactory</code> 的一种抽象类实现，规范了 IoC 容器的基本结构，但是把生成 <code>Bean</code> 的具体实现方式留给子类实现。IoC 容器的结构：<code>AbstractBeanFactory</code> 维护一个 <code>beanDefinitionMap</code> 哈希表用于保存类的定义信息（<code>BeanDefinition</code>）。获取 <code>Bean</code> 时，如果 <code>Bean</code> 已经存在于容器中，则返回之，否则则调用 <code>doCreateBean</code> 方法装配一个 <code>Bean</code>。（所谓存在于容器中，是指容器可以通过 <code>beanDefinitionMap</code> 获取 <code>BeanDefinition</code> 进而通过其 <code>getBean()</code> 方法获取 <code>Bean</code>。）</td></tr><tr><td align="left"><code>AutowireCapableBeanFactory</code></td><td align="left">可以实现自动装配的 <code>BeanFactory</code>。在这个工厂中，实现了 <code>doCreateBean</code> 方法，该方法分三步：1，通过 <code>BeanDefinition</code> 中保存的类信息实例化一个对象；2，把对象保存在 <code>BeanDefinition</code> 中，以备下次获取；3，为其装配属性。装配属性时，通过 <code>BeanDefinition</code> 中维护的 <code>PropertyValues</code> 集合类，把 <code>String</code> - <code>Value</code> 键值对注入到 <code>Bean</code> 的属性中去。如果 <code>Value</code> 的类型是 <code>BeanReference</code> 则说明其是一个引用（对应于 XML 中的 <code>ref</code>），通过 <code>getBean</code> 对其进行获取，然后注入到属性中。</td></tr></tbody></table><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>以 <code>ApplicationContext</code> 接口为核心发散出的几个类，主要是对前面 <code>Resouce</code> 、 <code>BeanFactory</code>、<code>BeanDefinition</code> 进行了功能的封装，解决 <strong>根据地址获取 IoC 容器并使用</strong> 的问题。</p><table><thead><tr><th align="left">类名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>ApplicationContext</code></td><td align="left">标记接口，继承了 <code>BeanFactory</code>。通常，要实现一个 IoC 容器时，需要先通过 <code>ResourceLoader</code> 获取一个 <code>Resource</code>，其中包括了容器的配置、<code>Bean</code> 的定义信息。接着，使用 <code>BeanDefinitionReader</code> 读取该 <code>Resource</code> 中的 <code>BeanDefinition</code> 信息。最后，把 <code>BeanDefinition</code> 保存在 <code>BeanFactory</code> 中，容器配置完毕可以使用。注意到 <code>BeanFactory</code> 只实现了 <code>Bean</code> 的 <strong>装配、获取</strong>，并未说明 <code>Bean</code> 的 <strong>来源</strong> 也就是 <code>BeanDefinition</code> 是如何 <strong>加载</strong> 的。该接口把 <code>BeanFactory</code> 和 <code>BeanDefinitionReader</code> 结合在了一起。</td></tr><tr><td align="left"><code>AbstractApplicationContext</code></td><td align="left"><code>ApplicationContext</code> 的抽象实现，内部包含一个 <code>BeanFactory</code> 类。主要方法有 <code>getBean()</code> 和 <code>refresh()</code> 方法。<code>getBean()</code> 直接调用了内置 <code>BeanFactory</code> 的 <code>getBean()</code> 方法，<code>refresh()</code> 则用于实现 <code>BeanFactory</code> 的刷新，也就是告诉 <code>BeanFactory</code> 该使用哪个资源（<code>Resource</code>）加载类定义（<code>BeanDefinition</code>）信息，该方法留给子类实现，用以实现 <strong>从不同来源的不同类型的资源加载类定义</strong> 的效果。</td></tr><tr><td align="left">ClassPathXmlApplicationContext</td><td align="left">从类路径加载资源的具体实现类。内部通过 <code>XmlBeanDefinitionReader</code> 解析 <code>UrlResourceLoader</code> 读取到的 <code>Resource</code>，获取 <code>BeanDefinition</code> 信息，然后将其保存到内置的 <code>BeanFactory</code> 中。</td></tr></tbody></table><blockquote><p>对 <code>ApplicatinoContext</code> 的分层更为细致。<code>AbstractApplicationContext</code> 中为了实现 <strong>不同来源</strong> 的 <strong>不同类型</strong> 的资源加载类定义，把这两步分层实现。以“从类路径读取 XML 定义”为例，首先使用 <code>AbstractXmlApplicationContext</code> 来实现 <strong>不同类型</strong> 的资源解析，接着，通过 <code>ClassPathXmlApplicationContext</code> 来实现 <strong>不同来源</strong> 的资源解析。</p></blockquote><h1 id="战略观望"><a href="#战略观望" class="headerlink" title="战略观望"></a>战略观望</h1><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210520110056368.png" alt="官网示例" style="zoom:50%;"><p><img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210520105808650.png" alt="Spring容器功能实现的各个阶段"></p><h2 id="容器启动阶段"><a href="#容器启动阶段" class="headerlink" title="容器启动阶段"></a>容器启动阶段</h2><p>使用Resource相关接口标识我们配置文件从哪里获取，然后使用BeanDefinitionReader对标识的文件进行解析，将分析后的信息编组为相应的BeanDefinition。最后将保存了每个Bean定义信息的BeanDefinition，注册到相应的BeanDefinitionRegistry，这样容器的启动就完成了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210520110900263.png" alt="启动阶段任务" title="">                </div>                <div class="image-caption">启动阶段任务</div>            </figure><h2 id="Bean实例化阶段"><a href="#Bean实例化阶段" class="headerlink" title="Bean实例化阶段"></a>Bean实例化阶段</h2><p>通过容器的启动阶段，现在所有的Bean定义的信息，都通过BeanDefiniton的方式注册到了BeanDefinitionRegistry中，当某个请求方通过容器的getBean方法明确的调用某个对象的时候，或者因为依赖关系容器需要隐式的调用getBean方法，就会出发第二阶段的活动。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/image-20210520150106541.png" alt="bean的实例化过程" title="">                </div>                <div class="image-caption">bean的实例化过程</div>            </figure><p>Spring容器将对其所管理的对象全部给予统一的生命周期管理，这些被管理的对象完全摆脱了原 来那种“new完后被使用，脱离作用域后即被回收”的命运</p><h1 id="详细阐述"><a href="#详细阐述" class="headerlink" title="详细阐述"></a>详细阐述</h1><h2 id="最简单的IoC容器"><a href="#最简单的IoC容器" class="headerlink" title="最简单的IoC容器"></a>最简单的IoC容器</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>{</span><br><span class="line">  <span class="comment">// 说白了就是一个map</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; beanMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(String name, Object bean)</span> </span>{</span><br><span class="line">beanMap.put(name, bean);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> beanMap.get(name);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBeanContainerTest</span> </span>{</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">// 需要我们去手动new依赖对象，然后放入</span></span><br><span class="line">BeanFactory beanFactory = <span class="keyword">new</span> BeanFactory();</span><br><span class="line">beanFactory.registerBean(<span class="string">"helloService"</span>, <span class="keyword">new</span> HelloService());</span><br><span class="line">HelloService helloService = (HelloService) beanFactory.getBean(<span class="string">"helloService"</span>);</span><br><span class="line">assertThat(helloService).isNotNull();</span><br><span class="line">assertThat(helloService.sayHello()).isEqualTo(<span class="string">"hello"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>{</span><br><span class="line">System.out.println(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="BeanFactoryPostProcess和BeanPostProcessor"><a href="#BeanFactoryPostProcess和BeanPostProcessor" class="headerlink" title="BeanFactoryPostProcess和BeanPostProcessor"></a>BeanFactoryPostProcess和BeanPostProcessor</h2><p>BeanFactoryPostProcess和BeanPostProcessor是spring框架中具有重量级地位的两个接口，理解了这两个接口的作用，基本就理解spring的核心原理了</p><ol><li>BeanFactoryPostProcessor是spring提供的容器拓展机制，允许我们在<strong>bean实例化之前修改bean的定义信息（BeanDedinition）</strong>，其重要的实现类PropertyPlaceholderConfigurer和CustomEditorConfigurer<ul><li>PropertyPlaceholderConfigurer的作用是用properties文件的配置值替换xml文件中的占位符</li><li>CustomEditorConfigurer的作用是实现类型转换。</li></ul></li><li>BeanPostProcessor也是spring提供的容器拓展机制，不同于BeanFactoryPostProcessor，BeanPostProcesssor在<strong>Bean实例化之后修改Bean或替换Bean</strong>。也是实现AOP的关键。</li></ol><p>等等等。。。</p><h2 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a>整体流程图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.jsdelivr.net/gh/Winniekun/cloudImg@master/uPic/iShot2021-05-21%2000.08.58.png" alt="整体流程图" title="">                </div>                <div class="image-caption">整体流程图</div>            </figure><ol><li>BeanDefinitionReader读取Bean的相关配置信息，并将读取到的信息使用BeanDefinition表示，同时注册到BeanDefinitionRegistry中。</li><li>通过实现了BeanFactoryPostProcessor的类，自定义修改BeanDefinition中的信息</li><li>Bean的实例化<ol><li>采用策略模式，策略化Bean的实例，共包含两种方式：cglib、反射</li><li>获取Bean的实例之后，根据BeanDefinition中的信息，填充Bean的属性、依赖</li></ol></li><li>检测各种检测各种Aware接口，并放入Bean中</li><li>调用BeanPostProcessor接口的前置处理方法，处理符合要求的Bean实例</li><li>如果实现了InitializingBean接口，则处理对应的afterPropertiesSet()方法</li><li>如果定义init-method方法，处理对应的初始化方法</li><li>调用BeanPostProcessor接口的后置处理方法，处理符合要求的Bean实例</li><li>使用</li><li>判断Bean的Scope，如果是prototype，不再管理</li><li>如果是单例，如果实现了DisposableBean接口，则执行对应的destroy方法</li><li>如果定义了destory-method，则执行自定义的销毁方法</li></ol><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>整理的还是很乱，虽然看的时候是都看了。。。</p><p>后面慢慢优化吧（涉及到以后==永远不会）<span class="github-emoji"><span>😑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f611.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><ul><li>spring揭秘</li><li><a href="https://github.com/code4craft/tiny-spring" target="_blank" rel="noopener">tiny-spring</a></li><li><a href="https://github.com/DerekYRC/mini-spring/blob/main/changelog.md#Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%AD%96%E7%95%A5InstantiationStrategy" target="_blank" rel="noopener">mini-spring</a></li><li><a href="https://www.zybuluo.com/dugu9sword/note/382745#beanfactory" target="_blank" rel="noopener">tiny-spring分析</a></li><li><a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noopener">Spring IoC容器分析</a></li><li><a href="http://www.tianxiaobo.com/2018/05/30/Spring-IOC-%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/#451-%E5%AE%9E%E7%8E%B0-applicationcontextaware-%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">Spring IOC 容器源码分析系列</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h1&gt;&lt;h2 id=&quot;IoC&quot;&gt;&lt;a href=&quot;#IoC&quot; class=&quot;headerlink&quot; title=&quot;IoC&quot;&gt;&lt;/a&gt;IoC&lt;/h2&gt;&lt;p&gt;IoC</summary>
      
    
    
    
    <category term="spring" scheme="https://winniekun.github.io/categories/spring/"/>
    
    
    <category term="ioc" scheme="https://winniekun.github.io/tags/ioc/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="https://winniekun.github.io/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://winniekun.github.io/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2021-04-30T13:35:01.000Z</published>
    <updated>2021-06-17T04:51:19.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>先选择分界点</li><li>先递归排序</li><li>归并 合二为一</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Users/weikunkun/Library/Application" alt="image-20210419120203122" title="Support/typora-user-images/image-20210419120203122.png">                </div>                <div class="image-caption">Support/typora-user-images/image-20210419120203122.png</div>            </figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(array, l, mid);</span><br><span class="line">        mergeSort(array, mid+<span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// 整合</span></span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>]; <span class="comment">// 临时数组, 用于临时存储 [l,r]区间内排好序的数据</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;  <span class="comment">// 两个指针</span></span><br><span class="line">        <span class="comment">// 进行归并</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) {</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt;= array[j]) </span><br><span class="line">                tmp[k++] = array[i++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tmp[k++] = array[j++];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = array[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r) tmp[k++] = array[j++];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进行赋值</span></span><br><span class="line">        <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">            array[i] = tmp[j];</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h2&gt;&lt;h3 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h</summary>
      
    
    
    
    <category term="排序" scheme="https://winniekun.github.io/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="归并排序" scheme="https://winniekun.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>死磕数学基础</title>
    <link href="https://winniekun.github.io/stick-to-math/"/>
    <id>https://winniekun.github.io/stick-to-math/</id>
    <published>2021-04-20T11:56:11.000Z</published>
    <updated>2021-05-16T16:42:07.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LeetCode死磕系列十二： 数学基础</p><p>说实话，其实都是刷题都是数学的实现，不过感觉有些题目更加偏向数学应用，譬如蓄水池，等概率抽样…。</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="470-用rand7-实现Rand10"><a href="#470-用rand7-实现Rand10" class="headerlink" title="470 用rand7()实现Rand10()"></a>470 用rand7()实现Rand10()</h3><p><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/cong-zui-ji-chu-de-jiang-qi-ru-he-zuo-dao-jun-yun-/" target="_blank" rel="noopener">从最基础的讲起如何做到均匀的生成随机数</a></p><p>从上述的文章可以得出：</p><blockquote><p><strong>已知:</strong>  <em>$randN()$可以==等概率==生成$[1, N]$范围的数字</em><br><strong>那么:</strong>  $(randN()-1) \times Y  + randY()$可以==等概率==生成$[1, Y \times N]$ 范围的数字</p><p><strong>即：</strong>实现了$randNY()$</p></blockquote><p>以$[(rand9() - 1) \times 7 + rand7()]$为例子</p><table><thead><tr><th>rand9()-1\rand7</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td><strong>0</strong></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td><strong>1</strong></td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td></tr><tr><td><strong>2</strong></td><td>15</td><td>16</td><td>17</td><td>18</td><td>19</td><td>20</td><td>21</td></tr><tr><td><strong>3</strong></td><td>22</td><td>23</td><td>24</td><td>25</td><td>26</td><td>27</td><td>28</td></tr><tr><td><strong>4</strong></td><td>29</td><td>30</td><td>31</td><td>32</td><td>33</td><td>34</td><td>35</td></tr><tr><td><strong>5</strong></td><td>36</td><td>37</td><td>38</td><td>39</td><td>40</td><td>41</td><td>42</td></tr><tr><td><strong>6</strong></td><td>43</td><td>44</td><td>45</td><td>46</td><td>47</td><td>48</td><td>49</td></tr><tr><td><strong>7</strong></td><td>50</td><td>51</td><td>52</td><td>53</td><td>54</td><td>55</td><td>56</td></tr><tr><td><strong>8</strong></td><td>57</td><td>58</td><td>59</td><td>60</td><td>61</td><td>62</td><td>63</td></tr></tbody></table><p><strong>是不是很神奇，数学证明不会</strong></p><p>那么想到通过rand4()来实现rand2()呢？这个就很简单了，已知rand4()会均匀产生[1,4]的随机数，通过取余，再加1就可以了。如下所示，结果也是等概率的。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rand4() % 2 + 1 = ?</span><br><span class="line">   1 % 2    + 1 = 2</span><br><span class="line">   2 % 2    + 1 = 1</span><br><span class="line">   3 % 2    + 1 = 2</span><br><span class="line">   4 % 2    + 1 = 1</span><br></pre></td></tr></tbody></table></figure><p>事实上，只要rand_N()中N是2的倍数，就都可以用来实现rand2()，反之，若N不是2的倍数，则产生的结果不是等概率的。比如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rand6() % 2 + 1 = ?</span><br><span class="line">   1 % 2    + 1 = 2</span><br><span class="line">   2 % 2    + 1 = 1</span><br><span class="line">   3 % 2    + 1 = 2</span><br><span class="line">   4 % 2    + 1 = 1</span><br><span class="line">   5 % 2    + 1 = 2</span><br><span class="line">   6 % 2    + 1 = 1</span><br><span class="line"></span><br><span class="line">rand5() % 2 + 1 = ?</span><br><span class="line">   1 % 2    + 1 = 2</span><br><span class="line">   2 % 2    + 1 = 1</span><br><span class="line">   3 % 2    + 1 = 2</span><br><span class="line">   4 % 2    + 1 = 1</span><br><span class="line">   5 % 2    + 1 = 2</span><br></pre></td></tr></tbody></table></figure><p><strong>通用一些的</strong></p><blockquote><p>如果需要实现$randX()$</p><ol><li>先实现$randN()$<ol><li>$N$为$X$的倍数（$N&gt;X$）</li></ol></li><li>再通过 $randN() % X + 1$即可</li></ol></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// rand 49</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">int</span> num = (rand7() - <span class="number">1</span>) * <span class="number">7</span> + rand7();  <span class="comment">// rand49</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt;= <span class="number">40</span>) { <span class="comment">// 使用拒绝采样，得到rand40</span></span><br><span class="line">                <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>;  <span class="comment">// rand10</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><strong>优化</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">SolBase</span> </span>{</span><br><span class="line">  <span class="comment">// 上述拒绝了9个数字，</span></span><br><span class="line">    <span class="comment">// 优化之后，减少丢弃值，提高命中率</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">int</span> a = rand7();</span><br><span class="line">            <span class="keyword">int</span> b = rand7();</span><br><span class="line">            <span class="keyword">int</span> num = (a-<span class="number">1</span>)*<span class="number">7</span> + b; <span class="comment">// rand 49</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">40</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>; <span class="comment">// 拒绝采样</span></span><br><span class="line">            </span><br><span class="line">            a = num - <span class="number">40</span>; <span class="comment">// rand 9</span></span><br><span class="line">            b = rand7();</span><br><span class="line">            num = (a-<span class="number">1</span>)*<span class="number">7</span> + b; <span class="comment">// rand 63</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">60</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            a = num - <span class="number">60</span>; <span class="comment">// rand 3</span></span><br><span class="line">            b = rand7();</span><br><span class="line">            num = (a-<span class="number">1</span>)*<span class="number">7</span> + b; <span class="comment">// rand 21</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">20</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;LeetCode死磕系列十二： 数学基础&lt;/p&gt;
&lt;p&gt;说实话，其实都是刷题都是数学的实现，不过感觉有些题目更加偏向数学应用，譬如蓄水池，等概率抽样…。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://winniekun.github.io/categories/LeetCode/"/>
    
    
    <category term="死磕系列" scheme="https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"/>
    
    <category term="数学基础" scheme="https://winniekun.github.io/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>死磕SQL</title>
    <link href="https://winniekun.github.io/stick-to-sql/"/>
    <id>https://winniekun.github.io/stick-to-sql/</id>
    <published>2021-04-20T11:56:11.000Z</published>
    <updated>2021-05-16T16:39:43.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LeetCode死磕系列十： SQL</p><a id="more"></a><p>作为一个后端开发程序员，SQL功底还是很重要的！！！</p><p>所以还是要练习。</p><blockquote><p>还记得去年被字节面试的时候，连SQL都写不出来。。。</p></blockquote><h2 id="LeetCode-SQL题目整理"><a href="#LeetCode-SQL题目整理" class="headerlink" title="LeetCode SQL题目整理"></a>LeetCode SQL题目整理</h2><p>刷了LC上的top70之后，感觉考察最多的还是多表的联合查找，毕竟实际中也不会仅仅是单表的查询。</p><p><strong>主要题型：</strong></p><ol><li>TOP N 问题</li><li>排名问题<ol><li>滑动窗口</li></ol></li><li>自链接问题</li></ol><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="TOP-N问题"><a href="#TOP-N问题" class="headerlink" title="TOP N问题"></a>TOP N问题</h3><h4 id="176-第二高的薪水"><a href="#176-第二高的薪水" class="headerlink" title="176. 第二高的薪水"></a><a href="https://leetcode-cn.com/problems/second-highest-salary/" target="_blank" rel="noopener">176. 第二高的薪水</a></h4><p><strong>思路：</strong></p><ol><li><p>使用limit</p><p>注意判空、去重</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">ifnull</span> ((<span class="keyword">select</span> </span><br><span class="line">    <span class="keyword">distinct</span> Salary </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    Employee</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">1</span>, <span class="number">1</span>) , <span class="literal">null</span>) <span class="keyword">as</span> SecondHighestSalary;</span><br></pre></td></tr></tbody></table></figure></li><li><p>先使用max查询最高的薪水 max，之后再通过自查询，查询小于max的max</p></li></ol><h4 id="184-部门工资最高的员工"><a href="#184-部门工资最高的员工" class="headerlink" title="184. 部门工资最高的员工"></a><a href="https://leetcode-cn.com/problems/department-highest-salary/" target="_blank" rel="noopener">184. 部门工资最高的员工</a></h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 思路： 寻找最大薪资的数据</span></span><br><span class="line"><span class="comment">-- join</span></span><br><span class="line"><span class="comment">-- 1. 直接join group by  选取最大的即可 但是 无法保证最大的薪资不重复 失败</span></span><br><span class="line"><span class="comment">-- 2. 先通过员工信息 寻找最大的薪资+id 的数据A，然后再join 两张表，将A中对应的数据返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1. </span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    d.Name <span class="keyword">as</span> Department,</span><br><span class="line">    e.Name <span class="keyword">as</span> Employee,</span><br><span class="line">    e.Salary <span class="keyword">as</span> Salary</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">    Employee e <span class="keyword">inner</span> <span class="keyword">join</span> Department d <span class="keyword">on</span> e.DepartmentId = d.Id</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">    (e.DepartmentId, e.Salary) <span class="keyword">in</span></span><br><span class="line">    (<span class="keyword">select</span> </span><br><span class="line">        DepartmentId,</span><br><span class="line">        <span class="keyword">max</span>(Salary)</span><br><span class="line">    <span class="keyword">from</span> </span><br><span class="line">        Employee</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> </span><br><span class="line">        DepartmentId);</span><br></pre></td></tr></tbody></table></figure><h4 id="177-第N高的薪水"><a href="#177-第N高的薪水" class="headerlink" title="177. 第N高的薪水"></a><a href="https://leetcode-cn.com/problems/nth-highest-salary/" target="_blank" rel="noopener">177. 第N高的薪水</a></h4><p>LIMIT PAGE, OFFSET</p><p>跳过 PAGE * OFFSET条数据，接下来的offset条数据， 因为题目中未说明薪资是否不重复，所以还需要使用distinct去重</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">set</span> N:= N<span class="number">-1</span>;</span><br><span class="line">  RETURN (  </span><br><span class="line">      <span class="comment"># Write your MySQL query statement below.</span></span><br><span class="line">    <span class="keyword">select</span> </span><br><span class="line">        <span class="keyword">distinct</span> Salary</span><br><span class="line">    <span class="keyword">from</span> </span><br><span class="line">        Employee</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> </span><br><span class="line">        Salary <span class="keyword">desc</span></span><br><span class="line">    <span class="keyword">limit</span> N,<span class="number">1</span></span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></tbody></table></figure><h4 id="185-部门工资前三高的所有员工"><a href="#185-部门工资前三高的所有员工" class="headerlink" title="185. 部门工资前三高的所有员工"></a><a href="https://leetcode-cn.com/problems/department-top-three-salaries/" target="_blank" rel="noopener">185. 部门工资前三高的所有员工</a></h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.Name <span class="keyword">as</span> Department, </span><br><span class="line">e2.Name <span class="keyword">as</span> Employee, </span><br><span class="line">e2.Salary <span class="keyword">from</span> </span><br><span class="line">Department d <span class="keyword">inner</span> <span class="keyword">join</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> e.*, </span><br><span class="line">    <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> DepartmentID </span><br><span class="line">    <span class="keyword">Order</span> <span class="keyword">by</span> Salary <span class="keyword">DESC</span>) <span class="keyword">as</span> <span class="string">'rank'</span></span><br><span class="line">    <span class="keyword">from</span> Employee e </span><br><span class="line">) e2 <span class="keyword">on</span> d.Id= e2.DepartmentID</span><br><span class="line"><span class="keyword">where</span> e2.rank&lt;=<span class="number">3</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Department <span class="keyword">AND</span> Salary</span><br></pre></td></tr></tbody></table></figure><h3 id="排名问题"><a href="#排名问题" class="headerlink" title="排名问题"></a>排名问题</h3><h4 id="178-分数排名"><a href="#178-分数排名" class="headerlink" title="178.分数排名"></a><a href="https://leetcode-cn.com/problems/rank-scores/" target="_blank" rel="noopener">178.分数排名</a></h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">Score, <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> Score <span class="keyword">desc</span>) <span class="keyword">as</span> <span class="string">`Rank`</span></span><br><span class="line"><span class="keyword">from</span> Scores;</span><br></pre></td></tr></tbody></table></figure><h3 id="自链接问题"><a href="#自链接问题" class="headerlink" title="自链接问题"></a>自链接问题</h3><h4 id="603-连续空余座位"><a href="#603-连续空余座位" class="headerlink" title="603. 连续空余座位"></a><a href="https://leetcode-cn.com/problems/consecutive-available-seats/" target="_blank" rel="noopener">603. 连续空余座位</a></h4><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 几个朋友来到电影院的售票处，准备预约连续空余座位。</span></span><br><span class="line"><span class="comment">-- 你能利用表&nbsp;cinema&nbsp;，帮他们写一个查询语句，获取所有空余座位，并将它们按照 seat_id 排序后返回吗？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> a.seat_id</span><br><span class="line"><span class="keyword">from</span> cinema a <span class="keyword">join</span> cinema b</span><br><span class="line">  <span class="keyword">on</span> <span class="keyword">abs</span>(a.seat_id - b.seat_id) = <span class="number">1</span></span><br><span class="line">  <span class="keyword">and</span> a.free = <span class="literal">true</span> <span class="keyword">and</span> b.free = <span class="literal">true</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> a.seat_id</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;LeetCode死磕系列十： SQL&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://winniekun.github.io/categories/LeetCode/"/>
    
    
    <category term="死磕系列" scheme="https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"/>
    
    <category term="SQL" scheme="https://winniekun.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>死磕多线程</title>
    <link href="https://winniekun.github.io/stick-to-multi-thread/"/>
    <id>https://winniekun.github.io/stick-to-multi-thread/</id>
    <published>2021-04-14T11:56:11.000Z</published>
    <updated>2021-06-06T07:56:37.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LeetCode死磕系列十一： 多线程</p><a id="more"></a><p>看那么多的面经，发现已经开始询问多线程的编程了。个人感觉多线程编程主要是理解，思想。是有固定的套路的，譬如：交替输出，有序的输出哇。深挖下去就是考察对线程通讯的使用，以及一些高阶用法。和哲学家就餐问题、生产者消费者问题、读写者问题差不多。</p><p>所以～～～</p><p>我来开始熟悉并发操作了，毕竟光看不练假把式</p><h2 id="LeetCode-多线程题目整理"><a href="#LeetCode-多线程题目整理" class="headerlink" title="LeetCode 多线程题目整理"></a>LeetCode 多线程题目整理</h2><h3 id="1114-按序打印"><a href="#1114-按序打印" class="headerlink" title="1114. 按序打印"></a><a href="https://leetcode-cn.com/problems/print-in-order/" target="_blank" rel="noopener">1114. 按序打印</a></h3>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;LeetCode死磕系列十一： 多线程&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://winniekun.github.io/categories/LeetCode/"/>
    
    
    <category term="死磕系列" scheme="https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"/>
    
    <category term="多线程" scheme="https://winniekun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一行一行源码分析清楚AbstractQueuedSynchronizer</title>
    <link href="https://winniekun.github.io/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9AAbstractQueuedSynchronizer/"/>
    <id>https://winniekun.github.io/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9AAbstractQueuedSynchronizer/</id>
    <published>2021-03-30T12:14:20.000Z</published>
    <updated>2021-04-05T12:19:21.814Z</updated>
    
    <content type="html"><![CDATA[<p>在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础。</p><p>Google 一下 AbstractQueuedSynchronizer，我们可以找到很多关于 AQS 的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。</p><p>本文将从 ReentrantLock 的公平锁源码出发，分析下 AbstractQueuedSynchronizer 这个类是怎么工作的，希望能给大家提供一些简单的帮助。</p><a id="more"></a><p>申明以下几点：</p><ol><li>本文有点长，但还是挺简单，主要面向读者对象为并发编程的初学者，或者想要阅读 Java 并发包源码的开发者。对于新手来说，可能需要花好几个小时才能完全看懂，但是这时间肯定是值得的。</li><li>源码环境 JDK1.7（1.8没啥变化），看到不懂或有疑惑的部分，最好能自己打开源码看看。Doug Lea 大神的代码写得真心不错。</li><li>本文不分析共享模式，这样可以给读者减少很多负担，<a href="/post/AbstractQueuedSynchronizer-3">第三篇文章</a>对共享模式进行了分析。而且也不分析 condition 部分，所以应该说很容易就可以看懂了。</li><li>本文大量使用我们平时用得最多的 ReentrantLock 的概念，本质上来说是不正确的，读者应该清楚，AQS 不仅仅用来实现可重入锁，只是希望读者可以用锁来联想 AQS 的使用场景，降低阅读压力。</li><li>ReentrantLock 的公平锁和非公平锁只有一点点区别，<a href="/post/AbstractQueuedSynchronizer-2">第二篇文章</a>做了介绍。</li><li>评论区有读者反馈本文直接用代码说不友好，应该多配点流程图，这篇文章确实有这个问题。但是作为过来人，我想告诉大家，对于 AQS 来说，形式真的不重要，重要的是把细节说清楚。</li></ol><h2 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h2><p>先来看看 AQS 有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了，毕竟可以猜嘛！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span></span><br><span class="line"><span class="comment">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span></span><br><span class="line"><span class="comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">// if (currentThread == getExclusiveOwnerThread()) {state++}</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; <span class="comment">//继承自AbstractOwnableSynchronizer</span></span><br></pre></td></tr></tbody></table></figure><p>怎么样，看样子应该是很简单的吧，毕竟也就四个属性啊。</p><p>AbstractQueuedSynchronizer 的等待队列示意如下所示，注意了，之后分析过程中所说的 queue，也就是阻塞队列<strong>不包含 head，不包含 head，不包含 head</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-0.png" alt="aqs-0" title="">                </div>                <div class="image-caption">aqs-0</div>            </figure><p>等待队列中每个线程被包装成一个 Node 实例，数据结构是链表，一起看看源码吧：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="comment">// 标识节点当前在共享模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 标识节点当前在独占模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ======== 下面的几个int常量是给waitStatus用的 ===========</span></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">    <span class="comment">// 代码此线程取消了争抢这个锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">    <span class="comment">// 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="comment">// 本文不分析condition，所以略过吧，下一篇文章会介绍这个</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">     * unconditionally propagate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 同样的不分析，略过吧</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">// =====================================================</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 取值为上面的1、-1、-2、-3，或者0(以后会讲到)</span></span><br><span class="line">    <span class="comment">// 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span></span><br><span class="line">    <span class="comment">//    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 后继节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 这个就是线程本尊</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。</p><p>上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说 ReentrantLock 的公平锁。再次强调，我说的阻塞队列不包含 head 节点。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-0.png" alt="aqs-0" title="">                </div>                <div class="image-caption">aqs-0</div>            </figure><p>首先，我们先看下 ReentrantLock 的使用方式。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我用个web开发中的service概念吧</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>{</span><br><span class="line">    <span class="comment">// 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrder</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 比如我们同一时间，只允许一个线程创建订单</span></span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="comment">// 通常，lock 之后紧跟着 try 语句</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 这块代码同一时间只能有一个线程进来(获取到锁的线程)，</span></span><br><span class="line">            <span class="comment">// 其他的线程在lock()方法上阻塞，等待获取到锁，再进来</span></span><br><span class="line">            <span class="comment">// 执行代码...</span></span><br><span class="line">            <span class="comment">// 执行代码...</span></span><br><span class="line">            <span class="comment">// 执行代码...</span></span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ReentrantLock 在内部用了内部类 Sync 来管理锁，所以真正的获取锁和释放锁是由 Sync 的实现类来控制的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Sync 有两个实现，分别为 NonfairSync（非公平锁）和 FairSync（公平锁），我们看 FairSync 部分。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>{</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="线程抢锁"><a href="#线程抢锁" class="headerlink" title="线程抢锁"></a>线程抢锁</h2><p>很多人肯定开始嫌弃上面废话太多了，下面跟着代码走，我就不废话了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line">  <span class="comment">// 争锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">  <span class="comment">// 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力</span></span><br><span class="line">    <span class="comment">// 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。</span></span><br><span class="line">    <span class="comment">// 否则，acquireQueued方法会将线程压到队列中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{ <span class="comment">// 此时 arg == 1</span></span><br><span class="line">        <span class="comment">// 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试</span></span><br><span class="line">        <span class="comment">// 因为有可能直接就成功了呢，也就不需要进队列排了，</span></span><br><span class="line">        <span class="comment">// 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) {</span><br><span class="line">              selfInterrupt();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span></span><br><span class="line">    <span class="comment">// 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// state == 0 此时此刻没有线程持有锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class="line">            <span class="comment">// 看看有没有别人在队列中等了半天了</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                <span class="comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span></span><br><span class="line">                <span class="comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span></span><br><span class="line">                <span class="comment">// 因为刚刚还没人的，我判断过了</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) {</span><br><span class="line">              </span><br><span class="line">                <span class="comment">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">      <span class="comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span></span><br><span class="line">        <span class="comment">// 这里不存在并发问题</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) {</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span></span><br><span class="line">        <span class="comment">// 回到上面一个外层调用方法继续看:</span></span><br><span class="line">        <span class="comment">// if (!tryAcquire(arg) </span></span><br><span class="line">        <span class="comment">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span></span><br><span class="line">        <span class="comment">//     selfInterrupt();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 假设tryAcquire(arg) 返回false，那么代码将执行：</span></span><br><span class="line">  <span class="comment">//acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，</span></span><br><span class="line">    <span class="comment">// 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 此方法的作用是把线程包装成node，同时进入到队列中</span></span><br><span class="line">    <span class="comment">// 参数mode此时是Node.EXCLUSIVE，代表独占模式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>{</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="comment">// 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) { </span><br><span class="line">            <span class="comment">// 将当前的队尾节点，设置为自己的前驱 </span></span><br><span class="line">            node.prev = pred; </span><br><span class="line">            <span class="comment">// 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) { </span><br><span class="line">                <span class="comment">// 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，</span></span><br><span class="line">                <span class="comment">// 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="comment">// 线程入队了，可以返回了</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 仔细看看上面的代码，如果会到这里，</span></span><br><span class="line">        <span class="comment">// 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span></span><br><span class="line">        <span class="comment">// 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> node's predecessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 采用自旋的方式入队</span></span><br><span class="line">    <span class="comment">// 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，</span></span><br><span class="line">    <span class="comment">// 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="comment">// 之前说过，队列为空也会进来这里</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) { <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="comment">// 初始化head节点</span></span><br><span class="line">                <span class="comment">// 细心的读者会知道原来 head 和 tail 初始化的时候都是 null 的</span></span><br><span class="line">                <span class="comment">// 还是一步CAS，你懂的，现在可能是很多线程同时进来呢</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    <span class="comment">// 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了</span></span><br><span class="line">                  </span><br><span class="line">                    <span class="comment">// 这个时候有了head，但是tail还是null，设置一下，</span></span><br><span class="line">                    <span class="comment">// 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了</span></span><br><span class="line">                    <span class="comment">// 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return</span></span><br><span class="line">                    <span class="comment">// 所以，设置完了以后，继续for循环，下次就到下面的else分支了</span></span><br><span class="line">                    tail = head;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 下面几行，和上一个方法 addWaiter 是一样的，</span></span><br><span class="line">                <span class="comment">// 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) {</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 现在，又回到这段代码了</span></span><br><span class="line">    <span class="comment">// if (!tryAcquire(arg) </span></span><br><span class="line">    <span class="comment">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span></span><br><span class="line">    <span class="comment">//     selfInterrupt();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列</span></span><br><span class="line">    <span class="comment">// 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，</span></span><br><span class="line">    <span class="comment">// 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false</span></span><br><span class="line">    <span class="comment">// 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head</span></span><br><span class="line">                <span class="comment">// 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列</span></span><br><span class="line">                <span class="comment">// 所以当前节点可以去试抢一下锁</span></span><br><span class="line">                <span class="comment">// 这里我们说一下，为什么可以去试试：</span></span><br><span class="line">                <span class="comment">// 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span></span><br><span class="line">                <span class="comment">// enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span></span><br><span class="line">                <span class="comment">// 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span></span><br><span class="line">                <span class="comment">// tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) {</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，</span></span><br><span class="line">                <span class="comment">// 要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 什么时候 failed 会为 true???</span></span><br><span class="line">            <span class="comment">// tryAcquire() 方法抛异常的情况</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment">     * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment">     * control in all acquire loops.  Requires that pred == node.prev</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pred node's predecessor holding status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> {<span class="doctag">@code</span> true} if thread should block</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是："当前线程没有抢到锁，是否需要挂起当前线程？"</span></span><br><span class="line">    <span class="comment">// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="comment">// 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span></span><br><span class="line">        <span class="comment">// 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span></span><br><span class="line">        <span class="comment">// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span></span><br><span class="line">        <span class="comment">// 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span></span><br><span class="line">        <span class="comment">// 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> {</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            } <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 仔细想想，如果进入到这个分支意味着什么</span></span><br><span class="line">            <span class="comment">// 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span></span><br><span class="line">            <span class="comment">// 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span></span><br><span class="line">            <span class="comment">// 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span></span><br><span class="line">            <span class="comment">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 这个方法返回 false，那么会再走一次 for 循序，</span></span><br><span class="line">        <span class="comment">//     然后再次进来此方法，此时会从第一个分支返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)</span></span><br><span class="line">    <span class="comment">// 这个方法结束根据返回值我们简单分析下：</span></span><br><span class="line">    <span class="comment">// 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒</span></span><br><span class="line">    <span class="comment">//我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span></span><br><span class="line">    <span class="comment">// 如果返回false, 说明当前不需要被挂起，为什么呢？往后看</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 跳回到前面是这个方法</span></span><br><span class="line">    <span class="comment">// if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span></span><br><span class="line">    <span class="comment">//                parkAndCheckInterrupt())</span></span><br><span class="line">    <span class="comment">//                interrupted = true;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，</span></span><br><span class="line">    <span class="comment">// 那么需要执行parkAndCheckInterrupt():</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的</span></span><br><span class="line">    <span class="comment">// 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>{</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：</span></span><br><span class="line">    <span class="comment">// =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>说到这里，也就明白了，多看几遍 <code>final boolean acquireQueued(final Node node, int arg)</code> 这个方法吧。自己推演下各个分支怎么走，哪种情况下会发生什么，走到哪里。</p><h2 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h2><p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被 <code>LockSupport.park(this);</code> 挂起停止，等待被唤醒。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{</span><br><span class="line">    <span class="comment">// 往后看吧</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) {</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回到ReentrantLock看tryRelease方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 是否完全释放锁</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) {</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up node's successor, if one exists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 唤醒后继节点</span></span><br><span class="line"><span class="comment">// 从上面调用处知道，参数node是head头结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果head节点当前waitStatus&lt;0, 将其修改为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）</span></span><br><span class="line">    <span class="comment">// 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) {</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 唤醒线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>{</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 刚刚线程被挂起在这里了</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</span></span><br></pre></td></tr></tbody></table></figure><p>好了，后面就不分析源码了，剩下的还有问题自己去仔细看看代码吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下吧。</p><p>在并发环境下，加锁和解锁需要以下三个部件的协调：</p><ol><li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li><li>线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。</li><li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现，感兴趣的读者可以参考这篇文章<a href="http://coderbee.net/index.php/concurrent/20131115/577" target="_blank" rel="noopener">关于CLH的介绍</a>，写得简单明了。</li></ol><h2 id="示例图解析"><a href="#示例图解析" class="headerlink" title="示例图解析"></a>示例图解析</h2><p>下面属于回顾环节，用简单的示例来说一遍，如果上面的有些东西没看懂，这里还有一次帮助你理解的机会。</p><p>首先，第一个线程调用 reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回 true 了，结束。只是设置了 state=1，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，那世界就太太太平了，完全没有交集嘛，那我还要 AQS 干嘛。</p><p>如果线程 1 没有调用 unlock() 之前，线程 2 调用了 lock(), 想想会发生什么？</p><p>线程 2 会初始化 head【new Node()】，同时线程 2 也会插入到阻塞队列并挂起 (注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) { <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) {</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>首先，是线程 2 初始化 head 节点，此时 head==tail, waitStatus==0</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-1.png" alt="aqs-1" title="">                </div>                <div class="image-caption">aqs-1</div>            </figure><p>然后线程 2 入队：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-2.png" alt="aqs-2" title="">                </div>                <div class="image-caption">aqs-2</div>            </figure><p>同时我们也要看此时节点的 waitStatus，我们知道 head 节点是线程 2 初始化的，此时的 waitStatus 没有设置， java 默认会设置为 0，但是到 shouldParkAfterFailedAcquire 这个方法的时候，线程 2 会把前驱节点，也就是 head 的waitStatus设置为 -1。</p><p>那线程 2 节点此时的 waitStatus 是多少呢，由于没有设置，所以是 0；</p><p>如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 shouldParkAfterFailedAcquire 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-3.png" alt="aqs-3" title="">                </div>                <div class="image-caption">aqs-3</div>            </figure><p>这里可以简单说下 waitStatus 中 SIGNAL(-1) 状态的意思，Doug Lea 注释的是：代表后继节点需要被唤醒。也就是说这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着 “waitStatus代表后继节点的状态” 这种思路去看一遍源码。</p><p>（全文完）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础。&lt;/p&gt;
&lt;p&gt;Google 一下 AbstractQueuedSynchronizer，我们可以找到很多关于 AQS 的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。&lt;/p&gt;
&lt;p&gt;本文将从 ReentrantLock 的公平锁源码出发，分析下 AbstractQueuedSynchronizer 这个类是怎么工作的，希望能给大家提供一些简单的帮助。&lt;/p&gt;</summary>
    
    
    
    <category term="concurrency" scheme="https://winniekun.github.io/categories/concurrency/"/>
    
    
  </entry>
  
  <entry>
    <title>2020年总结</title>
    <link href="https://winniekun.github.io/2020%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>https://winniekun.github.io/2020%E5%B9%B4%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-02T16:11:11.000Z</published>
    <updated>2021-01-02T16:40:50.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="啊"><a href="#啊" class="headerlink" title="啊"></a>啊</h2><a id="more"></a><p>2020年到底还是结束了，感觉现在的自己也不喜欢做各种阶段性总结了，总感觉把自己的经历写出来是一种特别矫情的事情。相反，更想把这些经历仅供自己慢慢回味和感触。但是，时间久了，有些东西记得就不够客观了（虽然现在记忆的也不够观。。。）</p><p>所以，以后的每一年都还是做一次年终小结吧。</p><h2 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h2><p>因为疫情，上半年一直在家里呆着，每天的生活差不多如下</p><table><thead><tr><th>时间</th><th>干啥</th></tr></thead><tbody><tr><td>上午</td><td>网课（挂机，干自己的事情）</td></tr><tr><td>下午</td><td>网课（挂机，干自己的事情）</td></tr><tr><td>晚上</td><td>和韩老师还有沈总打游戏</td></tr></tbody></table><p>在上网课的3个月里，自己虽然课没好好上过，不过还是做了一些事情的：</p><ol><li>剑指offer刷了3遍</li><li>LeetCode300大关完成</li><li>深入理解JVM虚拟机终于是看懂了</li><li>JDK源码（collection、juc）嗑了一遍<ol><li>HashMap的设计是真的精妙</li><li>红黑树真的不是正常人写的来的</li></ol></li><li>操作系统过了一遍</li></ol><p>为啥要做这些事情嘞，主要还是想找实习，感觉在学校里面呆腻了，想出来看看（什么**想法）…</p><p>终于，在我的艰苦复习和准备之下，我心仪的字节还是把我拒绝了（今年只面了字节一家大厂），被打击到了之后，也就没再继续投递其他大厂。后面通过牛客上的内推，来到了蔚来汽车实习。</p><h2 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a>下半年</h2><p>从9月中旬起，开始我的实习生活，从刚开始的不适应，到后面的一脸懵逼，再到现在的勉强适应。让我认识到了自己技术上的不足，以及交流上的问题。所以基本每天回来都会主动去看每个节点的所负责的业务逻辑，涉及哪些技术栈，这些技术栈是怎么使用的，和我之前自己写着玩儿的有什么区别。自己也学会了在做任务的时候，先去看需求背景，再去看实现方案，然后脑子构建实现方式，最后再看是撸代码。遇到了自己解决不了的，有疑惑的地方，也渐渐的学会主动去请教同事了。最后，在距离实习结束还有两个月不到的时间里，希望能够拓宽自己的技术栈，精进自己的技术深度。主动去和同事交流，学习经验。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;啊&quot;&gt;&lt;a href=&quot;#啊&quot; class=&quot;headerlink&quot; title=&quot;啊&quot;&gt;&lt;/a&gt;啊&lt;/h2&gt;</summary>
    
    
    
    <category term="碎碎念" scheme="https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="杂谈" scheme="https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>2021年书单【年汇总】</title>
    <link href="https://winniekun.github.io/2021%E5%B9%B4%E4%B9%A6%E5%8D%95%E3%80%90%E5%B9%B4%E6%B1%87%E6%80%BB%E3%80%91/"/>
    <id>https://winniekun.github.io/2021%E5%B9%B4%E4%B9%A6%E5%8D%95%E3%80%90%E5%B9%B4%E6%B1%87%E6%80%BB%E3%80%91/</id>
    <published>2021-01-01T07:01:10.000Z</published>
    <updated>2021-02-24T12:06:26.477Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 <a href="https://blog.jamespan.me/" target="_blank" rel="noopener">摘自鶸道场</a></p></blockquote><p>趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。</p><a id="more"></a><h2 id="书籍相关"><a href="#书籍相关" class="headerlink" title="书籍相关"></a>书籍相关</h2><ul><li>程序员代码面试指南- IT名企算法与数据结构题目最优解<ul><li>计划的是去年年底开始刷，然后计划赶不上变化</li><li>公司安排的1230的任务挺复杂的，还挺多，就没有开始搞</li><li>不过终于在31号，下定决心先把书买了，然后1号正式开刷</li></ul></li></ul><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><h2 id="电影、电视剧、综艺、纪录片"><a href="#电影、电视剧、综艺、纪录片" class="headerlink" title="电影、电视剧、综艺、纪录片"></a>电影、电视剧、综艺、纪录片</h2><ul><li><p>一点就通</p><ul><li>合伙人2 ？？？</li></ul></li><li><p>温暖的抱抱</p></li><li><p>拆弹专家2</p></li><li><p>送你一朵小红花</p></li><li><p>赘婿</p><ul><li>上头看的</li></ul></li><li><p>哪吒重生</p><ul><li>够朋克</li></ul></li><li><p>你好李焕英</p><ul><li>好看的</li></ul></li><li><p>因为是男高所以很幸福</p><ul><li>憨批一家人哇</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我的能力就这么多，我若全心工作，则必然忽略生活；我若用心生活，则必然一事无成；我若两者兼顾，又难免平庸 &lt;a href=&quot;https://blog.jamespan.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;摘自鶸道场&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;趁我还能写得动代码看进书的年纪，努力一回，看看这平庸的资质能发挥几分。&lt;/p&gt;</summary>
    
    
    
    <category term="碎碎念" scheme="https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="书单" scheme="https://winniekun.github.io/tags/%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>if-else代码优化的几种方案</title>
    <link href="https://winniekun.github.io/if-else-code-optimization/"/>
    <id>https://winniekun.github.io/if-else-code-optimization/</id>
    <published>2020-11-02T11:46:42.000Z</published>
    <updated>2020-11-02T12:46:17.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代码中涉及到较为复杂的逻辑是，一般情况下会出现大量的<code>if-else</code>，虽然实现了整个功能，但是阅读起来比较耗时，并且维护的时候也十分的困难，同时只要有一个地方没有考虑清楚，修改起来就难免出现<code>bug</code>。最近在做公司某个节点的性能优化，就遇到了这个问题，然后在<code>review</code>的时候，同事和我讲了一些优化方案，以及默认的规范之后。自己重新修改之后，感觉很舒服，后续自己重新整理一下，所以就写了这篇博客。</p><a id="more"></a><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><h3 id="优化一：提前return，去除不必要的else"><a href="#优化一：提前return，去除不必要的else" class="headerlink" title="优化一：提前return，去除不必要的else"></a>优化一：提前return，去除不必要的else</h3><p>如果<code>if-else</code>代码块包含<code>return</code>语句，可以考虑通过提前<code>return</code>，把多余<code>else</code>干掉，使代码更加优雅。</p><h4 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition){</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="comment">// do other thing</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!condition) {</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">} </span><br><span class="line"><span class="comment">// do something</span></span><br></pre></td></tr></tbody></table></figure><h3 id="优化二：使用三元运算"><a href="#优化二：使用三元运算" class="headerlink" title="优化二：使用三元运算"></a>优化二：使用三元运算</h3><h4 id="优化前-1"><a href="#优化前-1" class="headerlink" title="优化前"></a>优化前</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">if</span>(condition){</span><br><span class="line">  price = <span class="number">10</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  price = <span class="number">20</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="优化后-1"><a href="#优化后-1" class="headerlink" title="优化后"></a>优化后</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> price = condition ? <span class="number">10</span> : <span class="number">20</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="优化三：使用枚举"><a href="#优化三：使用枚举" class="headerlink" title="优化三：使用枚举"></a>优化三：使用枚举</h3><h4 id="优化前-2"><a href="#优化前-2" class="headerlink" title="优化前"></a>优化前</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> orderStatus = getXXX(xxx);</span><br><span class="line">String OrderStatusDes;</span><br><span class="line"><span class="keyword">if</span>(orderStatus == <span class="number">0</span>) {</span><br><span class="line">    OrderStatusDes = <span class="string">"订单未支付"</span>;</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(OrderStatus == <span class="number">1</span>) {</span><br><span class="line">    OrderStatusDes = <span class="string">"订单已支付"</span>;</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(OrderStatus == <span class="number">2</span>) {</span><br><span class="line">   OrderStatusDes = <span class="string">"已发货"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="优化后-2"><a href="#优化后-2" class="headerlink" title="优化后"></a>优化后</h4><p><strong>先定义一个枚举类型</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OrderStatusEnum {</span><br><span class="line">    UN_PAID(<span class="number">0</span>,<span class="string">"订单未支付"</span>),PAIDED(<span class="number">1</span>,<span class="string">"订单已支付"</span>),SENDED(<span class="number">2</span>,<span class="string">"已发货"</span>),;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    OrderStatusEnum(<span class="keyword">int</span> index, String desc){</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">        <span class="keyword">this</span>.desc =desc;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function">OrderStatusEnum <span class="title">ofCode</span><span class="params">(<span class="keyword">int</span> orderStatus)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (OrderStatusEnum temp : OrderStatusEnum.values()) {</span><br><span class="line">            <span class="keyword">if</span> (temp.getIndex() == orderStatus) {</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>有了枚举之后，以上if-else逻辑分支，可以优化为一行代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String OrderStatusDes = OrderStatusEnum.ofCode(orderStatus).getDesc();</span><br></pre></td></tr></tbody></table></figure><h3 id="优化四：合并条件表达式"><a href="#优化四：合并条件表达式" class="headerlink" title="优化四：合并条件表达式"></a>优化四：合并条件表达式</h3><p>如果有一系列条件返回一样的结果，可以将它们合并为一个条件表达式，让逻辑更加清晰。</p><h4 id="优化前-3"><a href="#优化前-3" class="headerlink" title="优化前"></a>优化前</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getVipDiscount</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(age&lt;<span class="number">18</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"深圳"</span>.equals(city)){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(isStudent){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//do somethig</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="优化后-3"><a href="#优化后-3" class="headerlink" title="优化后"></a>优化后</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getVipDiscount</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(age&lt;<span class="number">18</span>|| <span class="string">"深圳"</span>.equals(city)||isStudent){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//doSomthing</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果返回统一结果的条件过多，可以再编写一个方法，封装起来<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h3 id="优化五：使用Optional"><a href="#优化五：使用Optional" class="headerlink" title="优化五：使用Optional"></a>优化五：使用Optional</h3><p>有时候<code>if-else</code>比较多，是因为非空判断导致的，这时候你可以使用<code>Java9</code>的<code>Optional</code>进行优化。</p><h4 id="优化前-4"><a href="#优化前-4" class="headerlink" title="优化前"></a>优化前</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"wkk"</span>;</span><br><span class="line"><span class="keyword">if</span> (str != <span class="keyword">null</span>) {</span><br><span class="line">    System.out.println(str);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    System.out.println(<span class="string">"Null"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="优化后-4"><a href="#优化后-4" class="headerlink" title="优化后"></a>优化后</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; strOptional = Optional.ofNullable(<span class="string">"wkk"</span>);</span><br><span class="line">strOptional.ifPresentOrElse(System.out::println, () -&gt; System.out.println(<span class="string">"Null"</span>));</span><br></pre></td></tr></tbody></table></figure><p><code>Java8</code>的<code>Optional</code>虽然没有这个方法，但是我们可以用Optional来优化非空的赋值操作</p><p><strong>示例：</strong></p><p>电池平台服役状态赋值：如果为null，赋值为0，否则为原来的值</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">batteryBasicInfoCollectDto.setFlowControlState(Optional.ofNullable(batteryInfo.getFlowControlState()).orElse(<span class="number">0</span>));</span><br></pre></td></tr></tbody></table></figure><h3 id="优化六：表驱动法"><a href="#优化六：表驱动法" class="headerlink" title="优化六：表驱动法"></a>优化六：表驱动法</h3><h4 id="优化前-5"><a href="#优化前-5" class="headerlink" title="优化前"></a>优化前</h4><p><strong>表驱动法</strong>，又称之为表驱动、表驱动方法。表驱动方法是一种使你可以在表中查找信息，而不必用很多的逻辑语句（if或Case）来把它们找出来的方法。以下的demo，把map抽象成表，在map中查找信息，而省去不必要的逻辑语句。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (param.equals(value1)) {</span><br><span class="line">    doAction1(someParams);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (param.equals(value2)) {</span><br><span class="line">    doAction2(someParams);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (param.equals(value3)) {</span><br><span class="line">    doAction3(someParams);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="优化后-5"><a href="#优化后-5" class="headerlink" title="优化后"></a>优化后</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里泛型是为方便演示，实际可替换为你需要的类型</span></span><br><span class="line">Map&lt;?, Function&lt;?&gt; action&gt; actionMappings = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">actionMappings.put(value1, (someParams) -&gt; { doAction1(someParams)});</span><br><span class="line">actionMappings.put(value2, (someParams) -&gt; { doAction2(someParams)});</span><br><span class="line">actionMappings.put(value3, (someParams) -&gt; { doAction3(someParams)});</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 省略多余逻辑语句</span></span><br><span class="line">actionMappings.get(param).apply(someParams);</span><br></pre></td></tr></tbody></table></figure><h3 id="优化七：优化逻辑结构，让正常流程走主干"><a href="#优化七：优化逻辑结构，让正常流程走主干" class="headerlink" title="优化七：优化逻辑结构，让正常流程走主干"></a>优化七：优化逻辑结构，让正常流程走主干</h3><h4 id="优化前-6"><a href="#优化前-6" class="headerlink" title="优化前"></a>优化前</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAdjustedCapital</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(_capital &lt;= <span class="number">0.0</span> ){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(_intRate &gt; <span class="number">0</span> &amp;&amp; _duration &gt;<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> (_income / _duration) *ADJ_FACTOR;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="优化后-6"><a href="#优化后-6" class="headerlink" title="优化后"></a>优化后</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAdjustedCapital</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(_capital &lt;= <span class="number">0.0</span> ){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(_intRate &lt;= <span class="number">0</span> || _duration &lt;= <span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> (_income / _duration) *ADJ_FACTOR;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>将条件反转使异常情况先退出，让正常流程维持在主干流程，可以让代码结构更加清晰。</strong></p><h3 id="优化八：策略模式-工厂方法消除if-else"><a href="#优化八：策略模式-工厂方法消除if-else" class="headerlink" title="优化八：策略模式+工厂方法消除if-else"></a>优化八：策略模式+工厂方法消除if-else</h3><p><strong>策略类定义</strong>：一个策略接口和一组实现这个接口的策略类。</p><p><strong>特点</strong>：客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。</p><p><strong>假设需求</strong>：根据不同勋章类型，处理相对应的勋章服务</p><h4 id="优化前-7"><a href="#优化前-7" class="headerlink" title="优化前"></a>优化前</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String medalType = <span class="string">"guest"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"guest"</span>.equals(medalType)) {</span><br><span class="line">    System.out.println(<span class="string">"嘉宾勋章"</span>);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"vip"</span>.equals(medalType)) {</span><br><span class="line">    System.out.println(<span class="string">"会员勋章"</span>);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"guard"</span>.equals(medalType)) {</span><br><span class="line">    System.out.println(<span class="string">"展示守护勋章"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="优化后-7"><a href="#优化后-7" class="headerlink" title="优化后"></a>优化后</h4><p>首先，我们把每个条件逻辑代码块，抽象成一个公共的接口，可以得出以下代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//勋章接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMedalService</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showMedal</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们根据每个逻辑条件，定义相对应的策略实现类，可得以下代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//守护勋章策略实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuardMedalServiceImpl</span> <span class="keyword">implements</span> <span class="title">IMedalService</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMedal</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"展示守护勋章"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//嘉宾勋章策略实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuestMedalServiceImpl</span> <span class="keyword">implements</span> <span class="title">IMedalService</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMedal</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"嘉宾勋章"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//VIP勋章策略实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VipMedalServiceImpl</span> <span class="keyword">implements</span> <span class="title">IMedalService</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMedal</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"会员勋章"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来，我们再定义策略工厂类，用来管理这些勋章实现策略类，如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//勋章服务工产类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedalServicesFactory</span> </span>{</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, IMedalService&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        map.put(<span class="string">"guard"</span>, <span class="keyword">new</span> GuardMedalServiceImpl());</span><br><span class="line">        map.put(<span class="string">"vip"</span>, <span class="keyword">new</span> VipMedalServiceImpl());</span><br><span class="line">        map.put(<span class="string">"guest"</span>, <span class="keyword">new</span> GuestMedalServiceImpl());</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IMedalService <span class="title">getMedalService</span><span class="params">(String medalType)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> map.get(medalType);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用了策略+工厂模式之后，代码变得简洁多了，如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String medalType = <span class="string">"guest"</span>;</span><br><span class="line">        IMedalService medalService = MedalServicesFactory.getMedalService(medalType);</span><br><span class="line">        medalService.showMedal();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;代码中涉及到较为复杂的逻辑是，一般情况下会出现大量的&lt;code&gt;if-else&lt;/code&gt;，虽然实现了整个功能，但是阅读起来比较耗时，并且维护的时候也十分的困难，同时只要有一个地方没有考虑清楚，修改起来就难免出现&lt;code&gt;bug&lt;/code&gt;。最近在做公司某个节点的性能优化，就遇到了这个问题，然后在&lt;code&gt;review&lt;/code&gt;的时候，同事和我讲了一些优化方案，以及默认的规范之后。自己重新修改之后，感觉很舒服，后续自己重新整理一下，所以就写了这篇博客。&lt;/p&gt;</summary>
    
    
    
    <category term="代码质量" scheme="https://winniekun.github.io/categories/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"/>
    
    
    <category term="if-else优化" scheme="https://winniekun.github.io/tags/if-else%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>lombok介绍</title>
    <link href="https://winniekun.github.io/lombok-introduce/"/>
    <id>https://winniekun.github.io/lombok-introduce/</id>
    <published>2020-10-02T12:08:21.000Z</published>
    <updated>2020-10-04T14:34:01.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lombok使用"><a href="#Lombok使用" class="headerlink" title="Lombok使用"></a>Lombok使用</h2><blockquote><p>Lombok是一款好用顺手的工具，值得去好好去熟练使用和深究。<strong>Lombok是一种Java™实用工具，可用来帮助开发人员消除Java的冗长代码，尤其是对于简单的Java对象（POJO）。它通过注释实现这一目的</strong>。通过在开发环境中实现Lombok，开发人员可以节省构建诸如hashCode()和equals()这样的方法以及以往用来分类各种accessor和mutator的大量时间。</p></blockquote><a id="more"></a><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li><p>导入Maven依赖</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>${lomok.version}<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>在IDE中安装对应的插件（<strong>lombok plugin</strong>）</p></li></ol><h2 id="常用注解详解"><a href="#常用注解详解" class="headerlink" title="常用注解详解"></a>常用注解详解</h2><h3 id="简化代码，增加可读性"><a href="#简化代码，增加可读性" class="headerlink" title="简化代码，增加可读性"></a>简化代码，增加可读性</h3><h4 id="Getter-amp-Setter"><a href="#Getter-amp-Setter" class="headerlink" title="@Getter&amp;@Setter"></a>@Getter&amp;@Setter</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过<code>@Getter和@Setter</code>之后，其就类似于如下的代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Persons</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h4><p>其等同于如下的几个注解，使用的频率最高</p><ul><li>@Getter/@Setter</li><li>@ToString</li><li>@EqualsAndHashCode</li><li>@RequiredArgsConstructor</li></ul><h4 id="Buider"><a href="#Buider" class="headerlink" title="@Buider"></a>@Buider</h4><p>自动生成流式set写法，能够快速的设定<code>Object</code>值。但是需要注意的是，虽然该方法很好，但是因为大多数的框架都使用到了<code>set</code>方法进进行注入，<strong>所以在开发的时候，我们一般是将<code>@Builder</code>和<code>@Data</code>一起使用</strong>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方便查看输出对象</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Person person = Person.builder().age(<span class="string">"11"</span>).id(<span class="number">1</span>).name(<span class="string">"wkk"</span>).build();</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Builder的使用等同于如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonBuilder</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> Integer id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">        PersonBuilder() {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Person.<span class="function">PersonBuilder <span class="title">id</span><span class="params">(Integer id)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Person.<span class="function">PersonBuilder <span class="title">name</span><span class="params">(String name)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Person.<span class="function">PersonBuilder <span class="title">age</span><span class="params">(String age)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="keyword">this</span>.id, <span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Person.PersonBuilder(id="</span> + <span class="keyword">this</span>.id + <span class="string">", name="</span> + <span class="keyword">this</span>.name + <span class="string">", age="</span> + <span class="keyword">this</span>.age + <span class="string">")"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="日志使用"><a href="#日志使用" class="headerlink" title="日志使用"></a>日志使用</h3><p>一般情况下，我们做日志处理，都会先生成一个Logger的静态常量，使用<code>@Slf4j</code>之后，我们就可以完全不用new一个该常量了。</p> <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">      logger.info(<span class="string">"logger: {}"</span>, <span class="string">"aaaa"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lombok实现</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"fsda"</span>);</span><br><span class="line">        log.info(<span class="string">"Person: {}"</span>, <span class="string">"fdsa"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="流式对象的关闭"><a href="#流式对象的关闭" class="headerlink" title="流式对象的关闭"></a><del>流式对象的关闭</del></h3>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Lombok使用&quot;&gt;&lt;a href=&quot;#Lombok使用&quot; class=&quot;headerlink&quot; title=&quot;Lombok使用&quot;&gt;&lt;/a&gt;Lombok使用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Lombok是一款好用顺手的工具，值得去好好去熟练使用和深究。&lt;strong&gt;Lombok是一种Java™实用工具，可用来帮助开发人员消除Java的冗长代码，尤其是对于简单的Java对象（POJO）。它通过注释实现这一目的&lt;/strong&gt;。通过在开发环境中实现Lombok，开发人员可以节省构建诸如hashCode()和equals()这样的方法以及以往用来分类各种accessor和mutator的大量时间。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="java" scheme="https://winniekun.github.io/categories/java/"/>
    
    
    <category term="基础" scheme="https://winniekun.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>2020实习前的总结</title>
    <link href="https://winniekun.github.io/before-internship/"/>
    <id>https://winniekun.github.io/before-internship/</id>
    <published>2020-09-06T11:11:50.000Z</published>
    <updated>2020-10-01T15:12:36.296Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2020年2月底，在自己确定要找实习的时候，开始和女朋友哭诉所害怕自己找不到实习，没有公司要我，我太菜了等等等。经过耗时半年的时间，终于确定下来的了实习地点和实习公司，感觉整个过程还挺好玩儿的，所以就记录下来吧。</p><a id="more"></a><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p>挺尴尬的，本来想着再实习之前把文章写好，但是后面有别的事情就没有来得及写，最后想写的时候，发现<code>hexo</code>出问题了。所以就一直拖到了国庆假期，抽了点时间改改，终于又能重新写blog了。</p><p>目前已经在NIO实习两周了，第一周还好，就是看看公司文档，然后按照需求完善了一个接口，后面老师安排我看几个节点的代码，然后修复<code>sonarQube</code>上检测出的<code>Bug</code>。第二周就开始忙碌了，刚好排期，分配了我还挺多的任务，希望能做的又好又棒。</p><p>放张我所在楼的前台，感觉还挺好看的（假期前一天走的晚，刚好没有多少人，顺手拍的<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/10/01/87TWFU4HfEacrxw.jpg" alt="NIO" title="">                </div>                <div class="image-caption">NIO</div>            </figure><p>国庆假期人是真的多，虹桥车站爆满。不知道为什么，脑子里竟然是釜山行的画面…</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/10/01/aob7WsqUM2pTzxi.jpg" alt="虹桥火车站" title="">                </div>                <div class="image-caption">虹桥火车站</div>            </figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面试真的并不可怕，大不了就是给面试官感觉你不行，在面试官面前尬聊一个小时，其他的真的没什么。面多了就感觉还挺好玩儿的（就是每次面试前还是会紧张好长时间）。面试期间，感觉有一些问题并没有标准的答案，所以可以使用和面试官讨论的形式阐述自己的观点。最后就是记得面试后做好复盘，这样不仅可以帮助自己查缺补漏，还能让自己能够更好的梳理知识点。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2020年2月底，在自己确定要找实习的时候，开始和女朋友哭诉所害怕自己找不到实习，没有公司要我，我太菜了等等等。经过耗时半年的时间，终于确定下来的了实习地点和实习公司，感觉整个过程还挺好玩儿的，所以就记录下来吧。&lt;/p&gt;</summary>
    
    
    
    <category term="碎碎念" scheme="https://winniekun.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="杂谈" scheme="https://winniekun.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>死磕图</title>
    <link href="https://winniekun.github.io/stick-to-graph/"/>
    <id>https://winniekun.github.io/stick-to-graph/</id>
    <published>2020-08-20T00:59:56.000Z</published>
    <updated>2020-08-30T04:50:22.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>LeetCode死磕系列九： 图</p><p>说实话图目前遇到的题目类型不多, 再加上今年图论课程上的一些算法, 只能说算是覆盖了图相关的一丢丢的内容<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>最近LeetCode每日一题, 遇到了较多的图遍历(深度遍历, 广度遍历)问题, 感觉是有迹可循的, 所以做一下整理吧.</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li><p><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. 被围绕的区域</a></p></li><li><p><a href="https://leetcode-cn.com/problems/clone-graph/" target="_blank" rel="noopener">133. 克隆图</a></p></li><li><p><a href="https://leetcode-cn.com/problems/flood-fill/" target="_blank" rel="noopener">733. 图像渲染</a></p></li><li><p><a href="https://leetcode-cn.com/problems/minesweeper/" target="_blank" rel="noopener">529. 扫雷游戏</a></p></li></ol><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;LeetCode死磕系列九： 图&lt;/p&gt;
&lt;p&gt;说实话图目前遇到的题目类型不多, 再加上今年图论课程上的一些算法, 只能说算是覆盖了图相关的一丢丢的内容&lt;span class=&quot;github-emoji&quot;&gt;&lt;span&gt;😄&lt;/span&gt;&lt;img src=&quot;https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8&quot; aria-hidden=&quot;true&quot; onerror=&quot;this.parent.classList.add(&#39;github-emoji-fallback&#39;)&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最近LeetCode每日一题, 遇到了较多的图遍历(深度遍历, 广度遍历)问题, 感觉是有迹可循的, 所以做一下整理吧.&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://winniekun.github.io/categories/LeetCode/"/>
    
    
    <category term="死磕系列" scheme="https://winniekun.github.io/tags/%E6%AD%BB%E7%A3%95%E7%B3%BB%E5%88%97/"/>
    
    <category term="dfs" scheme="https://winniekun.github.io/tags/dfs/"/>
    
    <category term="bfs" scheme="https://winniekun.github.io/tags/bfs/"/>
    
  </entry>
  
</feed>
