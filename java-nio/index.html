<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>JavaIO的今世-NIO | Wkkの笔记 | 好记性不如烂键盘</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="I/O">
    <meta name="description" content="Java NIO新的输入&#x2F;输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I&#x2F;O 的不足，提供了高速的、面向块的 I&#x2F;O。">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaIO的今世-NIO">
<meta property="og:url" content="https://winniekun.github.io/java-nio/index.html">
<meta property="og:site_name" content="Wkkの笔记">
<meta property="og:description" content="Java NIO新的输入&#x2F;输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I&#x2F;O 的不足，提供了高速的、面向块的 I&#x2F;O。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/04/24/UyzdCTEPgiutxR1.png">
<meta property="og:image" content="https://i.loli.net/2020/04/24/9qBn1RE8dsIYULt.png">
<meta property="og:image" content="https://i.loli.net/2020/05/21/682eHdpv3hiy7sE.png">
<meta property="og:image" content="https://i.loli.net/2020/05/22/O384LvYwqpg91Uf.png">
<meta property="article:published_time" content="2020-04-07T06:16:56.000Z">
<meta property="article:modified_time" content="2020-08-30T04:50:22.245Z">
<meta property="article:author" content="weikunkun">
<meta property="article:tag" content="I&#x2F;O">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/04/24/UyzdCTEPgiutxR1.png">
    
        <link rel="alternate" type="application/atom+xml" title="Wkkの笔记" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.png">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/people.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="https://avatars.githubusercontent.com/u/19886738?v=4">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">weikunkun</h5>
          <a href="mailto:kongwiki5@gmail.com" title="kongwiki5@gmail.com" class="mail">kongwiki5@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-user-md"></i>
                About
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Winniekun" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">JavaIO的今世-NIO</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">JavaIO的今世-NIO</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-04-07T06:16:56.000Z" itemprop="datePublished" class="page-time">
  2020-04-07
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/java/">java</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Java-NIO"><span class="post-toc-number">1.</span> <span class="post-toc-text">Java NIO</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#BIO带来的挑战"><span class="post-toc-number">2.</span> <span class="post-toc-text">BIO带来的挑战</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#NIO-简介"><span class="post-toc-number">3.</span> <span class="post-toc-text">NIO 简介</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Channel"><span class="post-toc-number">4.</span> <span class="post-toc-text">Channel</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#基本使用"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">基本使用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Buffer"><span class="post-toc-number">5.</span> <span class="post-toc-text">Buffer</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Capacity、Position、Limit"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">Capacity、Position、Limit</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#demo"><span class="post-toc-number">5.1.1.</span> <span class="post-toc-text">demo</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Buffer-类型"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">Buffer 类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#读和写"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">读和写</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#向Buffer中写入数据："><span class="post-toc-number">5.3.1.</span> <span class="post-toc-text">向Buffer中写入数据：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#从Buffer中读出数据"><span class="post-toc-number">5.3.2.</span> <span class="post-toc-text">从Buffer中读出数据</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Selector"><span class="post-toc-number">6.</span> <span class="post-toc-text">Selector</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#步骤"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">步骤</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#创建选择器"><span class="post-toc-number">6.1.1.</span> <span class="post-toc-text">创建选择器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#绑定端口-通道注册到选择器"><span class="post-toc-number">6.1.2.</span> <span class="post-toc-text">绑定端口,通道注册到选择器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#监听事件"><span class="post-toc-number">6.1.3.</span> <span class="post-toc-text">监听事件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#获取可达事件"><span class="post-toc-number">6.1.4.</span> <span class="post-toc-text">获取可达事件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#事件循环"><span class="post-toc-number">6.1.5.</span> <span class="post-toc-text">事件循环</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#整合"><span class="post-toc-number">6.1.6.</span> <span class="post-toc-text">整合</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#应用"><span class="post-toc-number">7.</span> <span class="post-toc-text">应用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#References"><span class="post-toc-number">8.</span> <span class="post-toc-text">References</span></a></li></ol>
        </nav>
    </aside>


<article id="post-Java进阶/IO/java-nio"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">JavaIO的今世-NIO</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-04-07 14:16:56" datetime="2020-04-07T06:16:56.000Z"  itemprop="datePublished">2020-04-07</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/java/">java</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p>
<a id="more"></a>

<h2 id="BIO带来的挑战"><a href="#BIO带来的挑战" class="headerlink" title="BIO带来的挑战"></a>BIO带来的挑战</h2><p>BIO(blocking-IO)</p>
<blockquote>
<p>不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputStream 读取时都有可能会阻塞。一旦有线程阻塞将会失去 CPU 的使用权，这在当前的大规模访问量和有性能要求情况下是不能接受的。虽然当前的网络 I/O 有一些解决办法，如一个客户端一个处理线程，出现阻塞时只是一个线程阻塞而不会影响其它线程工作，还有为了减少系统线程的开销，采用线程池的办法来减少线程创建和回收的成本，但是有一些使用场景仍然是无法解决的。如当前一些需要大量 HTTP 长连接的情况，像淘宝现在使用的 Web 旺旺项目，服务端需要同时保持几百万的 HTTP 连接，但是并不是每时每刻这些连接都在传输数据，这种情况下不可能同时创建这么多线程来保持连接。即使线程的数量不是问题，仍然有一些问题还是无法避免的。如这种情况，我们想给某些客户端更高的服务优先级，很难通过设计线程的优先级来完成，另外一种情况是，我们需要让每个客户端的请求在服务端可能需要访问一些竞争资源，由于这些客户端是在不同线程中，因此需要同步，而往往要实现这些同步操作要远远比用单线程复杂很多。以上这些情况都说明，我们需要另外一种新的 I/O 操作方式。</p>
</blockquote>
<h2 id="NIO-简介"><a href="#NIO-简介" class="headerlink" title="NIO 简介"></a>NIO 简介</h2><p>NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> 、<code>Selector</code>、<code>Buffer</code> 等抽象。</p>
<p>NIO有两种解释：一种叫非阻塞IO（Non-blocking I/O），另一种叫新的IO（New I/O），其实是同一个概念。它是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。(<strong>只有Socket Channel 才能配置为非阻塞，而 FileChannel 不能， 为 FileChannel 配置非阻塞也没有意义</strong>)</p>
<p>NIO是一种基于<code>通道</code>和<code>缓冲区</code>的I/O方式，它可以使用Native函数库直接分配堆外内存（区别于JVM的运行时数据区），然后通过一个存储在Java堆里面的<code>DirectByteBuffer</code>对象作为这块内存的直接引用进行操作。这样能在一些场景显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p><code>Channel</code>是对 BIO 中的流的模拟，可以通过它读写数据(<strong>真正读写</strong>数据的是Buffer)，永远不会出现直接向Channel写入数据或者直接从Channel中读取数据的操作。</p>
<p>通道与流的不同之处在于：</p>
<ul>
<li><strong>流是单向的</strong> - 一个流只能单纯的负责读或写。</li>
<li><strong>通道是双向的</strong> - 一个通道可以同时用于读写。</li>
</ul>
<p>因为<strong>Channel</strong>是双向的，其能更好的反应底层操作系统的真实情况（如操作系统中的通道）。同时<strong>Channel</strong>包括以下类型(标粗的是常用的类型)：</p>
<ul>
<li><strong>FileChannel</strong>：从文件中读写数据；</li>
<li><code>DatagramChannel</code>：通过 UDP 读写网络中数据；</li>
<li><strong>SocketChannel</strong>：通过 TCP 读写网络中数据；</li>
<li><strong>ServerSocketChannel</strong>：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol>
<li>从<strong>Channel</strong>进行读取数据<ol>
<li><p>首先会创建一个<strong>Buffer</strong>，<strong>Channel</strong>将数据读入其中，之后在<strong>Bufer</strong>中读取数据</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"aaa.txt"</span>);</span><br><span class="line">    FileChannel inputChannel = fileInputStream.getChannel();</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    inputChannel.read(buffer);</span><br><span class="line">    <span class="comment">// 切换为读模式</span></span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining()){</span><br><span class="line">        <span class="keyword">byte</span> b = buffer.get();</span><br><span class="line">        System.out.println(<span class="string">"Character: "</span> + (<span class="keyword">char</span>)b);</span><br><span class="line">    }</span><br><span class="line">    buffer.clear();</span><br><span class="line">    fileInputStream.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
<li>向<strong>Channel</strong>写入数据<ol>
<li><p>创建<strong>Buffer</strong>，填充数据。之后<strong>Channel</strong>去写出数据</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"bbb.txt"</span>);</span><br><span class="line">    FileChannel outChannel = fileOutputStream.getChannel();</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] msg = <span class="string">"hello i'm wkk"</span>.getBytes();</span><br><span class="line">    buffer.put(msg);</span><br><span class="line">    buffer.flip();</span><br><span class="line">    outChannel.write(buffer);</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</li>
</ol>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A buffer is a linear, finite sequence of elements of a specific</span><br><span class="line">* primitive type.  Aside from its content, the essential properties of a</span><br><span class="line">* buffer are its capacity, limit, and position:    --- 摘自Buffer源码</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p><strong>Buffer</strong>本身就是一块内存，底层实现上，实际是一个数组。数据的读写均是通过<strong>Buffer</strong>实现。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioBase</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// 初始化一个Buffer</span></span><br><span class="line">        IntBuffer buffer = IntBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向Buffer中随机写入10个数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="keyword">int</span> randomNumber = <span class="keyword">new</span> SecureRandom().nextInt(<span class="number">20</span>);</span><br><span class="line">            buffer.put(randomNumber);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换为读模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()){</span><br><span class="line">            System.out.print(buffer.get() + <span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="Capacity、Position、Limit"><a href="#Capacity、Position、Limit" class="headerlink" title="Capacity、Position、Limit"></a>Capacity、Position、Limit</h3><blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*   &lt;p&gt; A buffer's &lt;i&gt;capacity&lt;/i&gt; is the number of elements it contains.  The</span><br><span class="line">*   capacity of a buffer is never negative and never changes.  &lt;/p&gt;</span><br><span class="line">*</span><br><span class="line">*   &lt;p&gt; A buffer's &lt;i&gt;limit&lt;/i&gt; is the index of the first element that should</span><br><span class="line">*   not be read or written.  A buffer's limit is never negative and is never</span><br><span class="line">*   greater than its capacity.  &lt;/p&gt;</span><br><span class="line">*</span><br><span class="line">*   &lt;p&gt; A buffer's &lt;i&gt;position&lt;/i&gt; is the index of the next element to be</span><br><span class="line">*   read or written.  A buffer's position is never negative and is never</span><br><span class="line">*   greater than its limit.  &lt;/p&gt;</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>在NIO中，真正和数据打交道的是<code>Buffer</code>。可以将<code>Buffer</code>简单的理解为一组基本数据类型的元素列表，其通过以下的基本变量来保存这个数据的当前位置状态，共有四个索引（mark用于记录以下三个索引，所以没有记录）。</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>capacity</td>
<td>缓冲数组的总长度</td>
</tr>
<tr>
<td>position</td>
<td>下一个要操作的数据元素的位置</td>
</tr>
<tr>
<td>limit</td>
<td>缓冲区数组不可操作的下一个元素的位置， limit&lt;=capacity</td>
</tr>
</tbody></table>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/04/24/UyzdCTEPgiutxR1.png" alt="image" title="">
                </div>
                <div class="image-caption">image</div>
            </figure>

<h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="comment">// 创建缓冲区</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//buffer中四个变量的值</span></span><br><span class="line">    System.out.println(<span class="string">"初始时----&gt;limit----&gt;"</span> + buffer.limit());</span><br><span class="line">    System.out.println(<span class="string">"初始时----&gt;capacity----&gt;"</span> + buffer.capacity());</span><br><span class="line">    System.out.println(<span class="string">"初始时----&gt;position----&gt;"</span> + buffer.position());</span><br><span class="line">    System.out.println(<span class="string">"初始时----&gt;mark----&gt;"</span> + buffer.mark());</span><br><span class="line">    System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line"><span class="comment">//初始时----&gt;limit----&gt;1024</span></span><br><span class="line"><span class="comment">//初始时----&gt;capacity----&gt;1024</span></span><br><span class="line"><span class="comment">//初始时----&gt;position----&gt;0</span></span><br><span class="line"><span class="comment">//初始时----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=0 lim=1024 cap=1024]</span></span><br><span class="line">    String s = <span class="string">"abcd"</span>;</span><br><span class="line">    buffer.put(s.getBytes());</span><br><span class="line">    <span class="comment">//buffer添加数据之后，四个变量的值</span></span><br><span class="line">    System.out.println(<span class="string">"put完之后----&gt;limit----&gt;"</span> + buffer.limit());</span><br><span class="line">    System.out.println(<span class="string">"put完之后----&gt;capacity----&gt;"</span> + buffer.capacity());</span><br><span class="line">    System.out.println(<span class="string">"put完之后----&gt;position----&gt;"</span> + buffer.position());</span><br><span class="line">    System.out.println(<span class="string">"put完之后----&gt;mark----&gt;"</span> + buffer.mark());</span><br><span class="line"><span class="comment">//put完之后----&gt;limit----&gt;1024</span></span><br><span class="line"><span class="comment">//put完之后----&gt;capacity----&gt;1024</span></span><br><span class="line"><span class="comment">//put完之后----&gt;position----&gt;4</span></span><br><span class="line"><span class="comment">//put完之后----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=4 lim=1024 cap=1024]</span></span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">    System.out.println(<span class="string">"flip()之后----&gt;limit----&gt;"</span> + buffer.limit());</span><br><span class="line">    System.out.println(<span class="string">"flip()之后----&gt;capacity----&gt;"</span> + buffer.capacity());</span><br><span class="line">    System.out.println(<span class="string">"flip()之后----&gt;position----&gt;"</span> + buffer.position());</span><br><span class="line">    System.out.println(<span class="string">"flip()之后----&gt;mark----&gt;"</span> + buffer.mark());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.limit()];</span><br><span class="line">    buffer.get(bytes);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, bytes.length));</span><br><span class="line"><span class="comment">//flip()之后----&gt;limit----&gt;4</span></span><br><span class="line"><span class="comment">//flip()之后----&gt;capacity----&gt;1024</span></span><br><span class="line"><span class="comment">//flip()之后----&gt;position----&gt;0</span></span><br><span class="line"><span class="comment">//flip()之后----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=0 lim=4 cap=1024]</span></span><br><span class="line"><span class="comment">//abc</span></span><br><span class="line">    System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">    System.out.println(<span class="string">"读完之后----&gt;limit----&gt;"</span> + buffer.limit());</span><br><span class="line">    System.out.println(<span class="string">"读完之后----&gt;capacity----&gt;"</span> + buffer.capacity());</span><br><span class="line">    System.out.println(<span class="string">"读完之后----&gt;position----&gt;"</span> + buffer.position());</span><br><span class="line">    System.out.println(<span class="string">"读完之后----&gt;mark----&gt;"</span> + buffer.mark());</span><br><span class="line"><span class="comment">//读完之后----&gt;limit----&gt;4</span></span><br><span class="line"><span class="comment">//读完之后----&gt;capacity----&gt;1024</span></span><br><span class="line"><span class="comment">//读完之后----&gt;position----&gt;3</span></span><br><span class="line"><span class="comment">//读完之后----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=3 lim=4 cap=1024]    </span></span><br><span class="line">    System.out.println(<span class="string">"----------------清空缓冲区-------------"</span>);</span><br><span class="line">    buffer.clear();</span><br><span class="line">    System.out.println(<span class="string">"清空之后----&gt;limit----&gt;"</span> + buffer.limit());</span><br><span class="line">    System.out.println(<span class="string">"清空之后----&gt;capacity----&gt;"</span> + buffer.capacity());</span><br><span class="line">    System.out.println(<span class="string">"清空之后----&gt;position----&gt;"</span> + buffer.position());</span><br><span class="line">    System.out.println(<span class="string">"清空之后----&gt;mark----&gt;"</span> + buffer.mark());</span><br><span class="line"><span class="comment">//清空之后----&gt;limit----&gt;1024</span></span><br><span class="line"><span class="comment">//清空之后----&gt;capacity----&gt;1024</span></span><br><span class="line"><span class="comment">//清空之后----&gt;position----&gt;0</span></span><br><span class="line"><span class="comment">//清空之后----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=0 lim=1024 cap=1024]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>关于这三种索引的实际关系，以及<code>flip()</code> <code>clear()</code>在下述<code>Buffer的读写</code>中会详细阐述</p>
<h3 id="Buffer-类型"><a href="#Buffer-类型" class="headerlink" title="Buffer 类型"></a>Buffer 类型</h3><p>Buffer实现了java的所有的基础数据类型</p>
<ul>
<li>ByteBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
<li>CharBuffer</li>
<li><strong>MappedByteBuffer</strong></li>
</ul>
<p>使用<code>Buffer</code>对象之前需要先进行分配，每个类型的<code>Buffer</code>类都可以使用静态方法<code>allocate（）</code>分配该<code>Buffer</code>的容量大小</p>
<h3 id="读和写"><a href="#读和写" class="headerlink" title="读和写"></a>读和写</h3><h4 id="向Buffer中写入数据："><a href="#向Buffer中写入数据：" class="headerlink" title="向Buffer中写入数据："></a>向Buffer中写入数据：</h4><p>有两种方式：</p>
<ol>
<li><p>通过channel.read(buffer)写入数据</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"../../Downloads/aaa.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = file.getChannel();</span><br><span class="line"><span class="comment">// 创建缓冲区</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="comment">// 从channel中写入数据</span></span><br><span class="line"><span class="keyword">int</span> read = inChannel.read(buffer);</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>直接通过buffer.put()写入数据</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建缓冲区</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">18</span>);</span><br><span class="line">String s = <span class="string">"abcd"</span>;</span><br><span class="line">buffer.put(s.getBytes());</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p><strong><code>flip()</code>方法</strong></p>
<p>使用该方法之后，<code>position</code>索引会指向0，<code>limit</code>索引会指向缓冲区数组不可操作的下一个元素的位置（也可表示为当前缓冲数组可读元素的长度）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/04/24/9qBn1RE8dsIYULt.png" alt="flip__方法索引变化.png" title="">
                </div>
                <div class="image-caption">flip__方法索引变化.png</div>
            </figure>

<p>所以，flip()方法也可以理解为切换读模式，输入一定的元素之后，感觉需要读出数据，使用flip()方法，切换为读的模式。</p>
<h4 id="从Buffer中读出数据"><a href="#从Buffer中读出数据" class="headerlink" title="从Buffer中读出数据"></a>从Buffer中读出数据</h4><p>同理，也有两种方式从<strong>Buffer</strong>中读出数据</p>
<ol>
<li>channel.write(buffer)</li>
<li>buffer.get()</li>
</ol>
<p><code>clear()</code>方法，操作数据的索引重归初始状态，类似于数据被清空，可以理解为切换写模式</p>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。即用选择器，借助单一线程，就可对数量庞大的活动I/O通道实施监控和维护。其和单片机中的事件轮询是一个道理,可惜本科上单片机的时候,并没有好好听(对不起小邹邹)</p>
<blockquote>
<p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p>
<p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过<strong>轮询的方式</strong> 去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p>
<p>通过配置监听的通道 Channel 为<strong>非阻塞</strong>，那么当 Channel 上的 IO 事件还未到达时， 就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p>
<p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件， 对于 IO 密集型的应用具有很好地性能。</p>
<p>应该注意的是，只有Socket的Channel 才能配置为非阻塞，而 FileChannel 不能， 为 FileChannel 配置非阻塞也没有意义。</p>
</blockquote>
<p><strong>使用Selector的优点:</strong> 使用更少的线程来处理任务, 相比更多的线程,避免了线程上下文的切换开销</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/05/21/682eHdpv3hiy7sE.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<p>可以将上图做更细致的绘制:</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/05/22/O384LvYwqpg91Uf.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<blockquote>
<p> NIO模型的服务器端如何实现非阻塞？服务器上所有<code>Channel</code>需要向<code>Selector</code>注册，而<code>Selector</code>则负责监视这些<code>Channel</code>的IO状态(<code>观察者</code>)，当其中任意一个或者多个<code>Channel</code>具有可用的IO操作时，该<code>Selector</code>的<code>select()</code>方法将会返回大于0的整数(表示该<code>Selector</code>上有多少个<code>Channel</code>具有可用的IO操作)，并提供了<code>selectedKeys()</code>方法来返回这些<code>Channel</code>对应的<code>SelectionKey</code>集合(一个<code>SelectionKey</code>对应一个就绪的通道)。正是通过<code>Selector</code>，使得服务器端只需要不断地调用<code>Selector</code>实例的<code>select()</code>，即可知道当前所有<code>Channel</code>是否有需要处理的IO操作。</p>
</blockquote>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="创建选择器"><a href="#创建选择器" class="headerlink" title="创建选择器"></a>创建选择器</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></tbody></table></figure>



<h4 id="绑定端口-通道注册到选择器"><a href="#绑定端口-通道注册到选择器" class="headerlink" title="绑定端口,通道注册到选择器"></a>绑定端口,通道注册到选择器</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定端口</span></span><br><span class="line">ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">server.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 设置为非阻塞</span></span><br><span class="line">ServerSocket socket = server.socket();</span><br><span class="line">socket.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将通道注册到该线程的选择器</span></span><br><span class="line">server.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></tbody></table></figure>

<p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p>
<p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<h4 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selector.select();</span><br></pre></td></tr></tbody></table></figure>

<p>使用 select() 来监听到达的事件，它会<strong>一直阻塞直到有至少一个事件到达</strong>。</p>
<h4 id="获取可达事件"><a href="#获取可达事件" class="headerlink" title="获取可达事件"></a>获取可达事件</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可达事件</span></span><br><span class="line">Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator = selectionKeys.interator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasnext()){</span><br><span class="line">    SelectionKey key = iterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()){</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()){</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// remove已经处理的事件</span></span><br><span class="line">    iterator.remove();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>){</span><br><span class="line">    <span class="comment">// 监听事件</span></span><br><span class="line">    selector.select();</span><br><span class="line">    <span class="comment">// 获取可达事件</span></span><br><span class="line">    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">	Iterator&lt;SelectionKey&gt; iterator = selectionKeys.interator();</span><br><span class="line">	<span class="keyword">while</span>(iterator.hasnext()){</span><br><span class="line">    	SelectionKey key = iterator.next();</span><br><span class="line">    	<span class="keyword">if</span>(key.isAcceptable()){</span><br><span class="line">        	<span class="comment">// ...</span></span><br><span class="line">    	}<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()){</span><br><span class="line">        	<span class="comment">//...</span></span><br><span class="line">    	}</span><br><span class="line">    	<span class="comment">// remove已经处理的事件</span></span><br><span class="line">    	iterator.remove();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">// 1. 创建选择器</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    <span class="comment">// 2. 绑定端口 通道注册到选择器</span></span><br><span class="line">    ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">    serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    ServerSocket socket = serverChannel.socket();</span><br><span class="line">    socket.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">    <span class="comment">// 通道注册到selector上</span></span><br><span class="line">    serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 事件轮询</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>){</span><br><span class="line">        <span class="comment">// 3 监听事件</span></span><br><span class="line">        selector.select();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4 获取可达事件</span></span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()){</span><br><span class="line">            SelectionKey key = itrator.next();</span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) {</span><br><span class="line">                ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">                <span class="comment">// 服务器会为每个新连接创建一个 SocketChannel</span></span><br><span class="line">                SocketChannel client = server.accept();</span><br><span class="line">                client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 这个新连接的channel主要用于从客户端读取数据</span></span><br><span class="line">                client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()){</span><br><span class="line">                SocketChannel client = (SocketChannel)key.channel();</span><br><span class="line">                <span class="comment">// 数据的处理</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                buffer.clear();</span><br><span class="line">                <span class="keyword">while</span> (channel.read(buffer) &gt; <span class="number">0</span>);</span><br><span class="line">                buffer.flip();</span><br><span class="line">                channel.write(buffer);</span><br><span class="line">            }</span><br><span class="line">            iterator.remove();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>创建一个简单的服务端</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">	<span class="comment">// 服务端监听5个端口</span></span><br><span class="line">    <span class="keyword">int</span>[] ports = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">9000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">        ports[i] = base++;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 创建选择器</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    <span class="comment">// 绑定端口 通道注册到选择器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> port : ports) {</span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">        server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ServerSocket socket = server.socket();</span><br><span class="line">        socket.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">"监听端口: "</span> + port);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 事件轮询</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">        <span class="comment">// 监听事件</span></span><br><span class="line">        <span class="keyword">int</span> num = selector.select();</span><br><span class="line">        System.out.println(<span class="string">"numbers: "</span> + num);</span><br><span class="line">        <span class="comment">// 获取可达事件</span></span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">        System.out.println(<span class="string">"可达事件集有: "</span> + selectionKeys.size());</span><br><span class="line">        <span class="keyword">for</span> (SelectionKey selectionKey : selectionKeys) {</span><br><span class="line">            System.out.println(<span class="string">"可达事件集类型有: "</span> + selectionKey);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 事件处理</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) {</span><br><span class="line">            SelectionKey key = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) {</span><br><span class="line">                ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">                SocketChannel client = server.accept();</span><br><span class="line">                client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                System.out.println(<span class="string">"获得客户端的链接"</span> + client);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) {</span><br><span class="line">                SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                buffer.clear();</span><br><span class="line">                <span class="keyword">while</span> (channel.read(buffer) &gt; <span class="number">0</span>);</span><br><span class="line">                buffer.flip();</span><br><span class="line">                channel.write(buffer);</span><br><span class="line">                System.out.println(<span class="string">"读取: "</span> + buffer + <span class="string">", 来自于"</span> + channel);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 记得remove</span></span><br><span class="line">            iterator.remove();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="noopener">Java NIO</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">IBM NIO 入门</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-08-30T04:50:22.245Z" itemprop="dateUpdated">2020-08-30 12:50:22</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://winniekun.github.io">
            <img src="https://avatars.githubusercontent.com/u/19886738?v=4" alt="weikunkun">
            weikunkun
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/I-O/" rel="tag">I/O</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://winniekun.github.io/java-nio/&title=《JavaIO的今世-NIO》 — Wkkの笔记&pic=https://avatars.githubusercontent.com/u/19886738?v=4" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://winniekun.github.io/java-nio/&title=《JavaIO的今世-NIO》 — Wkkの笔记&source=Java NIO新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://winniekun.github.io/java-nio/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JavaIO的今世-NIO》 — Wkkの笔记&url=https://winniekun.github.io/java-nio/&via=https://winniekun.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://winniekun.github.io/java-nio/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/java-bio/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">JavaIO的前世-BIO阻塞模型</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/%E5%A0%86%E6%8E%92%E5%BA%8F/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">堆排序</h4>
      </a>
    </div>
  
</nav>



    




















</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>weikunkun &copy; 2015 - 2021</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://winniekun.github.io/java-nio/&title=《JavaIO的今世-NIO》 — Wkkの笔记&pic=https://avatars.githubusercontent.com/u/19886738?v=4" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://winniekun.github.io/java-nio/&title=《JavaIO的今世-NIO》 — Wkkの笔记&source=Java NIO新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://winniekun.github.io/java-nio/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JavaIO的今世-NIO》 — Wkkの笔记&url=https://winniekun.github.io/java-nio/&via=https://winniekun.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://winniekun.github.io/java-nio/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABwElEQVR42u3aS26EMBAFQO5/abJNNMK8tnGHROUVmkG4vGn1x8cRr/Pbyt/8XJ9vHjsWLi7uMjfZYPzLeOPq92++jIuL28i92iYJOlfbV7ljAy4u7t/ijlnjA+Di4v4P7riMmaPg4uK+k1tNQeaaGq21Gi4u7gI332bf85b+Li4u7hT3LK5krJKnO+XdcXFxW7grLY/896daLbi4uJ3c9abnY0VLcXyLi4u7m/vsGDVJd6p1DS4ubg/32WQlb4Xkx/vxjIuL28LNt1/pXs5d1bqR4OLibuPOBZFqmHus+MHFxW3h5m2IlcbHXLpz09/FxcXdxq2mHXnqk2RV1cEMLi5uJ7fazqgOX+eKpctAhouLu5m7o925PmqNWqW4uLiN3CSszLVZ82PcfBMXF7eRWw1VeWu1OqYd74KLi9vPzS9mVS9hzKU49b9xcXFXuWdx5SXKONGpJj24uLid3JUrEXNlTKH9EQ9vcHFxd3Dz8WpeAuWj03LjFRcXt5E7F4byUiePoIWGKS4u7mu4+aWKavFTqNhwcXFfz622X5fexMXFbeRWx6t5bFkponBxcX+LWw0l+WHyxGi9ZMLFxX2I+wWBYAEvHMgShgAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
