<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>JavaIO的今世-NIO | Wkkの笔记 | 好记性不如烂键盘</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="I/O">
    <meta name="description" content="Java NIO新的输入&#x2F;输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I&#x2F;O 的不足，提供了高速的、面向块的 I&#x2F;O。">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaIO的今世-NIO">
<meta property="og:url" content="https://winniekun.github.io/java-nio/index.html">
<meta property="og:site_name" content="Wkkの笔记">
<meta property="og:description" content="Java NIO新的输入&#x2F;输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I&#x2F;O 的不足，提供了高速的、面向块的 I&#x2F;O。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/04/24/UyzdCTEPgiutxR1.png">
<meta property="og:image" content="https://i.loli.net/2020/04/24/9qBn1RE8dsIYULt.png">
<meta property="og:image" content="https://i.loli.net/2020/05/21/682eHdpv3hiy7sE.png">
<meta property="og:image" content="https://i.loli.net/2020/05/22/O384LvYwqpg91Uf.png">
<meta property="article:published_time" content="2020-04-07T06:16:56.000Z">
<meta property="article:modified_time" content="2020-08-30T04:50:22.245Z">
<meta property="article:author" content="weikunkun">
<meta property="article:tag" content="I&#x2F;O">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/04/24/UyzdCTEPgiutxR1.png">
    
        <link rel="alternate" type="application/atom+xml" title="Wkkの笔记" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <link rel="stylesheet" href="/css/prism/prism-tomorrow-night.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-list-ul"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/people.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="https://avatars.githubusercontent.com/u/19886738?v=4">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">weikunkun</h5>
          <a href="mailto:kongwiki5@gmail.com" title="kongwiki5@gmail.com" class="mail">kongwiki5@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-user-md"></i>
                About
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://winniekun.github.io/acsaber/#/" target="_blank" >
                <i class="icon icon-lg icon-trello"></i>
                LeetCode
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Winniekun" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">JavaIO的今世-NIO</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">JavaIO的今世-NIO</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-04-07T06:16:56.000Z" itemprop="datePublished" class="page-time">
  2020-04-07
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/java/">java</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Java-NIO"><span class="post-toc-number">1.</span> <span class="post-toc-text">Java NIO</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#BIO带来的挑战"><span class="post-toc-number">2.</span> <span class="post-toc-text">BIO带来的挑战</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#NIO-简介"><span class="post-toc-number">3.</span> <span class="post-toc-text">NIO 简介</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Channel"><span class="post-toc-number">4.</span> <span class="post-toc-text">Channel</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#基本使用"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">基本使用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Buffer"><span class="post-toc-number">5.</span> <span class="post-toc-text">Buffer</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Capacity、Position、Limit"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">Capacity、Position、Limit</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#demo"><span class="post-toc-number">5.1.1.</span> <span class="post-toc-text">demo</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Buffer-类型"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">Buffer 类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#读和写"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">读和写</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#向Buffer中写入数据："><span class="post-toc-number">5.3.1.</span> <span class="post-toc-text">向Buffer中写入数据：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#从Buffer中读出数据"><span class="post-toc-number">5.3.2.</span> <span class="post-toc-text">从Buffer中读出数据</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Selector"><span class="post-toc-number">6.</span> <span class="post-toc-text">Selector</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#步骤"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">步骤</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#创建选择器"><span class="post-toc-number">6.1.1.</span> <span class="post-toc-text">创建选择器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#绑定端口-通道注册到选择器"><span class="post-toc-number">6.1.2.</span> <span class="post-toc-text">绑定端口,通道注册到选择器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#监听事件"><span class="post-toc-number">6.1.3.</span> <span class="post-toc-text">监听事件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#获取可达事件"><span class="post-toc-number">6.1.4.</span> <span class="post-toc-text">获取可达事件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#事件循环"><span class="post-toc-number">6.1.5.</span> <span class="post-toc-text">事件循环</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#整合"><span class="post-toc-number">6.1.6.</span> <span class="post-toc-text">整合</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#应用"><span class="post-toc-number">7.</span> <span class="post-toc-text">应用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#References"><span class="post-toc-number">8.</span> <span class="post-toc-text">References</span></a></li></ol>
        </nav>
    </aside>


<article id="post-Java进阶/IO/java-nio"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">JavaIO的今世-NIO</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-04-07 14:16:56" datetime="2020-04-07T06:16:56.000Z"  itemprop="datePublished">2020-04-07</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/java/">java</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p>
<a id="more"></a>
<h2 id="BIO带来的挑战"><a href="#BIO带来的挑战" class="headerlink" title="BIO带来的挑战"></a>BIO带来的挑战</h2><p>BIO(blocking-IO)</p>
<blockquote>
<p>不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputStream 读取时都有可能会阻塞。一旦有线程阻塞将会失去 CPU 的使用权，这在当前的大规模访问量和有性能要求情况下是不能接受的。虽然当前的网络 I/O 有一些解决办法，如一个客户端一个处理线程，出现阻塞时只是一个线程阻塞而不会影响其它线程工作，还有为了减少系统线程的开销，采用线程池的办法来减少线程创建和回收的成本，但是有一些使用场景仍然是无法解决的。如当前一些需要大量 HTTP 长连接的情况，像淘宝现在使用的 Web 旺旺项目，服务端需要同时保持几百万的 HTTP 连接，但是并不是每时每刻这些连接都在传输数据，这种情况下不可能同时创建这么多线程来保持连接。即使线程的数量不是问题，仍然有一些问题还是无法避免的。如这种情况，我们想给某些客户端更高的服务优先级，很难通过设计线程的优先级来完成，另外一种情况是，我们需要让每个客户端的请求在服务端可能需要访问一些竞争资源，由于这些客户端是在不同线程中，因此需要同步，而往往要实现这些同步操作要远远比用单线程复杂很多。以上这些情况都说明，我们需要另外一种新的 I/O 操作方式。</p>
</blockquote>
<h2 id="NIO-简介"><a href="#NIO-简介" class="headerlink" title="NIO 简介"></a>NIO 简介</h2><p>NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> 、<code>Selector</code>、<code>Buffer</code> 等抽象。</p>
<p>NIO有两种解释：一种叫非阻塞IO（Non-blocking I/O），另一种叫新的IO（New I/O），其实是同一个概念。它是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。(<strong>只有Socket Channel 才能配置为非阻塞，而 FileChannel 不能， 为 FileChannel 配置非阻塞也没有意义</strong>)</p>
<p>NIO是一种基于<code>通道</code>和<code>缓冲区</code>的I/O方式，它可以使用Native函数库直接分配堆外内存（区别于JVM的运行时数据区），然后通过一个存储在Java堆里面的<code>DirectByteBuffer</code>对象作为这块内存的直接引用进行操作。这样能在一些场景显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p><code>Channel</code>是对 BIO 中的流的模拟，可以通过它读写数据(<strong>真正读写</strong>数据的是Buffer)，永远不会出现直接向Channel写入数据或者直接从Channel中读取数据的操作。</p>
<p>通道与流的不同之处在于：</p>
<ul>
<li><strong>流是单向的</strong> - 一个流只能单纯的负责读或写。</li>
<li><strong>通道是双向的</strong> - 一个通道可以同时用于读写。</li>
</ul>
<p>因为<strong>Channel</strong>是双向的，其能更好的反应底层操作系统的真实情况（如操作系统中的通道）。同时<strong>Channel</strong>包括以下类型(标粗的是常用的类型)：</p>
<ul>
<li><strong>FileChannel</strong>：从文件中读写数据；</li>
<li><code>DatagramChannel</code>：通过 UDP 读写网络中数据；</li>
<li><strong>SocketChannel</strong>：通过 TCP 读写网络中数据；</li>
<li><strong>ServerSocketChannel</strong>：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol>
<li><p>从<strong>Channel</strong>进行读取数据</p>
<ol>
<li><p>首先会创建一个<strong>Buffer</strong>，<strong>Channel</strong>将数据读入其中，之后在<strong>Bufer</strong>中读取数据</p>
<pre><code class="lang-java">public static void read() throws IOException {
    FileInputStream fileInputStream = new FileInputStream("aaa.txt");
    FileChannel inputChannel = fileInputStream.getChannel();
    ByteBuffer buffer = ByteBuffer.allocate(1024);
    inputChannel.read(buffer);
    // 切换为读模式
    buffer.flip();
    while (buffer.hasRemaining()){
        byte b = buffer.get();
        System.out.println("Character: " + (char)b);
    }
    buffer.clear();
    fileInputStream.close();
}
</code></pre>
</li>
</ol>
</li>
<li><p>向<strong>Channel</strong>写入数据</p>
<ol>
<li><p>创建<strong>Buffer</strong>，填充数据。之后<strong>Channel</strong>去写出数据</p>
<pre><code class="lang-java">public static void write() throws IOException {
    FileOutputStream fileOutputStream = new FileOutputStream("bbb.txt");
    FileChannel outChannel = fileOutputStream.getChannel();
    ByteBuffer buffer = ByteBuffer.allocate(1024);
    byte[] msg = "hello i'm wkk".getBytes();
    buffer.put(msg);
    buffer.flip();
    outChannel.write(buffer);
    fileOutputStream.close();
}
</code></pre>
</li>
</ol>
</li>
</ol>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><blockquote>
<pre><code>A buffer is a linear, finite sequence of elements of a specific
* primitive type.  Aside from its content, the essential properties of a
* buffer are its capacity, limit, and position:    --- 摘自Buffer源码
</code></pre></blockquote>
<p><strong>Buffer</strong>本身就是一块内存，底层实现上，实际是一个数组。数据的读写均是通过<strong>Buffer</strong>实现。</p>
<pre><code class="lang-java">public class NioBase {
    public static void main(String[] args) {
        // 初始化一个Buffer
        IntBuffer buffer = IntBuffer.allocate(1024);

        // 向Buffer中随机写入10个数字
        for (int i = 0; i &lt; 10; i++) {
            int randomNumber = new SecureRandom().nextInt(20);
            buffer.put(randomNumber);
        }

        // 切换为读模式
        buffer.flip();
        while (buffer.hasRemaining()){
            System.out.print(buffer.get() + " ");
        }

    }
}
</code></pre>
<h3 id="Capacity、Position、Limit"><a href="#Capacity、Position、Limit" class="headerlink" title="Capacity、Position、Limit"></a>Capacity、Position、Limit</h3><blockquote>
<pre><code>*   &lt;p&gt; A buffer's &lt;i&gt;capacity&lt;/i&gt; is the number of elements it contains.  The
*   capacity of a buffer is never negative and never changes.  &lt;/p&gt;
*
*   &lt;p&gt; A buffer's &lt;i&gt;limit&lt;/i&gt; is the index of the first element that should
*   not be read or written.  A buffer's limit is never negative and is never
*   greater than its capacity.  &lt;/p&gt;
*
*   &lt;p&gt; A buffer's &lt;i&gt;position&lt;/i&gt; is the index of the next element to be
*   read or written.  A buffer's position is never negative and is never
*   greater than its limit.  &lt;/p&gt;
</code></pre></blockquote>
<p>在NIO中，真正和数据打交道的是<code>Buffer</code>。可以将<code>Buffer</code>简单的理解为一组基本数据类型的元素列表，其通过以下的基本变量来保存这个数据的当前位置状态，共有四个索引（mark用于记录以下三个索引，所以没有记录）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>索引</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>capacity</td>
<td>缓冲数组的总长度</td>
</tr>
<tr>
<td>position</td>
<td>下一个要操作的数据元素的位置</td>
</tr>
<tr>
<td>limit</td>
<td>缓冲区数组不可操作的下一个元素的位置， limit&lt;=capacity</td>
</tr>
</tbody>
</table>
</div>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/04/24/UyzdCTEPgiutxR1.png" alt="image" title="">
                </div>
                <div class="image-caption">image</div>
            </figure>
<h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><pre><code class="lang-java">public static void main(String[] args) {
    // 创建缓冲区
    ByteBuffer buffer = ByteBuffer.allocate(1024);
    //buffer中四个变量的值
    System.out.println("初始时----&gt;limit----&gt;" + buffer.limit());
    System.out.println("初始时----&gt;capacity----&gt;" + buffer.capacity());
    System.out.println("初始时----&gt;position----&gt;" + buffer.position());
    System.out.println("初始时----&gt;mark----&gt;" + buffer.mark());
    System.out.println("--------------------------------");
//初始时----&gt;limit----&gt;1024
//初始时----&gt;capacity----&gt;1024
//初始时----&gt;position----&gt;0
//初始时----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=0 lim=1024 cap=1024]
    String s = "abcd";
    buffer.put(s.getBytes());
    //buffer添加数据之后，四个变量的值
    System.out.println("put完之后----&gt;limit----&gt;" + buffer.limit());
    System.out.println("put完之后----&gt;capacity----&gt;" + buffer.capacity());
    System.out.println("put完之后----&gt;position----&gt;" + buffer.position());
    System.out.println("put完之后----&gt;mark----&gt;" + buffer.mark());
//put完之后----&gt;limit----&gt;1024
//put完之后----&gt;capacity----&gt;1024
//put完之后----&gt;position----&gt;4
//put完之后----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=4 lim=1024 cap=1024]
    buffer.flip();
    System.out.println("-------------------------------------------");
    System.out.println("flip()之后----&gt;limit----&gt;" + buffer.limit());
    System.out.println("flip()之后----&gt;capacity----&gt;" + buffer.capacity());
    System.out.println("flip()之后----&gt;position----&gt;" + buffer.position());
    System.out.println("flip()之后----&gt;mark----&gt;" + buffer.mark());

    byte[] bytes = new byte[buffer.limit()];
    buffer.get(bytes);
    System.out.println(new String(bytes, 0, bytes.length));
//flip()之后----&gt;limit----&gt;4
//flip()之后----&gt;capacity----&gt;1024
//flip()之后----&gt;position----&gt;0
//flip()之后----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=0 lim=4 cap=1024]
//abc
    System.out.println("-------------------------------------------");
    System.out.println("读完之后----&gt;limit----&gt;" + buffer.limit());
    System.out.println("读完之后----&gt;capacity----&gt;" + buffer.capacity());
    System.out.println("读完之后----&gt;position----&gt;" + buffer.position());
    System.out.println("读完之后----&gt;mark----&gt;" + buffer.mark());
//读完之后----&gt;limit----&gt;4
//读完之后----&gt;capacity----&gt;1024
//读完之后----&gt;position----&gt;3
//读完之后----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=3 lim=4 cap=1024]    
    System.out.println("----------------清空缓冲区-------------");
    buffer.clear();
    System.out.println("清空之后----&gt;limit----&gt;" + buffer.limit());
    System.out.println("清空之后----&gt;capacity----&gt;" + buffer.capacity());
    System.out.println("清空之后----&gt;position----&gt;" + buffer.position());
    System.out.println("清空之后----&gt;mark----&gt;" + buffer.mark());
//清空之后----&gt;limit----&gt;1024
//清空之后----&gt;capacity----&gt;1024
//清空之后----&gt;position----&gt;0
//清空之后----&gt;mark----&gt;java.nio.HeapByteBuffer[pos=0 lim=1024 cap=1024]
}
</code></pre>
<p>关于这三种索引的实际关系，以及<code>flip()</code> <code>clear()</code>在下述<code>Buffer的读写</code>中会详细阐述</p>
<h3 id="Buffer-类型"><a href="#Buffer-类型" class="headerlink" title="Buffer 类型"></a>Buffer 类型</h3><p>Buffer实现了java的所有的基础数据类型</p>
<ul>
<li>ByteBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
<li>CharBuffer</li>
<li><strong>MappedByteBuffer</strong></li>
</ul>
<p>使用<code>Buffer</code>对象之前需要先进行分配，每个类型的<code>Buffer</code>类都可以使用静态方法<code>allocate（）</code>分配该<code>Buffer</code>的容量大小</p>
<h3 id="读和写"><a href="#读和写" class="headerlink" title="读和写"></a>读和写</h3><h4 id="向Buffer中写入数据："><a href="#向Buffer中写入数据：" class="headerlink" title="向Buffer中写入数据："></a>向Buffer中写入数据：</h4><p>有两种方式：</p>
<ol>
<li><p>通过channel.read(buffer)写入数据</p>
<pre><code class="lang-java">RandomAccessFile file = new RandomAccessFile("../../Downloads/aaa.txt", "rw");
FileChannel inChannel = file.getChannel();
// 创建缓冲区
ByteBuffer buffer = ByteBuffer.allocate(1024);
// 从channel中写入数据
int read = inChannel.read(buffer);
</code></pre>
</li>
</ol>
<ol>
<li><p>直接通过buffer.put()写入数据</p>
<pre><code class="lang-java">// 创建缓冲区
ByteBuffer buffer = ByteBuffer.allocate(18);
String s = "abcd";
buffer.put(s.getBytes());
</code></pre>
</li>
</ol>
<p><strong><code>flip()</code>方法</strong></p>
<p>使用该方法之后，<code>position</code>索引会指向0，<code>limit</code>索引会指向缓冲区数组不可操作的下一个元素的位置（也可表示为当前缓冲数组可读元素的长度）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/04/24/9qBn1RE8dsIYULt.png" alt="flip__方法索引变化.png" title="">
                </div>
                <div class="image-caption">flip__方法索引变化.png</div>
            </figure>
<p>所以，flip()方法也可以理解为切换读模式，输入一定的元素之后，感觉需要读出数据，使用flip()方法，切换为读的模式。</p>
<h4 id="从Buffer中读出数据"><a href="#从Buffer中读出数据" class="headerlink" title="从Buffer中读出数据"></a>从Buffer中读出数据</h4><p>同理，也有两种方式从<strong>Buffer</strong>中读出数据</p>
<ol>
<li>channel.write(buffer)</li>
<li>buffer.get()</li>
</ol>
<p><code>clear()</code>方法，操作数据的索引重归初始状态，类似于数据被清空，可以理解为切换写模式</p>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。即用选择器，借助单一线程，就可对数量庞大的活动I/O通道实施监控和维护。其和单片机中的事件轮询是一个道理,可惜本科上单片机的时候,并没有好好听(对不起小邹邹)</p>
<blockquote>
<p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p>
<p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过<strong>轮询的方式</strong> 去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p>
<p>通过配置监听的通道 Channel 为<strong>非阻塞</strong>，那么当 Channel 上的 IO 事件还未到达时， 就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p>
<p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件， 对于 IO 密集型的应用具有很好地性能。</p>
<p>应该注意的是，只有Socket的Channel 才能配置为非阻塞，而 FileChannel 不能， 为 FileChannel 配置非阻塞也没有意义。</p>
</blockquote>
<p><strong>使用Selector的优点:</strong> 使用更少的线程来处理任务, 相比更多的线程,避免了线程上下文的切换开销</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/05/21/682eHdpv3hiy7sE.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>可以将上图做更细致的绘制:</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/05/22/O384LvYwqpg91Uf.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p> NIO模型的服务器端如何实现非阻塞？服务器上所有<code>Channel</code>需要向<code>Selector</code>注册，而<code>Selector</code>则负责监视这些<code>Channel</code>的IO状态(<code>观察者</code>)，当其中任意一个或者多个<code>Channel</code>具有可用的IO操作时，该<code>Selector</code>的<code>select()</code>方法将会返回大于0的整数(表示该<code>Selector</code>上有多少个<code>Channel</code>具有可用的IO操作)，并提供了<code>selectedKeys()</code>方法来返回这些<code>Channel</code>对应的<code>SelectionKey</code>集合(一个<code>SelectionKey</code>对应一个就绪的通道)。正是通过<code>Selector</code>，使得服务器端只需要不断地调用<code>Selector</code>实例的<code>select()</code>，即可知道当前所有<code>Channel</code>是否有需要处理的IO操作。</p>
</blockquote>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="创建选择器"><a href="#创建选择器" class="headerlink" title="创建选择器"></a>创建选择器</h4><pre><code class="lang-java">Selector selector = Selector.open();
</code></pre>
<h4 id="绑定端口-通道注册到选择器"><a href="#绑定端口-通道注册到选择器" class="headerlink" title="绑定端口,通道注册到选择器"></a>绑定端口,通道注册到选择器</h4><pre><code class="lang-java">// 绑定端口
ServerSocketChannel server = ServerSocketChannel.open();
server.configureBlocking(false); // 设置为非阻塞
ServerSocket socket = server.socket();
socket.bind(new InetSocketAddress(port));

// 将通道注册到该线程的选择器
server.register(selector, SelectionKey.OP_ACCEPT);
</code></pre>
<p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p>
<p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<h4 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h4><pre><code class="lang-java">selector.select();
</code></pre>
<p>使用 select() 来监听到达的事件，它会<strong>一直阻塞直到有至少一个事件到达</strong>。</p>
<h4 id="获取可达事件"><a href="#获取可达事件" class="headerlink" title="获取可达事件"></a>获取可达事件</h4><pre><code class="lang-java">// 可达事件
Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
Iterator&lt;SelectionKey&gt; iterator = selectionKeys.interator();
while(iterator.hasnext()){
    SelectionKey key = iterator.next();
    if(key.isAcceptable()){
        // ...
    }else if(key.isReadable()){
        //...
    }
    // remove已经处理的事件
    iterator.remove();
}
</code></pre>
<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p>
<pre><code class="lang-java">while(true){
    // 监听事件
    selector.select();
    // 获取可达事件
    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.interator();
    while(iterator.hasnext()){
        SelectionKey key = iterator.next();
        if(key.isAcceptable()){
            // ...
        }else if(key.isReadable()){
            //...
        }
        // remove已经处理的事件
        iterator.remove();
    }
}
</code></pre>
<h4 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h4><pre><code class="lang-java">public void start(){
    // 1. 创建选择器
    Selector selector = Selector.open();
    // 2. 绑定端口 通道注册到选择器
    ServerSocketChannel serverChannel = ServerSocketChannel.open();
    serverChannel.configureBlocking(false);
    ServerSocket socket = serverChannel.socket();
    socket.bind(new InetSocketAddress(port));
    // 通道注册到selector上
    serverChannel.register(selector, SelectionKey.OP_ACCEPT);

    // 事件轮询
    while(true){
        // 3 监听事件
        selector.select();

        // 4 获取可达事件
        Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
        Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();
        while(iterator.hasNext()){
            SelectionKey key = itrator.next();
            if (key.isAcceptable()) {
                ServerSocketChannel server = (ServerSocketChannel) key.channel();
                // 服务器会为每个新连接创建一个 SocketChannel
                SocketChannel client = server.accept();
                client.configureBlocking(false);
                // 这个新连接的channel主要用于从客户端读取数据
                client.register(selector, SelectionKey.OP_READ);
            }else if(key.isReadable()){
                SocketChannel client = (SocketChannel)key.channel();
                // 数据的处理
                ByteBuffer buffer = ByteBuffer.allocate(1024);
                buffer.clear();
                while (channel.read(buffer) &gt; 0);
                buffer.flip();
                channel.write(buffer);
            }
            iterator.remove();
        }
    }
}
</code></pre>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>创建一个简单的服务端</p>
<pre><code class="lang-java">public static void main(String[] args) throws IOException {
    // 服务端监听5个端口
    int[] ports = new int[5];
    int base = 9000;
    for (int i = 0; i &lt; 5; i++) {
        ports[i] = base++;
    }
    // 创建选择器
    Selector selector = Selector.open();
    // 绑定端口 通道注册到选择器
    for (int port : ports) {
        ServerSocketChannel server = ServerSocketChannel.open();
        server.configureBlocking(false);
        ServerSocket socket = server.socket();
        socket.bind(new InetSocketAddress(port));
        server.register(selector, SelectionKey.OP_ACCEPT);
        System.out.println("监听端口: " + port);
    }
    // 事件轮询
    while (true) {
        // 监听事件
        int num = selector.select();
        System.out.println("numbers: " + num);
        // 获取可达事件
        Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
        System.out.println("可达事件集有: " + selectionKeys.size());
        for (SelectionKey selectionKey : selectionKeys) {
            System.out.println("可达事件集类型有: " + selectionKey);
        }
        // 事件处理
        Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();
        while (iterator.hasNext()) {
            SelectionKey key = iterator.next();
            if (key.isAcceptable()) {
                ServerSocketChannel server = (ServerSocketChannel) key.channel();
                SocketChannel client = server.accept();
                client.configureBlocking(false);
                client.register(selector, SelectionKey.OP_READ);
                System.out.println("获得客户端的链接" + client);
            } else if (key.isReadable()) {
                SocketChannel channel = (SocketChannel) key.channel();
                ByteBuffer buffer = ByteBuffer.allocate(1024);
                buffer.clear();
                while (channel.read(buffer) &gt; 0);
                buffer.flip();
                channel.write(buffer);
                System.out.println("读取: " + buffer + ", 来自于" + channel);
            }
            // 记得remove
            iterator.remove();
        }
    }
}
</code></pre>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="noopener">Java NIO</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">IBM NIO 入门</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-08-30T04:50:22.245Z" itemprop="dateUpdated">2020-08-30 12:50:22</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="https://winniekun.github.io">
            <img src="https://avatars.githubusercontent.com/u/19886738?v=4" alt="weikunkun">
            weikunkun
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/I-O/" rel="tag">I/O</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://winniekun.github.io/java-nio/&title=《JavaIO的今世-NIO》 — Wkkの笔记&pic=https://avatars.githubusercontent.com/u/19886738?v=4" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://winniekun.github.io/java-nio/&title=《JavaIO的今世-NIO》 — Wkkの笔记&source=Java NIO新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://winniekun.github.io/java-nio/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JavaIO的今世-NIO》 — Wkkの笔记&url=https://winniekun.github.io/java-nio/&via=https://winniekun.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://winniekun.github.io/java-nio/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/java-bio/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">JavaIO的前世-BIO阻塞模型</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/%E5%A0%86%E6%8E%92%E5%BA%8F/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">堆排序</h4>
      </a>
    </div>
  
</nav>



    





















</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


            <p>
                
                    <span>
                        <a href="/atom.xml" target="_blank" class="rss" title="rss">
                            <i class="icon icon-lg icon-rss"></i>
                        </a>
                    </span>
                    
                        <span>
                            博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
                        </span>
            </p>
    </div>
    <div class="bottom">
        <p>
            <span>
                weikunkun &copy;
                    
                        2015 -
                            
                                2022
            </span>
            <span>
                
                        Power by
                        <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
                        <a href="https://github.com/abelsu7/hexo-theme-indigo-plus" target="_blank">indigo plus</a>
                        <p>Hosted by <a href="https://pages.github.com" target="_blank" style="font-weight: bold">Github Pages</a></p>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>
<a href="javascript:;" id="gobottom" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-comments"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://winniekun.github.io/java-nio/&title=《JavaIO的今世-NIO》 — Wkkの笔记&pic=https://avatars.githubusercontent.com/u/19886738?v=4" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://winniekun.github.io/java-nio/&title=《JavaIO的今世-NIO》 — Wkkの笔记&source=Java NIO新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://winniekun.github.io/java-nio/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JavaIO的今世-NIO》 — Wkkの笔记&url=https://winniekun.github.io/java-nio/&via=https://winniekun.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://winniekun.github.io/java-nio/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABwElEQVR42u3aS26EMBAFQO5/abJNNMK8tnGHROUVmkG4vGn1x8cRr/Pbyt/8XJ9vHjsWLi7uMjfZYPzLeOPq92++jIuL28i92iYJOlfbV7ljAy4u7t/ijlnjA+Di4v4P7riMmaPg4uK+k1tNQeaaGq21Gi4u7gI332bf85b+Li4u7hT3LK5krJKnO+XdcXFxW7grLY/896daLbi4uJ3c9abnY0VLcXyLi4u7m/vsGDVJd6p1DS4ubg/32WQlb4Xkx/vxjIuL28LNt1/pXs5d1bqR4OLibuPOBZFqmHus+MHFxW3h5m2IlcbHXLpz09/FxcXdxq2mHXnqk2RV1cEMLi5uJ7fazqgOX+eKpctAhouLu5m7o925PmqNWqW4uLiN3CSszLVZ82PcfBMXF7eRWw1VeWu1OqYd74KLi9vPzS9mVS9hzKU49b9xcXFXuWdx5SXKONGpJj24uLid3JUrEXNlTKH9EQ9vcHFxd3Dz8WpeAuWj03LjFRcXt5E7F4byUiePoIWGKS4u7mu4+aWKavFTqNhwcXFfz622X5fexMXFbeRWx6t5bFkponBxcX+LWw0l+WHyxGi9ZMLFxX2I+wWBYAEvHMgShgAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.jsdelivr.net/npm/node-waves@0.7.6/src/js/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>


<script src="/js/prism.min.js?v=1.7.2"></script>
<script src="/js/prism-vim.min.js?v=1.7.2"></script>
</body>
</html>
